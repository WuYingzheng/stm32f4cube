
Custom_Loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000003f4  20000004  20000004  00010004  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .ARM          00000008  200003f8  200003f8  000103f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000004  20000400  20000400  00010400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  20000404  20000404  00010404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000078  20000408  20000408  00010408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000090  20000480  20000480  00010480  2**2
                  ALLOC
  6 .text         0000e110  20000510  20000510  00010510  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .Dev_info     000000c8  2000e620  2000e620  0002e620  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rodata       00000024  2000e6e8  2000e6e8  0001e6e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 ._user_heap_stack 00000600  2000e70c  2000e70c  0001e70c  2**0
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  0002e6e8  2**0
                  CONTENTS, READONLY
 11 .debug_info   000104a7  00000000  00000000  0002e716  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00002f07  00000000  00000000  0003ebbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00000df0  00000000  00000000  00041ac8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  0002dfe2  00000000  00000000  000428b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000f5e5  00000000  00000000  0007089a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0010967d  00000000  00000000  0007fe7f  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007b  00000000  00000000  001894fc  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00000c20  00000000  00000000  00189578  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  00003608  00000000  00000000  0018a198  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

20000510 <__do_global_dtors_aux>:
20000510:	b510      	push	{r4, lr}
20000512:	4c05      	ldr	r4, [pc, #20]	; (20000528 <__bss_end__+0x18>)
20000514:	7823      	ldrb	r3, [r4, #0]
20000516:	b933      	cbnz	r3, 20000526 <__do_global_dtors_aux+0x16>
20000518:	4b04      	ldr	r3, [pc, #16]	; (2000052c <__bss_end__+0x1c>)
2000051a:	b113      	cbz	r3, 20000522 <__do_global_dtors_aux+0x12>
2000051c:	4804      	ldr	r0, [pc, #16]	; (20000530 <__bss_end__+0x20>)
2000051e:	f3af 8000 	nop.w
20000522:	2301      	movs	r3, #1
20000524:	7023      	strb	r3, [r4, #0]
20000526:	bd10      	pop	{r4, pc}
20000528:	20000480 	.word	0x20000480
2000052c:	00000000 	.word	0x00000000
20000530:	2000e604 	.word	0x2000e604

20000534 <frame_dummy>:
20000534:	b508      	push	{r3, lr}
20000536:	4b03      	ldr	r3, [pc, #12]	; (20000544 <frame_dummy+0x10>)
20000538:	b11b      	cbz	r3, 20000542 <frame_dummy+0xe>
2000053a:	4903      	ldr	r1, [pc, #12]	; (20000548 <frame_dummy+0x14>)
2000053c:	4803      	ldr	r0, [pc, #12]	; (2000054c <frame_dummy+0x18>)
2000053e:	f3af 8000 	nop.w
20000542:	bd08      	pop	{r3, pc}
20000544:	00000000 	.word	0x00000000
20000548:	20000484 	.word	0x20000484
2000054c:	2000e604 	.word	0x2000e604

20000550 <_mainCRTStartup>:
20000550:	4b15      	ldr	r3, [pc, #84]	; (200005a8 <_mainCRTStartup+0x58>)
20000552:	2b00      	cmp	r3, #0
20000554:	bf08      	it	eq
20000556:	4b13      	ldreq	r3, [pc, #76]	; (200005a4 <_mainCRTStartup+0x54>)
20000558:	469d      	mov	sp, r3
2000055a:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
2000055e:	2100      	movs	r1, #0
20000560:	468b      	mov	fp, r1
20000562:	460f      	mov	r7, r1
20000564:	4813      	ldr	r0, [pc, #76]	; (200005b4 <_mainCRTStartup+0x64>)
20000566:	4a14      	ldr	r2, [pc, #80]	; (200005b8 <_mainCRTStartup+0x68>)
20000568:	1a12      	subs	r2, r2, r0
2000056a:	f00e f842 	bl	2000e5f2 <memset>
2000056e:	4b0f      	ldr	r3, [pc, #60]	; (200005ac <_mainCRTStartup+0x5c>)
20000570:	2b00      	cmp	r3, #0
20000572:	d000      	beq.n	20000576 <_mainCRTStartup+0x26>
20000574:	4798      	blx	r3
20000576:	4b0e      	ldr	r3, [pc, #56]	; (200005b0 <_mainCRTStartup+0x60>)
20000578:	2b00      	cmp	r3, #0
2000057a:	d000      	beq.n	2000057e <_mainCRTStartup+0x2e>
2000057c:	4798      	blx	r3
2000057e:	2000      	movs	r0, #0
20000580:	2100      	movs	r1, #0
20000582:	0004      	movs	r4, r0
20000584:	000d      	movs	r5, r1
20000586:	480d      	ldr	r0, [pc, #52]	; (200005bc <_mainCRTStartup+0x6c>)
20000588:	2800      	cmp	r0, #0
2000058a:	d002      	beq.n	20000592 <_mainCRTStartup+0x42>
2000058c:	480c      	ldr	r0, [pc, #48]	; (200005c0 <_mainCRTStartup+0x70>)
2000058e:	f3af 8000 	nop.w
20000592:	f00d fffb 	bl	2000e58c <__libc_init_array>
20000596:	0020      	movs	r0, r4
20000598:	0029      	movs	r1, r5
2000059a:	f000 fbcf 	bl	20000d3c <main>
2000059e:	f00d ffe1 	bl	2000e564 <exit>
200005a2:	bf00      	nop
200005a4:	00080000 	.word	0x00080000
	...
200005b4:	20000480 	.word	0x20000480
200005b8:	20000510 	.word	0x20000510
	...
200005c4:	20000408 	.word	0x20000408
200005c8:	20000408 	.word	0x20000408
200005cc:	20000480 	.word	0x20000480
200005d0:	20000480 	.word	0x20000480
200005d4:	20000510 	.word	0x20000510

200005d8 <__aeabi_uldivmod>:
200005d8:	b953      	cbnz	r3, 200005f0 <__aeabi_uldivmod+0x18>
200005da:	b94a      	cbnz	r2, 200005f0 <__aeabi_uldivmod+0x18>
200005dc:	2900      	cmp	r1, #0
200005de:	bf08      	it	eq
200005e0:	2800      	cmpeq	r0, #0
200005e2:	bf1c      	itt	ne
200005e4:	f04f 31ff 	movne.w	r1, #4294967295
200005e8:	f04f 30ff 	movne.w	r0, #4294967295
200005ec:	f000 b972 	b.w	200008d4 <__aeabi_idiv0>
200005f0:	f1ad 0c08 	sub.w	ip, sp, #8
200005f4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
200005f8:	f000 f806 	bl	20000608 <__udivmoddi4>
200005fc:	f8dd e004 	ldr.w	lr, [sp, #4]
20000600:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
20000604:	b004      	add	sp, #16
20000606:	4770      	bx	lr

20000608 <__udivmoddi4>:
20000608:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
2000060c:	9e08      	ldr	r6, [sp, #32]
2000060e:	4604      	mov	r4, r0
20000610:	4688      	mov	r8, r1
20000612:	2b00      	cmp	r3, #0
20000614:	d14b      	bne.n	200006ae <__udivmoddi4+0xa6>
20000616:	428a      	cmp	r2, r1
20000618:	4615      	mov	r5, r2
2000061a:	d967      	bls.n	200006ec <__udivmoddi4+0xe4>
2000061c:	fab2 f282 	clz	r2, r2
20000620:	b14a      	cbz	r2, 20000636 <__udivmoddi4+0x2e>
20000622:	f1c2 0720 	rsb	r7, r2, #32
20000626:	fa01 f302 	lsl.w	r3, r1, r2
2000062a:	fa20 f707 	lsr.w	r7, r0, r7
2000062e:	4095      	lsls	r5, r2
20000630:	ea47 0803 	orr.w	r8, r7, r3
20000634:	4094      	lsls	r4, r2
20000636:	ea4f 4e15 	mov.w	lr, r5, lsr #16
2000063a:	0c23      	lsrs	r3, r4, #16
2000063c:	fbb8 f7fe 	udiv	r7, r8, lr
20000640:	fa1f fc85 	uxth.w	ip, r5
20000644:	fb0e 8817 	mls	r8, lr, r7, r8
20000648:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
2000064c:	fb07 f10c 	mul.w	r1, r7, ip
20000650:	4299      	cmp	r1, r3
20000652:	d909      	bls.n	20000668 <__udivmoddi4+0x60>
20000654:	18eb      	adds	r3, r5, r3
20000656:	f107 30ff 	add.w	r0, r7, #4294967295
2000065a:	f080 811b 	bcs.w	20000894 <__udivmoddi4+0x28c>
2000065e:	4299      	cmp	r1, r3
20000660:	f240 8118 	bls.w	20000894 <__udivmoddi4+0x28c>
20000664:	3f02      	subs	r7, #2
20000666:	442b      	add	r3, r5
20000668:	1a5b      	subs	r3, r3, r1
2000066a:	b2a4      	uxth	r4, r4
2000066c:	fbb3 f0fe 	udiv	r0, r3, lr
20000670:	fb0e 3310 	mls	r3, lr, r0, r3
20000674:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
20000678:	fb00 fc0c 	mul.w	ip, r0, ip
2000067c:	45a4      	cmp	ip, r4
2000067e:	d909      	bls.n	20000694 <__udivmoddi4+0x8c>
20000680:	192c      	adds	r4, r5, r4
20000682:	f100 33ff 	add.w	r3, r0, #4294967295
20000686:	f080 8107 	bcs.w	20000898 <__udivmoddi4+0x290>
2000068a:	45a4      	cmp	ip, r4
2000068c:	f240 8104 	bls.w	20000898 <__udivmoddi4+0x290>
20000690:	3802      	subs	r0, #2
20000692:	442c      	add	r4, r5
20000694:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
20000698:	eba4 040c 	sub.w	r4, r4, ip
2000069c:	2700      	movs	r7, #0
2000069e:	b11e      	cbz	r6, 200006a8 <__udivmoddi4+0xa0>
200006a0:	40d4      	lsrs	r4, r2
200006a2:	2300      	movs	r3, #0
200006a4:	e9c6 4300 	strd	r4, r3, [r6]
200006a8:	4639      	mov	r1, r7
200006aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
200006ae:	428b      	cmp	r3, r1
200006b0:	d909      	bls.n	200006c6 <__udivmoddi4+0xbe>
200006b2:	2e00      	cmp	r6, #0
200006b4:	f000 80eb 	beq.w	2000088e <__udivmoddi4+0x286>
200006b8:	2700      	movs	r7, #0
200006ba:	e9c6 0100 	strd	r0, r1, [r6]
200006be:	4638      	mov	r0, r7
200006c0:	4639      	mov	r1, r7
200006c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
200006c6:	fab3 f783 	clz	r7, r3
200006ca:	2f00      	cmp	r7, #0
200006cc:	d147      	bne.n	2000075e <__udivmoddi4+0x156>
200006ce:	428b      	cmp	r3, r1
200006d0:	d302      	bcc.n	200006d8 <__udivmoddi4+0xd0>
200006d2:	4282      	cmp	r2, r0
200006d4:	f200 80fa 	bhi.w	200008cc <__udivmoddi4+0x2c4>
200006d8:	1a84      	subs	r4, r0, r2
200006da:	eb61 0303 	sbc.w	r3, r1, r3
200006de:	2001      	movs	r0, #1
200006e0:	4698      	mov	r8, r3
200006e2:	2e00      	cmp	r6, #0
200006e4:	d0e0      	beq.n	200006a8 <__udivmoddi4+0xa0>
200006e6:	e9c6 4800 	strd	r4, r8, [r6]
200006ea:	e7dd      	b.n	200006a8 <__udivmoddi4+0xa0>
200006ec:	b902      	cbnz	r2, 200006f0 <__udivmoddi4+0xe8>
200006ee:	deff      	udf	#255	; 0xff
200006f0:	fab2 f282 	clz	r2, r2
200006f4:	2a00      	cmp	r2, #0
200006f6:	f040 808f 	bne.w	20000818 <__udivmoddi4+0x210>
200006fa:	1b49      	subs	r1, r1, r5
200006fc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
20000700:	fa1f f885 	uxth.w	r8, r5
20000704:	2701      	movs	r7, #1
20000706:	fbb1 fcfe 	udiv	ip, r1, lr
2000070a:	0c23      	lsrs	r3, r4, #16
2000070c:	fb0e 111c 	mls	r1, lr, ip, r1
20000710:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
20000714:	fb08 f10c 	mul.w	r1, r8, ip
20000718:	4299      	cmp	r1, r3
2000071a:	d907      	bls.n	2000072c <__udivmoddi4+0x124>
2000071c:	18eb      	adds	r3, r5, r3
2000071e:	f10c 30ff 	add.w	r0, ip, #4294967295
20000722:	d202      	bcs.n	2000072a <__udivmoddi4+0x122>
20000724:	4299      	cmp	r1, r3
20000726:	f200 80cd 	bhi.w	200008c4 <__udivmoddi4+0x2bc>
2000072a:	4684      	mov	ip, r0
2000072c:	1a59      	subs	r1, r3, r1
2000072e:	b2a3      	uxth	r3, r4
20000730:	fbb1 f0fe 	udiv	r0, r1, lr
20000734:	fb0e 1410 	mls	r4, lr, r0, r1
20000738:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
2000073c:	fb08 f800 	mul.w	r8, r8, r0
20000740:	45a0      	cmp	r8, r4
20000742:	d907      	bls.n	20000754 <__udivmoddi4+0x14c>
20000744:	192c      	adds	r4, r5, r4
20000746:	f100 33ff 	add.w	r3, r0, #4294967295
2000074a:	d202      	bcs.n	20000752 <__udivmoddi4+0x14a>
2000074c:	45a0      	cmp	r8, r4
2000074e:	f200 80b6 	bhi.w	200008be <__udivmoddi4+0x2b6>
20000752:	4618      	mov	r0, r3
20000754:	eba4 0408 	sub.w	r4, r4, r8
20000758:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
2000075c:	e79f      	b.n	2000069e <__udivmoddi4+0x96>
2000075e:	f1c7 0c20 	rsb	ip, r7, #32
20000762:	40bb      	lsls	r3, r7
20000764:	fa22 fe0c 	lsr.w	lr, r2, ip
20000768:	ea4e 0e03 	orr.w	lr, lr, r3
2000076c:	fa01 f407 	lsl.w	r4, r1, r7
20000770:	fa20 f50c 	lsr.w	r5, r0, ip
20000774:	fa21 f30c 	lsr.w	r3, r1, ip
20000778:	ea4f 481e 	mov.w	r8, lr, lsr #16
2000077c:	4325      	orrs	r5, r4
2000077e:	fbb3 f9f8 	udiv	r9, r3, r8
20000782:	0c2c      	lsrs	r4, r5, #16
20000784:	fb08 3319 	mls	r3, r8, r9, r3
20000788:	fa1f fa8e 	uxth.w	sl, lr
2000078c:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
20000790:	fb09 f40a 	mul.w	r4, r9, sl
20000794:	429c      	cmp	r4, r3
20000796:	fa02 f207 	lsl.w	r2, r2, r7
2000079a:	fa00 f107 	lsl.w	r1, r0, r7
2000079e:	d90b      	bls.n	200007b8 <__udivmoddi4+0x1b0>
200007a0:	eb1e 0303 	adds.w	r3, lr, r3
200007a4:	f109 30ff 	add.w	r0, r9, #4294967295
200007a8:	f080 8087 	bcs.w	200008ba <__udivmoddi4+0x2b2>
200007ac:	429c      	cmp	r4, r3
200007ae:	f240 8084 	bls.w	200008ba <__udivmoddi4+0x2b2>
200007b2:	f1a9 0902 	sub.w	r9, r9, #2
200007b6:	4473      	add	r3, lr
200007b8:	1b1b      	subs	r3, r3, r4
200007ba:	b2ad      	uxth	r5, r5
200007bc:	fbb3 f0f8 	udiv	r0, r3, r8
200007c0:	fb08 3310 	mls	r3, r8, r0, r3
200007c4:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
200007c8:	fb00 fa0a 	mul.w	sl, r0, sl
200007cc:	45a2      	cmp	sl, r4
200007ce:	d908      	bls.n	200007e2 <__udivmoddi4+0x1da>
200007d0:	eb1e 0404 	adds.w	r4, lr, r4
200007d4:	f100 33ff 	add.w	r3, r0, #4294967295
200007d8:	d26b      	bcs.n	200008b2 <__udivmoddi4+0x2aa>
200007da:	45a2      	cmp	sl, r4
200007dc:	d969      	bls.n	200008b2 <__udivmoddi4+0x2aa>
200007de:	3802      	subs	r0, #2
200007e0:	4474      	add	r4, lr
200007e2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
200007e6:	fba0 8902 	umull	r8, r9, r0, r2
200007ea:	eba4 040a 	sub.w	r4, r4, sl
200007ee:	454c      	cmp	r4, r9
200007f0:	46c2      	mov	sl, r8
200007f2:	464b      	mov	r3, r9
200007f4:	d354      	bcc.n	200008a0 <__udivmoddi4+0x298>
200007f6:	d051      	beq.n	2000089c <__udivmoddi4+0x294>
200007f8:	2e00      	cmp	r6, #0
200007fa:	d069      	beq.n	200008d0 <__udivmoddi4+0x2c8>
200007fc:	ebb1 050a 	subs.w	r5, r1, sl
20000800:	eb64 0403 	sbc.w	r4, r4, r3
20000804:	fa04 fc0c 	lsl.w	ip, r4, ip
20000808:	40fd      	lsrs	r5, r7
2000080a:	40fc      	lsrs	r4, r7
2000080c:	ea4c 0505 	orr.w	r5, ip, r5
20000810:	e9c6 5400 	strd	r5, r4, [r6]
20000814:	2700      	movs	r7, #0
20000816:	e747      	b.n	200006a8 <__udivmoddi4+0xa0>
20000818:	f1c2 0320 	rsb	r3, r2, #32
2000081c:	fa20 f703 	lsr.w	r7, r0, r3
20000820:	4095      	lsls	r5, r2
20000822:	fa01 f002 	lsl.w	r0, r1, r2
20000826:	fa21 f303 	lsr.w	r3, r1, r3
2000082a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
2000082e:	4338      	orrs	r0, r7
20000830:	0c01      	lsrs	r1, r0, #16
20000832:	fbb3 f7fe 	udiv	r7, r3, lr
20000836:	fa1f f885 	uxth.w	r8, r5
2000083a:	fb0e 3317 	mls	r3, lr, r7, r3
2000083e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
20000842:	fb07 f308 	mul.w	r3, r7, r8
20000846:	428b      	cmp	r3, r1
20000848:	fa04 f402 	lsl.w	r4, r4, r2
2000084c:	d907      	bls.n	2000085e <__udivmoddi4+0x256>
2000084e:	1869      	adds	r1, r5, r1
20000850:	f107 3cff 	add.w	ip, r7, #4294967295
20000854:	d22f      	bcs.n	200008b6 <__udivmoddi4+0x2ae>
20000856:	428b      	cmp	r3, r1
20000858:	d92d      	bls.n	200008b6 <__udivmoddi4+0x2ae>
2000085a:	3f02      	subs	r7, #2
2000085c:	4429      	add	r1, r5
2000085e:	1acb      	subs	r3, r1, r3
20000860:	b281      	uxth	r1, r0
20000862:	fbb3 f0fe 	udiv	r0, r3, lr
20000866:	fb0e 3310 	mls	r3, lr, r0, r3
2000086a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
2000086e:	fb00 f308 	mul.w	r3, r0, r8
20000872:	428b      	cmp	r3, r1
20000874:	d907      	bls.n	20000886 <__udivmoddi4+0x27e>
20000876:	1869      	adds	r1, r5, r1
20000878:	f100 3cff 	add.w	ip, r0, #4294967295
2000087c:	d217      	bcs.n	200008ae <__udivmoddi4+0x2a6>
2000087e:	428b      	cmp	r3, r1
20000880:	d915      	bls.n	200008ae <__udivmoddi4+0x2a6>
20000882:	3802      	subs	r0, #2
20000884:	4429      	add	r1, r5
20000886:	1ac9      	subs	r1, r1, r3
20000888:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
2000088c:	e73b      	b.n	20000706 <__udivmoddi4+0xfe>
2000088e:	4637      	mov	r7, r6
20000890:	4630      	mov	r0, r6
20000892:	e709      	b.n	200006a8 <__udivmoddi4+0xa0>
20000894:	4607      	mov	r7, r0
20000896:	e6e7      	b.n	20000668 <__udivmoddi4+0x60>
20000898:	4618      	mov	r0, r3
2000089a:	e6fb      	b.n	20000694 <__udivmoddi4+0x8c>
2000089c:	4541      	cmp	r1, r8
2000089e:	d2ab      	bcs.n	200007f8 <__udivmoddi4+0x1f0>
200008a0:	ebb8 0a02 	subs.w	sl, r8, r2
200008a4:	eb69 020e 	sbc.w	r2, r9, lr
200008a8:	3801      	subs	r0, #1
200008aa:	4613      	mov	r3, r2
200008ac:	e7a4      	b.n	200007f8 <__udivmoddi4+0x1f0>
200008ae:	4660      	mov	r0, ip
200008b0:	e7e9      	b.n	20000886 <__udivmoddi4+0x27e>
200008b2:	4618      	mov	r0, r3
200008b4:	e795      	b.n	200007e2 <__udivmoddi4+0x1da>
200008b6:	4667      	mov	r7, ip
200008b8:	e7d1      	b.n	2000085e <__udivmoddi4+0x256>
200008ba:	4681      	mov	r9, r0
200008bc:	e77c      	b.n	200007b8 <__udivmoddi4+0x1b0>
200008be:	3802      	subs	r0, #2
200008c0:	442c      	add	r4, r5
200008c2:	e747      	b.n	20000754 <__udivmoddi4+0x14c>
200008c4:	f1ac 0c02 	sub.w	ip, ip, #2
200008c8:	442b      	add	r3, r5
200008ca:	e72f      	b.n	2000072c <__udivmoddi4+0x124>
200008cc:	4638      	mov	r0, r7
200008ce:	e708      	b.n	200006e2 <__udivmoddi4+0xda>
200008d0:	4637      	mov	r7, r6
200008d2:	e6e9      	b.n	200006a8 <__udivmoddi4+0xa0>

200008d4 <__aeabi_idiv0>:
200008d4:	4770      	bx	lr
200008d6:	bf00      	nop

200008d8 <Init>:
 * @brief  System initialization.
 * @param  None
 * @retval  LOADER_OK = 1	: Operation succeeded
 * @retval  LOADER_FAIL = 0	: Operation failed
 */
int Init(void) {
200008d8:	b580      	push	{r7, lr}
200008da:	af00      	add	r7, sp, #0

	*(uint32_t*)0xE000EDF0=0xA05F0000; //enable interrupts in debug
200008dc:	4b18      	ldr	r3, [pc, #96]	; (20000940 <Init+0x68>)
200008de:	4a19      	ldr	r2, [pc, #100]	; (20000944 <Init+0x6c>)
200008e0:	601a      	str	r2, [r3, #0]

	SystemInit();
200008e2:	f001 f8e9 	bl	20001ab8 <SystemInit>
 * change VTOR setting for other devices
 * SCB->VTOR = 0x20000000 | 0x200;
 *
 * */

	SCB->VTOR = 0x20000000 | 0x200;
200008e6:	4b18      	ldr	r3, [pc, #96]	; (20000948 <Init+0x70>)
200008e8:	4a18      	ldr	r2, [pc, #96]	; (2000094c <Init+0x74>)
200008ea:	609a      	str	r2, [r3, #8]

	HAL_Init();
200008ec:	f001 f9bd 	bl	20001c6a <HAL_Init>

    SystemClock_Config();
200008f0:	f000 fad0 	bl	20000e94 <SystemClock_Config>

    MX_GPIO_Init();
200008f4:	f000 f9e6 	bl	20000cc4 <MX_GPIO_Init>
	
	__HAL_RCC_QSPI_FORCE_RESET();  //completely reset peripheral
200008f8:	4b15      	ldr	r3, [pc, #84]	; (20000950 <Init+0x78>)
200008fa:	699b      	ldr	r3, [r3, #24]
200008fc:	4a14      	ldr	r2, [pc, #80]	; (20000950 <Init+0x78>)
200008fe:	f043 0302 	orr.w	r3, r3, #2
20000902:	6193      	str	r3, [r2, #24]
    __HAL_RCC_QSPI_RELEASE_RESET();
20000904:	4b12      	ldr	r3, [pc, #72]	; (20000950 <Init+0x78>)
20000906:	699b      	ldr	r3, [r3, #24]
20000908:	4a11      	ldr	r2, [pc, #68]	; (20000950 <Init+0x78>)
2000090a:	f023 0302 	bic.w	r3, r3, #2
2000090e:	6193      	str	r3, [r2, #24]

	if (CSP_QUADSPI_Init() != HAL_OK)
20000910:	f000 fc42 	bl	20001198 <CSP_QUADSPI_Init>
20000914:	4603      	mov	r3, r0
20000916:	2b00      	cmp	r3, #0
20000918:	d003      	beq.n	20000922 <Init+0x4a>
	{
		HAL_SuspendTick();
2000091a:	f001 fa97 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
2000091e:	2300      	movs	r3, #0
20000920:	e00b      	b.n	2000093a <Init+0x62>
	}


	if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
20000922:	f000 feaf 	bl	20001684 <CSP_QSPI_EnableMemoryMappedMode>
20000926:	4603      	mov	r3, r0
20000928:	2b00      	cmp	r3, #0
2000092a:	d003      	beq.n	20000934 <Init+0x5c>
	{
		HAL_SuspendTick();
2000092c:	f001 fa8e 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
20000930:	2300      	movs	r3, #0
20000932:	e002      	b.n	2000093a <Init+0x62>
	}

		HAL_SuspendTick();
20000934:	f001 fa8a 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_OK;
20000938:	2301      	movs	r3, #1
}
2000093a:	4618      	mov	r0, r3
2000093c:	bd80      	pop	{r7, pc}
2000093e:	bf00      	nop
20000940:	e000edf0 	.word	0xe000edf0
20000944:	a05f0000 	.word	0xa05f0000
20000948:	e000ed00 	.word	0xe000ed00
2000094c:	20000200 	.word	0x20000200
20000950:	40023800 	.word	0x40023800

20000954 <Write>:
 * @param   Size   : size of data
 * @param   buffer : pointer to data buffer
 * @retval  LOADER_OK = 1		: Operation succeeded
 * @retval  LOADER_FAIL = 0	: Operation failed
 */
int Write(uint32_t Address, uint32_t Size, uint8_t* buffer) {
20000954:	b580      	push	{r7, lr}
20000956:	b084      	sub	sp, #16
20000958:	af00      	add	r7, sp, #0
2000095a:	60f8      	str	r0, [r7, #12]
2000095c:	60b9      	str	r1, [r7, #8]
2000095e:	607a      	str	r2, [r7, #4]

	HAL_ResumeTick();
20000960:	f001 fa84 	bl	20001e6c <HAL_ResumeTick>


	if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
20000964:	480f      	ldr	r0, [pc, #60]	; (200009a4 <Write+0x50>)
20000966:	f00b fc58 	bl	2000c21a <HAL_QSPI_Abort>
2000096a:	4603      	mov	r3, r0
2000096c:	2b00      	cmp	r3, #0
2000096e:	d003      	beq.n	20000978 <Write+0x24>
	{
		HAL_SuspendTick();
20000970:	f001 fa6c 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
20000974:	2300      	movs	r3, #0
20000976:	e011      	b.n	2000099c <Write+0x48>
	}


	if (CSP_QSPI_WriteMemory((uint8_t*) buffer, (Address & (0x0fffffff)),Size) != HAL_OK)
20000978:	68fb      	ldr	r3, [r7, #12]
2000097a:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
2000097e:	68ba      	ldr	r2, [r7, #8]
20000980:	4619      	mov	r1, r3
20000982:	6878      	ldr	r0, [r7, #4]
20000984:	f000 fdf2 	bl	2000156c <CSP_QSPI_WriteMemory>
20000988:	4603      	mov	r3, r0
2000098a:	2b00      	cmp	r3, #0
2000098c:	d003      	beq.n	20000996 <Write+0x42>
	{
		HAL_SuspendTick();
2000098e:	f001 fa5d 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
20000992:	2300      	movs	r3, #0
20000994:	e002      	b.n	2000099c <Write+0x48>
	}

	HAL_SuspendTick();
20000996:	f001 fa59 	bl	20001e4c <HAL_SuspendTick>
	return LOADER_OK;
2000099a:	2301      	movs	r3, #1
}
2000099c:	4618      	mov	r0, r3
2000099e:	3710      	adds	r7, #16
200009a0:	46bd      	mov	sp, r7
200009a2:	bd80      	pop	{r7, pc}
200009a4:	200004a4 	.word	0x200004a4

200009a8 <SectorErase>:
 * @param   EraseStartAddress :  erase start address
 * @param   EraseEndAddress   :  erase end address
 * @retval  LOADER_OK = 1		: Operation succeeded
 * @retval  LOADER_FAIL = 0	: Operation failed
 */
int SectorErase(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
200009a8:	b580      	push	{r7, lr}
200009aa:	b082      	sub	sp, #8
200009ac:	af00      	add	r7, sp, #0
200009ae:	6078      	str	r0, [r7, #4]
200009b0:	6039      	str	r1, [r7, #0]

	HAL_ResumeTick();
200009b2:	f001 fa5b 	bl	20001e6c <HAL_ResumeTick>

	if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
200009b6:	480e      	ldr	r0, [pc, #56]	; (200009f0 <SectorErase+0x48>)
200009b8:	f00b fc2f 	bl	2000c21a <HAL_QSPI_Abort>
200009bc:	4603      	mov	r3, r0
200009be:	2b00      	cmp	r3, #0
200009c0:	d003      	beq.n	200009ca <SectorErase+0x22>
	{
		HAL_SuspendTick();
200009c2:	f001 fa43 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
200009c6:	2300      	movs	r3, #0
200009c8:	e00d      	b.n	200009e6 <SectorErase+0x3e>
	}


	if (CSP_QSPI_EraseSector(EraseStartAddress, EraseEndAddress) != HAL_OK)
200009ca:	6839      	ldr	r1, [r7, #0]
200009cc:	6878      	ldr	r0, [r7, #4]
200009ce:	f000 fd7b 	bl	200014c8 <CSP_QSPI_EraseSector>
200009d2:	4603      	mov	r3, r0
200009d4:	2b00      	cmp	r3, #0
200009d6:	d003      	beq.n	200009e0 <SectorErase+0x38>
	{
		HAL_SuspendTick();
200009d8:	f001 fa38 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
200009dc:	2300      	movs	r3, #0
200009de:	e002      	b.n	200009e6 <SectorErase+0x3e>
	}

	HAL_SuspendTick();
200009e0:	f001 fa34 	bl	20001e4c <HAL_SuspendTick>
	return LOADER_OK;
200009e4:	2301      	movs	r3, #1
}
200009e6:	4618      	mov	r0, r3
200009e8:	3708      	adds	r7, #8
200009ea:	46bd      	mov	sp, r7
200009ec:	bd80      	pop	{r7, pc}
200009ee:	bf00      	nop
200009f0:	200004a4 	.word	0x200004a4

200009f4 <MassErase>:
 *      none
 * outputs   :
 *     none
 * Note: Optional for all types of device
 */
int MassErase(void) {
200009f4:	b580      	push	{r7, lr}
200009f6:	af00      	add	r7, sp, #0

	HAL_ResumeTick();
200009f8:	f001 fa38 	bl	20001e6c <HAL_ResumeTick>


	if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
200009fc:	480b      	ldr	r0, [pc, #44]	; (20000a2c <MassErase+0x38>)
200009fe:	f00b fc0c 	bl	2000c21a <HAL_QSPI_Abort>
20000a02:	4603      	mov	r3, r0
20000a04:	2b00      	cmp	r3, #0
20000a06:	d003      	beq.n	20000a10 <MassErase+0x1c>
	{
		HAL_SuspendTick();
20000a08:	f001 fa20 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
20000a0c:	2300      	movs	r3, #0
20000a0e:	e00b      	b.n	20000a28 <MassErase+0x34>
	}


	if (CSP_QSPI_Erase_Chip() != HAL_OK)
20000a10:	f000 fbf2 	bl	200011f8 <CSP_QSPI_Erase_Chip>
20000a14:	4603      	mov	r3, r0
20000a16:	2b00      	cmp	r3, #0
20000a18:	d003      	beq.n	20000a22 <MassErase+0x2e>
	{
		 HAL_SuspendTick();
20000a1a:	f001 fa17 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
20000a1e:	2300      	movs	r3, #0
20000a20:	e002      	b.n	20000a28 <MassErase+0x34>
	}

	HAL_SuspendTick();
20000a22:	f001 fa13 	bl	20001e4c <HAL_SuspendTick>
	return LOADER_OK;
20000a26:	2301      	movs	r3, #1
}
20000a28:	4618      	mov	r0, r3
20000a2a:	bd80      	pop	{r7, pc}
20000a2c:	200004a4 	.word	0x200004a4

20000a30 <CheckSum>:
 *      InitVal       : Initial CRC value
 * outputs   :
 *     R0             : Checksum value
 * Note: Optional for all types of device
 */
uint32_t CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal) {
20000a30:	b480      	push	{r7}
20000a32:	b089      	sub	sp, #36	; 0x24
20000a34:	af00      	add	r7, sp, #0
20000a36:	60f8      	str	r0, [r7, #12]
20000a38:	60b9      	str	r1, [r7, #8]
20000a3a:	607a      	str	r2, [r7, #4]
	uint8_t missalignementAddress = StartAddress % 4;
20000a3c:	68fb      	ldr	r3, [r7, #12]
20000a3e:	b2db      	uxtb	r3, r3
20000a40:	f003 0303 	and.w	r3, r3, #3
20000a44:	77fb      	strb	r3, [r7, #31]
	uint8_t missalignementSize = Size;
20000a46:	68bb      	ldr	r3, [r7, #8]
20000a48:	77bb      	strb	r3, [r7, #30]
	int cnt;
	uint32_t Val;

	StartAddress -= StartAddress % 4;
20000a4a:	68fb      	ldr	r3, [r7, #12]
20000a4c:	f023 0303 	bic.w	r3, r3, #3
20000a50:	60fb      	str	r3, [r7, #12]
	Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
20000a52:	68bb      	ldr	r3, [r7, #8]
20000a54:	f003 0303 	and.w	r3, r3, #3
20000a58:	2b00      	cmp	r3, #0
20000a5a:	d005      	beq.n	20000a68 <CheckSum+0x38>
20000a5c:	68bb      	ldr	r3, [r7, #8]
20000a5e:	f003 0303 	and.w	r3, r3, #3
20000a62:	f1c3 0304 	rsb	r3, r3, #4
20000a66:	e000      	b.n	20000a6a <CheckSum+0x3a>
20000a68:	2300      	movs	r3, #0
20000a6a:	68ba      	ldr	r2, [r7, #8]
20000a6c:	4413      	add	r3, r2
20000a6e:	60bb      	str	r3, [r7, #8]

	for (cnt = 0; cnt < Size; cnt += 4) {
20000a70:	2300      	movs	r3, #0
20000a72:	61bb      	str	r3, [r7, #24]
20000a74:	e0af      	b.n	20000bd6 <CheckSum+0x1a6>
		Val = *(uint32_t*) StartAddress;
20000a76:	68fb      	ldr	r3, [r7, #12]
20000a78:	681b      	ldr	r3, [r3, #0]
20000a7a:	617b      	str	r3, [r7, #20]
		if (missalignementAddress) {
20000a7c:	7ffb      	ldrb	r3, [r7, #31]
20000a7e:	2b00      	cmp	r3, #0
20000a80:	d03e      	beq.n	20000b00 <CheckSum+0xd0>
			switch (missalignementAddress) {
20000a82:	7ffb      	ldrb	r3, [r7, #31]
20000a84:	2b02      	cmp	r3, #2
20000a86:	d01d      	beq.n	20000ac4 <CheckSum+0x94>
20000a88:	2b03      	cmp	r3, #3
20000a8a:	d02d      	beq.n	20000ae8 <CheckSum+0xb8>
20000a8c:	2b01      	cmp	r3, #1
20000a8e:	f040 809c 	bne.w	20000bca <CheckSum+0x19a>
			case 1:
				InitVal += (uint8_t) (Val >> 8 & 0xff);
20000a92:	697b      	ldr	r3, [r7, #20]
20000a94:	0a1b      	lsrs	r3, r3, #8
20000a96:	b2db      	uxtb	r3, r3
20000a98:	461a      	mov	r2, r3
20000a9a:	687b      	ldr	r3, [r7, #4]
20000a9c:	4413      	add	r3, r2
20000a9e:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 16 & 0xff);
20000aa0:	697b      	ldr	r3, [r7, #20]
20000aa2:	0c1b      	lsrs	r3, r3, #16
20000aa4:	b2db      	uxtb	r3, r3
20000aa6:	461a      	mov	r2, r3
20000aa8:	687b      	ldr	r3, [r7, #4]
20000aaa:	4413      	add	r3, r2
20000aac:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 24 & 0xff);
20000aae:	697b      	ldr	r3, [r7, #20]
20000ab0:	0e1b      	lsrs	r3, r3, #24
20000ab2:	b2db      	uxtb	r3, r3
20000ab4:	461a      	mov	r2, r3
20000ab6:	687b      	ldr	r3, [r7, #4]
20000ab8:	4413      	add	r3, r2
20000aba:	607b      	str	r3, [r7, #4]
				missalignementAddress -= 1;
20000abc:	7ffb      	ldrb	r3, [r7, #31]
20000abe:	3b01      	subs	r3, #1
20000ac0:	77fb      	strb	r3, [r7, #31]
				break;
20000ac2:	e082      	b.n	20000bca <CheckSum+0x19a>
			case 2:
				InitVal += (uint8_t) (Val >> 16 & 0xff);
20000ac4:	697b      	ldr	r3, [r7, #20]
20000ac6:	0c1b      	lsrs	r3, r3, #16
20000ac8:	b2db      	uxtb	r3, r3
20000aca:	461a      	mov	r2, r3
20000acc:	687b      	ldr	r3, [r7, #4]
20000ace:	4413      	add	r3, r2
20000ad0:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 24 & 0xff);
20000ad2:	697b      	ldr	r3, [r7, #20]
20000ad4:	0e1b      	lsrs	r3, r3, #24
20000ad6:	b2db      	uxtb	r3, r3
20000ad8:	461a      	mov	r2, r3
20000ada:	687b      	ldr	r3, [r7, #4]
20000adc:	4413      	add	r3, r2
20000ade:	607b      	str	r3, [r7, #4]
				missalignementAddress -= 2;
20000ae0:	7ffb      	ldrb	r3, [r7, #31]
20000ae2:	3b02      	subs	r3, #2
20000ae4:	77fb      	strb	r3, [r7, #31]
				break;
20000ae6:	e070      	b.n	20000bca <CheckSum+0x19a>
			case 3:
				InitVal += (uint8_t) (Val >> 24 & 0xff);
20000ae8:	697b      	ldr	r3, [r7, #20]
20000aea:	0e1b      	lsrs	r3, r3, #24
20000aec:	b2db      	uxtb	r3, r3
20000aee:	461a      	mov	r2, r3
20000af0:	687b      	ldr	r3, [r7, #4]
20000af2:	4413      	add	r3, r2
20000af4:	607b      	str	r3, [r7, #4]
				missalignementAddress -= 3;
20000af6:	7ffb      	ldrb	r3, [r7, #31]
20000af8:	3b03      	subs	r3, #3
20000afa:	77fb      	strb	r3, [r7, #31]
				break;
20000afc:	bf00      	nop
20000afe:	e064      	b.n	20000bca <CheckSum+0x19a>
			}
		} else if ((Size - missalignementSize) % 4 && (Size - cnt) <= 4) {
20000b00:	7fbb      	ldrb	r3, [r7, #30]
20000b02:	68ba      	ldr	r2, [r7, #8]
20000b04:	1ad3      	subs	r3, r2, r3
20000b06:	f003 0303 	and.w	r3, r3, #3
20000b0a:	2b00      	cmp	r3, #0
20000b0c:	d042      	beq.n	20000b94 <CheckSum+0x164>
20000b0e:	69bb      	ldr	r3, [r7, #24]
20000b10:	68ba      	ldr	r2, [r7, #8]
20000b12:	1ad3      	subs	r3, r2, r3
20000b14:	2b04      	cmp	r3, #4
20000b16:	d83d      	bhi.n	20000b94 <CheckSum+0x164>
			switch (Size - missalignementSize) {
20000b18:	7fbb      	ldrb	r3, [r7, #30]
20000b1a:	68ba      	ldr	r2, [r7, #8]
20000b1c:	1ad3      	subs	r3, r2, r3
20000b1e:	2b02      	cmp	r3, #2
20000b20:	d01c      	beq.n	20000b5c <CheckSum+0x12c>
20000b22:	2b03      	cmp	r3, #3
20000b24:	d02b      	beq.n	20000b7e <CheckSum+0x14e>
20000b26:	2b01      	cmp	r3, #1
20000b28:	d000      	beq.n	20000b2c <CheckSum+0xfc>
			case 3:
				InitVal += (uint8_t) Val;
				missalignementSize -= 3;
				break;
			}
		} else {
20000b2a:	e04e      	b.n	20000bca <CheckSum+0x19a>
				InitVal += (uint8_t) Val;
20000b2c:	697b      	ldr	r3, [r7, #20]
20000b2e:	b2db      	uxtb	r3, r3
20000b30:	461a      	mov	r2, r3
20000b32:	687b      	ldr	r3, [r7, #4]
20000b34:	4413      	add	r3, r2
20000b36:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 8 & 0xff);
20000b38:	697b      	ldr	r3, [r7, #20]
20000b3a:	0a1b      	lsrs	r3, r3, #8
20000b3c:	b2db      	uxtb	r3, r3
20000b3e:	461a      	mov	r2, r3
20000b40:	687b      	ldr	r3, [r7, #4]
20000b42:	4413      	add	r3, r2
20000b44:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 16 & 0xff);
20000b46:	697b      	ldr	r3, [r7, #20]
20000b48:	0c1b      	lsrs	r3, r3, #16
20000b4a:	b2db      	uxtb	r3, r3
20000b4c:	461a      	mov	r2, r3
20000b4e:	687b      	ldr	r3, [r7, #4]
20000b50:	4413      	add	r3, r2
20000b52:	607b      	str	r3, [r7, #4]
				missalignementSize -= 1;
20000b54:	7fbb      	ldrb	r3, [r7, #30]
20000b56:	3b01      	subs	r3, #1
20000b58:	77bb      	strb	r3, [r7, #30]
				break;
20000b5a:	e01a      	b.n	20000b92 <CheckSum+0x162>
				InitVal += (uint8_t) Val;
20000b5c:	697b      	ldr	r3, [r7, #20]
20000b5e:	b2db      	uxtb	r3, r3
20000b60:	461a      	mov	r2, r3
20000b62:	687b      	ldr	r3, [r7, #4]
20000b64:	4413      	add	r3, r2
20000b66:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 8 & 0xff);
20000b68:	697b      	ldr	r3, [r7, #20]
20000b6a:	0a1b      	lsrs	r3, r3, #8
20000b6c:	b2db      	uxtb	r3, r3
20000b6e:	461a      	mov	r2, r3
20000b70:	687b      	ldr	r3, [r7, #4]
20000b72:	4413      	add	r3, r2
20000b74:	607b      	str	r3, [r7, #4]
				missalignementSize -= 2;
20000b76:	7fbb      	ldrb	r3, [r7, #30]
20000b78:	3b02      	subs	r3, #2
20000b7a:	77bb      	strb	r3, [r7, #30]
				break;
20000b7c:	e009      	b.n	20000b92 <CheckSum+0x162>
				InitVal += (uint8_t) Val;
20000b7e:	697b      	ldr	r3, [r7, #20]
20000b80:	b2db      	uxtb	r3, r3
20000b82:	461a      	mov	r2, r3
20000b84:	687b      	ldr	r3, [r7, #4]
20000b86:	4413      	add	r3, r2
20000b88:	607b      	str	r3, [r7, #4]
				missalignementSize -= 3;
20000b8a:	7fbb      	ldrb	r3, [r7, #30]
20000b8c:	3b03      	subs	r3, #3
20000b8e:	77bb      	strb	r3, [r7, #30]
				break;
20000b90:	bf00      	nop
		} else {
20000b92:	e01a      	b.n	20000bca <CheckSum+0x19a>
			InitVal += (uint8_t) Val;
20000b94:	697b      	ldr	r3, [r7, #20]
20000b96:	b2db      	uxtb	r3, r3
20000b98:	461a      	mov	r2, r3
20000b9a:	687b      	ldr	r3, [r7, #4]
20000b9c:	4413      	add	r3, r2
20000b9e:	607b      	str	r3, [r7, #4]
			InitVal += (uint8_t) (Val >> 8 & 0xff);
20000ba0:	697b      	ldr	r3, [r7, #20]
20000ba2:	0a1b      	lsrs	r3, r3, #8
20000ba4:	b2db      	uxtb	r3, r3
20000ba6:	461a      	mov	r2, r3
20000ba8:	687b      	ldr	r3, [r7, #4]
20000baa:	4413      	add	r3, r2
20000bac:	607b      	str	r3, [r7, #4]
			InitVal += (uint8_t) (Val >> 16 & 0xff);
20000bae:	697b      	ldr	r3, [r7, #20]
20000bb0:	0c1b      	lsrs	r3, r3, #16
20000bb2:	b2db      	uxtb	r3, r3
20000bb4:	461a      	mov	r2, r3
20000bb6:	687b      	ldr	r3, [r7, #4]
20000bb8:	4413      	add	r3, r2
20000bba:	607b      	str	r3, [r7, #4]
			InitVal += (uint8_t) (Val >> 24 & 0xff);
20000bbc:	697b      	ldr	r3, [r7, #20]
20000bbe:	0e1b      	lsrs	r3, r3, #24
20000bc0:	b2db      	uxtb	r3, r3
20000bc2:	461a      	mov	r2, r3
20000bc4:	687b      	ldr	r3, [r7, #4]
20000bc6:	4413      	add	r3, r2
20000bc8:	607b      	str	r3, [r7, #4]
		}
		StartAddress += 4;
20000bca:	68fb      	ldr	r3, [r7, #12]
20000bcc:	3304      	adds	r3, #4
20000bce:	60fb      	str	r3, [r7, #12]
	for (cnt = 0; cnt < Size; cnt += 4) {
20000bd0:	69bb      	ldr	r3, [r7, #24]
20000bd2:	3304      	adds	r3, #4
20000bd4:	61bb      	str	r3, [r7, #24]
20000bd6:	69bb      	ldr	r3, [r7, #24]
20000bd8:	68ba      	ldr	r2, [r7, #8]
20000bda:	429a      	cmp	r2, r3
20000bdc:	f63f af4b 	bhi.w	20000a76 <CheckSum+0x46>
	}

	return (InitVal);
20000be0:	687b      	ldr	r3, [r7, #4]
}
20000be2:	4618      	mov	r0, r3
20000be4:	3724      	adds	r7, #36	; 0x24
20000be6:	46bd      	mov	sp, r7
20000be8:	f85d 7b04 	ldr.w	r7, [sp], #4
20000bec:	4770      	bx	lr

20000bee <Verify>:
 * outputs   :
 *     R0             : Operation failed (address of failure)
 *     R1             : Checksum value
 * Note: Optional for all types of device
 */
uint64_t Verify(uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size,uint32_t missalignement){
20000bee:	e92d 4890 	stmdb	sp!, {r4, r7, fp, lr}
20000bf2:	b088      	sub	sp, #32
20000bf4:	af00      	add	r7, sp, #0
20000bf6:	60f8      	str	r0, [r7, #12]
20000bf8:	60b9      	str	r1, [r7, #8]
20000bfa:	607a      	str	r2, [r7, #4]
20000bfc:	603b      	str	r3, [r7, #0]

	HAL_ResumeTick();
20000bfe:	f001 f935 	bl	20001e6c <HAL_ResumeTick>
	uint32_t VerifiedData = 0, InitVal = 0;
20000c02:	2300      	movs	r3, #0
20000c04:	61fb      	str	r3, [r7, #28]
20000c06:	2300      	movs	r3, #0
20000c08:	61bb      	str	r3, [r7, #24]
	uint64_t checksum;
	Size *= 4;
20000c0a:	687b      	ldr	r3, [r7, #4]
20000c0c:	009b      	lsls	r3, r3, #2
20000c0e:	607b      	str	r3, [r7, #4]

	if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
20000c10:	f000 fd38 	bl	20001684 <CSP_QSPI_EnableMemoryMappedMode>
20000c14:	4603      	mov	r3, r0
20000c16:	2b00      	cmp	r3, #0
20000c18:	d006      	beq.n	20000c28 <Verify+0x3a>
	{
		HAL_SuspendTick();
20000c1a:	f001 f917 	bl	20001e4c <HAL_SuspendTick>
		return LOADER_FAIL;
20000c1e:	f04f 0b00 	mov.w	fp, #0
20000c22:	f04f 0c00 	mov.w	ip, #0
20000c26:	e045      	b.n	20000cb4 <Verify+0xc6>
	}

	checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
20000c28:	683b      	ldr	r3, [r7, #0]
20000c2a:	f003 020f 	and.w	r2, r3, #15
20000c2e:	68fb      	ldr	r3, [r7, #12]
20000c30:	18d0      	adds	r0, r2, r3
			Size - ((missalignement >> 16) & 0xF), InitVal);
20000c32:	683b      	ldr	r3, [r7, #0]
20000c34:	0c1b      	lsrs	r3, r3, #16
20000c36:	f003 030f 	and.w	r3, r3, #15
	checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
20000c3a:	687a      	ldr	r2, [r7, #4]
20000c3c:	1ad3      	subs	r3, r2, r3
20000c3e:	69ba      	ldr	r2, [r7, #24]
20000c40:	4619      	mov	r1, r3
20000c42:	f7ff fef5 	bl	20000a30 <CheckSum>
20000c46:	4603      	mov	r3, r0
20000c48:	f04f 0400 	mov.w	r4, #0
20000c4c:	e9c7 3404 	strd	r3, r4, [r7, #16]
	while (Size > VerifiedData) {
20000c50:	e021      	b.n	20000c96 <Verify+0xa8>
		if (*(uint8_t*) MemoryAddr++
20000c52:	68fb      	ldr	r3, [r7, #12]
20000c54:	1c5a      	adds	r2, r3, #1
20000c56:	60fa      	str	r2, [r7, #12]
20000c58:	781a      	ldrb	r2, [r3, #0]
				!= *((uint8_t*) RAMBufferAddr + VerifiedData)){
20000c5a:	69f9      	ldr	r1, [r7, #28]
20000c5c:	68bb      	ldr	r3, [r7, #8]
20000c5e:	440b      	add	r3, r1
20000c60:	781b      	ldrb	r3, [r3, #0]
		if (*(uint8_t*) MemoryAddr++
20000c62:	429a      	cmp	r2, r3
20000c64:	d014      	beq.n	20000c90 <Verify+0xa2>
			HAL_SuspendTick();
20000c66:	f001 f8f1 	bl	20001e4c <HAL_SuspendTick>
			return ((checksum << 32) + (MemoryAddr + VerifiedData));
20000c6a:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
20000c6e:	f04f 0300 	mov.w	r3, #0
20000c72:	f04f 0400 	mov.w	r4, #0
20000c76:	000c      	movs	r4, r1
20000c78:	2300      	movs	r3, #0
20000c7a:	68f9      	ldr	r1, [r7, #12]
20000c7c:	69fa      	ldr	r2, [r7, #28]
20000c7e:	440a      	add	r2, r1
20000c80:	4611      	mov	r1, r2
20000c82:	f04f 0200 	mov.w	r2, #0
20000c86:	eb13 0b01 	adds.w	fp, r3, r1
20000c8a:	eb44 0c02 	adc.w	ip, r4, r2
20000c8e:	e011      	b.n	20000cb4 <Verify+0xc6>
		}
		VerifiedData++;
20000c90:	69fb      	ldr	r3, [r7, #28]
20000c92:	3301      	adds	r3, #1
20000c94:	61fb      	str	r3, [r7, #28]
	while (Size > VerifiedData) {
20000c96:	687a      	ldr	r2, [r7, #4]
20000c98:	69fb      	ldr	r3, [r7, #28]
20000c9a:	429a      	cmp	r2, r3
20000c9c:	d8d9      	bhi.n	20000c52 <Verify+0x64>
	}

	HAL_SuspendTick();
20000c9e:	f001 f8d5 	bl	20001e4c <HAL_SuspendTick>
	return (checksum << 32);
20000ca2:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
20000ca6:	f04f 0b00 	mov.w	fp, #0
20000caa:	f04f 0c00 	mov.w	ip, #0
20000cae:	468c      	mov	ip, r1
20000cb0:	f04f 0b00 	mov.w	fp, #0
20000cb4:	465b      	mov	r3, fp
20000cb6:	4664      	mov	r4, ip
}
20000cb8:	4618      	mov	r0, r3
20000cba:	4621      	mov	r1, r4
20000cbc:	3720      	adds	r7, #32
20000cbe:	46bd      	mov	sp, r7
20000cc0:	e8bd 8890 	ldmia.w	sp!, {r4, r7, fp, pc}

20000cc4 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Pinout Configuration
*/
void MX_GPIO_Init(void)
{
20000cc4:	b480      	push	{r7}
20000cc6:	b085      	sub	sp, #20
20000cc8:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
20000cca:	4b1b      	ldr	r3, [pc, #108]	; (20000d38 <MX_GPIO_Init+0x74>)
20000ccc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000cce:	4a1a      	ldr	r2, [pc, #104]	; (20000d38 <MX_GPIO_Init+0x74>)
20000cd0:	f043 0310 	orr.w	r3, r3, #16
20000cd4:	6313      	str	r3, [r2, #48]	; 0x30
20000cd6:	4b18      	ldr	r3, [pc, #96]	; (20000d38 <MX_GPIO_Init+0x74>)
20000cd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000cda:	f003 0310 	and.w	r3, r3, #16
20000cde:	60fb      	str	r3, [r7, #12]
20000ce0:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
20000ce2:	4b15      	ldr	r3, [pc, #84]	; (20000d38 <MX_GPIO_Init+0x74>)
20000ce4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000ce6:	4a14      	ldr	r2, [pc, #80]	; (20000d38 <MX_GPIO_Init+0x74>)
20000ce8:	f043 0302 	orr.w	r3, r3, #2
20000cec:	6313      	str	r3, [r2, #48]	; 0x30
20000cee:	4b12      	ldr	r3, [pc, #72]	; (20000d38 <MX_GPIO_Init+0x74>)
20000cf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000cf2:	f003 0302 	and.w	r3, r3, #2
20000cf6:	60bb      	str	r3, [r7, #8]
20000cf8:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
20000cfa:	4b0f      	ldr	r3, [pc, #60]	; (20000d38 <MX_GPIO_Init+0x74>)
20000cfc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000cfe:	4a0e      	ldr	r2, [pc, #56]	; (20000d38 <MX_GPIO_Init+0x74>)
20000d00:	f043 0304 	orr.w	r3, r3, #4
20000d04:	6313      	str	r3, [r2, #48]	; 0x30
20000d06:	4b0c      	ldr	r3, [pc, #48]	; (20000d38 <MX_GPIO_Init+0x74>)
20000d08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000d0a:	f003 0304 	and.w	r3, r3, #4
20000d0e:	607b      	str	r3, [r7, #4]
20000d10:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOD_CLK_ENABLE();
20000d12:	4b09      	ldr	r3, [pc, #36]	; (20000d38 <MX_GPIO_Init+0x74>)
20000d14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000d16:	4a08      	ldr	r2, [pc, #32]	; (20000d38 <MX_GPIO_Init+0x74>)
20000d18:	f043 0308 	orr.w	r3, r3, #8
20000d1c:	6313      	str	r3, [r2, #48]	; 0x30
20000d1e:	4b06      	ldr	r3, [pc, #24]	; (20000d38 <MX_GPIO_Init+0x74>)
20000d20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000d22:	f003 0308 	and.w	r3, r3, #8
20000d26:	603b      	str	r3, [r7, #0]
20000d28:	683b      	ldr	r3, [r7, #0]

}
20000d2a:	bf00      	nop
20000d2c:	3714      	adds	r7, #20
20000d2e:	46bd      	mov	sp, r7
20000d30:	f85d 7b04 	ldr.w	r7, [sp], #4
20000d34:	4770      	bx	lr
20000d36:	bf00      	nop
20000d38:	40023800 	.word	0x40023800

20000d3c <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
20000d3c:	b580      	push	{r7, lr}
20000d3e:	f5ad 5d80 	sub.w	sp, sp, #4096	; 0x1000
20000d42:	b082      	sub	sp, #8
20000d44:	af00      	add	r7, sp, #0
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
20000d46:	f000 ff90 	bl	20001c6a <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
20000d4a:	f000 f8a3 	bl	20000e94 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
20000d4e:	f7ff ffb9 	bl	20000cc4 <MX_GPIO_Init>
  MX_QUADSPI_Init();
20000d52:	f000 f913 	bl	20000f7c <MX_QUADSPI_Init>
  /* USER CODE BEGIN 2 */

  	uint8_t buffer_test[MEMORY_SECTOR_SIZE];
      uint32_t var = 0;
20000d56:	2300      	movs	r3, #0
20000d58:	f241 0204 	movw	r2, #4100	; 0x1004
20000d5c:	443a      	add	r2, r7
20000d5e:	6013      	str	r3, [r2, #0]

  	CSP_QUADSPI_Init();
20000d60:	f000 fa1a 	bl	20001198 <CSP_QUADSPI_Init>

  	for (var = 0; var < MEMORY_SECTOR_SIZE; var++) {
20000d64:	2300      	movs	r3, #0
20000d66:	f241 0204 	movw	r2, #4100	; 0x1004
20000d6a:	443a      	add	r2, r7
20000d6c:	6013      	str	r3, [r2, #0]
20000d6e:	e019      	b.n	20000da4 <main+0x68>
  		buffer_test[var] = (var & 0xff);
20000d70:	f241 0304 	movw	r3, #4100	; 0x1004
20000d74:	443b      	add	r3, r7
20000d76:	681b      	ldr	r3, [r3, #0]
20000d78:	b2d9      	uxtb	r1, r3
20000d7a:	4b45      	ldr	r3, [pc, #276]	; (20000e90 <main+0x154>)
20000d7c:	f241 0208 	movw	r2, #4104	; 0x1008
20000d80:	443a      	add	r2, r7
20000d82:	4413      	add	r3, r2
20000d84:	f241 0204 	movw	r2, #4100	; 0x1004
20000d88:	443a      	add	r2, r7
20000d8a:	6812      	ldr	r2, [r2, #0]
20000d8c:	4413      	add	r3, r2
20000d8e:	460a      	mov	r2, r1
20000d90:	701a      	strb	r2, [r3, #0]
  	for (var = 0; var < MEMORY_SECTOR_SIZE; var++) {
20000d92:	f241 0304 	movw	r3, #4100	; 0x1004
20000d96:	443b      	add	r3, r7
20000d98:	681b      	ldr	r3, [r3, #0]
20000d9a:	3301      	adds	r3, #1
20000d9c:	f241 0204 	movw	r2, #4100	; 0x1004
20000da0:	443a      	add	r2, r7
20000da2:	6013      	str	r3, [r2, #0]
20000da4:	f241 0304 	movw	r3, #4100	; 0x1004
20000da8:	443b      	add	r3, r7
20000daa:	681b      	ldr	r3, [r3, #0]
20000dac:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20000db0:	d3de      	bcc.n	20000d70 <main+0x34>
  	}

  	for (var = 0; var < SECTORS_COUNT; var++) {
20000db2:	2300      	movs	r3, #0
20000db4:	f241 0204 	movw	r2, #4100	; 0x1004
20000db8:	443a      	add	r2, r7
20000dba:	6013      	str	r3, [r2, #0]
20000dbc:	e02f      	b.n	20000e1e <main+0xe2>

  		if (CSP_QSPI_EraseSector(var * MEMORY_SECTOR_SIZE,
20000dbe:	f241 0304 	movw	r3, #4100	; 0x1004
20000dc2:	443b      	add	r3, r7
20000dc4:	681b      	ldr	r3, [r3, #0]
20000dc6:	031a      	lsls	r2, r3, #12
  				(var + 1) * MEMORY_SECTOR_SIZE - 1) != HAL_OK) {
20000dc8:	f241 0304 	movw	r3, #4100	; 0x1004
20000dcc:	443b      	add	r3, r7
20000dce:	681b      	ldr	r3, [r3, #0]
20000dd0:	3301      	adds	r3, #1
20000dd2:	031b      	lsls	r3, r3, #12
  		if (CSP_QSPI_EraseSector(var * MEMORY_SECTOR_SIZE,
20000dd4:	3b01      	subs	r3, #1
20000dd6:	4619      	mov	r1, r3
20000dd8:	4610      	mov	r0, r2
20000dda:	f000 fb75 	bl	200014c8 <CSP_QSPI_EraseSector>
20000dde:	4603      	mov	r3, r0
20000de0:	2b00      	cmp	r3, #0
20000de2:	d000      	beq.n	20000de6 <main+0xaa>

  			while (1)
20000de4:	e7fe      	b.n	20000de4 <main+0xa8>
  				;  //breakpoint - error detected
  		}

  		if (CSP_QSPI_WriteMemory(buffer_test, var * MEMORY_SECTOR_SIZE,
20000de6:	f241 0304 	movw	r3, #4100	; 0x1004
20000dea:	443b      	add	r3, r7
20000dec:	681b      	ldr	r3, [r3, #0]
20000dee:	0319      	lsls	r1, r3, #12
20000df0:	4b27      	ldr	r3, [pc, #156]	; (20000e90 <main+0x154>)
20000df2:	f241 0208 	movw	r2, #4104	; 0x1008
20000df6:	443a      	add	r2, r7
20000df8:	4413      	add	r3, r2
20000dfa:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20000dfe:	4618      	mov	r0, r3
20000e00:	f000 fbb4 	bl	2000156c <CSP_QSPI_WriteMemory>
20000e04:	4603      	mov	r3, r0
20000e06:	2b00      	cmp	r3, #0
20000e08:	d000      	beq.n	20000e0c <main+0xd0>
  				sizeof(buffer_test)) != HAL_OK) {

  			while (1)
20000e0a:	e7fe      	b.n	20000e0a <main+0xce>
  	for (var = 0; var < SECTORS_COUNT; var++) {
20000e0c:	f241 0304 	movw	r3, #4100	; 0x1004
20000e10:	443b      	add	r3, r7
20000e12:	681b      	ldr	r3, [r3, #0]
20000e14:	3301      	adds	r3, #1
20000e16:	f241 0204 	movw	r2, #4100	; 0x1004
20000e1a:	443a      	add	r2, r7
20000e1c:	6013      	str	r3, [r2, #0]
20000e1e:	f241 0304 	movw	r3, #4100	; 0x1004
20000e22:	443b      	add	r3, r7
20000e24:	681b      	ldr	r3, [r3, #0]
20000e26:	2b63      	cmp	r3, #99	; 0x63
20000e28:	d9c9      	bls.n	20000dbe <main+0x82>
  				;  //breakpoint - error detected
  		}

  	}

  	if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK) {
20000e2a:	f000 fc2b 	bl	20001684 <CSP_QSPI_EnableMemoryMappedMode>
20000e2e:	4603      	mov	r3, r0
20000e30:	2b00      	cmp	r3, #0
20000e32:	d000      	beq.n	20000e36 <main+0xfa>

  		while (1)
20000e34:	e7fe      	b.n	20000e34 <main+0xf8>
  			; //breakpoint - error detected
  	}

  	for (var = 0; var < SECTORS_COUNT; var++) {
20000e36:	2300      	movs	r3, #0
20000e38:	f241 0204 	movw	r2, #4100	; 0x1004
20000e3c:	443a      	add	r2, r7
20000e3e:	6013      	str	r3, [r2, #0]
20000e40:	e01e      	b.n	20000e80 <main+0x144>
  		if (memcmp(buffer_test,
  				(uint8_t*) (0x90000000 + var * MEMORY_SECTOR_SIZE),
20000e42:	f241 0304 	movw	r3, #4100	; 0x1004
20000e46:	443b      	add	r3, r7
20000e48:	681b      	ldr	r3, [r3, #0]
20000e4a:	f503 2310 	add.w	r3, r3, #589824	; 0x90000
20000e4e:	031b      	lsls	r3, r3, #12
  		if (memcmp(buffer_test,
20000e50:	4619      	mov	r1, r3
20000e52:	4b0f      	ldr	r3, [pc, #60]	; (20000e90 <main+0x154>)
20000e54:	f241 0208 	movw	r2, #4104	; 0x1008
20000e58:	443a      	add	r2, r7
20000e5a:	4413      	add	r3, r2
20000e5c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20000e60:	4618      	mov	r0, r3
20000e62:	f00d fbb7 	bl	2000e5d4 <memcmp>
20000e66:	4603      	mov	r3, r0
20000e68:	2b00      	cmp	r3, #0
20000e6a:	d000      	beq.n	20000e6e <main+0x132>
  				MEMORY_SECTOR_SIZE) != HAL_OK) {
  			while (1)
20000e6c:	e7fe      	b.n	20000e6c <main+0x130>
  	for (var = 0; var < SECTORS_COUNT; var++) {
20000e6e:	f241 0304 	movw	r3, #4100	; 0x1004
20000e72:	443b      	add	r3, r7
20000e74:	681b      	ldr	r3, [r3, #0]
20000e76:	3301      	adds	r3, #1
20000e78:	f241 0204 	movw	r2, #4100	; 0x1004
20000e7c:	443a      	add	r2, r7
20000e7e:	6013      	str	r3, [r2, #0]
20000e80:	f241 0304 	movw	r3, #4100	; 0x1004
20000e84:	443b      	add	r3, r7
20000e86:	681b      	ldr	r3, [r3, #0]
20000e88:	2b63      	cmp	r3, #99	; 0x63
20000e8a:	d9da      	bls.n	20000e42 <main+0x106>
 
 

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
20000e8c:	e7fe      	b.n	20000e8c <main+0x150>
20000e8e:	bf00      	nop
20000e90:	ffffeffc 	.word	0xffffeffc

20000e94 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
20000e94:	b580      	push	{r7, lr}
20000e96:	b094      	sub	sp, #80	; 0x50
20000e98:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
20000e9a:	f107 031c 	add.w	r3, r7, #28
20000e9e:	2234      	movs	r2, #52	; 0x34
20000ea0:	2100      	movs	r1, #0
20000ea2:	4618      	mov	r0, r3
20000ea4:	f00d fba5 	bl	2000e5f2 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
20000ea8:	f107 0308 	add.w	r3, r7, #8
20000eac:	2200      	movs	r2, #0
20000eae:	601a      	str	r2, [r3, #0]
20000eb0:	605a      	str	r2, [r3, #4]
20000eb2:	609a      	str	r2, [r3, #8]
20000eb4:	60da      	str	r2, [r3, #12]
20000eb6:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
20000eb8:	4b2a      	ldr	r3, [pc, #168]	; (20000f64 <SystemClock_Config+0xd0>)
20000eba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20000ebc:	4a29      	ldr	r2, [pc, #164]	; (20000f64 <SystemClock_Config+0xd0>)
20000ebe:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20000ec2:	6413      	str	r3, [r2, #64]	; 0x40
20000ec4:	4b27      	ldr	r3, [pc, #156]	; (20000f64 <SystemClock_Config+0xd0>)
20000ec6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20000ec8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20000ecc:	607b      	str	r3, [r7, #4]
20000ece:	687b      	ldr	r3, [r7, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
20000ed0:	4b25      	ldr	r3, [pc, #148]	; (20000f68 <SystemClock_Config+0xd4>)
20000ed2:	681b      	ldr	r3, [r3, #0]
20000ed4:	4a24      	ldr	r2, [pc, #144]	; (20000f68 <SystemClock_Config+0xd4>)
20000ed6:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
20000eda:	6013      	str	r3, [r2, #0]
20000edc:	4b22      	ldr	r3, [pc, #136]	; (20000f68 <SystemClock_Config+0xd4>)
20000ede:	681b      	ldr	r3, [r3, #0]
20000ee0:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
20000ee4:	603b      	str	r3, [r7, #0]
20000ee6:	683b      	ldr	r3, [r7, #0]
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
20000ee8:	2302      	movs	r3, #2
20000eea:	61fb      	str	r3, [r7, #28]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
20000eec:	2301      	movs	r3, #1
20000eee:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
20000ef0:	2310      	movs	r3, #16
20000ef2:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
20000ef4:	2302      	movs	r3, #2
20000ef6:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
20000ef8:	2300      	movs	r3, #0
20000efa:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLM = 8;
20000efc:	2308      	movs	r3, #8
20000efe:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLN = 216;
20000f00:	23d8      	movs	r3, #216	; 0xd8
20000f02:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
20000f04:	2302      	movs	r3, #2
20000f06:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = 2;
20000f08:	2302      	movs	r3, #2
20000f0a:	64bb      	str	r3, [r7, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
20000f0c:	f107 031c 	add.w	r3, r7, #28
20000f10:	4618      	mov	r0, r3
20000f12:	f00b fdd9 	bl	2000cac8 <HAL_RCC_OscConfig>
20000f16:	4603      	mov	r3, r0
20000f18:	2b00      	cmp	r3, #0
20000f1a:	d001      	beq.n	20000f20 <SystemClock_Config+0x8c>
  {
    Error_Handler();
20000f1c:	f000 f826 	bl	20000f6c <Error_Handler>
  }
  /** Activate the Over-Drive mode 
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
20000f20:	f009 feea 	bl	2000acf8 <HAL_PWREx_EnableOverDrive>
20000f24:	4603      	mov	r3, r0
20000f26:	2b00      	cmp	r3, #0
20000f28:	d001      	beq.n	20000f2e <SystemClock_Config+0x9a>
  {
    Error_Handler();
20000f2a:	f000 f81f 	bl	20000f6c <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
20000f2e:	230f      	movs	r3, #15
20000f30:	60bb      	str	r3, [r7, #8]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
20000f32:	2302      	movs	r3, #2
20000f34:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
20000f36:	2300      	movs	r3, #0
20000f38:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
20000f3a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
20000f3e:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
20000f40:	f44f 5380 	mov.w	r3, #4096	; 0x1000
20000f44:	61bb      	str	r3, [r7, #24]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
20000f46:	f107 0308 	add.w	r3, r7, #8
20000f4a:	2107      	movs	r1, #7
20000f4c:	4618      	mov	r0, r3
20000f4e:	f00c f82d 	bl	2000cfac <HAL_RCC_ClockConfig>
20000f52:	4603      	mov	r3, r0
20000f54:	2b00      	cmp	r3, #0
20000f56:	d001      	beq.n	20000f5c <SystemClock_Config+0xc8>
  {
    Error_Handler();
20000f58:	f000 f808 	bl	20000f6c <Error_Handler>
  }
}
20000f5c:	bf00      	nop
20000f5e:	3750      	adds	r7, #80	; 0x50
20000f60:	46bd      	mov	sp, r7
20000f62:	bd80      	pop	{r7, pc}
20000f64:	40023800 	.word	0x40023800
20000f68:	40007000 	.word	0x40007000

20000f6c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
20000f6c:	b480      	push	{r7}
20000f6e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
20000f70:	bf00      	nop
20000f72:	46bd      	mov	sp, r7
20000f74:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f78:	4770      	bx	lr
	...

20000f7c <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
20000f7c:	b580      	push	{r7, lr}
20000f7e:	af00      	add	r7, sp, #0

  hqspi.Instance = QUADSPI;
20000f80:	4b12      	ldr	r3, [pc, #72]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000f82:	4a13      	ldr	r2, [pc, #76]	; (20000fd0 <MX_QUADSPI_Init+0x54>)
20000f84:	601a      	str	r2, [r3, #0]
  hqspi.Init.ClockPrescaler = 2;
20000f86:	4b11      	ldr	r3, [pc, #68]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000f88:	2202      	movs	r2, #2
20000f8a:	605a      	str	r2, [r3, #4]
  hqspi.Init.FifoThreshold = 4;
20000f8c:	4b0f      	ldr	r3, [pc, #60]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000f8e:	2204      	movs	r2, #4
20000f90:	609a      	str	r2, [r3, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
20000f92:	4b0e      	ldr	r3, [pc, #56]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000f94:	2200      	movs	r2, #0
20000f96:	60da      	str	r2, [r3, #12]
  hqspi.Init.FlashSize = 25;
20000f98:	4b0c      	ldr	r3, [pc, #48]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000f9a:	2219      	movs	r2, #25
20000f9c:	611a      	str	r2, [r3, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
20000f9e:	4b0b      	ldr	r3, [pc, #44]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000fa0:	2200      	movs	r2, #0
20000fa2:	615a      	str	r2, [r3, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
20000fa4:	4b09      	ldr	r3, [pc, #36]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000fa6:	2200      	movs	r2, #0
20000fa8:	619a      	str	r2, [r3, #24]
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
20000faa:	4b08      	ldr	r3, [pc, #32]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000fac:	2200      	movs	r2, #0
20000fae:	61da      	str	r2, [r3, #28]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
20000fb0:	4b06      	ldr	r3, [pc, #24]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000fb2:	2200      	movs	r2, #0
20000fb4:	621a      	str	r2, [r3, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
20000fb6:	4805      	ldr	r0, [pc, #20]	; (20000fcc <MX_QUADSPI_Init+0x50>)
20000fb8:	f00a f82a 	bl	2000b010 <HAL_QSPI_Init>
20000fbc:	4603      	mov	r3, r0
20000fbe:	2b00      	cmp	r3, #0
20000fc0:	d001      	beq.n	20000fc6 <MX_QUADSPI_Init+0x4a>
  {
    Error_Handler();
20000fc2:	f7ff ffd3 	bl	20000f6c <Error_Handler>
  }

}
20000fc6:	bf00      	nop
20000fc8:	bd80      	pop	{r7, pc}
20000fca:	bf00      	nop
20000fcc:	200004a4 	.word	0x200004a4
20000fd0:	a0001000 	.word	0xa0001000

20000fd4 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
20000fd4:	b580      	push	{r7, lr}
20000fd6:	b08c      	sub	sp, #48	; 0x30
20000fd8:	af00      	add	r7, sp, #0
20000fda:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
20000fdc:	f107 031c 	add.w	r3, r7, #28
20000fe0:	2200      	movs	r2, #0
20000fe2:	601a      	str	r2, [r3, #0]
20000fe4:	605a      	str	r2, [r3, #4]
20000fe6:	609a      	str	r2, [r3, #8]
20000fe8:	60da      	str	r2, [r3, #12]
20000fea:	611a      	str	r2, [r3, #16]
  if(qspiHandle->Instance==QUADSPI)
20000fec:	687b      	ldr	r3, [r7, #4]
20000fee:	681b      	ldr	r3, [r3, #0]
20000ff0:	4a4a      	ldr	r2, [pc, #296]	; (2000111c <HAL_QSPI_MspInit+0x148>)
20000ff2:	4293      	cmp	r3, r2
20000ff4:	f040 808e 	bne.w	20001114 <HAL_QSPI_MspInit+0x140>
  {
  /* USER CODE BEGIN QUADSPI_MspInit 0 */

  /* USER CODE END QUADSPI_MspInit 0 */
    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
20000ff8:	4b49      	ldr	r3, [pc, #292]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20000ffa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20000ffc:	4a48      	ldr	r2, [pc, #288]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20000ffe:	f043 0302 	orr.w	r3, r3, #2
20001002:	6393      	str	r3, [r2, #56]	; 0x38
20001004:	4b46      	ldr	r3, [pc, #280]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20001006:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20001008:	f003 0302 	and.w	r3, r3, #2
2000100c:	61bb      	str	r3, [r7, #24]
2000100e:	69bb      	ldr	r3, [r7, #24]
  
    __HAL_RCC_GPIOE_CLK_ENABLE();
20001010:	4b43      	ldr	r3, [pc, #268]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20001012:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001014:	4a42      	ldr	r2, [pc, #264]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20001016:	f043 0310 	orr.w	r3, r3, #16
2000101a:	6313      	str	r3, [r2, #48]	; 0x30
2000101c:	4b40      	ldr	r3, [pc, #256]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
2000101e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001020:	f003 0310 	and.w	r3, r3, #16
20001024:	617b      	str	r3, [r7, #20]
20001026:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
20001028:	4b3d      	ldr	r3, [pc, #244]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
2000102a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000102c:	4a3c      	ldr	r2, [pc, #240]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
2000102e:	f043 0302 	orr.w	r3, r3, #2
20001032:	6313      	str	r3, [r2, #48]	; 0x30
20001034:	4b3a      	ldr	r3, [pc, #232]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20001036:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001038:	f003 0302 	and.w	r3, r3, #2
2000103c:	613b      	str	r3, [r7, #16]
2000103e:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOC_CLK_ENABLE();
20001040:	4b37      	ldr	r3, [pc, #220]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20001042:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001044:	4a36      	ldr	r2, [pc, #216]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20001046:	f043 0304 	orr.w	r3, r3, #4
2000104a:	6313      	str	r3, [r2, #48]	; 0x30
2000104c:	4b34      	ldr	r3, [pc, #208]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
2000104e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001050:	f003 0304 	and.w	r3, r3, #4
20001054:	60fb      	str	r3, [r7, #12]
20001056:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
20001058:	4b31      	ldr	r3, [pc, #196]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
2000105a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000105c:	4a30      	ldr	r2, [pc, #192]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
2000105e:	f043 0308 	orr.w	r3, r3, #8
20001062:	6313      	str	r3, [r2, #48]	; 0x30
20001064:	4b2e      	ldr	r3, [pc, #184]	; (20001120 <HAL_QSPI_MspInit+0x14c>)
20001066:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001068:	f003 0308 	and.w	r3, r3, #8
2000106c:	60bb      	str	r3, [r7, #8]
2000106e:	68bb      	ldr	r3, [r7, #8]
    PC10     ------> QUADSPI_BK1_IO1
    PC9     ------> QUADSPI_BK1_IO0
    PB2     ------> QUADSPI_CLK
    PD13     ------> QUADSPI_BK1_IO3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
20001070:	2304      	movs	r3, #4
20001072:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20001074:	2302      	movs	r3, #2
20001076:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20001078:	2300      	movs	r3, #0
2000107a:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2000107c:	2303      	movs	r3, #3
2000107e:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
20001080:	2309      	movs	r3, #9
20001082:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
20001084:	f107 031c 	add.w	r3, r7, #28
20001088:	4619      	mov	r1, r3
2000108a:	4826      	ldr	r0, [pc, #152]	; (20001124 <HAL_QSPI_MspInit+0x150>)
2000108c:	f004 fb4e 	bl	2000572c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6;
20001090:	2340      	movs	r3, #64	; 0x40
20001092:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20001094:	2302      	movs	r3, #2
20001096:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20001098:	2300      	movs	r3, #0
2000109a:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2000109c:	2303      	movs	r3, #3
2000109e:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
200010a0:	230a      	movs	r3, #10
200010a2:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
200010a4:	f107 031c 	add.w	r3, r7, #28
200010a8:	4619      	mov	r1, r3
200010aa:	481f      	ldr	r0, [pc, #124]	; (20001128 <HAL_QSPI_MspInit+0x154>)
200010ac:	f004 fb3e 	bl	2000572c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_9;
200010b0:	f44f 63c0 	mov.w	r3, #1536	; 0x600
200010b4:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
200010b6:	2302      	movs	r3, #2
200010b8:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
200010ba:	2300      	movs	r3, #0
200010bc:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
200010be:	2303      	movs	r3, #3
200010c0:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
200010c2:	2309      	movs	r3, #9
200010c4:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
200010c6:	f107 031c 	add.w	r3, r7, #28
200010ca:	4619      	mov	r1, r3
200010cc:	4817      	ldr	r0, [pc, #92]	; (2000112c <HAL_QSPI_MspInit+0x158>)
200010ce:	f004 fb2d 	bl	2000572c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
200010d2:	2304      	movs	r3, #4
200010d4:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
200010d6:	2302      	movs	r3, #2
200010d8:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
200010da:	2300      	movs	r3, #0
200010dc:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
200010de:	2303      	movs	r3, #3
200010e0:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
200010e2:	2309      	movs	r3, #9
200010e4:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
200010e6:	f107 031c 	add.w	r3, r7, #28
200010ea:	4619      	mov	r1, r3
200010ec:	480e      	ldr	r0, [pc, #56]	; (20001128 <HAL_QSPI_MspInit+0x154>)
200010ee:	f004 fb1d 	bl	2000572c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_13;
200010f2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
200010f6:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
200010f8:	2302      	movs	r3, #2
200010fa:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
200010fc:	2300      	movs	r3, #0
200010fe:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
20001100:	2303      	movs	r3, #3
20001102:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
20001104:	2309      	movs	r3, #9
20001106:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
20001108:	f107 031c 	add.w	r3, r7, #28
2000110c:	4619      	mov	r1, r3
2000110e:	4808      	ldr	r0, [pc, #32]	; (20001130 <HAL_QSPI_MspInit+0x15c>)
20001110:	f004 fb0c 	bl	2000572c <HAL_GPIO_Init>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
20001114:	bf00      	nop
20001116:	3730      	adds	r7, #48	; 0x30
20001118:	46bd      	mov	sp, r7
2000111a:	bd80      	pop	{r7, pc}
2000111c:	a0001000 	.word	0xa0001000
20001120:	40023800 	.word	0x40023800
20001124:	40021000 	.word	0x40021000
20001128:	40020400 	.word	0x40020400
2000112c:	40020800 	.word	0x40020800
20001130:	40020c00 	.word	0x40020c00

20001134 <HAL_QSPI_MspDeInit>:

void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)
{
20001134:	b580      	push	{r7, lr}
20001136:	b082      	sub	sp, #8
20001138:	af00      	add	r7, sp, #0
2000113a:	6078      	str	r0, [r7, #4]

  if(qspiHandle->Instance==QUADSPI)
2000113c:	687b      	ldr	r3, [r7, #4]
2000113e:	681b      	ldr	r3, [r3, #0]
20001140:	4a0f      	ldr	r2, [pc, #60]	; (20001180 <HAL_QSPI_MspDeInit+0x4c>)
20001142:	4293      	cmp	r3, r2
20001144:	d117      	bne.n	20001176 <HAL_QSPI_MspDeInit+0x42>
  {
  /* USER CODE BEGIN QUADSPI_MspDeInit 0 */

  /* USER CODE END QUADSPI_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_QSPI_CLK_DISABLE();
20001146:	4b0f      	ldr	r3, [pc, #60]	; (20001184 <HAL_QSPI_MspDeInit+0x50>)
20001148:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000114a:	4a0e      	ldr	r2, [pc, #56]	; (20001184 <HAL_QSPI_MspDeInit+0x50>)
2000114c:	f023 0302 	bic.w	r3, r3, #2
20001150:	6393      	str	r3, [r2, #56]	; 0x38
    PC10     ------> QUADSPI_BK1_IO1
    PC9     ------> QUADSPI_BK1_IO0
    PB2     ------> QUADSPI_CLK
    PD13     ------> QUADSPI_BK1_IO3 
    */
    HAL_GPIO_DeInit(GPIOE, GPIO_PIN_2);
20001152:	2104      	movs	r1, #4
20001154:	480c      	ldr	r0, [pc, #48]	; (20001188 <HAL_QSPI_MspDeInit+0x54>)
20001156:	f004 fc93 	bl	20005a80 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6|GPIO_PIN_2);
2000115a:	2144      	movs	r1, #68	; 0x44
2000115c:	480b      	ldr	r0, [pc, #44]	; (2000118c <HAL_QSPI_MspDeInit+0x58>)
2000115e:	f004 fc8f 	bl	20005a80 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_10|GPIO_PIN_9);
20001162:	f44f 61c0 	mov.w	r1, #1536	; 0x600
20001166:	480a      	ldr	r0, [pc, #40]	; (20001190 <HAL_QSPI_MspDeInit+0x5c>)
20001168:	f004 fc8a 	bl	20005a80 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_13);
2000116c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
20001170:	4808      	ldr	r0, [pc, #32]	; (20001194 <HAL_QSPI_MspDeInit+0x60>)
20001172:	f004 fc85 	bl	20005a80 <HAL_GPIO_DeInit>

  /* USER CODE BEGIN QUADSPI_MspDeInit 1 */

  /* USER CODE END QUADSPI_MspDeInit 1 */
  }
} 
20001176:	bf00      	nop
20001178:	3708      	adds	r7, #8
2000117a:	46bd      	mov	sp, r7
2000117c:	bd80      	pop	{r7, pc}
2000117e:	bf00      	nop
20001180:	a0001000 	.word	0xa0001000
20001184:	40023800 	.word	0x40023800
20001188:	40021000 	.word	0x40021000
2000118c:	40020400 	.word	0x40020400
20001190:	40020800 	.word	0x40020800
20001194:	40020c00 	.word	0x40020c00

20001198 <CSP_QUADSPI_Init>:

/* USER CODE BEGIN 1 */

/* QUADSPI init function */
uint8_t CSP_QUADSPI_Init(void) {
20001198:	b580      	push	{r7, lr}
2000119a:	af00      	add	r7, sp, #0
	//prepare QSPI peripheral for ST-Link Utility operations
	if (HAL_QSPI_DeInit(&hqspi) != HAL_OK) {
2000119c:	4815      	ldr	r0, [pc, #84]	; (200011f4 <CSP_QUADSPI_Init+0x5c>)
2000119e:	f009 ffc1 	bl	2000b124 <HAL_QSPI_DeInit>
200011a2:	4603      	mov	r3, r0
200011a4:	2b00      	cmp	r3, #0
200011a6:	d001      	beq.n	200011ac <CSP_QUADSPI_Init+0x14>
		return HAL_ERROR;
200011a8:	2301      	movs	r3, #1
200011aa:	e021      	b.n	200011f0 <CSP_QUADSPI_Init+0x58>
	}

	MX_QUADSPI_Init();
200011ac:	f7ff fee6 	bl	20000f7c <MX_QUADSPI_Init>

	if (QSPI_ResetChip() != HAL_OK) {
200011b0:	f000 fa9c 	bl	200016ec <QSPI_ResetChip>
200011b4:	4603      	mov	r3, r0
200011b6:	2b00      	cmp	r3, #0
200011b8:	d001      	beq.n	200011be <CSP_QUADSPI_Init+0x26>
		return HAL_ERROR;
200011ba:	2301      	movs	r3, #1
200011bc:	e018      	b.n	200011f0 <CSP_QUADSPI_Init+0x58>
	}

	HAL_Delay(1);
200011be:	2001      	movs	r0, #1
200011c0:	f000 fe22 	bl	20001e08 <HAL_Delay>

	if (QSPI_AutoPollingMemReady() != HAL_OK) {
200011c4:	f000 f854 	bl	20001270 <QSPI_AutoPollingMemReady>
200011c8:	4603      	mov	r3, r0
200011ca:	2b00      	cmp	r3, #0
200011cc:	d001      	beq.n	200011d2 <CSP_QUADSPI_Init+0x3a>
		return HAL_ERROR;
200011ce:	2301      	movs	r3, #1
200011d0:	e00e      	b.n	200011f0 <CSP_QUADSPI_Init+0x58>
	}

	if (QSPI_WriteEnable() != HAL_OK) {
200011d2:	f000 f885 	bl	200012e0 <QSPI_WriteEnable>
200011d6:	4603      	mov	r3, r0
200011d8:	2b00      	cmp	r3, #0
200011da:	d001      	beq.n	200011e0 <CSP_QUADSPI_Init+0x48>

		return HAL_ERROR;
200011dc:	2301      	movs	r3, #1
200011de:	e007      	b.n	200011f0 <CSP_QUADSPI_Init+0x58>
	}

	if (QSPI_Configuration() != HAL_OK) {
200011e0:	f000 f8c8 	bl	20001374 <QSPI_Configuration>
200011e4:	4603      	mov	r3, r0
200011e6:	2b00      	cmp	r3, #0
200011e8:	d001      	beq.n	200011ee <CSP_QUADSPI_Init+0x56>
		return HAL_ERROR;
200011ea:	2301      	movs	r3, #1
200011ec:	e000      	b.n	200011f0 <CSP_QUADSPI_Init+0x58>
	}

	return HAL_OK;
200011ee:	2300      	movs	r3, #0
}
200011f0:	4618      	mov	r0, r3
200011f2:	bd80      	pop	{r7, pc}
200011f4:	200004a4 	.word	0x200004a4

200011f8 <CSP_QSPI_Erase_Chip>:


uint8_t CSP_QSPI_Erase_Chip(void) {
200011f8:	b580      	push	{r7, lr}
200011fa:	b08e      	sub	sp, #56	; 0x38
200011fc:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;


	if (QSPI_WriteEnable() != HAL_OK) {
200011fe:	f000 f86f 	bl	200012e0 <QSPI_WriteEnable>
20001202:	4603      	mov	r3, r0
20001204:	2b00      	cmp	r3, #0
20001206:	d001      	beq.n	2000120c <CSP_QSPI_Erase_Chip+0x14>
		return HAL_ERROR;
20001208:	2301      	movs	r3, #1
2000120a:	e02b      	b.n	20001264 <CSP_QSPI_Erase_Chip+0x6c>
	}


	/* Erasing Sequence --------------------------------- */
	sCommand.Instruction = CHIP_ERASE_CMD;
2000120c:	23c7      	movs	r3, #199	; 0xc7
2000120e:	603b      	str	r3, [r7, #0]
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20001210:	f44f 7380 	mov.w	r3, #256	; 0x100
20001214:	61bb      	str	r3, [r7, #24]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20001216:	f44f 5300 	mov.w	r3, #8192	; 0x2000
2000121a:	60fb      	str	r3, [r7, #12]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2000121c:	2300      	movs	r3, #0
2000121e:	623b      	str	r3, [r7, #32]
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001220:	2300      	movs	r3, #0
20001222:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20001224:	2300      	movs	r3, #0
20001226:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20001228:	2300      	movs	r3, #0
2000122a:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
2000122c:	2300      	movs	r3, #0
2000122e:	61fb      	str	r3, [r7, #28]
	sCommand.Address = 0;
20001230:	2300      	movs	r3, #0
20001232:	607b      	str	r3, [r7, #4]
	sCommand.DataMode = QSPI_DATA_NONE;
20001234:	2300      	movs	r3, #0
20001236:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DummyCycles = 0;
20001238:	2300      	movs	r3, #0
2000123a:	617b      	str	r3, [r7, #20]


	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2000123c:	463b      	mov	r3, r7
2000123e:	f241 3288 	movw	r2, #5000	; 0x1388
20001242:	4619      	mov	r1, r3
20001244:	4809      	ldr	r0, [pc, #36]	; (2000126c <CSP_QSPI_Erase_Chip+0x74>)
20001246:	f00a f95d 	bl	2000b504 <HAL_QSPI_Command>
2000124a:	4603      	mov	r3, r0
2000124c:	2b00      	cmp	r3, #0
2000124e:	d001      	beq.n	20001254 <CSP_QSPI_Erase_Chip+0x5c>
			!= HAL_OK) {
		return HAL_ERROR;
20001250:	2301      	movs	r3, #1
20001252:	e007      	b.n	20001264 <CSP_QSPI_Erase_Chip+0x6c>
	}

	if (QSPI_AutoPollingMemReady() != HAL_OK) {
20001254:	f000 f80c 	bl	20001270 <QSPI_AutoPollingMemReady>
20001258:	4603      	mov	r3, r0
2000125a:	2b00      	cmp	r3, #0
2000125c:	d001      	beq.n	20001262 <CSP_QSPI_Erase_Chip+0x6a>
				return HAL_ERROR;
2000125e:	2301      	movs	r3, #1
20001260:	e000      	b.n	20001264 <CSP_QSPI_Erase_Chip+0x6c>
			}

	return HAL_OK;
20001262:	2300      	movs	r3, #0
}
20001264:	4618      	mov	r0, r3
20001266:	3738      	adds	r7, #56	; 0x38
20001268:	46bd      	mov	sp, r7
2000126a:	bd80      	pop	{r7, pc}
2000126c:	200004a4 	.word	0x200004a4

20001270 <QSPI_AutoPollingMemReady>:

uint8_t QSPI_AutoPollingMemReady(void) {
20001270:	b580      	push	{r7, lr}
20001272:	b094      	sub	sp, #80	; 0x50
20001274:	af00      	add	r7, sp, #0

	QSPI_CommandTypeDef sCommand;
	 QSPI_AutoPollingTypeDef sConfig;

	/* Configure automatic polling mode to wait for memory ready ------ */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20001276:	f44f 7380 	mov.w	r3, #256	; 0x100
2000127a:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Instruction = READ_STATUS_REG_CMD;
2000127c:	2305      	movs	r3, #5
2000127e:	61bb      	str	r3, [r7, #24]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001280:	2300      	movs	r3, #0
20001282:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20001284:	2300      	movs	r3, #0
20001286:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DataMode = QSPI_DATA_1_LINE;
20001288:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000128c:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DummyCycles = 0;
2000128e:	2300      	movs	r3, #0
20001290:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001292:	2300      	movs	r3, #0
20001294:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20001296:	2300      	movs	r3, #0
20001298:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2000129a:	2300      	movs	r3, #0
2000129c:	64fb      	str	r3, [r7, #76]	; 0x4c

	sConfig.Match = 0x00;
2000129e:	2300      	movs	r3, #0
200012a0:	603b      	str	r3, [r7, #0]
	sConfig.Mask = 0x01;
200012a2:	2301      	movs	r3, #1
200012a4:	607b      	str	r3, [r7, #4]
	sConfig.MatchMode = QSPI_MATCH_MODE_AND;
200012a6:	2300      	movs	r3, #0
200012a8:	613b      	str	r3, [r7, #16]
	sConfig.StatusBytesSize = 1;
200012aa:	2301      	movs	r3, #1
200012ac:	60fb      	str	r3, [r7, #12]
	sConfig.Interval = 0x10;
200012ae:	2310      	movs	r3, #16
200012b0:	60bb      	str	r3, [r7, #8]
	sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
200012b2:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
200012b6:	617b      	str	r3, [r7, #20]

	if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,
200012b8:	463a      	mov	r2, r7
200012ba:	f107 0118 	add.w	r1, r7, #24
200012be:	f241 3388 	movw	r3, #5000	; 0x1388
200012c2:	4806      	ldr	r0, [pc, #24]	; (200012dc <QSPI_AutoPollingMemReady+0x6c>)
200012c4:	f00a fdd4 	bl	2000be70 <HAL_QSPI_AutoPolling>
200012c8:	4603      	mov	r3, r0
200012ca:	2b00      	cmp	r3, #0
200012cc:	d001      	beq.n	200012d2 <QSPI_AutoPollingMemReady+0x62>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
200012ce:	2301      	movs	r3, #1
200012d0:	e000      	b.n	200012d4 <QSPI_AutoPollingMemReady+0x64>
	}

	return HAL_OK;
200012d2:	2300      	movs	r3, #0
}
200012d4:	4618      	mov	r0, r3
200012d6:	3750      	adds	r7, #80	; 0x50
200012d8:	46bd      	mov	sp, r7
200012da:	bd80      	pop	{r7, pc}
200012dc:	200004a4 	.word	0x200004a4

200012e0 <QSPI_WriteEnable>:

static uint8_t QSPI_WriteEnable(void) {
200012e0:	b580      	push	{r7, lr}
200012e2:	b094      	sub	sp, #80	; 0x50
200012e4:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	QSPI_AutoPollingTypeDef sConfig;

	/* Enable write operations ------------------------------------------ */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200012e6:	f44f 7380 	mov.w	r3, #256	; 0x100
200012ea:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Instruction = WRITE_ENABLE_CMD;
200012ec:	2306      	movs	r3, #6
200012ee:	61bb      	str	r3, [r7, #24]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
200012f0:	2300      	movs	r3, #0
200012f2:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
200012f4:	2300      	movs	r3, #0
200012f6:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DataMode = QSPI_DATA_NONE;
200012f8:	2300      	movs	r3, #0
200012fa:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DummyCycles = 0;
200012fc:	2300      	movs	r3, #0
200012fe:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001300:	2300      	movs	r3, #0
20001302:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20001304:	2300      	movs	r3, #0
20001306:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20001308:	2300      	movs	r3, #0
2000130a:	64fb      	str	r3, [r7, #76]	; 0x4c

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2000130c:	f107 0318 	add.w	r3, r7, #24
20001310:	f241 3288 	movw	r2, #5000	; 0x1388
20001314:	4619      	mov	r1, r3
20001316:	4816      	ldr	r0, [pc, #88]	; (20001370 <QSPI_WriteEnable+0x90>)
20001318:	f00a f8f4 	bl	2000b504 <HAL_QSPI_Command>
2000131c:	4603      	mov	r3, r0
2000131e:	2b00      	cmp	r3, #0
20001320:	d001      	beq.n	20001326 <QSPI_WriteEnable+0x46>
			!= HAL_OK) {
		return HAL_ERROR;
20001322:	2301      	movs	r3, #1
20001324:	e01f      	b.n	20001366 <QSPI_WriteEnable+0x86>
	}

	/* Configure automatic polling mode to wait for write enabling ---- */
	sConfig.Match = 0x02;
20001326:	2302      	movs	r3, #2
20001328:	603b      	str	r3, [r7, #0]
	sConfig.Mask = 0x02;
2000132a:	2302      	movs	r3, #2
2000132c:	607b      	str	r3, [r7, #4]
	sConfig.MatchMode = QSPI_MATCH_MODE_AND;
2000132e:	2300      	movs	r3, #0
20001330:	613b      	str	r3, [r7, #16]
	sConfig.StatusBytesSize = 1;
20001332:	2301      	movs	r3, #1
20001334:	60fb      	str	r3, [r7, #12]
	sConfig.Interval = 0x10;
20001336:	2310      	movs	r3, #16
20001338:	60bb      	str	r3, [r7, #8]
	sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
2000133a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2000133e:	617b      	str	r3, [r7, #20]

	sCommand.Instruction = READ_STATUS_REG_CMD;
20001340:	2305      	movs	r3, #5
20001342:	61bb      	str	r3, [r7, #24]
	sCommand.DataMode = QSPI_DATA_1_LINE;
20001344:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20001348:	63fb      	str	r3, [r7, #60]	; 0x3c
	if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,
2000134a:	463a      	mov	r2, r7
2000134c:	f107 0118 	add.w	r1, r7, #24
20001350:	f241 3388 	movw	r3, #5000	; 0x1388
20001354:	4806      	ldr	r0, [pc, #24]	; (20001370 <QSPI_WriteEnable+0x90>)
20001356:	f00a fd8b 	bl	2000be70 <HAL_QSPI_AutoPolling>
2000135a:	4603      	mov	r3, r0
2000135c:	2b00      	cmp	r3, #0
2000135e:	d001      	beq.n	20001364 <QSPI_WriteEnable+0x84>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
20001360:	2301      	movs	r3, #1
20001362:	e000      	b.n	20001366 <QSPI_WriteEnable+0x86>
	}

	return HAL_OK;
20001364:	2300      	movs	r3, #0
}
20001366:	4618      	mov	r0, r3
20001368:	3750      	adds	r7, #80	; 0x50
2000136a:	46bd      	mov	sp, r7
2000136c:	bd80      	pop	{r7, pc}
2000136e:	bf00      	nop
20001370:	200004a4 	.word	0x200004a4

20001374 <QSPI_Configuration>:
/*Enable quad mode and set dummy cycles count*/
uint8_t QSPI_Configuration(void) {
20001374:	b580      	push	{r7, lr}
20001376:	b090      	sub	sp, #64	; 0x40
20001378:	af00      	add	r7, sp, #0

	QSPI_CommandTypeDef sCommand;
	uint8_t test_buffer[4] = { 0 };
2000137a:	2300      	movs	r3, #0
2000137c:	607b      	str	r3, [r7, #4]
	/*read status register*/
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2000137e:	f44f 7380 	mov.w	r3, #256	; 0x100
20001382:	623b      	str	r3, [r7, #32]
	sCommand.Instruction = READ_STATUS_REG_CMD;
20001384:	2305      	movs	r3, #5
20001386:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001388:	2300      	movs	r3, #0
2000138a:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2000138c:	2300      	movs	r3, #0
2000138e:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DataMode = QSPI_DATA_1_LINE;
20001390:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20001394:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
20001396:	2300      	movs	r3, #0
20001398:	61fb      	str	r3, [r7, #28]
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2000139a:	2300      	movs	r3, #0
2000139c:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2000139e:	2300      	movs	r3, #0
200013a0:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
200013a2:	2300      	movs	r3, #0
200013a4:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.NbData = 1;
200013a6:	2301      	movs	r3, #1
200013a8:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
200013aa:	f107 0308 	add.w	r3, r7, #8
200013ae:	f241 3288 	movw	r2, #5000	; 0x1388
200013b2:	4619      	mov	r1, r3
200013b4:	4843      	ldr	r0, [pc, #268]	; (200014c4 <QSPI_Configuration+0x150>)
200013b6:	f00a f8a5 	bl	2000b504 <HAL_QSPI_Command>
200013ba:	4603      	mov	r3, r0
200013bc:	2b00      	cmp	r3, #0
200013be:	d001      	beq.n	200013c4 <QSPI_Configuration+0x50>
			!= HAL_OK) {
		return HAL_ERROR;
200013c0:	2301      	movs	r3, #1
200013c2:	e07a      	b.n	200014ba <QSPI_Configuration+0x146>
	}
	if (HAL_QSPI_Receive(&hqspi, test_buffer,
200013c4:	1d3b      	adds	r3, r7, #4
200013c6:	f241 3288 	movw	r2, #5000	; 0x1388
200013ca:	4619      	mov	r1, r3
200013cc:	483d      	ldr	r0, [pc, #244]	; (200014c4 <QSPI_Configuration+0x150>)
200013ce:	f00a f9f1 	bl	2000b7b4 <HAL_QSPI_Receive>
200013d2:	4603      	mov	r3, r0
200013d4:	2b00      	cmp	r3, #0
200013d6:	d001      	beq.n	200013dc <QSPI_Configuration+0x68>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
200013d8:	2301      	movs	r3, #1
200013da:	e06e      	b.n	200014ba <QSPI_Configuration+0x146>
	}
	/*read configuration register*/
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200013dc:	f44f 7380 	mov.w	r3, #256	; 0x100
200013e0:	623b      	str	r3, [r7, #32]
	sCommand.Instruction = READ_CONFIGURATION_REG_CMD;
200013e2:	2315      	movs	r3, #21
200013e4:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
200013e6:	2300      	movs	r3, #0
200013e8:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
200013ea:	2300      	movs	r3, #0
200013ec:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DataMode = QSPI_DATA_1_LINE;
200013ee:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200013f2:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
200013f4:	2300      	movs	r3, #0
200013f6:	61fb      	str	r3, [r7, #28]
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
200013f8:	2300      	movs	r3, #0
200013fa:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
200013fc:	2300      	movs	r3, #0
200013fe:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20001400:	2300      	movs	r3, #0
20001402:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.NbData = 1;
20001404:	2301      	movs	r3, #1
20001406:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
20001408:	f107 0308 	add.w	r3, r7, #8
2000140c:	f241 3288 	movw	r2, #5000	; 0x1388
20001410:	4619      	mov	r1, r3
20001412:	482c      	ldr	r0, [pc, #176]	; (200014c4 <QSPI_Configuration+0x150>)
20001414:	f00a f876 	bl	2000b504 <HAL_QSPI_Command>
20001418:	4603      	mov	r3, r0
2000141a:	2b00      	cmp	r3, #0
2000141c:	d001      	beq.n	20001422 <QSPI_Configuration+0xae>
			!= HAL_OK) {
		return HAL_ERROR;
2000141e:	2301      	movs	r3, #1
20001420:	e04b      	b.n	200014ba <QSPI_Configuration+0x146>
	}
	if (HAL_QSPI_Receive(&hqspi, &(test_buffer[1]),
20001422:	1d3b      	adds	r3, r7, #4
20001424:	3301      	adds	r3, #1
20001426:	f241 3288 	movw	r2, #5000	; 0x1388
2000142a:	4619      	mov	r1, r3
2000142c:	4825      	ldr	r0, [pc, #148]	; (200014c4 <QSPI_Configuration+0x150>)
2000142e:	f00a f9c1 	bl	2000b7b4 <HAL_QSPI_Receive>
20001432:	4603      	mov	r3, r0
20001434:	2b00      	cmp	r3, #0
20001436:	d001      	beq.n	2000143c <QSPI_Configuration+0xc8>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
20001438:	2301      	movs	r3, #1
2000143a:	e03e      	b.n	200014ba <QSPI_Configuration+0x146>
	}
	/*modify buffer to enable quad mode*/
	test_buffer[0] |= 0x40;
2000143c:	793b      	ldrb	r3, [r7, #4]
2000143e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20001442:	b2db      	uxtb	r3, r3
20001444:	713b      	strb	r3, [r7, #4]

	/*set dummy cycles*/
	test_buffer[1] |= 0xC0;
20001446:	797b      	ldrb	r3, [r7, #5]
20001448:	f063 033f 	orn	r3, r3, #63	; 0x3f
2000144c:	b2db      	uxtb	r3, r3
2000144e:	717b      	strb	r3, [r7, #5]

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20001450:	f44f 7380 	mov.w	r3, #256	; 0x100
20001454:	623b      	str	r3, [r7, #32]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20001456:	f44f 5300 	mov.w	r3, #8192	; 0x2000
2000145a:	617b      	str	r3, [r7, #20]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2000145c:	2300      	movs	r3, #0
2000145e:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001460:	2300      	movs	r3, #0
20001462:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20001464:	2300      	movs	r3, #0
20001466:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20001468:	2300      	movs	r3, #0
2000146a:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.Instruction = WRITE_STATUS_REG_CMD;
2000146c:	2301      	movs	r3, #1
2000146e:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001470:	2300      	movs	r3, #0
20001472:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_1_LINE;
20001474:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20001478:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
2000147a:	2300      	movs	r3, #0
2000147c:	61fb      	str	r3, [r7, #28]
	sCommand.NbData = 2;
2000147e:	2302      	movs	r3, #2
20001480:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
20001482:	f107 0308 	add.w	r3, r7, #8
20001486:	f241 3288 	movw	r2, #5000	; 0x1388
2000148a:	4619      	mov	r1, r3
2000148c:	480d      	ldr	r0, [pc, #52]	; (200014c4 <QSPI_Configuration+0x150>)
2000148e:	f00a f839 	bl	2000b504 <HAL_QSPI_Command>
20001492:	4603      	mov	r3, r0
20001494:	2b00      	cmp	r3, #0
20001496:	d001      	beq.n	2000149c <QSPI_Configuration+0x128>
			!= HAL_OK) {
		return HAL_ERROR;
20001498:	2301      	movs	r3, #1
2000149a:	e00e      	b.n	200014ba <QSPI_Configuration+0x146>
	}

	if (HAL_QSPI_Transmit(&hqspi, test_buffer,
2000149c:	1d3b      	adds	r3, r7, #4
2000149e:	f241 3288 	movw	r2, #5000	; 0x1388
200014a2:	4619      	mov	r1, r3
200014a4:	4807      	ldr	r0, [pc, #28]	; (200014c4 <QSPI_Configuration+0x150>)
200014a6:	f00a f8f5 	bl	2000b694 <HAL_QSPI_Transmit>
200014aa:	4603      	mov	r3, r0
200014ac:	2b00      	cmp	r3, #0
200014ae:	d003      	beq.n	200014b8 <QSPI_Configuration+0x144>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		Error_Handler();
200014b0:	f7ff fd5c 	bl	20000f6c <Error_Handler>
		return HAL_ERROR;
200014b4:	2301      	movs	r3, #1
200014b6:	e000      	b.n	200014ba <QSPI_Configuration+0x146>
	}
	return HAL_OK;
200014b8:	2300      	movs	r3, #0
}
200014ba:	4618      	mov	r0, r3
200014bc:	3740      	adds	r7, #64	; 0x40
200014be:	46bd      	mov	sp, r7
200014c0:	bd80      	pop	{r7, pc}
200014c2:	bf00      	nop
200014c4:	200004a4 	.word	0x200004a4

200014c8 <CSP_QSPI_EraseSector>:

uint8_t CSP_QSPI_EraseSector(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
200014c8:	b580      	push	{r7, lr}
200014ca:	b090      	sub	sp, #64	; 0x40
200014cc:	af00      	add	r7, sp, #0
200014ce:	6078      	str	r0, [r7, #4]
200014d0:	6039      	str	r1, [r7, #0]

	QSPI_CommandTypeDef sCommand;

	EraseStartAddress = EraseStartAddress
200014d2:	687a      	ldr	r2, [r7, #4]
200014d4:	4b23      	ldr	r3, [pc, #140]	; (20001564 <CSP_QSPI_EraseSector+0x9c>)
200014d6:	4013      	ands	r3, r2
200014d8:	607b      	str	r3, [r7, #4]
			- EraseStartAddress % MEMORY_SECTOR_SIZE;

	/* Erasing Sequence -------------------------------------------------- */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200014da:	f44f 7380 	mov.w	r3, #256	; 0x100
200014de:	623b      	str	r3, [r7, #32]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
200014e0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
200014e4:	617b      	str	r3, [r7, #20]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
200014e6:	2300      	movs	r3, #0
200014e8:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
200014ea:	2300      	movs	r3, #0
200014ec:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
200014ee:	2300      	movs	r3, #0
200014f0:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
200014f2:	2300      	movs	r3, #0
200014f4:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.Instruction = SECTOR_ERASE_CMD;
200014f6:	2320      	movs	r3, #32
200014f8:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
200014fa:	f44f 6380 	mov.w	r3, #1024	; 0x400
200014fe:	627b      	str	r3, [r7, #36]	; 0x24

	sCommand.DataMode = QSPI_DATA_NONE;
20001500:	2300      	movs	r3, #0
20001502:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
20001504:	2300      	movs	r3, #0
20001506:	61fb      	str	r3, [r7, #28]

	while (EraseEndAddress >= EraseStartAddress) {
20001508:	e022      	b.n	20001550 <CSP_QSPI_EraseSector+0x88>
		sCommand.Address = (EraseStartAddress & 0x0FFFFFFF);
2000150a:	687b      	ldr	r3, [r7, #4]
2000150c:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
20001510:	60fb      	str	r3, [r7, #12]

		if (QSPI_WriteEnable() != HAL_OK) {
20001512:	f7ff fee5 	bl	200012e0 <QSPI_WriteEnable>
20001516:	4603      	mov	r3, r0
20001518:	2b00      	cmp	r3, #0
2000151a:	d001      	beq.n	20001520 <CSP_QSPI_EraseSector+0x58>
			return HAL_ERROR;
2000151c:	2301      	movs	r3, #1
2000151e:	e01c      	b.n	2000155a <CSP_QSPI_EraseSector+0x92>
		}

		if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
20001520:	f107 0308 	add.w	r3, r7, #8
20001524:	f241 3288 	movw	r2, #5000	; 0x1388
20001528:	4619      	mov	r1, r3
2000152a:	480f      	ldr	r0, [pc, #60]	; (20001568 <CSP_QSPI_EraseSector+0xa0>)
2000152c:	f009 ffea 	bl	2000b504 <HAL_QSPI_Command>
20001530:	4603      	mov	r3, r0
20001532:	2b00      	cmp	r3, #0
20001534:	d001      	beq.n	2000153a <CSP_QSPI_EraseSector+0x72>
				!= HAL_OK) {
			return HAL_ERROR;
20001536:	2301      	movs	r3, #1
20001538:	e00f      	b.n	2000155a <CSP_QSPI_EraseSector+0x92>
		}
		EraseStartAddress += MEMORY_SECTOR_SIZE;
2000153a:	687b      	ldr	r3, [r7, #4]
2000153c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
20001540:	607b      	str	r3, [r7, #4]

		if (QSPI_AutoPollingMemReady() != HAL_OK) {
20001542:	f7ff fe95 	bl	20001270 <QSPI_AutoPollingMemReady>
20001546:	4603      	mov	r3, r0
20001548:	2b00      	cmp	r3, #0
2000154a:	d001      	beq.n	20001550 <CSP_QSPI_EraseSector+0x88>
			return HAL_ERROR;
2000154c:	2301      	movs	r3, #1
2000154e:	e004      	b.n	2000155a <CSP_QSPI_EraseSector+0x92>
	while (EraseEndAddress >= EraseStartAddress) {
20001550:	683a      	ldr	r2, [r7, #0]
20001552:	687b      	ldr	r3, [r7, #4]
20001554:	429a      	cmp	r2, r3
20001556:	d2d8      	bcs.n	2000150a <CSP_QSPI_EraseSector+0x42>
		}
	}

	return HAL_OK;
20001558:	2300      	movs	r3, #0
}
2000155a:	4618      	mov	r0, r3
2000155c:	3740      	adds	r7, #64	; 0x40
2000155e:	46bd      	mov	sp, r7
20001560:	bd80      	pop	{r7, pc}
20001562:	bf00      	nop
20001564:	fffff000 	.word	0xfffff000
20001568:	200004a4 	.word	0x200004a4

2000156c <CSP_QSPI_WriteMemory>:

uint8_t CSP_QSPI_WriteMemory(uint8_t* buffer, uint32_t address,uint32_t buffer_size) {
2000156c:	b580      	push	{r7, lr}
2000156e:	b096      	sub	sp, #88	; 0x58
20001570:	af00      	add	r7, sp, #0
20001572:	60f8      	str	r0, [r7, #12]
20001574:	60b9      	str	r1, [r7, #8]
20001576:	607a      	str	r2, [r7, #4]

	QSPI_CommandTypeDef sCommand;
	uint32_t end_addr, current_size, current_addr;

	/* Calculation of the size between the write address and the end of the page */
	current_addr = 0;
20001578:	2300      	movs	r3, #0
2000157a:	653b      	str	r3, [r7, #80]	; 0x50


	//
	while (current_addr <= address) {
2000157c:	e003      	b.n	20001586 <CSP_QSPI_WriteMemory+0x1a>
		current_addr += MEMORY_PAGE_SIZE;
2000157e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
20001580:	f503 7380 	add.w	r3, r3, #256	; 0x100
20001584:	653b      	str	r3, [r7, #80]	; 0x50
	while (current_addr <= address) {
20001586:	6d3a      	ldr	r2, [r7, #80]	; 0x50
20001588:	68bb      	ldr	r3, [r7, #8]
2000158a:	429a      	cmp	r2, r3
2000158c:	d9f7      	bls.n	2000157e <CSP_QSPI_WriteMemory+0x12>
	}
	current_size = current_addr - address;
2000158e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
20001590:	68bb      	ldr	r3, [r7, #8]
20001592:	1ad3      	subs	r3, r2, r3
20001594:	657b      	str	r3, [r7, #84]	; 0x54

	/* Check if the size of the data is less than the remaining place in the page */
	if (current_size > buffer_size) {
20001596:	6d7a      	ldr	r2, [r7, #84]	; 0x54
20001598:	687b      	ldr	r3, [r7, #4]
2000159a:	429a      	cmp	r2, r3
2000159c:	d901      	bls.n	200015a2 <CSP_QSPI_WriteMemory+0x36>
		current_size = buffer_size;
2000159e:	687b      	ldr	r3, [r7, #4]
200015a0:	657b      	str	r3, [r7, #84]	; 0x54
	}

	/* Initialize the adress variables */
	current_addr = address;
200015a2:	68bb      	ldr	r3, [r7, #8]
200015a4:	653b      	str	r3, [r7, #80]	; 0x50
	end_addr = address + buffer_size;
200015a6:	68ba      	ldr	r2, [r7, #8]
200015a8:	687b      	ldr	r3, [r7, #4]
200015aa:	4413      	add	r3, r2
200015ac:	64fb      	str	r3, [r7, #76]	; 0x4c

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200015ae:	f44f 7380 	mov.w	r3, #256	; 0x100
200015b2:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
200015b4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
200015b8:	623b      	str	r3, [r7, #32]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
200015ba:	2300      	movs	r3, #0
200015bc:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
200015be:	2300      	movs	r3, #0
200015c0:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
200015c2:	2300      	movs	r3, #0
200015c4:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
200015c6:	2300      	movs	r3, #0
200015c8:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.Instruction = QUAD_IN_FAST_PROG_CMD;
200015ca:	2338      	movs	r3, #56	; 0x38
200015cc:	617b      	str	r3, [r7, #20]
	sCommand.AddressMode = QSPI_ADDRESS_4_LINES;
200015ce:	f44f 6340 	mov.w	r3, #3072	; 0xc00
200015d2:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DataMode = QSPI_DATA_4_LINES;
200015d4:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
200015d8:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.NbData = buffer_size;
200015da:	687b      	ldr	r3, [r7, #4]
200015dc:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.Address = address;
200015de:	68bb      	ldr	r3, [r7, #8]
200015e0:	61bb      	str	r3, [r7, #24]
	sCommand.DummyCycles = 0;
200015e2:	2300      	movs	r3, #0
200015e4:	62bb      	str	r3, [r7, #40]	; 0x28

	/* Perform the write page by page */
	do {
		sCommand.Address = current_addr;
200015e6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
200015e8:	61bb      	str	r3, [r7, #24]
		sCommand.NbData = current_size;
200015ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
200015ec:	63fb      	str	r3, [r7, #60]	; 0x3c

		if (current_size == 0) {
200015ee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
200015f0:	2b00      	cmp	r3, #0
200015f2:	d101      	bne.n	200015f8 <CSP_QSPI_WriteMemory+0x8c>
			return HAL_OK;
200015f4:	2300      	movs	r3, #0
200015f6:	e03f      	b.n	20001678 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Enable write operations */
		if (QSPI_WriteEnable() != HAL_OK) {
200015f8:	f7ff fe72 	bl	200012e0 <QSPI_WriteEnable>
200015fc:	4603      	mov	r3, r0
200015fe:	2b00      	cmp	r3, #0
20001600:	d001      	beq.n	20001606 <CSP_QSPI_WriteMemory+0x9a>
			return HAL_ERROR;
20001602:	2301      	movs	r3, #1
20001604:	e038      	b.n	20001678 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Configure the command */
		if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
20001606:	f107 0314 	add.w	r3, r7, #20
2000160a:	f241 3288 	movw	r2, #5000	; 0x1388
2000160e:	4619      	mov	r1, r3
20001610:	481b      	ldr	r0, [pc, #108]	; (20001680 <CSP_QSPI_WriteMemory+0x114>)
20001612:	f009 ff77 	bl	2000b504 <HAL_QSPI_Command>
20001616:	4603      	mov	r3, r0
20001618:	2b00      	cmp	r3, #0
2000161a:	d001      	beq.n	20001620 <CSP_QSPI_WriteMemory+0xb4>
				!= HAL_OK) {

			return HAL_ERROR;
2000161c:	2301      	movs	r3, #1
2000161e:	e02b      	b.n	20001678 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Transmission of the data */
		if (HAL_QSPI_Transmit(&hqspi, buffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
20001620:	f241 3288 	movw	r2, #5000	; 0x1388
20001624:	68f9      	ldr	r1, [r7, #12]
20001626:	4816      	ldr	r0, [pc, #88]	; (20001680 <CSP_QSPI_WriteMemory+0x114>)
20001628:	f00a f834 	bl	2000b694 <HAL_QSPI_Transmit>
2000162c:	4603      	mov	r3, r0
2000162e:	2b00      	cmp	r3, #0
20001630:	d001      	beq.n	20001636 <CSP_QSPI_WriteMemory+0xca>

			return HAL_ERROR;
20001632:	2301      	movs	r3, #1
20001634:	e020      	b.n	20001678 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Configure automatic polling mode to wait for end of program */
		if (QSPI_AutoPollingMemReady() != HAL_OK) {
20001636:	f7ff fe1b 	bl	20001270 <QSPI_AutoPollingMemReady>
2000163a:	4603      	mov	r3, r0
2000163c:	2b00      	cmp	r3, #0
2000163e:	d001      	beq.n	20001644 <CSP_QSPI_WriteMemory+0xd8>
			return HAL_ERROR;
20001640:	2301      	movs	r3, #1
20001642:	e019      	b.n	20001678 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Update the address and size variables for next page programming */
		current_addr += current_size;
20001644:	6d3a      	ldr	r2, [r7, #80]	; 0x50
20001646:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001648:	4413      	add	r3, r2
2000164a:	653b      	str	r3, [r7, #80]	; 0x50
		buffer += current_size;
2000164c:	68fa      	ldr	r2, [r7, #12]
2000164e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001650:	4413      	add	r3, r2
20001652:	60fb      	str	r3, [r7, #12]
		current_size =
				((current_addr + MEMORY_PAGE_SIZE) > end_addr) ?
20001654:	6d3b      	ldr	r3, [r7, #80]	; 0x50
20001656:	f503 7380 	add.w	r3, r3, #256	; 0x100
						(end_addr - current_addr) : MEMORY_PAGE_SIZE;
2000165a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
2000165c:	429a      	cmp	r2, r3
2000165e:	d203      	bcs.n	20001668 <CSP_QSPI_WriteMemory+0xfc>
20001660:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
20001662:	6d3b      	ldr	r3, [r7, #80]	; 0x50
20001664:	1ad3      	subs	r3, r2, r3
20001666:	e001      	b.n	2000166c <CSP_QSPI_WriteMemory+0x100>
20001668:	f44f 7380 	mov.w	r3, #256	; 0x100
		current_size =
2000166c:	657b      	str	r3, [r7, #84]	; 0x54
	} while (current_addr <= end_addr);
2000166e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
20001670:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001672:	429a      	cmp	r2, r3
20001674:	d9b7      	bls.n	200015e6 <CSP_QSPI_WriteMemory+0x7a>

	return HAL_OK;
20001676:	2300      	movs	r3, #0

}
20001678:	4618      	mov	r0, r3
2000167a:	3758      	adds	r7, #88	; 0x58
2000167c:	46bd      	mov	sp, r7
2000167e:	bd80      	pop	{r7, pc}
20001680:	200004a4 	.word	0x200004a4

20001684 <CSP_QSPI_EnableMemoryMappedMode>:


uint8_t CSP_QSPI_EnableMemoryMappedMode(void) {
20001684:	b580      	push	{r7, lr}
20001686:	b090      	sub	sp, #64	; 0x40
20001688:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	QSPI_MemoryMappedTypeDef sMemMappedCfg;

	/* Enable Memory-Mapped mode-------------------------------------------------- */

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2000168a:	f44f 7380 	mov.w	r3, #256	; 0x100
2000168e:	623b      	str	r3, [r7, #32]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20001690:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20001694:	617b      	str	r3, [r7, #20]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20001696:	2300      	movs	r3, #0
20001698:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2000169a:	2300      	movs	r3, #0
2000169c:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2000169e:	2300      	movs	r3, #0
200016a0:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
200016a2:	2300      	movs	r3, #0
200016a4:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
200016a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
200016aa:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_4_LINES;
200016ac:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
200016b0:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.NbData = 0;
200016b2:	2300      	movs	r3, #0
200016b4:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Address = 0;
200016b6:	2300      	movs	r3, #0
200016b8:	60fb      	str	r3, [r7, #12]
	sCommand.Instruction = QUAD_OUT_FAST_READ_CMD;
200016ba:	236b      	movs	r3, #107	; 0x6b
200016bc:	60bb      	str	r3, [r7, #8]
	sCommand.DummyCycles = DUMMY_CLOCK_CYCLES_READ_QUAD;
200016be:	230a      	movs	r3, #10
200016c0:	61fb      	str	r3, [r7, #28]

	sMemMappedCfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
200016c2:	2300      	movs	r3, #0
200016c4:	607b      	str	r3, [r7, #4]

	if (HAL_QSPI_MemoryMapped(&hqspi, &sCommand, &sMemMappedCfg) != HAL_OK) {
200016c6:	463a      	mov	r2, r7
200016c8:	f107 0308 	add.w	r3, r7, #8
200016cc:	4619      	mov	r1, r3
200016ce:	4806      	ldr	r0, [pc, #24]	; (200016e8 <CSP_QSPI_EnableMemoryMappedMode+0x64>)
200016d0:	f00a fcc1 	bl	2000c056 <HAL_QSPI_MemoryMapped>
200016d4:	4603      	mov	r3, r0
200016d6:	2b00      	cmp	r3, #0
200016d8:	d001      	beq.n	200016de <CSP_QSPI_EnableMemoryMappedMode+0x5a>
		return HAL_ERROR;
200016da:	2301      	movs	r3, #1
200016dc:	e000      	b.n	200016e0 <CSP_QSPI_EnableMemoryMappedMode+0x5c>
	}
	return HAL_OK;
200016de:	2300      	movs	r3, #0
}
200016e0:	4618      	mov	r0, r3
200016e2:	3740      	adds	r7, #64	; 0x40
200016e4:	46bd      	mov	sp, r7
200016e6:	bd80      	pop	{r7, pc}
200016e8:	200004a4 	.word	0x200004a4

200016ec <QSPI_ResetChip>:

uint8_t QSPI_ResetChip() {
200016ec:	b580      	push	{r7, lr}
200016ee:	b090      	sub	sp, #64	; 0x40
200016f0:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	uint32_t temp = 0;
200016f2:	2300      	movs	r3, #0
200016f4:	63fb      	str	r3, [r7, #60]	; 0x3c
	/* Erasing Sequence -------------------------------------------------- */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200016f6:	f44f 7380 	mov.w	r3, #256	; 0x100
200016fa:	61fb      	str	r3, [r7, #28]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
200016fc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20001700:	613b      	str	r3, [r7, #16]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20001702:	2300      	movs	r3, #0
20001704:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001706:	2300      	movs	r3, #0
20001708:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2000170a:	2300      	movs	r3, #0
2000170c:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2000170e:	2300      	movs	r3, #0
20001710:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.Instruction = RESET_ENABLE_CMD;
20001712:	2366      	movs	r3, #102	; 0x66
20001714:	607b      	str	r3, [r7, #4]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001716:	2300      	movs	r3, #0
20001718:	623b      	str	r3, [r7, #32]
	sCommand.Address = 0;
2000171a:	2300      	movs	r3, #0
2000171c:	60bb      	str	r3, [r7, #8]
	sCommand.DataMode = QSPI_DATA_NONE;
2000171e:	2300      	movs	r3, #0
20001720:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DummyCycles = 0;
20001722:	2300      	movs	r3, #0
20001724:	61bb      	str	r3, [r7, #24]

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
20001726:	1d3b      	adds	r3, r7, #4
20001728:	f241 3288 	movw	r2, #5000	; 0x1388
2000172c:	4619      	mov	r1, r3
2000172e:	481d      	ldr	r0, [pc, #116]	; (200017a4 <QSPI_ResetChip+0xb8>)
20001730:	f009 fee8 	bl	2000b504 <HAL_QSPI_Command>
20001734:	4603      	mov	r3, r0
20001736:	2b00      	cmp	r3, #0
20001738:	d001      	beq.n	2000173e <QSPI_ResetChip+0x52>
			!= HAL_OK) {
		return HAL_ERROR;
2000173a:	2301      	movs	r3, #1
2000173c:	e02e      	b.n	2000179c <QSPI_ResetChip+0xb0>
	}
	for (temp = 0; temp < 0x2f; temp++) {
2000173e:	2300      	movs	r3, #0
20001740:	63fb      	str	r3, [r7, #60]	; 0x3c
20001742:	e003      	b.n	2000174c <QSPI_ResetChip+0x60>
		__NOP();
20001744:	bf00      	nop
	for (temp = 0; temp < 0x2f; temp++) {
20001746:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
20001748:	3301      	adds	r3, #1
2000174a:	63fb      	str	r3, [r7, #60]	; 0x3c
2000174c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
2000174e:	2b2e      	cmp	r3, #46	; 0x2e
20001750:	d9f8      	bls.n	20001744 <QSPI_ResetChip+0x58>
	}

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20001752:	f44f 7380 	mov.w	r3, #256	; 0x100
20001756:	61fb      	str	r3, [r7, #28]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
20001758:	f44f 5300 	mov.w	r3, #8192	; 0x2000
2000175c:	613b      	str	r3, [r7, #16]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2000175e:	2300      	movs	r3, #0
20001760:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001762:	2300      	movs	r3, #0
20001764:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20001766:	2300      	movs	r3, #0
20001768:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2000176a:	2300      	movs	r3, #0
2000176c:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.Instruction = RESET_EXECUTE_CMD;
2000176e:	2399      	movs	r3, #153	; 0x99
20001770:	607b      	str	r3, [r7, #4]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001772:	2300      	movs	r3, #0
20001774:	623b      	str	r3, [r7, #32]
	sCommand.Address = 0;
20001776:	2300      	movs	r3, #0
20001778:	60bb      	str	r3, [r7, #8]
	sCommand.DataMode = QSPI_DATA_NONE;
2000177a:	2300      	movs	r3, #0
2000177c:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DummyCycles = 0;
2000177e:	2300      	movs	r3, #0
20001780:	61bb      	str	r3, [r7, #24]

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
20001782:	1d3b      	adds	r3, r7, #4
20001784:	f241 3288 	movw	r2, #5000	; 0x1388
20001788:	4619      	mov	r1, r3
2000178a:	4806      	ldr	r0, [pc, #24]	; (200017a4 <QSPI_ResetChip+0xb8>)
2000178c:	f009 feba 	bl	2000b504 <HAL_QSPI_Command>
20001790:	4603      	mov	r3, r0
20001792:	2b00      	cmp	r3, #0
20001794:	d001      	beq.n	2000179a <QSPI_ResetChip+0xae>
			!= HAL_OK) {
		return HAL_ERROR;
20001796:	2301      	movs	r3, #1
20001798:	e000      	b.n	2000179c <QSPI_ResetChip+0xb0>
	}
	return HAL_OK;
2000179a:	2300      	movs	r3, #0
}
2000179c:	4618      	mov	r0, r3
2000179e:	3740      	adds	r7, #64	; 0x40
200017a0:	46bd      	mov	sp, r7
200017a2:	bd80      	pop	{r7, pc}
200017a4:	200004a4 	.word	0x200004a4

200017a8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
200017a8:	b480      	push	{r7}
200017aa:	b083      	sub	sp, #12
200017ac:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
200017ae:	4b0f      	ldr	r3, [pc, #60]	; (200017ec <HAL_MspInit+0x44>)
200017b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200017b2:	4a0e      	ldr	r2, [pc, #56]	; (200017ec <HAL_MspInit+0x44>)
200017b4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
200017b8:	6413      	str	r3, [r2, #64]	; 0x40
200017ba:	4b0c      	ldr	r3, [pc, #48]	; (200017ec <HAL_MspInit+0x44>)
200017bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200017be:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
200017c2:	607b      	str	r3, [r7, #4]
200017c4:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
200017c6:	4b09      	ldr	r3, [pc, #36]	; (200017ec <HAL_MspInit+0x44>)
200017c8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200017ca:	4a08      	ldr	r2, [pc, #32]	; (200017ec <HAL_MspInit+0x44>)
200017cc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
200017d0:	6453      	str	r3, [r2, #68]	; 0x44
200017d2:	4b06      	ldr	r3, [pc, #24]	; (200017ec <HAL_MspInit+0x44>)
200017d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200017d6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
200017da:	603b      	str	r3, [r7, #0]
200017dc:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
200017de:	bf00      	nop
200017e0:	370c      	adds	r7, #12
200017e2:	46bd      	mov	sp, r7
200017e4:	f85d 7b04 	ldr.w	r7, [sp], #4
200017e8:	4770      	bx	lr
200017ea:	bf00      	nop
200017ec:	40023800 	.word	0x40023800

200017f0 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
200017f0:	b480      	push	{r7}
200017f2:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
200017f4:	bf00      	nop
200017f6:	46bd      	mov	sp, r7
200017f8:	f85d 7b04 	ldr.w	r7, [sp], #4
200017fc:	4770      	bx	lr

200017fe <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
200017fe:	b480      	push	{r7}
20001800:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
20001802:	e7fe      	b.n	20001802 <HardFault_Handler+0x4>

20001804 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
20001804:	b480      	push	{r7}
20001806:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
20001808:	e7fe      	b.n	20001808 <MemManage_Handler+0x4>

2000180a <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
2000180a:	b480      	push	{r7}
2000180c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
2000180e:	e7fe      	b.n	2000180e <BusFault_Handler+0x4>

20001810 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
20001810:	b480      	push	{r7}
20001812:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
20001814:	e7fe      	b.n	20001814 <UsageFault_Handler+0x4>

20001816 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
20001816:	b480      	push	{r7}
20001818:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
2000181a:	bf00      	nop
2000181c:	46bd      	mov	sp, r7
2000181e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001822:	4770      	bx	lr

20001824 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
20001824:	b480      	push	{r7}
20001826:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
20001828:	bf00      	nop
2000182a:	46bd      	mov	sp, r7
2000182c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001830:	4770      	bx	lr

20001832 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
20001832:	b480      	push	{r7}
20001834:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
20001836:	bf00      	nop
20001838:	46bd      	mov	sp, r7
2000183a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000183e:	4770      	bx	lr

20001840 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
20001840:	b580      	push	{r7, lr}
20001842:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
20001844:	f000 fa88 	bl	20001d58 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
20001848:	bf00      	nop
2000184a:	bd80      	pop	{r7, pc}

2000184c <initialise_monitor_handles>:
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
2000184c:	b480      	push	{r7}
2000184e:	af00      	add	r7, sp, #0
}
20001850:	bf00      	nop
20001852:	46bd      	mov	sp, r7
20001854:	f85d 7b04 	ldr.w	r7, [sp], #4
20001858:	4770      	bx	lr

2000185a <_getpid>:

int _getpid(void)
{
2000185a:	b480      	push	{r7}
2000185c:	af00      	add	r7, sp, #0
	return 1;
2000185e:	2301      	movs	r3, #1
}
20001860:	4618      	mov	r0, r3
20001862:	46bd      	mov	sp, r7
20001864:	f85d 7b04 	ldr.w	r7, [sp], #4
20001868:	4770      	bx	lr

2000186a <_kill>:

int _kill(int pid, int sig)
{
2000186a:	b580      	push	{r7, lr}
2000186c:	b082      	sub	sp, #8
2000186e:	af00      	add	r7, sp, #0
20001870:	6078      	str	r0, [r7, #4]
20001872:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
20001874:	f00c fe70 	bl	2000e558 <__errno>
20001878:	4602      	mov	r2, r0
2000187a:	2316      	movs	r3, #22
2000187c:	6013      	str	r3, [r2, #0]
	return -1;
2000187e:	f04f 33ff 	mov.w	r3, #4294967295
}
20001882:	4618      	mov	r0, r3
20001884:	3708      	adds	r7, #8
20001886:	46bd      	mov	sp, r7
20001888:	bd80      	pop	{r7, pc}

2000188a <_exit>:

void _exit (int status)
{
2000188a:	b580      	push	{r7, lr}
2000188c:	b082      	sub	sp, #8
2000188e:	af00      	add	r7, sp, #0
20001890:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
20001892:	f04f 31ff 	mov.w	r1, #4294967295
20001896:	6878      	ldr	r0, [r7, #4]
20001898:	f7ff ffe7 	bl	2000186a <_kill>
	while (1) {}		/* Make sure we hang here */
2000189c:	e7fe      	b.n	2000189c <_exit+0x12>

2000189e <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
2000189e:	b580      	push	{r7, lr}
200018a0:	b086      	sub	sp, #24
200018a2:	af00      	add	r7, sp, #0
200018a4:	60f8      	str	r0, [r7, #12]
200018a6:	60b9      	str	r1, [r7, #8]
200018a8:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
200018aa:	2300      	movs	r3, #0
200018ac:	617b      	str	r3, [r7, #20]
200018ae:	e00a      	b.n	200018c6 <_read+0x28>
	{
		*ptr++ = __io_getchar();
200018b0:	f3af 8000 	nop.w
200018b4:	4601      	mov	r1, r0
200018b6:	68bb      	ldr	r3, [r7, #8]
200018b8:	1c5a      	adds	r2, r3, #1
200018ba:	60ba      	str	r2, [r7, #8]
200018bc:	b2ca      	uxtb	r2, r1
200018be:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
200018c0:	697b      	ldr	r3, [r7, #20]
200018c2:	3301      	adds	r3, #1
200018c4:	617b      	str	r3, [r7, #20]
200018c6:	697a      	ldr	r2, [r7, #20]
200018c8:	687b      	ldr	r3, [r7, #4]
200018ca:	429a      	cmp	r2, r3
200018cc:	dbf0      	blt.n	200018b0 <_read+0x12>
	}

return len;
200018ce:	687b      	ldr	r3, [r7, #4]
}
200018d0:	4618      	mov	r0, r3
200018d2:	3718      	adds	r7, #24
200018d4:	46bd      	mov	sp, r7
200018d6:	bd80      	pop	{r7, pc}

200018d8 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
200018d8:	b580      	push	{r7, lr}
200018da:	b086      	sub	sp, #24
200018dc:	af00      	add	r7, sp, #0
200018de:	60f8      	str	r0, [r7, #12]
200018e0:	60b9      	str	r1, [r7, #8]
200018e2:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
200018e4:	2300      	movs	r3, #0
200018e6:	617b      	str	r3, [r7, #20]
200018e8:	e009      	b.n	200018fe <_write+0x26>
	{
		__io_putchar(*ptr++);
200018ea:	68bb      	ldr	r3, [r7, #8]
200018ec:	1c5a      	adds	r2, r3, #1
200018ee:	60ba      	str	r2, [r7, #8]
200018f0:	781b      	ldrb	r3, [r3, #0]
200018f2:	4618      	mov	r0, r3
200018f4:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
200018f8:	697b      	ldr	r3, [r7, #20]
200018fa:	3301      	adds	r3, #1
200018fc:	617b      	str	r3, [r7, #20]
200018fe:	697a      	ldr	r2, [r7, #20]
20001900:	687b      	ldr	r3, [r7, #4]
20001902:	429a      	cmp	r2, r3
20001904:	dbf1      	blt.n	200018ea <_write+0x12>
	}
	return len;
20001906:	687b      	ldr	r3, [r7, #4]
}
20001908:	4618      	mov	r0, r3
2000190a:	3718      	adds	r7, #24
2000190c:	46bd      	mov	sp, r7
2000190e:	bd80      	pop	{r7, pc}

20001910 <_close>:

int _close(int file)
{
20001910:	b480      	push	{r7}
20001912:	b083      	sub	sp, #12
20001914:	af00      	add	r7, sp, #0
20001916:	6078      	str	r0, [r7, #4]
	return -1;
20001918:	f04f 33ff 	mov.w	r3, #4294967295
}
2000191c:	4618      	mov	r0, r3
2000191e:	370c      	adds	r7, #12
20001920:	46bd      	mov	sp, r7
20001922:	f85d 7b04 	ldr.w	r7, [sp], #4
20001926:	4770      	bx	lr

20001928 <_fstat>:


int _fstat(int file, struct stat *st)
{
20001928:	b480      	push	{r7}
2000192a:	b083      	sub	sp, #12
2000192c:	af00      	add	r7, sp, #0
2000192e:	6078      	str	r0, [r7, #4]
20001930:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
20001932:	683b      	ldr	r3, [r7, #0]
20001934:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20001938:	605a      	str	r2, [r3, #4]
	return 0;
2000193a:	2300      	movs	r3, #0
}
2000193c:	4618      	mov	r0, r3
2000193e:	370c      	adds	r7, #12
20001940:	46bd      	mov	sp, r7
20001942:	f85d 7b04 	ldr.w	r7, [sp], #4
20001946:	4770      	bx	lr

20001948 <_isatty>:

int _isatty(int file)
{
20001948:	b480      	push	{r7}
2000194a:	b083      	sub	sp, #12
2000194c:	af00      	add	r7, sp, #0
2000194e:	6078      	str	r0, [r7, #4]
	return 1;
20001950:	2301      	movs	r3, #1
}
20001952:	4618      	mov	r0, r3
20001954:	370c      	adds	r7, #12
20001956:	46bd      	mov	sp, r7
20001958:	f85d 7b04 	ldr.w	r7, [sp], #4
2000195c:	4770      	bx	lr

2000195e <_lseek>:

int _lseek(int file, int ptr, int dir)
{
2000195e:	b480      	push	{r7}
20001960:	b085      	sub	sp, #20
20001962:	af00      	add	r7, sp, #0
20001964:	60f8      	str	r0, [r7, #12]
20001966:	60b9      	str	r1, [r7, #8]
20001968:	607a      	str	r2, [r7, #4]
	return 0;
2000196a:	2300      	movs	r3, #0
}
2000196c:	4618      	mov	r0, r3
2000196e:	3714      	adds	r7, #20
20001970:	46bd      	mov	sp, r7
20001972:	f85d 7b04 	ldr.w	r7, [sp], #4
20001976:	4770      	bx	lr

20001978 <_open>:

int _open(char *path, int flags, ...)
{
20001978:	b40e      	push	{r1, r2, r3}
2000197a:	b480      	push	{r7}
2000197c:	b082      	sub	sp, #8
2000197e:	af00      	add	r7, sp, #0
20001980:	6078      	str	r0, [r7, #4]
	/* Pretend like we always fail */
	return -1;
20001982:	f04f 33ff 	mov.w	r3, #4294967295
}
20001986:	4618      	mov	r0, r3
20001988:	3708      	adds	r7, #8
2000198a:	46bd      	mov	sp, r7
2000198c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001990:	b003      	add	sp, #12
20001992:	4770      	bx	lr

20001994 <_wait>:

int _wait(int *status)
{
20001994:	b580      	push	{r7, lr}
20001996:	b082      	sub	sp, #8
20001998:	af00      	add	r7, sp, #0
2000199a:	6078      	str	r0, [r7, #4]
	errno = ECHILD;
2000199c:	f00c fddc 	bl	2000e558 <__errno>
200019a0:	4602      	mov	r2, r0
200019a2:	230a      	movs	r3, #10
200019a4:	6013      	str	r3, [r2, #0]
	return -1;
200019a6:	f04f 33ff 	mov.w	r3, #4294967295
}
200019aa:	4618      	mov	r0, r3
200019ac:	3708      	adds	r7, #8
200019ae:	46bd      	mov	sp, r7
200019b0:	bd80      	pop	{r7, pc}

200019b2 <_unlink>:

int _unlink(char *name)
{
200019b2:	b580      	push	{r7, lr}
200019b4:	b082      	sub	sp, #8
200019b6:	af00      	add	r7, sp, #0
200019b8:	6078      	str	r0, [r7, #4]
	errno = ENOENT;
200019ba:	f00c fdcd 	bl	2000e558 <__errno>
200019be:	4602      	mov	r2, r0
200019c0:	2302      	movs	r3, #2
200019c2:	6013      	str	r3, [r2, #0]
	return -1;
200019c4:	f04f 33ff 	mov.w	r3, #4294967295
}
200019c8:	4618      	mov	r0, r3
200019ca:	3708      	adds	r7, #8
200019cc:	46bd      	mov	sp, r7
200019ce:	bd80      	pop	{r7, pc}

200019d0 <_times>:

int _times(struct tms *buf)
{
200019d0:	b480      	push	{r7}
200019d2:	b083      	sub	sp, #12
200019d4:	af00      	add	r7, sp, #0
200019d6:	6078      	str	r0, [r7, #4]
	return -1;
200019d8:	f04f 33ff 	mov.w	r3, #4294967295
}
200019dc:	4618      	mov	r0, r3
200019de:	370c      	adds	r7, #12
200019e0:	46bd      	mov	sp, r7
200019e2:	f85d 7b04 	ldr.w	r7, [sp], #4
200019e6:	4770      	bx	lr

200019e8 <_stat>:

int _stat(char *file, struct stat *st)
{
200019e8:	b480      	push	{r7}
200019ea:	b083      	sub	sp, #12
200019ec:	af00      	add	r7, sp, #0
200019ee:	6078      	str	r0, [r7, #4]
200019f0:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
200019f2:	683b      	ldr	r3, [r7, #0]
200019f4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
200019f8:	605a      	str	r2, [r3, #4]
	return 0;
200019fa:	2300      	movs	r3, #0
}
200019fc:	4618      	mov	r0, r3
200019fe:	370c      	adds	r7, #12
20001a00:	46bd      	mov	sp, r7
20001a02:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a06:	4770      	bx	lr

20001a08 <_link>:

int _link(char *old, char *new)
{
20001a08:	b580      	push	{r7, lr}
20001a0a:	b082      	sub	sp, #8
20001a0c:	af00      	add	r7, sp, #0
20001a0e:	6078      	str	r0, [r7, #4]
20001a10:	6039      	str	r1, [r7, #0]
	errno = EMLINK;
20001a12:	f00c fda1 	bl	2000e558 <__errno>
20001a16:	4602      	mov	r2, r0
20001a18:	231f      	movs	r3, #31
20001a1a:	6013      	str	r3, [r2, #0]
	return -1;
20001a1c:	f04f 33ff 	mov.w	r3, #4294967295
}
20001a20:	4618      	mov	r0, r3
20001a22:	3708      	adds	r7, #8
20001a24:	46bd      	mov	sp, r7
20001a26:	bd80      	pop	{r7, pc}

20001a28 <_fork>:

int _fork(void)
{
20001a28:	b580      	push	{r7, lr}
20001a2a:	af00      	add	r7, sp, #0
	errno = EAGAIN;
20001a2c:	f00c fd94 	bl	2000e558 <__errno>
20001a30:	4602      	mov	r2, r0
20001a32:	230b      	movs	r3, #11
20001a34:	6013      	str	r3, [r2, #0]
	return -1;
20001a36:	f04f 33ff 	mov.w	r3, #4294967295
}
20001a3a:	4618      	mov	r0, r3
20001a3c:	bd80      	pop	{r7, pc}

20001a3e <_execve>:

int _execve(char *name, char **argv, char **env)
{
20001a3e:	b580      	push	{r7, lr}
20001a40:	b084      	sub	sp, #16
20001a42:	af00      	add	r7, sp, #0
20001a44:	60f8      	str	r0, [r7, #12]
20001a46:	60b9      	str	r1, [r7, #8]
20001a48:	607a      	str	r2, [r7, #4]
	errno = ENOMEM;
20001a4a:	f00c fd85 	bl	2000e558 <__errno>
20001a4e:	4602      	mov	r2, r0
20001a50:	230c      	movs	r3, #12
20001a52:	6013      	str	r3, [r2, #0]
	return -1;
20001a54:	f04f 33ff 	mov.w	r3, #4294967295
}
20001a58:	4618      	mov	r0, r3
20001a5a:	3710      	adds	r7, #16
20001a5c:	46bd      	mov	sp, r7
20001a5e:	bd80      	pop	{r7, pc}

20001a60 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
20001a60:	b580      	push	{r7, lr}
20001a62:	b084      	sub	sp, #16
20001a64:	af00      	add	r7, sp, #0
20001a66:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
20001a68:	4b11      	ldr	r3, [pc, #68]	; (20001ab0 <_sbrk+0x50>)
20001a6a:	681b      	ldr	r3, [r3, #0]
20001a6c:	2b00      	cmp	r3, #0
20001a6e:	d102      	bne.n	20001a76 <_sbrk+0x16>
		heap_end = &end;
20001a70:	4b0f      	ldr	r3, [pc, #60]	; (20001ab0 <_sbrk+0x50>)
20001a72:	4a10      	ldr	r2, [pc, #64]	; (20001ab4 <_sbrk+0x54>)
20001a74:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
20001a76:	4b0e      	ldr	r3, [pc, #56]	; (20001ab0 <_sbrk+0x50>)
20001a78:	681b      	ldr	r3, [r3, #0]
20001a7a:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
20001a7c:	4b0c      	ldr	r3, [pc, #48]	; (20001ab0 <_sbrk+0x50>)
20001a7e:	681a      	ldr	r2, [r3, #0]
20001a80:	687b      	ldr	r3, [r7, #4]
20001a82:	4413      	add	r3, r2
20001a84:	466a      	mov	r2, sp
20001a86:	4293      	cmp	r3, r2
20001a88:	d907      	bls.n	20001a9a <_sbrk+0x3a>
	{
		errno = ENOMEM;
20001a8a:	f00c fd65 	bl	2000e558 <__errno>
20001a8e:	4602      	mov	r2, r0
20001a90:	230c      	movs	r3, #12
20001a92:	6013      	str	r3, [r2, #0]
		return (caddr_t) -1;
20001a94:	f04f 33ff 	mov.w	r3, #4294967295
20001a98:	e006      	b.n	20001aa8 <_sbrk+0x48>
	}

	heap_end += incr;
20001a9a:	4b05      	ldr	r3, [pc, #20]	; (20001ab0 <_sbrk+0x50>)
20001a9c:	681a      	ldr	r2, [r3, #0]
20001a9e:	687b      	ldr	r3, [r7, #4]
20001aa0:	4413      	add	r3, r2
20001aa2:	4a03      	ldr	r2, [pc, #12]	; (20001ab0 <_sbrk+0x50>)
20001aa4:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
20001aa6:	68fb      	ldr	r3, [r7, #12]
}
20001aa8:	4618      	mov	r0, r3
20001aaa:	3710      	adds	r7, #16
20001aac:	46bd      	mov	sp, r7
20001aae:	bd80      	pop	{r7, pc}
20001ab0:	200004a0 	.word	0x200004a0
20001ab4:	2000e70c 	.word	0x2000e70c

20001ab8 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
20001ab8:	b480      	push	{r7}
20001aba:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
20001abc:	4b15      	ldr	r3, [pc, #84]	; (20001b14 <SystemInit+0x5c>)
20001abe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20001ac2:	4a14      	ldr	r2, [pc, #80]	; (20001b14 <SystemInit+0x5c>)
20001ac4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
20001ac8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
20001acc:	4b12      	ldr	r3, [pc, #72]	; (20001b18 <SystemInit+0x60>)
20001ace:	681b      	ldr	r3, [r3, #0]
20001ad0:	4a11      	ldr	r2, [pc, #68]	; (20001b18 <SystemInit+0x60>)
20001ad2:	f043 0301 	orr.w	r3, r3, #1
20001ad6:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
20001ad8:	4b0f      	ldr	r3, [pc, #60]	; (20001b18 <SystemInit+0x60>)
20001ada:	2200      	movs	r2, #0
20001adc:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
20001ade:	4b0e      	ldr	r3, [pc, #56]	; (20001b18 <SystemInit+0x60>)
20001ae0:	681a      	ldr	r2, [r3, #0]
20001ae2:	490d      	ldr	r1, [pc, #52]	; (20001b18 <SystemInit+0x60>)
20001ae4:	4b0d      	ldr	r3, [pc, #52]	; (20001b1c <SystemInit+0x64>)
20001ae6:	4013      	ands	r3, r2
20001ae8:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
20001aea:	4b0b      	ldr	r3, [pc, #44]	; (20001b18 <SystemInit+0x60>)
20001aec:	4a0c      	ldr	r2, [pc, #48]	; (20001b20 <SystemInit+0x68>)
20001aee:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
20001af0:	4b09      	ldr	r3, [pc, #36]	; (20001b18 <SystemInit+0x60>)
20001af2:	681b      	ldr	r3, [r3, #0]
20001af4:	4a08      	ldr	r2, [pc, #32]	; (20001b18 <SystemInit+0x60>)
20001af6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
20001afa:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
20001afc:	4b06      	ldr	r3, [pc, #24]	; (20001b18 <SystemInit+0x60>)
20001afe:	2200      	movs	r2, #0
20001b00:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
20001b02:	4b04      	ldr	r3, [pc, #16]	; (20001b14 <SystemInit+0x5c>)
20001b04:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
20001b08:	609a      	str	r2, [r3, #8]
#endif
}
20001b0a:	bf00      	nop
20001b0c:	46bd      	mov	sp, r7
20001b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b12:	4770      	bx	lr
20001b14:	e000ed00 	.word	0xe000ed00
20001b18:	40023800 	.word	0x40023800
20001b1c:	fef6ffff 	.word	0xfef6ffff
20001b20:	24003010 	.word	0x24003010

20001b24 <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
20001b24:	b480      	push	{r7}
20001b26:	b087      	sub	sp, #28
20001b28:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
20001b2a:	2300      	movs	r3, #0
20001b2c:	613b      	str	r3, [r7, #16]
20001b2e:	2300      	movs	r3, #0
20001b30:	617b      	str	r3, [r7, #20]
20001b32:	2302      	movs	r3, #2
20001b34:	60fb      	str	r3, [r7, #12]
20001b36:	2300      	movs	r3, #0
20001b38:	60bb      	str	r3, [r7, #8]
20001b3a:	2302      	movs	r3, #2
20001b3c:	607b      	str	r3, [r7, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
20001b3e:	4b31      	ldr	r3, [pc, #196]	; (20001c04 <SystemCoreClockUpdate+0xe0>)
20001b40:	689b      	ldr	r3, [r3, #8]
20001b42:	f003 030c 	and.w	r3, r3, #12
20001b46:	613b      	str	r3, [r7, #16]

  switch (tmp)
20001b48:	693b      	ldr	r3, [r7, #16]
20001b4a:	2b04      	cmp	r3, #4
20001b4c:	d007      	beq.n	20001b5e <SystemCoreClockUpdate+0x3a>
20001b4e:	2b08      	cmp	r3, #8
20001b50:	d009      	beq.n	20001b66 <SystemCoreClockUpdate+0x42>
20001b52:	2b00      	cmp	r3, #0
20001b54:	d13d      	bne.n	20001bd2 <SystemCoreClockUpdate+0xae>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
20001b56:	4b2c      	ldr	r3, [pc, #176]	; (20001c08 <SystemCoreClockUpdate+0xe4>)
20001b58:	4a2c      	ldr	r2, [pc, #176]	; (20001c0c <SystemCoreClockUpdate+0xe8>)
20001b5a:	601a      	str	r2, [r3, #0]
      break;
20001b5c:	e03d      	b.n	20001bda <SystemCoreClockUpdate+0xb6>
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
20001b5e:	4b2a      	ldr	r3, [pc, #168]	; (20001c08 <SystemCoreClockUpdate+0xe4>)
20001b60:	4a2b      	ldr	r2, [pc, #172]	; (20001c10 <SystemCoreClockUpdate+0xec>)
20001b62:	601a      	str	r2, [r3, #0]
      break;
20001b64:	e039      	b.n	20001bda <SystemCoreClockUpdate+0xb6>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
20001b66:	4b27      	ldr	r3, [pc, #156]	; (20001c04 <SystemCoreClockUpdate+0xe0>)
20001b68:	685b      	ldr	r3, [r3, #4]
20001b6a:	0d9b      	lsrs	r3, r3, #22
20001b6c:	f003 0301 	and.w	r3, r3, #1
20001b70:	60bb      	str	r3, [r7, #8]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
20001b72:	4b24      	ldr	r3, [pc, #144]	; (20001c04 <SystemCoreClockUpdate+0xe0>)
20001b74:	685b      	ldr	r3, [r3, #4]
20001b76:	f003 033f 	and.w	r3, r3, #63	; 0x3f
20001b7a:	607b      	str	r3, [r7, #4]
      
      if (pllsource != 0)
20001b7c:	68bb      	ldr	r3, [r7, #8]
20001b7e:	2b00      	cmp	r3, #0
20001b80:	d00c      	beq.n	20001b9c <SystemCoreClockUpdate+0x78>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
20001b82:	4a23      	ldr	r2, [pc, #140]	; (20001c10 <SystemCoreClockUpdate+0xec>)
20001b84:	687b      	ldr	r3, [r7, #4]
20001b86:	fbb2 f3f3 	udiv	r3, r2, r3
20001b8a:	4a1e      	ldr	r2, [pc, #120]	; (20001c04 <SystemCoreClockUpdate+0xe0>)
20001b8c:	6852      	ldr	r2, [r2, #4]
20001b8e:	0992      	lsrs	r2, r2, #6
20001b90:	f3c2 0208 	ubfx	r2, r2, #0, #9
20001b94:	fb02 f303 	mul.w	r3, r2, r3
20001b98:	617b      	str	r3, [r7, #20]
20001b9a:	e00b      	b.n	20001bb4 <SystemCoreClockUpdate+0x90>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
20001b9c:	4a1b      	ldr	r2, [pc, #108]	; (20001c0c <SystemCoreClockUpdate+0xe8>)
20001b9e:	687b      	ldr	r3, [r7, #4]
20001ba0:	fbb2 f3f3 	udiv	r3, r2, r3
20001ba4:	4a17      	ldr	r2, [pc, #92]	; (20001c04 <SystemCoreClockUpdate+0xe0>)
20001ba6:	6852      	ldr	r2, [r2, #4]
20001ba8:	0992      	lsrs	r2, r2, #6
20001baa:	f3c2 0208 	ubfx	r2, r2, #0, #9
20001bae:	fb02 f303 	mul.w	r3, r2, r3
20001bb2:	617b      	str	r3, [r7, #20]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
20001bb4:	4b13      	ldr	r3, [pc, #76]	; (20001c04 <SystemCoreClockUpdate+0xe0>)
20001bb6:	685b      	ldr	r3, [r3, #4]
20001bb8:	0c1b      	lsrs	r3, r3, #16
20001bba:	f003 0303 	and.w	r3, r3, #3
20001bbe:	3301      	adds	r3, #1
20001bc0:	005b      	lsls	r3, r3, #1
20001bc2:	60fb      	str	r3, [r7, #12]
      SystemCoreClock = pllvco/pllp;
20001bc4:	697a      	ldr	r2, [r7, #20]
20001bc6:	68fb      	ldr	r3, [r7, #12]
20001bc8:	fbb2 f3f3 	udiv	r3, r2, r3
20001bcc:	4a0e      	ldr	r2, [pc, #56]	; (20001c08 <SystemCoreClockUpdate+0xe4>)
20001bce:	6013      	str	r3, [r2, #0]
      break;
20001bd0:	e003      	b.n	20001bda <SystemCoreClockUpdate+0xb6>
    default:
      SystemCoreClock = HSI_VALUE;
20001bd2:	4b0d      	ldr	r3, [pc, #52]	; (20001c08 <SystemCoreClockUpdate+0xe4>)
20001bd4:	4a0d      	ldr	r2, [pc, #52]	; (20001c0c <SystemCoreClockUpdate+0xe8>)
20001bd6:	601a      	str	r2, [r3, #0]
      break;
20001bd8:	bf00      	nop
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
20001bda:	4b0a      	ldr	r3, [pc, #40]	; (20001c04 <SystemCoreClockUpdate+0xe0>)
20001bdc:	689b      	ldr	r3, [r3, #8]
20001bde:	091b      	lsrs	r3, r3, #4
20001be0:	f003 030f 	and.w	r3, r3, #15
20001be4:	4a0b      	ldr	r2, [pc, #44]	; (20001c14 <SystemCoreClockUpdate+0xf0>)
20001be6:	5cd3      	ldrb	r3, [r2, r3]
20001be8:	613b      	str	r3, [r7, #16]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
20001bea:	4b07      	ldr	r3, [pc, #28]	; (20001c08 <SystemCoreClockUpdate+0xe4>)
20001bec:	681a      	ldr	r2, [r3, #0]
20001bee:	693b      	ldr	r3, [r7, #16]
20001bf0:	fa22 f303 	lsr.w	r3, r2, r3
20001bf4:	4a04      	ldr	r2, [pc, #16]	; (20001c08 <SystemCoreClockUpdate+0xe4>)
20001bf6:	6013      	str	r3, [r2, #0]
}
20001bf8:	bf00      	nop
20001bfa:	371c      	adds	r7, #28
20001bfc:	46bd      	mov	sp, r7
20001bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c02:	4770      	bx	lr
20001c04:	40023800 	.word	0x40023800
20001c08:	20000410 	.word	0x20000410
20001c0c:	00f42400 	.word	0x00f42400
20001c10:	017d7840 	.word	0x017d7840
20001c14:	2000e6e8 	.word	0x2000e6e8

20001c18 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
20001c18:	f8df d034 	ldr.w	sp, [pc, #52]	; 20001c50 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
20001c1c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
20001c1e:	e003      	b.n	20001c28 <LoopCopyDataInit>

20001c20 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
20001c20:	4b0c      	ldr	r3, [pc, #48]	; (20001c54 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
20001c22:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
20001c24:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
20001c26:	3104      	adds	r1, #4

20001c28 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
20001c28:	480b      	ldr	r0, [pc, #44]	; (20001c58 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
20001c2a:	4b0c      	ldr	r3, [pc, #48]	; (20001c5c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
20001c2c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
20001c2e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
20001c30:	d3f6      	bcc.n	20001c20 <CopyDataInit>
  ldr  r2, =_sbss
20001c32:	4a0b      	ldr	r2, [pc, #44]	; (20001c60 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
20001c34:	e002      	b.n	20001c3c <LoopFillZerobss>

20001c36 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
20001c36:	2300      	movs	r3, #0
  str  r3, [r2], #4
20001c38:	f842 3b04 	str.w	r3, [r2], #4

20001c3c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
20001c3c:	4b09      	ldr	r3, [pc, #36]	; (20001c64 <LoopFillZerobss+0x28>)
  cmp  r2, r3
20001c3e:	429a      	cmp	r2, r3
  bcc  FillZerobss
20001c40:	d3f9      	bcc.n	20001c36 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
20001c42:	f7ff ff39 	bl	20001ab8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
20001c46:	f00c fca1 	bl	2000e58c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
20001c4a:	f7ff f877 	bl	20000d3c <main>
  bx  lr    
20001c4e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
20001c50:	20080004 	.word	0x20080004
  ldr  r3, =_sidata
20001c54:	20000408 	.word	0x20000408
  ldr  r0, =_sdata
20001c58:	20000408 	.word	0x20000408
  ldr  r3, =_edata
20001c5c:	20000480 	.word	0x20000480
  ldr  r2, =_sbss
20001c60:	20000480 	.word	0x20000480
  ldr  r3, = _ebss
20001c64:	20000510 	.word	0x20000510

20001c68 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
20001c68:	e7fe      	b.n	20001c68 <ADC_IRQHandler>

20001c6a <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
20001c6a:	b580      	push	{r7, lr}
20001c6c:	af00      	add	r7, sp, #0
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
20001c6e:	2003      	movs	r0, #3
20001c70:	f000 fbf8 	bl	20002464 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
20001c74:	2000      	movs	r0, #0
20001c76:	f000 f83f 	bl	20001cf8 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
20001c7a:	f7ff fd95 	bl	200017a8 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
20001c7e:	2300      	movs	r3, #0
}
20001c80:	4618      	mov	r0, r3
20001c82:	bd80      	pop	{r7, pc}

20001c84 <HAL_DeInit>:
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
20001c84:	b580      	push	{r7, lr}
20001c86:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
20001c88:	4b13      	ldr	r3, [pc, #76]	; (20001cd8 <HAL_DeInit+0x54>)
20001c8a:	f04f 32ff 	mov.w	r2, #4294967295
20001c8e:	621a      	str	r2, [r3, #32]
  __HAL_RCC_APB1_RELEASE_RESET();
20001c90:	4b11      	ldr	r3, [pc, #68]	; (20001cd8 <HAL_DeInit+0x54>)
20001c92:	2200      	movs	r2, #0
20001c94:	621a      	str	r2, [r3, #32]

  __HAL_RCC_APB2_FORCE_RESET();
20001c96:	4b10      	ldr	r3, [pc, #64]	; (20001cd8 <HAL_DeInit+0x54>)
20001c98:	f04f 32ff 	mov.w	r2, #4294967295
20001c9c:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_RCC_APB2_RELEASE_RESET();
20001c9e:	4b0e      	ldr	r3, [pc, #56]	; (20001cd8 <HAL_DeInit+0x54>)
20001ca0:	2200      	movs	r2, #0
20001ca2:	625a      	str	r2, [r3, #36]	; 0x24

  __HAL_RCC_AHB1_FORCE_RESET();
20001ca4:	4b0c      	ldr	r3, [pc, #48]	; (20001cd8 <HAL_DeInit+0x54>)
20001ca6:	f04f 32ff 	mov.w	r2, #4294967295
20001caa:	611a      	str	r2, [r3, #16]
  __HAL_RCC_AHB1_RELEASE_RESET();
20001cac:	4b0a      	ldr	r3, [pc, #40]	; (20001cd8 <HAL_DeInit+0x54>)
20001cae:	2200      	movs	r2, #0
20001cb0:	611a      	str	r2, [r3, #16]

  __HAL_RCC_AHB2_FORCE_RESET();
20001cb2:	4b09      	ldr	r3, [pc, #36]	; (20001cd8 <HAL_DeInit+0x54>)
20001cb4:	f04f 32ff 	mov.w	r2, #4294967295
20001cb8:	615a      	str	r2, [r3, #20]
  __HAL_RCC_AHB2_RELEASE_RESET();
20001cba:	4b07      	ldr	r3, [pc, #28]	; (20001cd8 <HAL_DeInit+0x54>)
20001cbc:	2200      	movs	r2, #0
20001cbe:	615a      	str	r2, [r3, #20]

  __HAL_RCC_AHB3_FORCE_RESET();
20001cc0:	4b05      	ldr	r3, [pc, #20]	; (20001cd8 <HAL_DeInit+0x54>)
20001cc2:	f04f 32ff 	mov.w	r2, #4294967295
20001cc6:	619a      	str	r2, [r3, #24]
  __HAL_RCC_AHB3_RELEASE_RESET();
20001cc8:	4b03      	ldr	r3, [pc, #12]	; (20001cd8 <HAL_DeInit+0x54>)
20001cca:	2200      	movs	r2, #0
20001ccc:	619a      	str	r2, [r3, #24]

  /* De-Init the low level hardware */
  HAL_MspDeInit();
20001cce:	f000 f80c 	bl	20001cea <HAL_MspDeInit>
    
  /* Return function status */
  return HAL_OK;
20001cd2:	2300      	movs	r3, #0
}
20001cd4:	4618      	mov	r0, r3
20001cd6:	bd80      	pop	{r7, pc}
20001cd8:	40023800 	.word	0x40023800
/**
  * @brief  Initialize the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
20001cdc:	b480      	push	{r7}
20001cde:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
20001ce0:	bf00      	nop
20001ce2:	46bd      	mov	sp, r7
20001ce4:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ce8:	4770      	bx	lr

20001cea <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
20001cea:	b480      	push	{r7}
20001cec:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */ 
}
20001cee:	bf00      	nop
20001cf0:	46bd      	mov	sp, r7
20001cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
20001cf6:	4770      	bx	lr

20001cf8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
20001cf8:	b580      	push	{r7, lr}
20001cfa:	b082      	sub	sp, #8
20001cfc:	af00      	add	r7, sp, #0
20001cfe:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
20001d00:	4b12      	ldr	r3, [pc, #72]	; (20001d4c <HAL_InitTick+0x54>)
20001d02:	681a      	ldr	r2, [r3, #0]
20001d04:	4b12      	ldr	r3, [pc, #72]	; (20001d50 <HAL_InitTick+0x58>)
20001d06:	781b      	ldrb	r3, [r3, #0]
20001d08:	4619      	mov	r1, r3
20001d0a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
20001d0e:	fbb3 f3f1 	udiv	r3, r3, r1
20001d12:	fbb2 f3f3 	udiv	r3, r2, r3
20001d16:	4618      	mov	r0, r3
20001d18:	f000 fbeb 	bl	200024f2 <HAL_SYSTICK_Config>
20001d1c:	4603      	mov	r3, r0
20001d1e:	2b00      	cmp	r3, #0
20001d20:	d001      	beq.n	20001d26 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
20001d22:	2301      	movs	r3, #1
20001d24:	e00e      	b.n	20001d44 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
20001d26:	687b      	ldr	r3, [r7, #4]
20001d28:	2b0f      	cmp	r3, #15
20001d2a:	d80a      	bhi.n	20001d42 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
20001d2c:	2200      	movs	r2, #0
20001d2e:	6879      	ldr	r1, [r7, #4]
20001d30:	f04f 30ff 	mov.w	r0, #4294967295
20001d34:	f000 fba1 	bl	2000247a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
20001d38:	4a06      	ldr	r2, [pc, #24]	; (20001d54 <HAL_InitTick+0x5c>)
20001d3a:	687b      	ldr	r3, [r7, #4]
20001d3c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
20001d3e:	2300      	movs	r3, #0
20001d40:	e000      	b.n	20001d44 <HAL_InitTick+0x4c>
    return HAL_ERROR;
20001d42:	2301      	movs	r3, #1
}
20001d44:	4618      	mov	r0, r3
20001d46:	3708      	adds	r7, #8
20001d48:	46bd      	mov	sp, r7
20001d4a:	bd80      	pop	{r7, pc}
20001d4c:	20000410 	.word	0x20000410
20001d50:	20000418 	.word	0x20000418
20001d54:	20000414 	.word	0x20000414

20001d58 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
20001d58:	b480      	push	{r7}
20001d5a:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
20001d5c:	4b06      	ldr	r3, [pc, #24]	; (20001d78 <HAL_IncTick+0x20>)
20001d5e:	781b      	ldrb	r3, [r3, #0]
20001d60:	461a      	mov	r2, r3
20001d62:	4b06      	ldr	r3, [pc, #24]	; (20001d7c <HAL_IncTick+0x24>)
20001d64:	681b      	ldr	r3, [r3, #0]
20001d66:	4413      	add	r3, r2
20001d68:	4a04      	ldr	r2, [pc, #16]	; (20001d7c <HAL_IncTick+0x24>)
20001d6a:	6013      	str	r3, [r2, #0]
}
20001d6c:	bf00      	nop
20001d6e:	46bd      	mov	sp, r7
20001d70:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d74:	4770      	bx	lr
20001d76:	bf00      	nop
20001d78:	20000418 	.word	0x20000418
20001d7c:	200004f0 	.word	0x200004f0

20001d80 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
20001d80:	b480      	push	{r7}
20001d82:	af00      	add	r7, sp, #0
  return uwTick;
20001d84:	4b03      	ldr	r3, [pc, #12]	; (20001d94 <HAL_GetTick+0x14>)
20001d86:	681b      	ldr	r3, [r3, #0]
}
20001d88:	4618      	mov	r0, r3
20001d8a:	46bd      	mov	sp, r7
20001d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d90:	4770      	bx	lr
20001d92:	bf00      	nop
20001d94:	200004f0 	.word	0x200004f0

20001d98 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
20001d98:	b480      	push	{r7}
20001d9a:	af00      	add	r7, sp, #0
  return uwTickPrio;
20001d9c:	4b03      	ldr	r3, [pc, #12]	; (20001dac <HAL_GetTickPrio+0x14>)
20001d9e:	681b      	ldr	r3, [r3, #0]
}
20001da0:	4618      	mov	r0, r3
20001da2:	46bd      	mov	sp, r7
20001da4:	f85d 7b04 	ldr.w	r7, [sp], #4
20001da8:	4770      	bx	lr
20001daa:	bf00      	nop
20001dac:	20000414 	.word	0x20000414

20001db0 <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval Status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
20001db0:	b580      	push	{r7, lr}
20001db2:	b084      	sub	sp, #16
20001db4:	af00      	add	r7, sp, #0
20001db6:	4603      	mov	r3, r0
20001db8:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status  = HAL_OK;
20001dba:	2300      	movs	r3, #0
20001dbc:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
20001dbe:	4b0a      	ldr	r3, [pc, #40]	; (20001de8 <HAL_SetTickFreq+0x38>)
20001dc0:	781b      	ldrb	r3, [r3, #0]
20001dc2:	79fa      	ldrb	r2, [r7, #7]
20001dc4:	429a      	cmp	r2, r3
20001dc6:	d009      	beq.n	20001ddc <HAL_SetTickFreq+0x2c>
  {
    uwTickFreq = Freq;
20001dc8:	4a07      	ldr	r2, [pc, #28]	; (20001de8 <HAL_SetTickFreq+0x38>)
20001dca:	79fb      	ldrb	r3, [r7, #7]
20001dcc:	7013      	strb	r3, [r2, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
20001dce:	4b07      	ldr	r3, [pc, #28]	; (20001dec <HAL_SetTickFreq+0x3c>)
20001dd0:	681b      	ldr	r3, [r3, #0]
20001dd2:	4618      	mov	r0, r3
20001dd4:	f7ff ff90 	bl	20001cf8 <HAL_InitTick>
20001dd8:	4603      	mov	r3, r0
20001dda:	73fb      	strb	r3, [r7, #15]
  }

  return status;
20001ddc:	7bfb      	ldrb	r3, [r7, #15]
}
20001dde:	4618      	mov	r0, r3
20001de0:	3710      	adds	r7, #16
20001de2:	46bd      	mov	sp, r7
20001de4:	bd80      	pop	{r7, pc}
20001de6:	bf00      	nop
20001de8:	20000418 	.word	0x20000418
20001dec:	20000414 	.word	0x20000414

20001df0 <HAL_GetTickFreq>:
/**
  * @brief Return tick frequency.
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
20001df0:	b480      	push	{r7}
20001df2:	af00      	add	r7, sp, #0
  return uwTickFreq;
20001df4:	4b03      	ldr	r3, [pc, #12]	; (20001e04 <HAL_GetTickFreq+0x14>)
20001df6:	781b      	ldrb	r3, [r3, #0]
}
20001df8:	4618      	mov	r0, r3
20001dfa:	46bd      	mov	sp, r7
20001dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e00:	4770      	bx	lr
20001e02:	bf00      	nop
20001e04:	20000418 	.word	0x20000418

20001e08 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
20001e08:	b580      	push	{r7, lr}
20001e0a:	b084      	sub	sp, #16
20001e0c:	af00      	add	r7, sp, #0
20001e0e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
20001e10:	f7ff ffb6 	bl	20001d80 <HAL_GetTick>
20001e14:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
20001e16:	687b      	ldr	r3, [r7, #4]
20001e18:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
20001e1a:	68fb      	ldr	r3, [r7, #12]
20001e1c:	f1b3 3fff 	cmp.w	r3, #4294967295
20001e20:	d005      	beq.n	20001e2e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
20001e22:	4b09      	ldr	r3, [pc, #36]	; (20001e48 <HAL_Delay+0x40>)
20001e24:	781b      	ldrb	r3, [r3, #0]
20001e26:	461a      	mov	r2, r3
20001e28:	68fb      	ldr	r3, [r7, #12]
20001e2a:	4413      	add	r3, r2
20001e2c:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
20001e2e:	bf00      	nop
20001e30:	f7ff ffa6 	bl	20001d80 <HAL_GetTick>
20001e34:	4602      	mov	r2, r0
20001e36:	68bb      	ldr	r3, [r7, #8]
20001e38:	1ad3      	subs	r3, r2, r3
20001e3a:	68fa      	ldr	r2, [r7, #12]
20001e3c:	429a      	cmp	r2, r3
20001e3e:	d8f7      	bhi.n	20001e30 <HAL_Delay+0x28>
  {
  }
}
20001e40:	bf00      	nop
20001e42:	3710      	adds	r7, #16
20001e44:	46bd      	mov	sp, r7
20001e46:	bd80      	pop	{r7, pc}
20001e48:	20000418 	.word	0x20000418

20001e4c <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
20001e4c:	b480      	push	{r7}
20001e4e:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
20001e50:	4b05      	ldr	r3, [pc, #20]	; (20001e68 <HAL_SuspendTick+0x1c>)
20001e52:	681b      	ldr	r3, [r3, #0]
20001e54:	4a04      	ldr	r2, [pc, #16]	; (20001e68 <HAL_SuspendTick+0x1c>)
20001e56:	f023 0302 	bic.w	r3, r3, #2
20001e5a:	6013      	str	r3, [r2, #0]
}
20001e5c:	bf00      	nop
20001e5e:	46bd      	mov	sp, r7
20001e60:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e64:	4770      	bx	lr
20001e66:	bf00      	nop
20001e68:	e000e010 	.word	0xe000e010

20001e6c <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
20001e6c:	b480      	push	{r7}
20001e6e:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
20001e70:	4b05      	ldr	r3, [pc, #20]	; (20001e88 <HAL_ResumeTick+0x1c>)
20001e72:	681b      	ldr	r3, [r3, #0]
20001e74:	4a04      	ldr	r2, [pc, #16]	; (20001e88 <HAL_ResumeTick+0x1c>)
20001e76:	f043 0302 	orr.w	r3, r3, #2
20001e7a:	6013      	str	r3, [r2, #0]
}
20001e7c:	bf00      	nop
20001e7e:	46bd      	mov	sp, r7
20001e80:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e84:	4770      	bx	lr
20001e86:	bf00      	nop
20001e88:	e000e010 	.word	0xe000e010

20001e8c <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
20001e8c:	b480      	push	{r7}
20001e8e:	af00      	add	r7, sp, #0
 return __STM32F7xx_HAL_VERSION;
20001e90:	4b02      	ldr	r3, [pc, #8]	; (20001e9c <HAL_GetHalVersion+0x10>)
}
20001e92:	4618      	mov	r0, r3
20001e94:	46bd      	mov	sp, r7
20001e96:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e9a:	4770      	bx	lr
20001e9c:	01020700 	.word	0x01020700

20001ea0 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
20001ea0:	b480      	push	{r7}
20001ea2:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16U);
20001ea4:	4b03      	ldr	r3, [pc, #12]	; (20001eb4 <HAL_GetREVID+0x14>)
20001ea6:	681b      	ldr	r3, [r3, #0]
20001ea8:	0c1b      	lsrs	r3, r3, #16
}
20001eaa:	4618      	mov	r0, r3
20001eac:	46bd      	mov	sp, r7
20001eae:	f85d 7b04 	ldr.w	r7, [sp], #4
20001eb2:	4770      	bx	lr
20001eb4:	e0042000 	.word	0xe0042000

20001eb8 <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
20001eb8:	b480      	push	{r7}
20001eba:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
20001ebc:	4b04      	ldr	r3, [pc, #16]	; (20001ed0 <HAL_GetDEVID+0x18>)
20001ebe:	681b      	ldr	r3, [r3, #0]
20001ec0:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
20001ec4:	4618      	mov	r0, r3
20001ec6:	46bd      	mov	sp, r7
20001ec8:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ecc:	4770      	bx	lr
20001ece:	bf00      	nop
20001ed0:	e0042000 	.word	0xe0042000

20001ed4 <HAL_GetUIDw0>:
/**
  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
20001ed4:	b480      	push	{r7}
20001ed6:	af00      	add	r7, sp, #0
   return(READ_REG(*((uint32_t *)UID_BASE)));
20001ed8:	4b03      	ldr	r3, [pc, #12]	; (20001ee8 <HAL_GetUIDw0+0x14>)
20001eda:	681b      	ldr	r3, [r3, #0]
}
20001edc:	4618      	mov	r0, r3
20001ede:	46bd      	mov	sp, r7
20001ee0:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ee4:	4770      	bx	lr
20001ee6:	bf00      	nop
20001ee8:	1ff0f420 	.word	0x1ff0f420

20001eec <HAL_GetUIDw1>:
/**
  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
20001eec:	b480      	push	{r7}
20001eee:	af00      	add	r7, sp, #0
   return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
20001ef0:	4b03      	ldr	r3, [pc, #12]	; (20001f00 <HAL_GetUIDw1+0x14>)
20001ef2:	681b      	ldr	r3, [r3, #0]
}
20001ef4:	4618      	mov	r0, r3
20001ef6:	46bd      	mov	sp, r7
20001ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
20001efc:	4770      	bx	lr
20001efe:	bf00      	nop
20001f00:	1ff0f424 	.word	0x1ff0f424

20001f04 <HAL_GetUIDw2>:
/**
  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
20001f04:	b480      	push	{r7}
20001f06:	af00      	add	r7, sp, #0
   return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
20001f08:	4b03      	ldr	r3, [pc, #12]	; (20001f18 <HAL_GetUIDw2+0x14>)
20001f0a:	681b      	ldr	r3, [r3, #0]
}
20001f0c:	4618      	mov	r0, r3
20001f0e:	46bd      	mov	sp, r7
20001f10:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f14:	4770      	bx	lr
20001f16:	bf00      	nop
20001f18:	1ff0f428 	.word	0x1ff0f428

20001f1c <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
20001f1c:	b480      	push	{r7}
20001f1e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
20001f20:	4b05      	ldr	r3, [pc, #20]	; (20001f38 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
20001f22:	685b      	ldr	r3, [r3, #4]
20001f24:	4a04      	ldr	r2, [pc, #16]	; (20001f38 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
20001f26:	f043 0301 	orr.w	r3, r3, #1
20001f2a:	6053      	str	r3, [r2, #4]
}
20001f2c:	bf00      	nop
20001f2e:	46bd      	mov	sp, r7
20001f30:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f34:	4770      	bx	lr
20001f36:	bf00      	nop
20001f38:	e0042000 	.word	0xe0042000

20001f3c <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
20001f3c:	b480      	push	{r7}
20001f3e:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
20001f40:	4b05      	ldr	r3, [pc, #20]	; (20001f58 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
20001f42:	685b      	ldr	r3, [r3, #4]
20001f44:	4a04      	ldr	r2, [pc, #16]	; (20001f58 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
20001f46:	f023 0301 	bic.w	r3, r3, #1
20001f4a:	6053      	str	r3, [r2, #4]
}
20001f4c:	bf00      	nop
20001f4e:	46bd      	mov	sp, r7
20001f50:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f54:	4770      	bx	lr
20001f56:	bf00      	nop
20001f58:	e0042000 	.word	0xe0042000

20001f5c <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during STOP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
20001f5c:	b480      	push	{r7}
20001f5e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
20001f60:	4b05      	ldr	r3, [pc, #20]	; (20001f78 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
20001f62:	685b      	ldr	r3, [r3, #4]
20001f64:	4a04      	ldr	r2, [pc, #16]	; (20001f78 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
20001f66:	f043 0302 	orr.w	r3, r3, #2
20001f6a:	6053      	str	r3, [r2, #4]
}
20001f6c:	bf00      	nop
20001f6e:	46bd      	mov	sp, r7
20001f70:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f74:	4770      	bx	lr
20001f76:	bf00      	nop
20001f78:	e0042000 	.word	0xe0042000

20001f7c <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during STOP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
20001f7c:	b480      	push	{r7}
20001f7e:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
20001f80:	4b05      	ldr	r3, [pc, #20]	; (20001f98 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
20001f82:	685b      	ldr	r3, [r3, #4]
20001f84:	4a04      	ldr	r2, [pc, #16]	; (20001f98 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
20001f86:	f023 0302 	bic.w	r3, r3, #2
20001f8a:	6053      	str	r3, [r2, #4]
}
20001f8c:	bf00      	nop
20001f8e:	46bd      	mov	sp, r7
20001f90:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f94:	4770      	bx	lr
20001f96:	bf00      	nop
20001f98:	e0042000 	.word	0xe0042000

20001f9c <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
20001f9c:	b480      	push	{r7}
20001f9e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
20001fa0:	4b05      	ldr	r3, [pc, #20]	; (20001fb8 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
20001fa2:	685b      	ldr	r3, [r3, #4]
20001fa4:	4a04      	ldr	r2, [pc, #16]	; (20001fb8 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
20001fa6:	f043 0304 	orr.w	r3, r3, #4
20001faa:	6053      	str	r3, [r2, #4]
}
20001fac:	bf00      	nop
20001fae:	46bd      	mov	sp, r7
20001fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
20001fb4:	4770      	bx	lr
20001fb6:	bf00      	nop
20001fb8:	e0042000 	.word	0xe0042000

20001fbc <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
20001fbc:	b480      	push	{r7}
20001fbe:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
20001fc0:	4b05      	ldr	r3, [pc, #20]	; (20001fd8 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
20001fc2:	685b      	ldr	r3, [r3, #4]
20001fc4:	4a04      	ldr	r2, [pc, #16]	; (20001fd8 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
20001fc6:	f023 0304 	bic.w	r3, r3, #4
20001fca:	6053      	str	r3, [r2, #4]
}
20001fcc:	bf00      	nop
20001fce:	46bd      	mov	sp, r7
20001fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
20001fd4:	4770      	bx	lr
20001fd6:	bf00      	nop
20001fd8:	e0042000 	.word	0xe0042000

20001fdc <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.  
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
20001fdc:	b480      	push	{r7}
20001fde:	af00      	add	r7, sp, #0
  SYSCFG->CMPCR |= SYSCFG_CMPCR_CMP_PD;
20001fe0:	4b05      	ldr	r3, [pc, #20]	; (20001ff8 <HAL_EnableCompensationCell+0x1c>)
20001fe2:	6a1b      	ldr	r3, [r3, #32]
20001fe4:	4a04      	ldr	r2, [pc, #16]	; (20001ff8 <HAL_EnableCompensationCell+0x1c>)
20001fe6:	f043 0301 	orr.w	r3, r3, #1
20001fea:	6213      	str	r3, [r2, #32]
}
20001fec:	bf00      	nop
20001fee:	46bd      	mov	sp, r7
20001ff0:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ff4:	4770      	bx	lr
20001ff6:	bf00      	nop
20001ff8:	40013800 	.word	0x40013800

20001ffc <HAL_DisableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.  
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
20001ffc:	b480      	push	{r7}
20001ffe:	af00      	add	r7, sp, #0
  SYSCFG->CMPCR &= (uint32_t)~((uint32_t)SYSCFG_CMPCR_CMP_PD);
20002000:	4b05      	ldr	r3, [pc, #20]	; (20002018 <HAL_DisableCompensationCell+0x1c>)
20002002:	6a1b      	ldr	r3, [r3, #32]
20002004:	4a04      	ldr	r2, [pc, #16]	; (20002018 <HAL_DisableCompensationCell+0x1c>)
20002006:	f023 0301 	bic.w	r3, r3, #1
2000200a:	6213      	str	r3, [r2, #32]
}
2000200c:	bf00      	nop
2000200e:	46bd      	mov	sp, r7
20002010:	f85d 7b04 	ldr.w	r7, [sp], #4
20002014:	4770      	bx	lr
20002016:	bf00      	nop
20002018:	40013800 	.word	0x40013800

2000201c <HAL_EnableFMCMemorySwapping>:
  *         and NOR/RAM is accessible at 0xC0000000   
  *
  * @retval None
  */
void HAL_EnableFMCMemorySwapping(void)
{
2000201c:	b480      	push	{r7}
2000201e:	af00      	add	r7, sp, #0
  SYSCFG->MEMRMP |= SYSCFG_MEMRMP_SWP_FMC_0;
20002020:	4b05      	ldr	r3, [pc, #20]	; (20002038 <HAL_EnableFMCMemorySwapping+0x1c>)
20002022:	681b      	ldr	r3, [r3, #0]
20002024:	4a04      	ldr	r2, [pc, #16]	; (20002038 <HAL_EnableFMCMemorySwapping+0x1c>)
20002026:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
2000202a:	6013      	str	r3, [r2, #0]
}
2000202c:	bf00      	nop
2000202e:	46bd      	mov	sp, r7
20002030:	f85d 7b04 	ldr.w	r7, [sp], #4
20002034:	4770      	bx	lr
20002036:	bf00      	nop
20002038:	40013800 	.word	0x40013800

2000203c <HAL_DisableFMCMemorySwapping>:
  *         and NOR/RAM is accessible at 0x60000000 (default mapping)    
  *           
  * @retval None
  */
void HAL_DisableFMCMemorySwapping(void)
{
2000203c:	b480      	push	{r7}
2000203e:	af00      	add	r7, sp, #0

  SYSCFG->MEMRMP &= (uint32_t)~((uint32_t)SYSCFG_MEMRMP_SWP_FMC);
20002040:	4b05      	ldr	r3, [pc, #20]	; (20002058 <HAL_DisableFMCMemorySwapping+0x1c>)
20002042:	681b      	ldr	r3, [r3, #0]
20002044:	4a04      	ldr	r2, [pc, #16]	; (20002058 <HAL_DisableFMCMemorySwapping+0x1c>)
20002046:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
2000204a:	6013      	str	r3, [r2, #0]
}
2000204c:	bf00      	nop
2000204e:	46bd      	mov	sp, r7
20002050:	f85d 7b04 	ldr.w	r7, [sp], #4
20002054:	4770      	bx	lr
20002056:	bf00      	nop
20002058:	40013800 	.word	0x40013800

2000205c <HAL_EnableMemorySwappingBank>:
*         and Flash Bank1 mapped at 0x08100000 (AXI) (aliased at 0x00300000 (TCM))   
*
* @retval None
*/
void HAL_EnableMemorySwappingBank(void)
{
2000205c:	b480      	push	{r7}
2000205e:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_SWP_FB);
20002060:	4b05      	ldr	r3, [pc, #20]	; (20002078 <HAL_EnableMemorySwappingBank+0x1c>)
20002062:	681b      	ldr	r3, [r3, #0]
20002064:	4a04      	ldr	r2, [pc, #16]	; (20002078 <HAL_EnableMemorySwappingBank+0x1c>)
20002066:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000206a:	6013      	str	r3, [r2, #0]
}
2000206c:	bf00      	nop
2000206e:	46bd      	mov	sp, r7
20002070:	f85d 7b04 	ldr.w	r7, [sp], #4
20002074:	4770      	bx	lr
20002076:	bf00      	nop
20002078:	40013800 	.word	0x40013800

2000207c <HAL_DisableMemorySwappingBank>:
*         and Flash Bank2 mapped at 0x08100000 (AXI)( aliased at 0x00300000 (TCM)) 
*           
* @retval None
*/
void HAL_DisableMemorySwappingBank(void)
{
2000207c:	b480      	push	{r7}
2000207e:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_SWP_FB);
20002080:	4b05      	ldr	r3, [pc, #20]	; (20002098 <HAL_DisableMemorySwappingBank+0x1c>)
20002082:	681b      	ldr	r3, [r3, #0]
20002084:	4a04      	ldr	r2, [pc, #16]	; (20002098 <HAL_DisableMemorySwappingBank+0x1c>)
20002086:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2000208a:	6013      	str	r3, [r2, #0]
}
2000208c:	bf00      	nop
2000208e:	46bd      	mov	sp, r7
20002090:	f85d 7b04 	ldr.w	r7, [sp], #4
20002094:	4770      	bx	lr
20002096:	bf00      	nop
20002098:	40013800 	.word	0x40013800

2000209c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
2000209c:	b480      	push	{r7}
2000209e:	b085      	sub	sp, #20
200020a0:	af00      	add	r7, sp, #0
200020a2:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
200020a4:	687b      	ldr	r3, [r7, #4]
200020a6:	f003 0307 	and.w	r3, r3, #7
200020aa:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
200020ac:	4b0b      	ldr	r3, [pc, #44]	; (200020dc <__NVIC_SetPriorityGrouping+0x40>)
200020ae:	68db      	ldr	r3, [r3, #12]
200020b0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
200020b2:	68ba      	ldr	r2, [r7, #8]
200020b4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
200020b8:	4013      	ands	r3, r2
200020ba:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
200020bc:	68fb      	ldr	r3, [r7, #12]
200020be:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
200020c0:	68bb      	ldr	r3, [r7, #8]
200020c2:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
200020c4:	4b06      	ldr	r3, [pc, #24]	; (200020e0 <__NVIC_SetPriorityGrouping+0x44>)
200020c6:	4313      	orrs	r3, r2
200020c8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
200020ca:	4a04      	ldr	r2, [pc, #16]	; (200020dc <__NVIC_SetPriorityGrouping+0x40>)
200020cc:	68bb      	ldr	r3, [r7, #8]
200020ce:	60d3      	str	r3, [r2, #12]
}
200020d0:	bf00      	nop
200020d2:	3714      	adds	r7, #20
200020d4:	46bd      	mov	sp, r7
200020d6:	f85d 7b04 	ldr.w	r7, [sp], #4
200020da:	4770      	bx	lr
200020dc:	e000ed00 	.word	0xe000ed00
200020e0:	05fa0000 	.word	0x05fa0000

200020e4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
200020e4:	b480      	push	{r7}
200020e6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
200020e8:	4b04      	ldr	r3, [pc, #16]	; (200020fc <__NVIC_GetPriorityGrouping+0x18>)
200020ea:	68db      	ldr	r3, [r3, #12]
200020ec:	0a1b      	lsrs	r3, r3, #8
200020ee:	f003 0307 	and.w	r3, r3, #7
}
200020f2:	4618      	mov	r0, r3
200020f4:	46bd      	mov	sp, r7
200020f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200020fa:	4770      	bx	lr
200020fc:	e000ed00 	.word	0xe000ed00

20002100 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
20002100:	b480      	push	{r7}
20002102:	b083      	sub	sp, #12
20002104:	af00      	add	r7, sp, #0
20002106:	4603      	mov	r3, r0
20002108:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
2000210a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000210e:	2b00      	cmp	r3, #0
20002110:	db0b      	blt.n	2000212a <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20002112:	79fb      	ldrb	r3, [r7, #7]
20002114:	f003 021f 	and.w	r2, r3, #31
20002118:	4907      	ldr	r1, [pc, #28]	; (20002138 <__NVIC_EnableIRQ+0x38>)
2000211a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000211e:	095b      	lsrs	r3, r3, #5
20002120:	2001      	movs	r0, #1
20002122:	fa00 f202 	lsl.w	r2, r0, r2
20002126:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
2000212a:	bf00      	nop
2000212c:	370c      	adds	r7, #12
2000212e:	46bd      	mov	sp, r7
20002130:	f85d 7b04 	ldr.w	r7, [sp], #4
20002134:	4770      	bx	lr
20002136:	bf00      	nop
20002138:	e000e100 	.word	0xe000e100

2000213c <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
2000213c:	b480      	push	{r7}
2000213e:	b083      	sub	sp, #12
20002140:	af00      	add	r7, sp, #0
20002142:	4603      	mov	r3, r0
20002144:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20002146:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000214a:	2b00      	cmp	r3, #0
2000214c:	db10      	blt.n	20002170 <__NVIC_DisableIRQ+0x34>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
2000214e:	79fb      	ldrb	r3, [r7, #7]
20002150:	f003 021f 	and.w	r2, r3, #31
20002154:	4909      	ldr	r1, [pc, #36]	; (2000217c <__NVIC_DisableIRQ+0x40>)
20002156:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000215a:	095b      	lsrs	r3, r3, #5
2000215c:	2001      	movs	r0, #1
2000215e:	fa00 f202 	lsl.w	r2, r0, r2
20002162:	3320      	adds	r3, #32
20002164:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
20002168:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2000216c:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
20002170:	bf00      	nop
20002172:	370c      	adds	r7, #12
20002174:	46bd      	mov	sp, r7
20002176:	f85d 7b04 	ldr.w	r7, [sp], #4
2000217a:	4770      	bx	lr
2000217c:	e000e100 	.word	0xe000e100

20002180 <__NVIC_GetPendingIRQ>:
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
20002180:	b480      	push	{r7}
20002182:	b083      	sub	sp, #12
20002184:	af00      	add	r7, sp, #0
20002186:	4603      	mov	r3, r0
20002188:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
2000218a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000218e:	2b00      	cmp	r3, #0
20002190:	db0e      	blt.n	200021b0 <__NVIC_GetPendingIRQ+0x30>
  {
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
20002192:	4a0b      	ldr	r2, [pc, #44]	; (200021c0 <__NVIC_GetPendingIRQ+0x40>)
20002194:	f997 3007 	ldrsb.w	r3, [r7, #7]
20002198:	095b      	lsrs	r3, r3, #5
2000219a:	3340      	adds	r3, #64	; 0x40
2000219c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
200021a0:	79fb      	ldrb	r3, [r7, #7]
200021a2:	f003 031f 	and.w	r3, r3, #31
200021a6:	fa22 f303 	lsr.w	r3, r2, r3
200021aa:	f003 0301 	and.w	r3, r3, #1
200021ae:	e000      	b.n	200021b2 <__NVIC_GetPendingIRQ+0x32>
  }
  else
  {
    return(0U);
200021b0:	2300      	movs	r3, #0
  }
}
200021b2:	4618      	mov	r0, r3
200021b4:	370c      	adds	r7, #12
200021b6:	46bd      	mov	sp, r7
200021b8:	f85d 7b04 	ldr.w	r7, [sp], #4
200021bc:	4770      	bx	lr
200021be:	bf00      	nop
200021c0:	e000e100 	.word	0xe000e100

200021c4 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
200021c4:	b480      	push	{r7}
200021c6:	b083      	sub	sp, #12
200021c8:	af00      	add	r7, sp, #0
200021ca:	4603      	mov	r3, r0
200021cc:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
200021ce:	f997 3007 	ldrsb.w	r3, [r7, #7]
200021d2:	2b00      	cmp	r3, #0
200021d4:	db0c      	blt.n	200021f0 <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
200021d6:	79fb      	ldrb	r3, [r7, #7]
200021d8:	f003 021f 	and.w	r2, r3, #31
200021dc:	4907      	ldr	r1, [pc, #28]	; (200021fc <__NVIC_SetPendingIRQ+0x38>)
200021de:	f997 3007 	ldrsb.w	r3, [r7, #7]
200021e2:	095b      	lsrs	r3, r3, #5
200021e4:	2001      	movs	r0, #1
200021e6:	fa00 f202 	lsl.w	r2, r0, r2
200021ea:	3340      	adds	r3, #64	; 0x40
200021ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
200021f0:	bf00      	nop
200021f2:	370c      	adds	r7, #12
200021f4:	46bd      	mov	sp, r7
200021f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200021fa:	4770      	bx	lr
200021fc:	e000e100 	.word	0xe000e100

20002200 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20002200:	b480      	push	{r7}
20002202:	b083      	sub	sp, #12
20002204:	af00      	add	r7, sp, #0
20002206:	4603      	mov	r3, r0
20002208:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
2000220a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000220e:	2b00      	cmp	r3, #0
20002210:	db0c      	blt.n	2000222c <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20002212:	79fb      	ldrb	r3, [r7, #7]
20002214:	f003 021f 	and.w	r2, r3, #31
20002218:	4907      	ldr	r1, [pc, #28]	; (20002238 <__NVIC_ClearPendingIRQ+0x38>)
2000221a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000221e:	095b      	lsrs	r3, r3, #5
20002220:	2001      	movs	r0, #1
20002222:	fa00 f202 	lsl.w	r2, r0, r2
20002226:	3360      	adds	r3, #96	; 0x60
20002228:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
2000222c:	bf00      	nop
2000222e:	370c      	adds	r7, #12
20002230:	46bd      	mov	sp, r7
20002232:	f85d 7b04 	ldr.w	r7, [sp], #4
20002236:	4770      	bx	lr
20002238:	e000e100 	.word	0xe000e100

2000223c <__NVIC_GetActive>:
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
2000223c:	b480      	push	{r7}
2000223e:	b083      	sub	sp, #12
20002240:	af00      	add	r7, sp, #0
20002242:	4603      	mov	r3, r0
20002244:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20002246:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000224a:	2b00      	cmp	r3, #0
2000224c:	db0e      	blt.n	2000226c <__NVIC_GetActive+0x30>
  {
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
2000224e:	4a0b      	ldr	r2, [pc, #44]	; (2000227c <__NVIC_GetActive+0x40>)
20002250:	f997 3007 	ldrsb.w	r3, [r7, #7]
20002254:	095b      	lsrs	r3, r3, #5
20002256:	3380      	adds	r3, #128	; 0x80
20002258:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
2000225c:	79fb      	ldrb	r3, [r7, #7]
2000225e:	f003 031f 	and.w	r3, r3, #31
20002262:	fa22 f303 	lsr.w	r3, r2, r3
20002266:	f003 0301 	and.w	r3, r3, #1
2000226a:	e000      	b.n	2000226e <__NVIC_GetActive+0x32>
  }
  else
  {
    return(0U);
2000226c:	2300      	movs	r3, #0
  }
}
2000226e:	4618      	mov	r0, r3
20002270:	370c      	adds	r7, #12
20002272:	46bd      	mov	sp, r7
20002274:	f85d 7b04 	ldr.w	r7, [sp], #4
20002278:	4770      	bx	lr
2000227a:	bf00      	nop
2000227c:	e000e100 	.word	0xe000e100

20002280 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
20002280:	b480      	push	{r7}
20002282:	b083      	sub	sp, #12
20002284:	af00      	add	r7, sp, #0
20002286:	4603      	mov	r3, r0
20002288:	6039      	str	r1, [r7, #0]
2000228a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
2000228c:	f997 3007 	ldrsb.w	r3, [r7, #7]
20002290:	2b00      	cmp	r3, #0
20002292:	db0a      	blt.n	200022aa <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
20002294:	683b      	ldr	r3, [r7, #0]
20002296:	b2da      	uxtb	r2, r3
20002298:	490c      	ldr	r1, [pc, #48]	; (200022cc <__NVIC_SetPriority+0x4c>)
2000229a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000229e:	0112      	lsls	r2, r2, #4
200022a0:	b2d2      	uxtb	r2, r2
200022a2:	440b      	add	r3, r1
200022a4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
200022a8:	e00a      	b.n	200022c0 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
200022aa:	683b      	ldr	r3, [r7, #0]
200022ac:	b2da      	uxtb	r2, r3
200022ae:	4908      	ldr	r1, [pc, #32]	; (200022d0 <__NVIC_SetPriority+0x50>)
200022b0:	79fb      	ldrb	r3, [r7, #7]
200022b2:	f003 030f 	and.w	r3, r3, #15
200022b6:	3b04      	subs	r3, #4
200022b8:	0112      	lsls	r2, r2, #4
200022ba:	b2d2      	uxtb	r2, r2
200022bc:	440b      	add	r3, r1
200022be:	761a      	strb	r2, [r3, #24]
}
200022c0:	bf00      	nop
200022c2:	370c      	adds	r7, #12
200022c4:	46bd      	mov	sp, r7
200022c6:	f85d 7b04 	ldr.w	r7, [sp], #4
200022ca:	4770      	bx	lr
200022cc:	e000e100 	.word	0xe000e100
200022d0:	e000ed00 	.word	0xe000ed00

200022d4 <__NVIC_GetPriority>:
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{
200022d4:	b480      	push	{r7}
200022d6:	b083      	sub	sp, #12
200022d8:	af00      	add	r7, sp, #0
200022da:	4603      	mov	r3, r0
200022dc:	71fb      	strb	r3, [r7, #7]

  if ((int32_t)(IRQn) >= 0)
200022de:	f997 3007 	ldrsb.w	r3, [r7, #7]
200022e2:	2b00      	cmp	r3, #0
200022e4:	db09      	blt.n	200022fa <__NVIC_GetPriority+0x26>
  {
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
200022e6:	4a0d      	ldr	r2, [pc, #52]	; (2000231c <__NVIC_GetPriority+0x48>)
200022e8:	f997 3007 	ldrsb.w	r3, [r7, #7]
200022ec:	4413      	add	r3, r2
200022ee:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
200022f2:	b2db      	uxtb	r3, r3
200022f4:	091b      	lsrs	r3, r3, #4
200022f6:	b2db      	uxtb	r3, r3
200022f8:	e009      	b.n	2000230e <__NVIC_GetPriority+0x3a>
  }
  else
  {
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
200022fa:	4a09      	ldr	r2, [pc, #36]	; (20002320 <__NVIC_GetPriority+0x4c>)
200022fc:	79fb      	ldrb	r3, [r7, #7]
200022fe:	f003 030f 	and.w	r3, r3, #15
20002302:	3b04      	subs	r3, #4
20002304:	4413      	add	r3, r2
20002306:	7e1b      	ldrb	r3, [r3, #24]
20002308:	b2db      	uxtb	r3, r3
2000230a:	091b      	lsrs	r3, r3, #4
2000230c:	b2db      	uxtb	r3, r3
  }
}
2000230e:	4618      	mov	r0, r3
20002310:	370c      	adds	r7, #12
20002312:	46bd      	mov	sp, r7
20002314:	f85d 7b04 	ldr.w	r7, [sp], #4
20002318:	4770      	bx	lr
2000231a:	bf00      	nop
2000231c:	e000e100 	.word	0xe000e100
20002320:	e000ed00 	.word	0xe000ed00

20002324 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
20002324:	b480      	push	{r7}
20002326:	b089      	sub	sp, #36	; 0x24
20002328:	af00      	add	r7, sp, #0
2000232a:	60f8      	str	r0, [r7, #12]
2000232c:	60b9      	str	r1, [r7, #8]
2000232e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
20002330:	68fb      	ldr	r3, [r7, #12]
20002332:	f003 0307 	and.w	r3, r3, #7
20002336:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
20002338:	69fb      	ldr	r3, [r7, #28]
2000233a:	f1c3 0307 	rsb	r3, r3, #7
2000233e:	2b04      	cmp	r3, #4
20002340:	bf28      	it	cs
20002342:	2304      	movcs	r3, #4
20002344:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
20002346:	69fb      	ldr	r3, [r7, #28]
20002348:	3304      	adds	r3, #4
2000234a:	2b06      	cmp	r3, #6
2000234c:	d902      	bls.n	20002354 <NVIC_EncodePriority+0x30>
2000234e:	69fb      	ldr	r3, [r7, #28]
20002350:	3b03      	subs	r3, #3
20002352:	e000      	b.n	20002356 <NVIC_EncodePriority+0x32>
20002354:	2300      	movs	r3, #0
20002356:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
20002358:	f04f 32ff 	mov.w	r2, #4294967295
2000235c:	69bb      	ldr	r3, [r7, #24]
2000235e:	fa02 f303 	lsl.w	r3, r2, r3
20002362:	43da      	mvns	r2, r3
20002364:	68bb      	ldr	r3, [r7, #8]
20002366:	401a      	ands	r2, r3
20002368:	697b      	ldr	r3, [r7, #20]
2000236a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
2000236c:	f04f 31ff 	mov.w	r1, #4294967295
20002370:	697b      	ldr	r3, [r7, #20]
20002372:	fa01 f303 	lsl.w	r3, r1, r3
20002376:	43d9      	mvns	r1, r3
20002378:	687b      	ldr	r3, [r7, #4]
2000237a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
2000237c:	4313      	orrs	r3, r2
         );
}
2000237e:	4618      	mov	r0, r3
20002380:	3724      	adds	r7, #36	; 0x24
20002382:	46bd      	mov	sp, r7
20002384:	f85d 7b04 	ldr.w	r7, [sp], #4
20002388:	4770      	bx	lr

2000238a <NVIC_DecodePriority>:
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
2000238a:	b480      	push	{r7}
2000238c:	b089      	sub	sp, #36	; 0x24
2000238e:	af00      	add	r7, sp, #0
20002390:	60f8      	str	r0, [r7, #12]
20002392:	60b9      	str	r1, [r7, #8]
20002394:	607a      	str	r2, [r7, #4]
20002396:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
20002398:	68bb      	ldr	r3, [r7, #8]
2000239a:	f003 0307 	and.w	r3, r3, #7
2000239e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
200023a0:	69fb      	ldr	r3, [r7, #28]
200023a2:	f1c3 0307 	rsb	r3, r3, #7
200023a6:	2b04      	cmp	r3, #4
200023a8:	bf28      	it	cs
200023aa:	2304      	movcs	r3, #4
200023ac:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
200023ae:	69fb      	ldr	r3, [r7, #28]
200023b0:	3304      	adds	r3, #4
200023b2:	2b06      	cmp	r3, #6
200023b4:	d902      	bls.n	200023bc <NVIC_DecodePriority+0x32>
200023b6:	69fb      	ldr	r3, [r7, #28]
200023b8:	3b03      	subs	r3, #3
200023ba:	e000      	b.n	200023be <NVIC_DecodePriority+0x34>
200023bc:	2300      	movs	r3, #0
200023be:	617b      	str	r3, [r7, #20]

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
200023c0:	68fa      	ldr	r2, [r7, #12]
200023c2:	697b      	ldr	r3, [r7, #20]
200023c4:	40da      	lsrs	r2, r3
200023c6:	f04f 31ff 	mov.w	r1, #4294967295
200023ca:	69bb      	ldr	r3, [r7, #24]
200023cc:	fa01 f303 	lsl.w	r3, r1, r3
200023d0:	43db      	mvns	r3, r3
200023d2:	401a      	ands	r2, r3
200023d4:	687b      	ldr	r3, [r7, #4]
200023d6:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
200023d8:	f04f 32ff 	mov.w	r2, #4294967295
200023dc:	697b      	ldr	r3, [r7, #20]
200023de:	fa02 f303 	lsl.w	r3, r2, r3
200023e2:	43da      	mvns	r2, r3
200023e4:	68fb      	ldr	r3, [r7, #12]
200023e6:	401a      	ands	r2, r3
200023e8:	683b      	ldr	r3, [r7, #0]
200023ea:	601a      	str	r2, [r3, #0]
}
200023ec:	bf00      	nop
200023ee:	3724      	adds	r7, #36	; 0x24
200023f0:	46bd      	mov	sp, r7
200023f2:	f85d 7b04 	ldr.w	r7, [sp], #4
200023f6:	4770      	bx	lr

200023f8 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
200023f8:	b480      	push	{r7}
200023fa:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
200023fc:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
20002400:	4b05      	ldr	r3, [pc, #20]	; (20002418 <__NVIC_SystemReset+0x20>)
20002402:	68db      	ldr	r3, [r3, #12]
20002404:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20002408:	4903      	ldr	r1, [pc, #12]	; (20002418 <__NVIC_SystemReset+0x20>)
2000240a:	4b04      	ldr	r3, [pc, #16]	; (2000241c <__NVIC_SystemReset+0x24>)
2000240c:	4313      	orrs	r3, r2
2000240e:	60cb      	str	r3, [r1, #12]
20002410:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
20002414:	bf00      	nop
20002416:	e7fd      	b.n	20002414 <__NVIC_SystemReset+0x1c>
20002418:	e000ed00 	.word	0xe000ed00
2000241c:	05fa0004 	.word	0x05fa0004

20002420 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
20002420:	b580      	push	{r7, lr}
20002422:	b082      	sub	sp, #8
20002424:	af00      	add	r7, sp, #0
20002426:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
20002428:	687b      	ldr	r3, [r7, #4]
2000242a:	3b01      	subs	r3, #1
2000242c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20002430:	d301      	bcc.n	20002436 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
20002432:	2301      	movs	r3, #1
20002434:	e00f      	b.n	20002456 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
20002436:	4a0a      	ldr	r2, [pc, #40]	; (20002460 <SysTick_Config+0x40>)
20002438:	687b      	ldr	r3, [r7, #4]
2000243a:	3b01      	subs	r3, #1
2000243c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
2000243e:	210f      	movs	r1, #15
20002440:	f04f 30ff 	mov.w	r0, #4294967295
20002444:	f7ff ff1c 	bl	20002280 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
20002448:	4b05      	ldr	r3, [pc, #20]	; (20002460 <SysTick_Config+0x40>)
2000244a:	2200      	movs	r2, #0
2000244c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
2000244e:	4b04      	ldr	r3, [pc, #16]	; (20002460 <SysTick_Config+0x40>)
20002450:	2207      	movs	r2, #7
20002452:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
20002454:	2300      	movs	r3, #0
}
20002456:	4618      	mov	r0, r3
20002458:	3708      	adds	r7, #8
2000245a:	46bd      	mov	sp, r7
2000245c:	bd80      	pop	{r7, pc}
2000245e:	bf00      	nop
20002460:	e000e010 	.word	0xe000e010

20002464 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
20002464:	b580      	push	{r7, lr}
20002466:	b082      	sub	sp, #8
20002468:	af00      	add	r7, sp, #0
2000246a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
2000246c:	6878      	ldr	r0, [r7, #4]
2000246e:	f7ff fe15 	bl	2000209c <__NVIC_SetPriorityGrouping>
}
20002472:	bf00      	nop
20002474:	3708      	adds	r7, #8
20002476:	46bd      	mov	sp, r7
20002478:	bd80      	pop	{r7, pc}

2000247a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
2000247a:	b580      	push	{r7, lr}
2000247c:	b086      	sub	sp, #24
2000247e:	af00      	add	r7, sp, #0
20002480:	4603      	mov	r3, r0
20002482:	60b9      	str	r1, [r7, #8]
20002484:	607a      	str	r2, [r7, #4]
20002486:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
20002488:	2300      	movs	r3, #0
2000248a:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
2000248c:	f7ff fe2a 	bl	200020e4 <__NVIC_GetPriorityGrouping>
20002490:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
20002492:	687a      	ldr	r2, [r7, #4]
20002494:	68b9      	ldr	r1, [r7, #8]
20002496:	6978      	ldr	r0, [r7, #20]
20002498:	f7ff ff44 	bl	20002324 <NVIC_EncodePriority>
2000249c:	4602      	mov	r2, r0
2000249e:	f997 300f 	ldrsb.w	r3, [r7, #15]
200024a2:	4611      	mov	r1, r2
200024a4:	4618      	mov	r0, r3
200024a6:	f7ff feeb 	bl	20002280 <__NVIC_SetPriority>
}
200024aa:	bf00      	nop
200024ac:	3718      	adds	r7, #24
200024ae:	46bd      	mov	sp, r7
200024b0:	bd80      	pop	{r7, pc}

200024b2 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
200024b2:	b580      	push	{r7, lr}
200024b4:	b082      	sub	sp, #8
200024b6:	af00      	add	r7, sp, #0
200024b8:	4603      	mov	r3, r0
200024ba:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
200024bc:	f997 3007 	ldrsb.w	r3, [r7, #7]
200024c0:	4618      	mov	r0, r3
200024c2:	f7ff fe1d 	bl	20002100 <__NVIC_EnableIRQ>
}
200024c6:	bf00      	nop
200024c8:	3708      	adds	r7, #8
200024ca:	46bd      	mov	sp, r7
200024cc:	bd80      	pop	{r7, pc}

200024ce <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
200024ce:	b580      	push	{r7, lr}
200024d0:	b082      	sub	sp, #8
200024d2:	af00      	add	r7, sp, #0
200024d4:	4603      	mov	r3, r0
200024d6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
200024d8:	f997 3007 	ldrsb.w	r3, [r7, #7]
200024dc:	4618      	mov	r0, r3
200024de:	f7ff fe2d 	bl	2000213c <__NVIC_DisableIRQ>
}
200024e2:	bf00      	nop
200024e4:	3708      	adds	r7, #8
200024e6:	46bd      	mov	sp, r7
200024e8:	bd80      	pop	{r7, pc}

200024ea <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
200024ea:	b580      	push	{r7, lr}
200024ec:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
200024ee:	f7ff ff83 	bl	200023f8 <__NVIC_SystemReset>

200024f2 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
200024f2:	b580      	push	{r7, lr}
200024f4:	b082      	sub	sp, #8
200024f6:	af00      	add	r7, sp, #0
200024f8:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
200024fa:	6878      	ldr	r0, [r7, #4]
200024fc:	f7ff ff90 	bl	20002420 <SysTick_Config>
20002500:	4603      	mov	r3, r0
}
20002502:	4618      	mov	r0, r3
20002504:	3708      	adds	r7, #8
20002506:	46bd      	mov	sp, r7
20002508:	bd80      	pop	{r7, pc}
	...

2000250c <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
2000250c:	b480      	push	{r7}
2000250e:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
20002510:	f3bf 8f5f 	dmb	sy
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
20002514:	4b06      	ldr	r3, [pc, #24]	; (20002530 <HAL_MPU_Disable+0x24>)
20002516:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20002518:	4a05      	ldr	r2, [pc, #20]	; (20002530 <HAL_MPU_Disable+0x24>)
2000251a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000251e:	6253      	str	r3, [r2, #36]	; 0x24
  
  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
20002520:	4b04      	ldr	r3, [pc, #16]	; (20002534 <HAL_MPU_Disable+0x28>)
20002522:	2200      	movs	r2, #0
20002524:	605a      	str	r2, [r3, #4]
}
20002526:	bf00      	nop
20002528:	46bd      	mov	sp, r7
2000252a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000252e:	4770      	bx	lr
20002530:	e000ed00 	.word	0xe000ed00
20002534:	e000ed90 	.word	0xe000ed90

20002538 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
20002538:	b480      	push	{r7}
2000253a:	b083      	sub	sp, #12
2000253c:	af00      	add	r7, sp, #0
2000253e:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
20002540:	4a0a      	ldr	r2, [pc, #40]	; (2000256c <HAL_MPU_Enable+0x34>)
20002542:	687b      	ldr	r3, [r7, #4]
20002544:	f043 0301 	orr.w	r3, r3, #1
20002548:	6053      	str	r3, [r2, #4]
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
2000254a:	4b09      	ldr	r3, [pc, #36]	; (20002570 <HAL_MPU_Enable+0x38>)
2000254c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000254e:	4a08      	ldr	r2, [pc, #32]	; (20002570 <HAL_MPU_Enable+0x38>)
20002550:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20002554:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
20002556:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2000255a:	f3bf 8f6f 	isb	sy
  
  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
2000255e:	bf00      	nop
20002560:	370c      	adds	r7, #12
20002562:	46bd      	mov	sp, r7
20002564:	f85d 7b04 	ldr.w	r7, [sp], #4
20002568:	4770      	bx	lr
2000256a:	bf00      	nop
2000256c:	e000ed90 	.word	0xe000ed90
20002570:	e000ed00 	.word	0xe000ed00

20002574 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
20002574:	b480      	push	{r7}
20002576:	b083      	sub	sp, #12
20002578:	af00      	add	r7, sp, #0
2000257a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
2000257c:	687b      	ldr	r3, [r7, #4]
2000257e:	785a      	ldrb	r2, [r3, #1]
20002580:	4b1d      	ldr	r3, [pc, #116]	; (200025f8 <HAL_MPU_ConfigRegion+0x84>)
20002582:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != RESET)
20002584:	687b      	ldr	r3, [r7, #4]
20002586:	781b      	ldrb	r3, [r3, #0]
20002588:	2b00      	cmp	r3, #0
2000258a:	d029      	beq.n	200025e0 <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
2000258c:	4a1a      	ldr	r2, [pc, #104]	; (200025f8 <HAL_MPU_ConfigRegion+0x84>)
2000258e:	687b      	ldr	r3, [r7, #4]
20002590:	685b      	ldr	r3, [r3, #4]
20002592:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
20002594:	687b      	ldr	r3, [r7, #4]
20002596:	7b1b      	ldrb	r3, [r3, #12]
20002598:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
2000259a:	687b      	ldr	r3, [r7, #4]
2000259c:	7adb      	ldrb	r3, [r3, #11]
2000259e:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
200025a0:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
200025a2:	687b      	ldr	r3, [r7, #4]
200025a4:	7a9b      	ldrb	r3, [r3, #10]
200025a6:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
200025a8:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
200025aa:	687b      	ldr	r3, [r7, #4]
200025ac:	7b5b      	ldrb	r3, [r3, #13]
200025ae:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
200025b0:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
200025b2:	687b      	ldr	r3, [r7, #4]
200025b4:	7b9b      	ldrb	r3, [r3, #14]
200025b6:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
200025b8:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
200025ba:	687b      	ldr	r3, [r7, #4]
200025bc:	7bdb      	ldrb	r3, [r3, #15]
200025be:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
200025c0:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
200025c2:	687b      	ldr	r3, [r7, #4]
200025c4:	7a5b      	ldrb	r3, [r3, #9]
200025c6:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
200025c8:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
200025ca:	687b      	ldr	r3, [r7, #4]
200025cc:	7a1b      	ldrb	r3, [r3, #8]
200025ce:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
200025d0:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
200025d2:	687a      	ldr	r2, [r7, #4]
200025d4:	7812      	ldrb	r2, [r2, #0]
200025d6:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
200025d8:	4a07      	ldr	r2, [pc, #28]	; (200025f8 <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
200025da:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
200025dc:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
200025de:	e005      	b.n	200025ec <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
200025e0:	4b05      	ldr	r3, [pc, #20]	; (200025f8 <HAL_MPU_ConfigRegion+0x84>)
200025e2:	2200      	movs	r2, #0
200025e4:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
200025e6:	4b04      	ldr	r3, [pc, #16]	; (200025f8 <HAL_MPU_ConfigRegion+0x84>)
200025e8:	2200      	movs	r2, #0
200025ea:	611a      	str	r2, [r3, #16]
}
200025ec:	bf00      	nop
200025ee:	370c      	adds	r7, #12
200025f0:	46bd      	mov	sp, r7
200025f2:	f85d 7b04 	ldr.w	r7, [sp], #4
200025f6:	4770      	bx	lr
200025f8:	e000ed90 	.word	0xe000ed90

200025fc <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
200025fc:	b580      	push	{r7, lr}
200025fe:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
20002600:	f7ff fd70 	bl	200020e4 <__NVIC_GetPriorityGrouping>
20002604:	4603      	mov	r3, r0
}
20002606:	4618      	mov	r0, r3
20002608:	bd80      	pop	{r7, pc}

2000260a <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
2000260a:	b580      	push	{r7, lr}
2000260c:	b084      	sub	sp, #16
2000260e:	af00      	add	r7, sp, #0
20002610:	60b9      	str	r1, [r7, #8]
20002612:	607a      	str	r2, [r7, #4]
20002614:	603b      	str	r3, [r7, #0]
20002616:	4603      	mov	r3, r0
20002618:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
2000261a:	f997 300f 	ldrsb.w	r3, [r7, #15]
2000261e:	4618      	mov	r0, r3
20002620:	f7ff fe58 	bl	200022d4 <__NVIC_GetPriority>
20002624:	683b      	ldr	r3, [r7, #0]
20002626:	687a      	ldr	r2, [r7, #4]
20002628:	68b9      	ldr	r1, [r7, #8]
2000262a:	f7ff feae 	bl	2000238a <NVIC_DecodePriority>
}
2000262e:	bf00      	nop
20002630:	3710      	adds	r7, #16
20002632:	46bd      	mov	sp, r7
20002634:	bd80      	pop	{r7, pc}

20002636 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
20002636:	b580      	push	{r7, lr}
20002638:	b082      	sub	sp, #8
2000263a:	af00      	add	r7, sp, #0
2000263c:	4603      	mov	r3, r0
2000263e:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
20002640:	f997 3007 	ldrsb.w	r3, [r7, #7]
20002644:	4618      	mov	r0, r3
20002646:	f7ff fdbd 	bl	200021c4 <__NVIC_SetPendingIRQ>
}
2000264a:	bf00      	nop
2000264c:	3708      	adds	r7, #8
2000264e:	46bd      	mov	sp, r7
20002650:	bd80      	pop	{r7, pc}

20002652 <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
20002652:	b580      	push	{r7, lr}
20002654:	b082      	sub	sp, #8
20002656:	af00      	add	r7, sp, #0
20002658:	4603      	mov	r3, r0
2000265a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
2000265c:	f997 3007 	ldrsb.w	r3, [r7, #7]
20002660:	4618      	mov	r0, r3
20002662:	f7ff fd8d 	bl	20002180 <__NVIC_GetPendingIRQ>
20002666:	4603      	mov	r3, r0
}
20002668:	4618      	mov	r0, r3
2000266a:	3708      	adds	r7, #8
2000266c:	46bd      	mov	sp, r7
2000266e:	bd80      	pop	{r7, pc}

20002670 <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20002670:	b580      	push	{r7, lr}
20002672:	b082      	sub	sp, #8
20002674:	af00      	add	r7, sp, #0
20002676:	4603      	mov	r3, r0
20002678:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
2000267a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000267e:	4618      	mov	r0, r3
20002680:	f7ff fdbe 	bl	20002200 <__NVIC_ClearPendingIRQ>
}
20002684:	bf00      	nop
20002686:	3708      	adds	r7, #8
20002688:	46bd      	mov	sp, r7
2000268a:	bd80      	pop	{r7, pc}

2000268c <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
2000268c:	b580      	push	{r7, lr}
2000268e:	b082      	sub	sp, #8
20002690:	af00      	add	r7, sp, #0
20002692:	4603      	mov	r3, r0
20002694:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
20002696:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000269a:	4618      	mov	r0, r3
2000269c:	f7ff fdce 	bl	2000223c <__NVIC_GetActive>
200026a0:	4603      	mov	r3, r0
}
200026a2:	4618      	mov	r0, r3
200026a4:	3708      	adds	r7, #8
200026a6:	46bd      	mov	sp, r7
200026a8:	bd80      	pop	{r7, pc}
	...

200026ac <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
200026ac:	b480      	push	{r7}
200026ae:	b083      	sub	sp, #12
200026b0:	af00      	add	r7, sp, #0
200026b2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
200026b4:	687b      	ldr	r3, [r7, #4]
200026b6:	2b04      	cmp	r3, #4
200026b8:	d106      	bne.n	200026c8 <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
200026ba:	4b09      	ldr	r3, [pc, #36]	; (200026e0 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200026bc:	681b      	ldr	r3, [r3, #0]
200026be:	4a08      	ldr	r2, [pc, #32]	; (200026e0 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200026c0:	f043 0304 	orr.w	r3, r3, #4
200026c4:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
200026c6:	e005      	b.n	200026d4 <HAL_SYSTICK_CLKSourceConfig+0x28>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
200026c8:	4b05      	ldr	r3, [pc, #20]	; (200026e0 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200026ca:	681b      	ldr	r3, [r3, #0]
200026cc:	4a04      	ldr	r2, [pc, #16]	; (200026e0 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200026ce:	f023 0304 	bic.w	r3, r3, #4
200026d2:	6013      	str	r3, [r2, #0]
}
200026d4:	bf00      	nop
200026d6:	370c      	adds	r7, #12
200026d8:	46bd      	mov	sp, r7
200026da:	f85d 7b04 	ldr.w	r7, [sp], #4
200026de:	4770      	bx	lr
200026e0:	e000e010 	.word	0xe000e010

200026e4 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
200026e4:	b580      	push	{r7, lr}
200026e6:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
200026e8:	f000 f802 	bl	200026f0 <HAL_SYSTICK_Callback>
}
200026ec:	bf00      	nop
200026ee:	bd80      	pop	{r7, pc}

200026f0 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
200026f0:	b480      	push	{r7}
200026f2:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
200026f4:	bf00      	nop
200026f6:	46bd      	mov	sp, r7
200026f8:	f85d 7b04 	ldr.w	r7, [sp], #4
200026fc:	4770      	bx	lr
	...

20002700 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
20002700:	b580      	push	{r7, lr}
20002702:	b086      	sub	sp, #24
20002704:	af00      	add	r7, sp, #0
20002706:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
20002708:	2300      	movs	r3, #0
2000270a:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
2000270c:	f7ff fb38 	bl	20001d80 <HAL_GetTick>
20002710:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
20002712:	687b      	ldr	r3, [r7, #4]
20002714:	2b00      	cmp	r3, #0
20002716:	d101      	bne.n	2000271c <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
20002718:	2301      	movs	r3, #1
2000271a:	e099      	b.n	20002850 <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
2000271c:	687b      	ldr	r3, [r7, #4]
2000271e:	2200      	movs	r2, #0
20002720:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
20002724:	687b      	ldr	r3, [r7, #4]
20002726:	2202      	movs	r2, #2
20002728:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
2000272c:	687b      	ldr	r3, [r7, #4]
2000272e:	681b      	ldr	r3, [r3, #0]
20002730:	681a      	ldr	r2, [r3, #0]
20002732:	687b      	ldr	r3, [r7, #4]
20002734:	681b      	ldr	r3, [r3, #0]
20002736:	f022 0201 	bic.w	r2, r2, #1
2000273a:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
2000273c:	e00f      	b.n	2000275e <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
2000273e:	f7ff fb1f 	bl	20001d80 <HAL_GetTick>
20002742:	4602      	mov	r2, r0
20002744:	693b      	ldr	r3, [r7, #16]
20002746:	1ad3      	subs	r3, r2, r3
20002748:	2b05      	cmp	r3, #5
2000274a:	d908      	bls.n	2000275e <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
2000274c:	687b      	ldr	r3, [r7, #4]
2000274e:	2220      	movs	r2, #32
20002750:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
20002752:	687b      	ldr	r3, [r7, #4]
20002754:	2203      	movs	r2, #3
20002756:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
2000275a:	2303      	movs	r3, #3
2000275c:	e078      	b.n	20002850 <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
2000275e:	687b      	ldr	r3, [r7, #4]
20002760:	681b      	ldr	r3, [r3, #0]
20002762:	681b      	ldr	r3, [r3, #0]
20002764:	f003 0301 	and.w	r3, r3, #1
20002768:	2b00      	cmp	r3, #0
2000276a:	d1e8      	bne.n	2000273e <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
2000276c:	687b      	ldr	r3, [r7, #4]
2000276e:	681b      	ldr	r3, [r3, #0]
20002770:	681b      	ldr	r3, [r3, #0]
20002772:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
20002774:	697a      	ldr	r2, [r7, #20]
20002776:	4b38      	ldr	r3, [pc, #224]	; (20002858 <HAL_DMA_Init+0x158>)
20002778:	4013      	ands	r3, r2
2000277a:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
2000277c:	687b      	ldr	r3, [r7, #4]
2000277e:	685a      	ldr	r2, [r3, #4]
20002780:	687b      	ldr	r3, [r7, #4]
20002782:	689b      	ldr	r3, [r3, #8]
20002784:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
20002786:	687b      	ldr	r3, [r7, #4]
20002788:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
2000278a:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
2000278c:	687b      	ldr	r3, [r7, #4]
2000278e:	691b      	ldr	r3, [r3, #16]
20002790:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
20002792:	687b      	ldr	r3, [r7, #4]
20002794:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
20002796:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
20002798:	687b      	ldr	r3, [r7, #4]
2000279a:	699b      	ldr	r3, [r3, #24]
2000279c:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
2000279e:	687b      	ldr	r3, [r7, #4]
200027a0:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
200027a2:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
200027a4:	687b      	ldr	r3, [r7, #4]
200027a6:	6a1b      	ldr	r3, [r3, #32]
200027a8:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
200027aa:	697a      	ldr	r2, [r7, #20]
200027ac:	4313      	orrs	r3, r2
200027ae:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
200027b0:	687b      	ldr	r3, [r7, #4]
200027b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200027b4:	2b04      	cmp	r3, #4
200027b6:	d107      	bne.n	200027c8 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
200027b8:	687b      	ldr	r3, [r7, #4]
200027ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200027bc:	687b      	ldr	r3, [r7, #4]
200027be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200027c0:	4313      	orrs	r3, r2
200027c2:	697a      	ldr	r2, [r7, #20]
200027c4:	4313      	orrs	r3, r2
200027c6:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
200027c8:	687b      	ldr	r3, [r7, #4]
200027ca:	681b      	ldr	r3, [r3, #0]
200027cc:	697a      	ldr	r2, [r7, #20]
200027ce:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
200027d0:	687b      	ldr	r3, [r7, #4]
200027d2:	681b      	ldr	r3, [r3, #0]
200027d4:	695b      	ldr	r3, [r3, #20]
200027d6:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
200027d8:	697b      	ldr	r3, [r7, #20]
200027da:	f023 0307 	bic.w	r3, r3, #7
200027de:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
200027e0:	687b      	ldr	r3, [r7, #4]
200027e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200027e4:	697a      	ldr	r2, [r7, #20]
200027e6:	4313      	orrs	r3, r2
200027e8:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
200027ea:	687b      	ldr	r3, [r7, #4]
200027ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200027ee:	2b04      	cmp	r3, #4
200027f0:	d117      	bne.n	20002822 <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
200027f2:	687b      	ldr	r3, [r7, #4]
200027f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200027f6:	697a      	ldr	r2, [r7, #20]
200027f8:	4313      	orrs	r3, r2
200027fa:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
200027fc:	687b      	ldr	r3, [r7, #4]
200027fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20002800:	2b00      	cmp	r3, #0
20002802:	d00e      	beq.n	20002822 <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
20002804:	6878      	ldr	r0, [r7, #4]
20002806:	f000 fd59 	bl	200032bc <DMA_CheckFifoParam>
2000280a:	4603      	mov	r3, r0
2000280c:	2b00      	cmp	r3, #0
2000280e:	d008      	beq.n	20002822 <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
20002810:	687b      	ldr	r3, [r7, #4]
20002812:	2240      	movs	r2, #64	; 0x40
20002814:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
20002816:	687b      	ldr	r3, [r7, #4]
20002818:	2201      	movs	r2, #1
2000281a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
2000281e:	2301      	movs	r3, #1
20002820:	e016      	b.n	20002850 <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
20002822:	687b      	ldr	r3, [r7, #4]
20002824:	681b      	ldr	r3, [r3, #0]
20002826:	697a      	ldr	r2, [r7, #20]
20002828:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
2000282a:	6878      	ldr	r0, [r7, #4]
2000282c:	f000 fd10 	bl	20003250 <DMA_CalcBaseAndBitshift>
20002830:	4603      	mov	r3, r0
20002832:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
20002834:	687b      	ldr	r3, [r7, #4]
20002836:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002838:	223f      	movs	r2, #63	; 0x3f
2000283a:	409a      	lsls	r2, r3
2000283c:	68fb      	ldr	r3, [r7, #12]
2000283e:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
20002840:	687b      	ldr	r3, [r7, #4]
20002842:	2200      	movs	r2, #0
20002844:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
20002846:	687b      	ldr	r3, [r7, #4]
20002848:	2201      	movs	r2, #1
2000284a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
2000284e:	2300      	movs	r3, #0
}
20002850:	4618      	mov	r0, r3
20002852:	3718      	adds	r7, #24
20002854:	46bd      	mov	sp, r7
20002856:	bd80      	pop	{r7, pc}
20002858:	e010803f 	.word	0xe010803f

2000285c <HAL_DMA_DeInit>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
2000285c:	b580      	push	{r7, lr}
2000285e:	b084      	sub	sp, #16
20002860:	af00      	add	r7, sp, #0
20002862:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
20002864:	687b      	ldr	r3, [r7, #4]
20002866:	2b00      	cmp	r3, #0
20002868:	d101      	bne.n	2000286e <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
2000286a:	2301      	movs	r3, #1
2000286c:	e050      	b.n	20002910 <HAL_DMA_DeInit+0xb4>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
2000286e:	687b      	ldr	r3, [r7, #4]
20002870:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20002874:	b2db      	uxtb	r3, r3
20002876:	2b02      	cmp	r3, #2
20002878:	d101      	bne.n	2000287e <HAL_DMA_DeInit+0x22>
  {
    /* Return error status */
    return HAL_BUSY;
2000287a:	2302      	movs	r3, #2
2000287c:	e048      	b.n	20002910 <HAL_DMA_DeInit+0xb4>

  /* Check the parameters */
  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
2000287e:	687b      	ldr	r3, [r7, #4]
20002880:	681b      	ldr	r3, [r3, #0]
20002882:	681a      	ldr	r2, [r3, #0]
20002884:	687b      	ldr	r3, [r7, #4]
20002886:	681b      	ldr	r3, [r3, #0]
20002888:	f022 0201 	bic.w	r2, r2, #1
2000288c:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0U;
2000288e:	687b      	ldr	r3, [r7, #4]
20002890:	681b      	ldr	r3, [r3, #0]
20002892:	2200      	movs	r2, #0
20002894:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0U;
20002896:	687b      	ldr	r3, [r7, #4]
20002898:	681b      	ldr	r3, [r3, #0]
2000289a:	2200      	movs	r2, #0
2000289c:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0U;
2000289e:	687b      	ldr	r3, [r7, #4]
200028a0:	681b      	ldr	r3, [r3, #0]
200028a2:	2200      	movs	r2, #0
200028a4:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0U;
200028a6:	687b      	ldr	r3, [r7, #4]
200028a8:	681b      	ldr	r3, [r3, #0]
200028aa:	2200      	movs	r2, #0
200028ac:	60da      	str	r2, [r3, #12]
  
  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0U;
200028ae:	687b      	ldr	r3, [r7, #4]
200028b0:	681b      	ldr	r3, [r3, #0]
200028b2:	2200      	movs	r2, #0
200028b4:	611a      	str	r2, [r3, #16]
  
  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
200028b6:	687b      	ldr	r3, [r7, #4]
200028b8:	681b      	ldr	r3, [r3, #0]
200028ba:	2221      	movs	r2, #33	; 0x21
200028bc:	615a      	str	r2, [r3, #20]
  
  /* Get DMA steam Base Address */  
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
200028be:	6878      	ldr	r0, [r7, #4]
200028c0:	f000 fcc6 	bl	20003250 <DMA_CalcBaseAndBitshift>
200028c4:	4603      	mov	r3, r0
200028c6:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags at correct offset within the register */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
200028c8:	687b      	ldr	r3, [r7, #4]
200028ca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200028cc:	223f      	movs	r2, #63	; 0x3f
200028ce:	409a      	lsls	r2, r3
200028d0:	68fb      	ldr	r3, [r7, #12]
200028d2:	609a      	str	r2, [r3, #8]
  
  /* Clean all callbacks */
  hdma->XferCpltCallback = NULL;
200028d4:	687b      	ldr	r3, [r7, #4]
200028d6:	2200      	movs	r2, #0
200028d8:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback = NULL;
200028da:	687b      	ldr	r3, [r7, #4]
200028dc:	2200      	movs	r2, #0
200028de:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback = NULL;
200028e0:	687b      	ldr	r3, [r7, #4]
200028e2:	2200      	movs	r2, #0
200028e4:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
200028e6:	687b      	ldr	r3, [r7, #4]
200028e8:	2200      	movs	r2, #0
200028ea:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback = NULL;
200028ec:	687b      	ldr	r3, [r7, #4]
200028ee:	2200      	movs	r2, #0
200028f0:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback = NULL;  
200028f2:	687b      	ldr	r3, [r7, #4]
200028f4:	2200      	movs	r2, #0
200028f6:	651a      	str	r2, [r3, #80]	; 0x50

  /* Reset the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200028f8:	687b      	ldr	r3, [r7, #4]
200028fa:	2200      	movs	r2, #0
200028fc:	655a      	str	r2, [r3, #84]	; 0x54

  /* Reset the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
200028fe:	687b      	ldr	r3, [r7, #4]
20002900:	2200      	movs	r2, #0
20002902:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
20002906:	687b      	ldr	r3, [r7, #4]
20002908:	2200      	movs	r2, #0
2000290a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
2000290e:	2300      	movs	r3, #0
}
20002910:	4618      	mov	r0, r3
20002912:	3710      	adds	r7, #16
20002914:	46bd      	mov	sp, r7
20002916:	bd80      	pop	{r7, pc}

20002918 <HAL_DMA_Start>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
20002918:	b580      	push	{r7, lr}
2000291a:	b086      	sub	sp, #24
2000291c:	af00      	add	r7, sp, #0
2000291e:	60f8      	str	r0, [r7, #12]
20002920:	60b9      	str	r1, [r7, #8]
20002922:	607a      	str	r2, [r7, #4]
20002924:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20002926:	2300      	movs	r3, #0
20002928:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
2000292a:	68fb      	ldr	r3, [r7, #12]
2000292c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20002930:	2b01      	cmp	r3, #1
20002932:	d101      	bne.n	20002938 <HAL_DMA_Start+0x20>
20002934:	2302      	movs	r3, #2
20002936:	e026      	b.n	20002986 <HAL_DMA_Start+0x6e>
20002938:	68fb      	ldr	r3, [r7, #12]
2000293a:	2201      	movs	r2, #1
2000293c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
20002940:	68fb      	ldr	r3, [r7, #12]
20002942:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20002946:	b2db      	uxtb	r3, r3
20002948:	2b01      	cmp	r3, #1
2000294a:	d115      	bne.n	20002978 <HAL_DMA_Start+0x60>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
2000294c:	68fb      	ldr	r3, [r7, #12]
2000294e:	2202      	movs	r2, #2
20002950:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
20002954:	68fb      	ldr	r3, [r7, #12]
20002956:	2200      	movs	r2, #0
20002958:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
2000295a:	683b      	ldr	r3, [r7, #0]
2000295c:	687a      	ldr	r2, [r7, #4]
2000295e:	68b9      	ldr	r1, [r7, #8]
20002960:	68f8      	ldr	r0, [r7, #12]
20002962:	f000 fc47 	bl	200031f4 <DMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
20002966:	68fb      	ldr	r3, [r7, #12]
20002968:	681b      	ldr	r3, [r3, #0]
2000296a:	681a      	ldr	r2, [r3, #0]
2000296c:	68fb      	ldr	r3, [r7, #12]
2000296e:	681b      	ldr	r3, [r3, #0]
20002970:	f042 0201 	orr.w	r2, r2, #1
20002974:	601a      	str	r2, [r3, #0]
20002976:	e005      	b.n	20002984 <HAL_DMA_Start+0x6c>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);
20002978:	68fb      	ldr	r3, [r7, #12]
2000297a:	2200      	movs	r2, #0
2000297c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
20002980:	2302      	movs	r3, #2
20002982:	75fb      	strb	r3, [r7, #23]
  } 
  return status; 
20002984:	7dfb      	ldrb	r3, [r7, #23]
}
20002986:	4618      	mov	r0, r3
20002988:	3718      	adds	r7, #24
2000298a:	46bd      	mov	sp, r7
2000298c:	bd80      	pop	{r7, pc}

2000298e <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
2000298e:	b580      	push	{r7, lr}
20002990:	b086      	sub	sp, #24
20002992:	af00      	add	r7, sp, #0
20002994:	60f8      	str	r0, [r7, #12]
20002996:	60b9      	str	r1, [r7, #8]
20002998:	607a      	str	r2, [r7, #4]
2000299a:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000299c:	2300      	movs	r3, #0
2000299e:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
200029a0:	68fb      	ldr	r3, [r7, #12]
200029a2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200029a4:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
200029a6:	68fb      	ldr	r3, [r7, #12]
200029a8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
200029ac:	2b01      	cmp	r3, #1
200029ae:	d101      	bne.n	200029b4 <HAL_DMA_Start_IT+0x26>
200029b0:	2302      	movs	r3, #2
200029b2:	e048      	b.n	20002a46 <HAL_DMA_Start_IT+0xb8>
200029b4:	68fb      	ldr	r3, [r7, #12]
200029b6:	2201      	movs	r2, #1
200029b8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
200029bc:	68fb      	ldr	r3, [r7, #12]
200029be:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200029c2:	b2db      	uxtb	r3, r3
200029c4:	2b01      	cmp	r3, #1
200029c6:	d137      	bne.n	20002a38 <HAL_DMA_Start_IT+0xaa>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
200029c8:	68fb      	ldr	r3, [r7, #12]
200029ca:	2202      	movs	r2, #2
200029cc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200029d0:	68fb      	ldr	r3, [r7, #12]
200029d2:	2200      	movs	r2, #0
200029d4:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
200029d6:	683b      	ldr	r3, [r7, #0]
200029d8:	687a      	ldr	r2, [r7, #4]
200029da:	68b9      	ldr	r1, [r7, #8]
200029dc:	68f8      	ldr	r0, [r7, #12]
200029de:	f000 fc09 	bl	200031f4 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
200029e2:	68fb      	ldr	r3, [r7, #12]
200029e4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
200029e6:	223f      	movs	r2, #63	; 0x3f
200029e8:	409a      	lsls	r2, r3
200029ea:	693b      	ldr	r3, [r7, #16]
200029ec:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
200029ee:	68fb      	ldr	r3, [r7, #12]
200029f0:	681b      	ldr	r3, [r3, #0]
200029f2:	681a      	ldr	r2, [r3, #0]
200029f4:	68fb      	ldr	r3, [r7, #12]
200029f6:	681b      	ldr	r3, [r3, #0]
200029f8:	f042 0216 	orr.w	r2, r2, #22
200029fc:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
200029fe:	68fb      	ldr	r3, [r7, #12]
20002a00:	681b      	ldr	r3, [r3, #0]
20002a02:	695a      	ldr	r2, [r3, #20]
20002a04:	68fb      	ldr	r3, [r7, #12]
20002a06:	681b      	ldr	r3, [r3, #0]
20002a08:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20002a0c:	615a      	str	r2, [r3, #20]
    
    if(hdma->XferHalfCpltCallback != NULL)
20002a0e:	68fb      	ldr	r3, [r7, #12]
20002a10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002a12:	2b00      	cmp	r3, #0
20002a14:	d007      	beq.n	20002a26 <HAL_DMA_Start_IT+0x98>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
20002a16:	68fb      	ldr	r3, [r7, #12]
20002a18:	681b      	ldr	r3, [r3, #0]
20002a1a:	681a      	ldr	r2, [r3, #0]
20002a1c:	68fb      	ldr	r3, [r7, #12]
20002a1e:	681b      	ldr	r3, [r3, #0]
20002a20:	f042 0208 	orr.w	r2, r2, #8
20002a24:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
20002a26:	68fb      	ldr	r3, [r7, #12]
20002a28:	681b      	ldr	r3, [r3, #0]
20002a2a:	681a      	ldr	r2, [r3, #0]
20002a2c:	68fb      	ldr	r3, [r7, #12]
20002a2e:	681b      	ldr	r3, [r3, #0]
20002a30:	f042 0201 	orr.w	r2, r2, #1
20002a34:	601a      	str	r2, [r3, #0]
20002a36:	e005      	b.n	20002a44 <HAL_DMA_Start_IT+0xb6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
20002a38:	68fb      	ldr	r3, [r7, #12]
20002a3a:	2200      	movs	r2, #0
20002a3c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
20002a40:	2302      	movs	r3, #2
20002a42:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
20002a44:	7dfb      	ldrb	r3, [r7, #23]
}
20002a46:	4618      	mov	r0, r3
20002a48:	3718      	adds	r7, #24
20002a4a:	46bd      	mov	sp, r7
20002a4c:	bd80      	pop	{r7, pc}

20002a4e <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
20002a4e:	b580      	push	{r7, lr}
20002a50:	b084      	sub	sp, #16
20002a52:	af00      	add	r7, sp, #0
20002a54:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
20002a56:	687b      	ldr	r3, [r7, #4]
20002a58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002a5a:	60fb      	str	r3, [r7, #12]
  
  uint32_t tickstart = HAL_GetTick();
20002a5c:	f7ff f990 	bl	20001d80 <HAL_GetTick>
20002a60:	60b8      	str	r0, [r7, #8]
  
  if(hdma->State != HAL_DMA_STATE_BUSY)
20002a62:	687b      	ldr	r3, [r7, #4]
20002a64:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20002a68:	b2db      	uxtb	r3, r3
20002a6a:	2b02      	cmp	r3, #2
20002a6c:	d008      	beq.n	20002a80 <HAL_DMA_Abort+0x32>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
20002a6e:	687b      	ldr	r3, [r7, #4]
20002a70:	2280      	movs	r2, #128	; 0x80
20002a72:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20002a74:	687b      	ldr	r3, [r7, #4]
20002a76:	2200      	movs	r2, #0
20002a78:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    return HAL_ERROR;
20002a7c:	2301      	movs	r3, #1
20002a7e:	e052      	b.n	20002b26 <HAL_DMA_Abort+0xd8>
  }
  else
  {
    /* Disable all the transfer interrupts */
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
20002a80:	687b      	ldr	r3, [r7, #4]
20002a82:	681b      	ldr	r3, [r3, #0]
20002a84:	681a      	ldr	r2, [r3, #0]
20002a86:	687b      	ldr	r3, [r7, #4]
20002a88:	681b      	ldr	r3, [r3, #0]
20002a8a:	f022 0216 	bic.w	r2, r2, #22
20002a8e:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
20002a90:	687b      	ldr	r3, [r7, #4]
20002a92:	681b      	ldr	r3, [r3, #0]
20002a94:	695a      	ldr	r2, [r3, #20]
20002a96:	687b      	ldr	r3, [r7, #4]
20002a98:	681b      	ldr	r3, [r3, #0]
20002a9a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
20002a9e:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
20002aa0:	687b      	ldr	r3, [r7, #4]
20002aa2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002aa4:	2b00      	cmp	r3, #0
20002aa6:	d103      	bne.n	20002ab0 <HAL_DMA_Abort+0x62>
20002aa8:	687b      	ldr	r3, [r7, #4]
20002aaa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002aac:	2b00      	cmp	r3, #0
20002aae:	d007      	beq.n	20002ac0 <HAL_DMA_Abort+0x72>
    {
      hdma->Instance->CR  &= ~(DMA_IT_HT);
20002ab0:	687b      	ldr	r3, [r7, #4]
20002ab2:	681b      	ldr	r3, [r3, #0]
20002ab4:	681a      	ldr	r2, [r3, #0]
20002ab6:	687b      	ldr	r3, [r7, #4]
20002ab8:	681b      	ldr	r3, [r3, #0]
20002aba:	f022 0208 	bic.w	r2, r2, #8
20002abe:	601a      	str	r2, [r3, #0]
    }
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
20002ac0:	687b      	ldr	r3, [r7, #4]
20002ac2:	681b      	ldr	r3, [r3, #0]
20002ac4:	681a      	ldr	r2, [r3, #0]
20002ac6:	687b      	ldr	r3, [r7, #4]
20002ac8:	681b      	ldr	r3, [r3, #0]
20002aca:	f022 0201 	bic.w	r2, r2, #1
20002ace:	601a      	str	r2, [r3, #0]
    
    /* Check if the DMA Stream is effectively disabled */
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
20002ad0:	e013      	b.n	20002afa <HAL_DMA_Abort+0xac>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
20002ad2:	f7ff f955 	bl	20001d80 <HAL_GetTick>
20002ad6:	4602      	mov	r2, r0
20002ad8:	68bb      	ldr	r3, [r7, #8]
20002ada:	1ad3      	subs	r3, r2, r3
20002adc:	2b05      	cmp	r3, #5
20002ade:	d90c      	bls.n	20002afa <HAL_DMA_Abort+0xac>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
20002ae0:	687b      	ldr	r3, [r7, #4]
20002ae2:	2220      	movs	r2, #32
20002ae4:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
20002ae6:	687b      	ldr	r3, [r7, #4]
20002ae8:	2200      	movs	r2, #0
20002aea:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
20002aee:	687b      	ldr	r3, [r7, #4]
20002af0:	2203      	movs	r2, #3
20002af2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_TIMEOUT;
20002af6:	2303      	movs	r3, #3
20002af8:	e015      	b.n	20002b26 <HAL_DMA_Abort+0xd8>
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
20002afa:	687b      	ldr	r3, [r7, #4]
20002afc:	681b      	ldr	r3, [r3, #0]
20002afe:	681b      	ldr	r3, [r3, #0]
20002b00:	f003 0301 	and.w	r3, r3, #1
20002b04:	2b00      	cmp	r3, #0
20002b06:	d1e4      	bne.n	20002ad2 <HAL_DMA_Abort+0x84>
      }
    }
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
20002b08:	687b      	ldr	r3, [r7, #4]
20002b0a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002b0c:	223f      	movs	r2, #63	; 0x3f
20002b0e:	409a      	lsls	r2, r3
20002b10:	68fb      	ldr	r3, [r7, #12]
20002b12:	609a      	str	r2, [r3, #8]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20002b14:	687b      	ldr	r3, [r7, #4]
20002b16:	2200      	movs	r2, #0
20002b18:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Change the DMA state*/
    hdma->State = HAL_DMA_STATE_READY;
20002b1c:	687b      	ldr	r3, [r7, #4]
20002b1e:	2201      	movs	r2, #1
20002b20:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  }
  return HAL_OK;
20002b24:	2300      	movs	r3, #0
}
20002b26:	4618      	mov	r0, r3
20002b28:	3710      	adds	r7, #16
20002b2a:	46bd      	mov	sp, r7
20002b2c:	bd80      	pop	{r7, pc}

20002b2e <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
20002b2e:	b480      	push	{r7}
20002b30:	b083      	sub	sp, #12
20002b32:	af00      	add	r7, sp, #0
20002b34:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
20002b36:	687b      	ldr	r3, [r7, #4]
20002b38:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20002b3c:	b2db      	uxtb	r3, r3
20002b3e:	2b02      	cmp	r3, #2
20002b40:	d004      	beq.n	20002b4c <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
20002b42:	687b      	ldr	r3, [r7, #4]
20002b44:	2280      	movs	r2, #128	; 0x80
20002b46:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
20002b48:	2301      	movs	r3, #1
20002b4a:	e00c      	b.n	20002b66 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
20002b4c:	687b      	ldr	r3, [r7, #4]
20002b4e:	2205      	movs	r2, #5
20002b50:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
20002b54:	687b      	ldr	r3, [r7, #4]
20002b56:	681b      	ldr	r3, [r3, #0]
20002b58:	681a      	ldr	r2, [r3, #0]
20002b5a:	687b      	ldr	r3, [r7, #4]
20002b5c:	681b      	ldr	r3, [r3, #0]
20002b5e:	f022 0201 	bic.w	r2, r2, #1
20002b62:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
20002b64:	2300      	movs	r3, #0
}
20002b66:	4618      	mov	r0, r3
20002b68:	370c      	adds	r7, #12
20002b6a:	46bd      	mov	sp, r7
20002b6c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002b70:	4770      	bx	lr

20002b72 <HAL_DMA_PollForTransfer>:
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). 
  * @param  Timeout       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
20002b72:	b580      	push	{r7, lr}
20002b74:	b08a      	sub	sp, #40	; 0x28
20002b76:	af00      	add	r7, sp, #0
20002b78:	60f8      	str	r0, [r7, #12]
20002b7a:	460b      	mov	r3, r1
20002b7c:	607a      	str	r2, [r7, #4]
20002b7e:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK; 
20002b80:	2300      	movs	r3, #0
20002b82:	77fb      	strb	r3, [r7, #31]
  uint32_t mask_cpltlevel;
  uint32_t tickstart = HAL_GetTick(); 
20002b84:	f7ff f8fc 	bl	20001d80 <HAL_GetTick>
20002b88:	61b8      	str	r0, [r7, #24]
  uint32_t tmpisr;
  
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs;

  if(HAL_DMA_STATE_BUSY != hdma->State)
20002b8a:	68fb      	ldr	r3, [r7, #12]
20002b8c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20002b90:	b2db      	uxtb	r3, r3
20002b92:	2b02      	cmp	r3, #2
20002b94:	d008      	beq.n	20002ba8 <HAL_DMA_PollForTransfer+0x36>
  {
    /* No transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
20002b96:	68fb      	ldr	r3, [r7, #12]
20002b98:	2280      	movs	r2, #128	; 0x80
20002b9a:	655a      	str	r2, [r3, #84]	; 0x54
    __HAL_UNLOCK(hdma);
20002b9c:	68fb      	ldr	r3, [r7, #12]
20002b9e:	2200      	movs	r2, #0
20002ba0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
20002ba4:	2301      	movs	r3, #1
20002ba6:	e0bf      	b.n	20002d28 <HAL_DMA_PollForTransfer+0x1b6>
  }

  /* Polling mode not supported in circular mode and double buffering mode */
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
20002ba8:	68fb      	ldr	r3, [r7, #12]
20002baa:	681b      	ldr	r3, [r3, #0]
20002bac:	681b      	ldr	r3, [r3, #0]
20002bae:	f403 7380 	and.w	r3, r3, #256	; 0x100
20002bb2:	2b00      	cmp	r3, #0
20002bb4:	d005      	beq.n	20002bc2 <HAL_DMA_PollForTransfer+0x50>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
20002bb6:	68fb      	ldr	r3, [r7, #12]
20002bb8:	f44f 7280 	mov.w	r2, #256	; 0x100
20002bbc:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
20002bbe:	2301      	movs	r3, #1
20002bc0:	e0b2      	b.n	20002d28 <HAL_DMA_PollForTransfer+0x1b6>
  }
  
  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
20002bc2:	7afb      	ldrb	r3, [r7, #11]
20002bc4:	2b00      	cmp	r3, #0
20002bc6:	d106      	bne.n	20002bd6 <HAL_DMA_PollForTransfer+0x64>
  {
    /* Transfer Complete flag */
    mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
20002bc8:	68fb      	ldr	r3, [r7, #12]
20002bca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002bcc:	2220      	movs	r2, #32
20002bce:	fa02 f303 	lsl.w	r3, r2, r3
20002bd2:	627b      	str	r3, [r7, #36]	; 0x24
20002bd4:	e005      	b.n	20002be2 <HAL_DMA_PollForTransfer+0x70>
  }
  else
  {
    /* Half Transfer Complete flag */
    mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
20002bd6:	68fb      	ldr	r3, [r7, #12]
20002bd8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002bda:	2210      	movs	r2, #16
20002bdc:	fa02 f303 	lsl.w	r3, r2, r3
20002be0:	627b      	str	r3, [r7, #36]	; 0x24
  }
  
  regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
20002be2:	68fb      	ldr	r3, [r7, #12]
20002be4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002be6:	617b      	str	r3, [r7, #20]
  tmpisr = regs->ISR;
20002be8:	697b      	ldr	r3, [r7, #20]
20002bea:	681b      	ldr	r3, [r3, #0]
20002bec:	623b      	str	r3, [r7, #32]
  
  while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
20002bee:	e05a      	b.n	20002ca6 <HAL_DMA_PollForTransfer+0x134>
  {
    /* Check for the Timeout (Not applicable in circular mode)*/
    if(Timeout != HAL_MAX_DELAY)
20002bf0:	687b      	ldr	r3, [r7, #4]
20002bf2:	f1b3 3fff 	cmp.w	r3, #4294967295
20002bf6:	d017      	beq.n	20002c28 <HAL_DMA_PollForTransfer+0xb6>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
20002bf8:	687b      	ldr	r3, [r7, #4]
20002bfa:	2b00      	cmp	r3, #0
20002bfc:	d007      	beq.n	20002c0e <HAL_DMA_PollForTransfer+0x9c>
20002bfe:	f7ff f8bf 	bl	20001d80 <HAL_GetTick>
20002c02:	4602      	mov	r2, r0
20002c04:	69bb      	ldr	r3, [r7, #24]
20002c06:	1ad3      	subs	r3, r2, r3
20002c08:	687a      	ldr	r2, [r7, #4]
20002c0a:	429a      	cmp	r2, r3
20002c0c:	d20c      	bcs.n	20002c28 <HAL_DMA_PollForTransfer+0xb6>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
20002c0e:	68fb      	ldr	r3, [r7, #12]
20002c10:	2220      	movs	r2, #32
20002c12:	655a      	str	r2, [r3, #84]	; 0x54

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
20002c14:	68fb      	ldr	r3, [r7, #12]
20002c16:	2200      	movs	r2, #0
20002c18:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
20002c1c:	68fb      	ldr	r3, [r7, #12]
20002c1e:	2201      	movs	r2, #1
20002c20:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_TIMEOUT;
20002c24:	2303      	movs	r3, #3
20002c26:	e07f      	b.n	20002d28 <HAL_DMA_PollForTransfer+0x1b6>
      }
    }

    /* Get the ISR register value */
    tmpisr = regs->ISR;
20002c28:	697b      	ldr	r3, [r7, #20]
20002c2a:	681b      	ldr	r3, [r3, #0]
20002c2c:	623b      	str	r3, [r7, #32]

    if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
20002c2e:	68fb      	ldr	r3, [r7, #12]
20002c30:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002c32:	2208      	movs	r2, #8
20002c34:	409a      	lsls	r2, r3
20002c36:	6a3b      	ldr	r3, [r7, #32]
20002c38:	4013      	ands	r3, r2
20002c3a:	2b00      	cmp	r3, #0
20002c3c:	d00b      	beq.n	20002c56 <HAL_DMA_PollForTransfer+0xe4>
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
20002c3e:	68fb      	ldr	r3, [r7, #12]
20002c40:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002c42:	f043 0201 	orr.w	r2, r3, #1
20002c46:	68fb      	ldr	r3, [r7, #12]
20002c48:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
20002c4a:	68fb      	ldr	r3, [r7, #12]
20002c4c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002c4e:	2208      	movs	r2, #8
20002c50:	409a      	lsls	r2, r3
20002c52:	697b      	ldr	r3, [r7, #20]
20002c54:	609a      	str	r2, [r3, #8]
    }
    
    if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
20002c56:	68fb      	ldr	r3, [r7, #12]
20002c58:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002c5a:	2201      	movs	r2, #1
20002c5c:	409a      	lsls	r2, r3
20002c5e:	6a3b      	ldr	r3, [r7, #32]
20002c60:	4013      	ands	r3, r2
20002c62:	2b00      	cmp	r3, #0
20002c64:	d00b      	beq.n	20002c7e <HAL_DMA_PollForTransfer+0x10c>
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
20002c66:	68fb      	ldr	r3, [r7, #12]
20002c68:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002c6a:	f043 0202 	orr.w	r2, r3, #2
20002c6e:	68fb      	ldr	r3, [r7, #12]
20002c70:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
20002c72:	68fb      	ldr	r3, [r7, #12]
20002c74:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002c76:	2201      	movs	r2, #1
20002c78:	409a      	lsls	r2, r3
20002c7a:	697b      	ldr	r3, [r7, #20]
20002c7c:	609a      	str	r2, [r3, #8]
    }
    
    if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
20002c7e:	68fb      	ldr	r3, [r7, #12]
20002c80:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002c82:	2204      	movs	r2, #4
20002c84:	409a      	lsls	r2, r3
20002c86:	6a3b      	ldr	r3, [r7, #32]
20002c88:	4013      	ands	r3, r2
20002c8a:	2b00      	cmp	r3, #0
20002c8c:	d00b      	beq.n	20002ca6 <HAL_DMA_PollForTransfer+0x134>
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
20002c8e:	68fb      	ldr	r3, [r7, #12]
20002c90:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002c92:	f043 0204 	orr.w	r2, r3, #4
20002c96:	68fb      	ldr	r3, [r7, #12]
20002c98:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Clear the Direct Mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
20002c9a:	68fb      	ldr	r3, [r7, #12]
20002c9c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002c9e:	2204      	movs	r2, #4
20002ca0:	409a      	lsls	r2, r3
20002ca2:	697b      	ldr	r3, [r7, #20]
20002ca4:	609a      	str	r2, [r3, #8]
  while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
20002ca6:	6a3a      	ldr	r2, [r7, #32]
20002ca8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20002caa:	4013      	ands	r3, r2
20002cac:	2b00      	cmp	r3, #0
20002cae:	d105      	bne.n	20002cbc <HAL_DMA_PollForTransfer+0x14a>
20002cb0:	68fb      	ldr	r3, [r7, #12]
20002cb2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002cb4:	f003 0301 	and.w	r3, r3, #1
20002cb8:	2b00      	cmp	r3, #0
20002cba:	d099      	beq.n	20002bf0 <HAL_DMA_PollForTransfer+0x7e>
    }
  }
  
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
20002cbc:	68fb      	ldr	r3, [r7, #12]
20002cbe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002cc0:	2b00      	cmp	r3, #0
20002cc2:	d018      	beq.n	20002cf6 <HAL_DMA_PollForTransfer+0x184>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
20002cc4:	68fb      	ldr	r3, [r7, #12]
20002cc6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002cc8:	f003 0301 	and.w	r3, r3, #1
20002ccc:	2b00      	cmp	r3, #0
20002cce:	d012      	beq.n	20002cf6 <HAL_DMA_PollForTransfer+0x184>
    {
      HAL_DMA_Abort(hdma);
20002cd0:	68f8      	ldr	r0, [r7, #12]
20002cd2:	f7ff febc 	bl	20002a4e <HAL_DMA_Abort>
    
      /* Clear the half transfer and transfer complete flags */
      regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
20002cd6:	68fb      	ldr	r3, [r7, #12]
20002cd8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002cda:	2230      	movs	r2, #48	; 0x30
20002cdc:	409a      	lsls	r2, r3
20002cde:	697b      	ldr	r3, [r7, #20]
20002ce0:	609a      	str	r2, [r3, #8]
    
      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
20002ce2:	68fb      	ldr	r3, [r7, #12]
20002ce4:	2200      	movs	r2, #0
20002ce6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State= HAL_DMA_STATE_READY;
20002cea:	68fb      	ldr	r3, [r7, #12]
20002cec:	2201      	movs	r2, #1
20002cee:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      return HAL_ERROR;
20002cf2:	2301      	movs	r3, #1
20002cf4:	e018      	b.n	20002d28 <HAL_DMA_PollForTransfer+0x1b6>
   }
  }
  
  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
20002cf6:	7afb      	ldrb	r3, [r7, #11]
20002cf8:	2b00      	cmp	r3, #0
20002cfa:	d10e      	bne.n	20002d1a <HAL_DMA_PollForTransfer+0x1a8>
  {
    /* Clear the half transfer and transfer complete flags */
    regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
20002cfc:	68fb      	ldr	r3, [r7, #12]
20002cfe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002d00:	2230      	movs	r2, #48	; 0x30
20002d02:	409a      	lsls	r2, r3
20002d04:	697b      	ldr	r3, [r7, #20]
20002d06:	609a      	str	r2, [r3, #8]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20002d08:	68fb      	ldr	r3, [r7, #12]
20002d0a:	2200      	movs	r2, #0
20002d0c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    hdma->State = HAL_DMA_STATE_READY;
20002d10:	68fb      	ldr	r3, [r7, #12]
20002d12:	2201      	movs	r2, #1
20002d14:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
20002d18:	e005      	b.n	20002d26 <HAL_DMA_PollForTransfer+0x1b4>
  }
  else
  {
    /* Clear the half transfer flag */
    regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
20002d1a:	68fb      	ldr	r3, [r7, #12]
20002d1c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002d1e:	2210      	movs	r2, #16
20002d20:	409a      	lsls	r2, r3
20002d22:	697b      	ldr	r3, [r7, #20]
20002d24:	609a      	str	r2, [r3, #8]
  }
  
  return status;
20002d26:	7ffb      	ldrb	r3, [r7, #31]
}
20002d28:	4618      	mov	r0, r3
20002d2a:	3728      	adds	r7, #40	; 0x28
20002d2c:	46bd      	mov	sp, r7
20002d2e:	bd80      	pop	{r7, pc}

20002d30 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
20002d30:	b580      	push	{r7, lr}
20002d32:	b086      	sub	sp, #24
20002d34:	af00      	add	r7, sp, #0
20002d36:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0;
20002d38:	2300      	movs	r3, #0
20002d3a:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600;
20002d3c:	4b92      	ldr	r3, [pc, #584]	; (20002f88 <HAL_DMA_IRQHandler+0x258>)
20002d3e:	681b      	ldr	r3, [r3, #0]
20002d40:	4a92      	ldr	r2, [pc, #584]	; (20002f8c <HAL_DMA_IRQHandler+0x25c>)
20002d42:	fba2 2303 	umull	r2, r3, r2, r3
20002d46:	0a9b      	lsrs	r3, r3, #10
20002d48:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
20002d4a:	687b      	ldr	r3, [r7, #4]
20002d4c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002d4e:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
20002d50:	693b      	ldr	r3, [r7, #16]
20002d52:	681b      	ldr	r3, [r3, #0]
20002d54:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
20002d56:	687b      	ldr	r3, [r7, #4]
20002d58:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002d5a:	2208      	movs	r2, #8
20002d5c:	409a      	lsls	r2, r3
20002d5e:	68fb      	ldr	r3, [r7, #12]
20002d60:	4013      	ands	r3, r2
20002d62:	2b00      	cmp	r3, #0
20002d64:	d01a      	beq.n	20002d9c <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
20002d66:	687b      	ldr	r3, [r7, #4]
20002d68:	681b      	ldr	r3, [r3, #0]
20002d6a:	681b      	ldr	r3, [r3, #0]
20002d6c:	f003 0304 	and.w	r3, r3, #4
20002d70:	2b00      	cmp	r3, #0
20002d72:	d013      	beq.n	20002d9c <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
20002d74:	687b      	ldr	r3, [r7, #4]
20002d76:	681b      	ldr	r3, [r3, #0]
20002d78:	681a      	ldr	r2, [r3, #0]
20002d7a:	687b      	ldr	r3, [r7, #4]
20002d7c:	681b      	ldr	r3, [r3, #0]
20002d7e:	f022 0204 	bic.w	r2, r2, #4
20002d82:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
20002d84:	687b      	ldr	r3, [r7, #4]
20002d86:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002d88:	2208      	movs	r2, #8
20002d8a:	409a      	lsls	r2, r3
20002d8c:	693b      	ldr	r3, [r7, #16]
20002d8e:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
20002d90:	687b      	ldr	r3, [r7, #4]
20002d92:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002d94:	f043 0201 	orr.w	r2, r3, #1
20002d98:	687b      	ldr	r3, [r7, #4]
20002d9a:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
20002d9c:	687b      	ldr	r3, [r7, #4]
20002d9e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002da0:	2201      	movs	r2, #1
20002da2:	409a      	lsls	r2, r3
20002da4:	68fb      	ldr	r3, [r7, #12]
20002da6:	4013      	ands	r3, r2
20002da8:	2b00      	cmp	r3, #0
20002daa:	d012      	beq.n	20002dd2 <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
20002dac:	687b      	ldr	r3, [r7, #4]
20002dae:	681b      	ldr	r3, [r3, #0]
20002db0:	695b      	ldr	r3, [r3, #20]
20002db2:	f003 0380 	and.w	r3, r3, #128	; 0x80
20002db6:	2b00      	cmp	r3, #0
20002db8:	d00b      	beq.n	20002dd2 <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
20002dba:	687b      	ldr	r3, [r7, #4]
20002dbc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002dbe:	2201      	movs	r2, #1
20002dc0:	409a      	lsls	r2, r3
20002dc2:	693b      	ldr	r3, [r7, #16]
20002dc4:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
20002dc6:	687b      	ldr	r3, [r7, #4]
20002dc8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002dca:	f043 0202 	orr.w	r2, r3, #2
20002dce:	687b      	ldr	r3, [r7, #4]
20002dd0:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
20002dd2:	687b      	ldr	r3, [r7, #4]
20002dd4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002dd6:	2204      	movs	r2, #4
20002dd8:	409a      	lsls	r2, r3
20002dda:	68fb      	ldr	r3, [r7, #12]
20002ddc:	4013      	ands	r3, r2
20002dde:	2b00      	cmp	r3, #0
20002de0:	d012      	beq.n	20002e08 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
20002de2:	687b      	ldr	r3, [r7, #4]
20002de4:	681b      	ldr	r3, [r3, #0]
20002de6:	681b      	ldr	r3, [r3, #0]
20002de8:	f003 0302 	and.w	r3, r3, #2
20002dec:	2b00      	cmp	r3, #0
20002dee:	d00b      	beq.n	20002e08 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
20002df0:	687b      	ldr	r3, [r7, #4]
20002df2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002df4:	2204      	movs	r2, #4
20002df6:	409a      	lsls	r2, r3
20002df8:	693b      	ldr	r3, [r7, #16]
20002dfa:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
20002dfc:	687b      	ldr	r3, [r7, #4]
20002dfe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002e00:	f043 0204 	orr.w	r2, r3, #4
20002e04:	687b      	ldr	r3, [r7, #4]
20002e06:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
20002e08:	687b      	ldr	r3, [r7, #4]
20002e0a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002e0c:	2210      	movs	r2, #16
20002e0e:	409a      	lsls	r2, r3
20002e10:	68fb      	ldr	r3, [r7, #12]
20002e12:	4013      	ands	r3, r2
20002e14:	2b00      	cmp	r3, #0
20002e16:	d043      	beq.n	20002ea0 <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
20002e18:	687b      	ldr	r3, [r7, #4]
20002e1a:	681b      	ldr	r3, [r3, #0]
20002e1c:	681b      	ldr	r3, [r3, #0]
20002e1e:	f003 0308 	and.w	r3, r3, #8
20002e22:	2b00      	cmp	r3, #0
20002e24:	d03c      	beq.n	20002ea0 <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
20002e26:	687b      	ldr	r3, [r7, #4]
20002e28:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002e2a:	2210      	movs	r2, #16
20002e2c:	409a      	lsls	r2, r3
20002e2e:	693b      	ldr	r3, [r7, #16]
20002e30:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
20002e32:	687b      	ldr	r3, [r7, #4]
20002e34:	681b      	ldr	r3, [r3, #0]
20002e36:	681b      	ldr	r3, [r3, #0]
20002e38:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20002e3c:	2b00      	cmp	r3, #0
20002e3e:	d018      	beq.n	20002e72 <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
20002e40:	687b      	ldr	r3, [r7, #4]
20002e42:	681b      	ldr	r3, [r3, #0]
20002e44:	681b      	ldr	r3, [r3, #0]
20002e46:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
20002e4a:	2b00      	cmp	r3, #0
20002e4c:	d108      	bne.n	20002e60 <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
20002e4e:	687b      	ldr	r3, [r7, #4]
20002e50:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002e52:	2b00      	cmp	r3, #0
20002e54:	d024      	beq.n	20002ea0 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
20002e56:	687b      	ldr	r3, [r7, #4]
20002e58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002e5a:	6878      	ldr	r0, [r7, #4]
20002e5c:	4798      	blx	r3
20002e5e:	e01f      	b.n	20002ea0 <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
20002e60:	687b      	ldr	r3, [r7, #4]
20002e62:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002e64:	2b00      	cmp	r3, #0
20002e66:	d01b      	beq.n	20002ea0 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
20002e68:	687b      	ldr	r3, [r7, #4]
20002e6a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002e6c:	6878      	ldr	r0, [r7, #4]
20002e6e:	4798      	blx	r3
20002e70:	e016      	b.n	20002ea0 <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
20002e72:	687b      	ldr	r3, [r7, #4]
20002e74:	681b      	ldr	r3, [r3, #0]
20002e76:	681b      	ldr	r3, [r3, #0]
20002e78:	f403 7380 	and.w	r3, r3, #256	; 0x100
20002e7c:	2b00      	cmp	r3, #0
20002e7e:	d107      	bne.n	20002e90 <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
20002e80:	687b      	ldr	r3, [r7, #4]
20002e82:	681b      	ldr	r3, [r3, #0]
20002e84:	681a      	ldr	r2, [r3, #0]
20002e86:	687b      	ldr	r3, [r7, #4]
20002e88:	681b      	ldr	r3, [r3, #0]
20002e8a:	f022 0208 	bic.w	r2, r2, #8
20002e8e:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
20002e90:	687b      	ldr	r3, [r7, #4]
20002e92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002e94:	2b00      	cmp	r3, #0
20002e96:	d003      	beq.n	20002ea0 <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
20002e98:	687b      	ldr	r3, [r7, #4]
20002e9a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002e9c:	6878      	ldr	r0, [r7, #4]
20002e9e:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
20002ea0:	687b      	ldr	r3, [r7, #4]
20002ea2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002ea4:	2220      	movs	r2, #32
20002ea6:	409a      	lsls	r2, r3
20002ea8:	68fb      	ldr	r3, [r7, #12]
20002eaa:	4013      	ands	r3, r2
20002eac:	2b00      	cmp	r3, #0
20002eae:	f000 808e 	beq.w	20002fce <HAL_DMA_IRQHandler+0x29e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
20002eb2:	687b      	ldr	r3, [r7, #4]
20002eb4:	681b      	ldr	r3, [r3, #0]
20002eb6:	681b      	ldr	r3, [r3, #0]
20002eb8:	f003 0310 	and.w	r3, r3, #16
20002ebc:	2b00      	cmp	r3, #0
20002ebe:	f000 8086 	beq.w	20002fce <HAL_DMA_IRQHandler+0x29e>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
20002ec2:	687b      	ldr	r3, [r7, #4]
20002ec4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002ec6:	2220      	movs	r2, #32
20002ec8:	409a      	lsls	r2, r3
20002eca:	693b      	ldr	r3, [r7, #16]
20002ecc:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
20002ece:	687b      	ldr	r3, [r7, #4]
20002ed0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20002ed4:	b2db      	uxtb	r3, r3
20002ed6:	2b05      	cmp	r3, #5
20002ed8:	d136      	bne.n	20002f48 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
20002eda:	687b      	ldr	r3, [r7, #4]
20002edc:	681b      	ldr	r3, [r3, #0]
20002ede:	681a      	ldr	r2, [r3, #0]
20002ee0:	687b      	ldr	r3, [r7, #4]
20002ee2:	681b      	ldr	r3, [r3, #0]
20002ee4:	f022 0216 	bic.w	r2, r2, #22
20002ee8:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
20002eea:	687b      	ldr	r3, [r7, #4]
20002eec:	681b      	ldr	r3, [r3, #0]
20002eee:	695a      	ldr	r2, [r3, #20]
20002ef0:	687b      	ldr	r3, [r7, #4]
20002ef2:	681b      	ldr	r3, [r3, #0]
20002ef4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
20002ef8:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
20002efa:	687b      	ldr	r3, [r7, #4]
20002efc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002efe:	2b00      	cmp	r3, #0
20002f00:	d103      	bne.n	20002f0a <HAL_DMA_IRQHandler+0x1da>
20002f02:	687b      	ldr	r3, [r7, #4]
20002f04:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002f06:	2b00      	cmp	r3, #0
20002f08:	d007      	beq.n	20002f1a <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
20002f0a:	687b      	ldr	r3, [r7, #4]
20002f0c:	681b      	ldr	r3, [r3, #0]
20002f0e:	681a      	ldr	r2, [r3, #0]
20002f10:	687b      	ldr	r3, [r7, #4]
20002f12:	681b      	ldr	r3, [r3, #0]
20002f14:	f022 0208 	bic.w	r2, r2, #8
20002f18:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
20002f1a:	687b      	ldr	r3, [r7, #4]
20002f1c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002f1e:	223f      	movs	r2, #63	; 0x3f
20002f20:	409a      	lsls	r2, r3
20002f22:	693b      	ldr	r3, [r7, #16]
20002f24:	609a      	str	r2, [r3, #8]

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
20002f26:	687b      	ldr	r3, [r7, #4]
20002f28:	2200      	movs	r2, #0
20002f2a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
20002f2e:	687b      	ldr	r3, [r7, #4]
20002f30:	2201      	movs	r2, #1
20002f32:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        if(hdma->XferAbortCallback != NULL)
20002f36:	687b      	ldr	r3, [r7, #4]
20002f38:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20002f3a:	2b00      	cmp	r3, #0
20002f3c:	d07d      	beq.n	2000303a <HAL_DMA_IRQHandler+0x30a>
        {
          hdma->XferAbortCallback(hdma);
20002f3e:	687b      	ldr	r3, [r7, #4]
20002f40:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20002f42:	6878      	ldr	r0, [r7, #4]
20002f44:	4798      	blx	r3
        }
        return;
20002f46:	e078      	b.n	2000303a <HAL_DMA_IRQHandler+0x30a>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
20002f48:	687b      	ldr	r3, [r7, #4]
20002f4a:	681b      	ldr	r3, [r3, #0]
20002f4c:	681b      	ldr	r3, [r3, #0]
20002f4e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20002f52:	2b00      	cmp	r3, #0
20002f54:	d01c      	beq.n	20002f90 <HAL_DMA_IRQHandler+0x260>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
20002f56:	687b      	ldr	r3, [r7, #4]
20002f58:	681b      	ldr	r3, [r3, #0]
20002f5a:	681b      	ldr	r3, [r3, #0]
20002f5c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
20002f60:	2b00      	cmp	r3, #0
20002f62:	d108      	bne.n	20002f76 <HAL_DMA_IRQHandler+0x246>
        {
          if(hdma->XferM1CpltCallback != NULL)
20002f64:	687b      	ldr	r3, [r7, #4]
20002f66:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002f68:	2b00      	cmp	r3, #0
20002f6a:	d030      	beq.n	20002fce <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
20002f6c:	687b      	ldr	r3, [r7, #4]
20002f6e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002f70:	6878      	ldr	r0, [r7, #4]
20002f72:	4798      	blx	r3
20002f74:	e02b      	b.n	20002fce <HAL_DMA_IRQHandler+0x29e>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
20002f76:	687b      	ldr	r3, [r7, #4]
20002f78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20002f7a:	2b00      	cmp	r3, #0
20002f7c:	d027      	beq.n	20002fce <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
20002f7e:	687b      	ldr	r3, [r7, #4]
20002f80:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20002f82:	6878      	ldr	r0, [r7, #4]
20002f84:	4798      	blx	r3
20002f86:	e022      	b.n	20002fce <HAL_DMA_IRQHandler+0x29e>
20002f88:	20000410 	.word	0x20000410
20002f8c:	1b4e81b5 	.word	0x1b4e81b5
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
20002f90:	687b      	ldr	r3, [r7, #4]
20002f92:	681b      	ldr	r3, [r3, #0]
20002f94:	681b      	ldr	r3, [r3, #0]
20002f96:	f403 7380 	and.w	r3, r3, #256	; 0x100
20002f9a:	2b00      	cmp	r3, #0
20002f9c:	d10f      	bne.n	20002fbe <HAL_DMA_IRQHandler+0x28e>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
20002f9e:	687b      	ldr	r3, [r7, #4]
20002fa0:	681b      	ldr	r3, [r3, #0]
20002fa2:	681a      	ldr	r2, [r3, #0]
20002fa4:	687b      	ldr	r3, [r7, #4]
20002fa6:	681b      	ldr	r3, [r3, #0]
20002fa8:	f022 0210 	bic.w	r2, r2, #16
20002fac:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
20002fae:	687b      	ldr	r3, [r7, #4]
20002fb0:	2200      	movs	r2, #0
20002fb2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
20002fb6:	687b      	ldr	r3, [r7, #4]
20002fb8:	2201      	movs	r2, #1
20002fba:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
20002fbe:	687b      	ldr	r3, [r7, #4]
20002fc0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20002fc2:	2b00      	cmp	r3, #0
20002fc4:	d003      	beq.n	20002fce <HAL_DMA_IRQHandler+0x29e>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
20002fc6:	687b      	ldr	r3, [r7, #4]
20002fc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20002fca:	6878      	ldr	r0, [r7, #4]
20002fcc:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
20002fce:	687b      	ldr	r3, [r7, #4]
20002fd0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002fd2:	2b00      	cmp	r3, #0
20002fd4:	d032      	beq.n	2000303c <HAL_DMA_IRQHandler+0x30c>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
20002fd6:	687b      	ldr	r3, [r7, #4]
20002fd8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002fda:	f003 0301 	and.w	r3, r3, #1
20002fde:	2b00      	cmp	r3, #0
20002fe0:	d022      	beq.n	20003028 <HAL_DMA_IRQHandler+0x2f8>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
20002fe2:	687b      	ldr	r3, [r7, #4]
20002fe4:	2205      	movs	r2, #5
20002fe6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
20002fea:	687b      	ldr	r3, [r7, #4]
20002fec:	681b      	ldr	r3, [r3, #0]
20002fee:	681a      	ldr	r2, [r3, #0]
20002ff0:	687b      	ldr	r3, [r7, #4]
20002ff2:	681b      	ldr	r3, [r3, #0]
20002ff4:	f022 0201 	bic.w	r2, r2, #1
20002ff8:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
20002ffa:	68bb      	ldr	r3, [r7, #8]
20002ffc:	3301      	adds	r3, #1
20002ffe:	60bb      	str	r3, [r7, #8]
20003000:	697a      	ldr	r2, [r7, #20]
20003002:	429a      	cmp	r2, r3
20003004:	d307      	bcc.n	20003016 <HAL_DMA_IRQHandler+0x2e6>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
20003006:	687b      	ldr	r3, [r7, #4]
20003008:	681b      	ldr	r3, [r3, #0]
2000300a:	681b      	ldr	r3, [r3, #0]
2000300c:	f003 0301 	and.w	r3, r3, #1
20003010:	2b00      	cmp	r3, #0
20003012:	d1f2      	bne.n	20002ffa <HAL_DMA_IRQHandler+0x2ca>
20003014:	e000      	b.n	20003018 <HAL_DMA_IRQHandler+0x2e8>
          break;
20003016:	bf00      	nop

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
20003018:	687b      	ldr	r3, [r7, #4]
2000301a:	2200      	movs	r2, #0
2000301c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
20003020:	687b      	ldr	r3, [r7, #4]
20003022:	2201      	movs	r2, #1
20003024:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
20003028:	687b      	ldr	r3, [r7, #4]
2000302a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000302c:	2b00      	cmp	r3, #0
2000302e:	d005      	beq.n	2000303c <HAL_DMA_IRQHandler+0x30c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
20003030:	687b      	ldr	r3, [r7, #4]
20003032:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20003034:	6878      	ldr	r0, [r7, #4]
20003036:	4798      	blx	r3
20003038:	e000      	b.n	2000303c <HAL_DMA_IRQHandler+0x30c>
        return;
2000303a:	bf00      	nop
    }
  }
}
2000303c:	3718      	adds	r7, #24
2000303e:	46bd      	mov	sp, r7
20003040:	bd80      	pop	{r7, pc}
20003042:	bf00      	nop

20003044 <HAL_DMA_RegisterCallback>:
  * @param  pCallback            pointer to private callbacsk function which has pointer to 
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */                      
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
20003044:	b480      	push	{r7}
20003046:	b087      	sub	sp, #28
20003048:	af00      	add	r7, sp, #0
2000304a:	60f8      	str	r0, [r7, #12]
2000304c:	460b      	mov	r3, r1
2000304e:	607a      	str	r2, [r7, #4]
20003050:	72fb      	strb	r3, [r7, #11]

  HAL_StatusTypeDef status = HAL_OK;
20003052:	2300      	movs	r3, #0
20003054:	75fb      	strb	r3, [r7, #23]

  /* Process locked */
  __HAL_LOCK(hdma);
20003056:	68fb      	ldr	r3, [r7, #12]
20003058:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2000305c:	2b01      	cmp	r3, #1
2000305e:	d101      	bne.n	20003064 <HAL_DMA_RegisterCallback+0x20>
20003060:	2302      	movs	r3, #2
20003062:	e03c      	b.n	200030de <HAL_DMA_RegisterCallback+0x9a>
20003064:	68fb      	ldr	r3, [r7, #12]
20003066:	2201      	movs	r2, #1
20003068:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
2000306c:	68fb      	ldr	r3, [r7, #12]
2000306e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20003072:	b2db      	uxtb	r3, r3
20003074:	2b01      	cmp	r3, #1
20003076:	d129      	bne.n	200030cc <HAL_DMA_RegisterCallback+0x88>
  {
    switch (CallbackID)
20003078:	7afb      	ldrb	r3, [r7, #11]
2000307a:	2b05      	cmp	r3, #5
2000307c:	d829      	bhi.n	200030d2 <HAL_DMA_RegisterCallback+0x8e>
2000307e:	a201      	add	r2, pc, #4	; (adr r2, 20003084 <HAL_DMA_RegisterCallback+0x40>)
20003080:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20003084:	2000309d 	.word	0x2000309d
20003088:	200030a5 	.word	0x200030a5
2000308c:	200030ad 	.word	0x200030ad
20003090:	200030b5 	.word	0x200030b5
20003094:	200030bd 	.word	0x200030bd
20003098:	200030c5 	.word	0x200030c5
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = pCallback;
2000309c:	68fb      	ldr	r3, [r7, #12]
2000309e:	687a      	ldr	r2, [r7, #4]
200030a0:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
200030a2:	e017      	b.n	200030d4 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = pCallback;
200030a4:	68fb      	ldr	r3, [r7, #12]
200030a6:	687a      	ldr	r2, [r7, #4]
200030a8:	641a      	str	r2, [r3, #64]	; 0x40
      break;
200030aa:	e013      	b.n	200030d4 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = pCallback;
200030ac:	68fb      	ldr	r3, [r7, #12]
200030ae:	687a      	ldr	r2, [r7, #4]
200030b0:	645a      	str	r2, [r3, #68]	; 0x44
      break;
200030b2:	e00f      	b.n	200030d4 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = pCallback;
200030b4:	68fb      	ldr	r3, [r7, #12]
200030b6:	687a      	ldr	r2, [r7, #4]
200030b8:	649a      	str	r2, [r3, #72]	; 0x48
      break;
200030ba:	e00b      	b.n	200030d4 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = pCallback;
200030bc:	68fb      	ldr	r3, [r7, #12]
200030be:	687a      	ldr	r2, [r7, #4]
200030c0:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
200030c2:	e007      	b.n	200030d4 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = pCallback;
200030c4:	68fb      	ldr	r3, [r7, #12]
200030c6:	687a      	ldr	r2, [r7, #4]
200030c8:	651a      	str	r2, [r3, #80]	; 0x50
      break;
200030ca:	e003      	b.n	200030d4 <HAL_DMA_RegisterCallback+0x90>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
200030cc:	2301      	movs	r3, #1
200030ce:	75fb      	strb	r3, [r7, #23]
200030d0:	e000      	b.n	200030d4 <HAL_DMA_RegisterCallback+0x90>
      break;
200030d2:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
200030d4:	68fb      	ldr	r3, [r7, #12]
200030d6:	2200      	movs	r2, #0
200030d8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  return status;
200030dc:	7dfb      	ldrb	r3, [r7, #23]
}
200030de:	4618      	mov	r0, r3
200030e0:	371c      	adds	r7, #28
200030e2:	46bd      	mov	sp, r7
200030e4:	f85d 7b04 	ldr.w	r7, [sp], #4
200030e8:	4770      	bx	lr
200030ea:	bf00      	nop

200030ec <HAL_DMA_UnRegisterCallback>:
  * @param  CallbackID           User Callback identifer
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */              
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
{
200030ec:	b480      	push	{r7}
200030ee:	b085      	sub	sp, #20
200030f0:	af00      	add	r7, sp, #0
200030f2:	6078      	str	r0, [r7, #4]
200030f4:	460b      	mov	r3, r1
200030f6:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
200030f8:	2300      	movs	r3, #0
200030fa:	73fb      	strb	r3, [r7, #15]
  
  /* Process locked */
  __HAL_LOCK(hdma);
200030fc:	687b      	ldr	r3, [r7, #4]
200030fe:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20003102:	2b01      	cmp	r3, #1
20003104:	d101      	bne.n	2000310a <HAL_DMA_UnRegisterCallback+0x1e>
20003106:	2302      	movs	r3, #2
20003108:	e054      	b.n	200031b4 <HAL_DMA_UnRegisterCallback+0xc8>
2000310a:	687b      	ldr	r3, [r7, #4]
2000310c:	2201      	movs	r2, #1
2000310e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
20003112:	687b      	ldr	r3, [r7, #4]
20003114:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
20003118:	b2db      	uxtb	r3, r3
2000311a:	2b01      	cmp	r3, #1
2000311c:	d143      	bne.n	200031a6 <HAL_DMA_UnRegisterCallback+0xba>
  {
    switch (CallbackID)
2000311e:	78fb      	ldrb	r3, [r7, #3]
20003120:	2b06      	cmp	r3, #6
20003122:	d83c      	bhi.n	2000319e <HAL_DMA_UnRegisterCallback+0xb2>
20003124:	a201      	add	r2, pc, #4	; (adr r2, 2000312c <HAL_DMA_UnRegisterCallback+0x40>)
20003126:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000312a:	bf00      	nop
2000312c:	20003149 	.word	0x20003149
20003130:	20003151 	.word	0x20003151
20003134:	20003159 	.word	0x20003159
20003138:	20003161 	.word	0x20003161
2000313c:	20003169 	.word	0x20003169
20003140:	20003171 	.word	0x20003171
20003144:	20003179 	.word	0x20003179
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = NULL;
20003148:	687b      	ldr	r3, [r7, #4]
2000314a:	2200      	movs	r2, #0
2000314c:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
2000314e:	e02c      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
      
    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = NULL;
20003150:	687b      	ldr	r3, [r7, #4]
20003152:	2200      	movs	r2, #0
20003154:	641a      	str	r2, [r3, #64]	; 0x40
      break;
20003156:	e028      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
      
    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = NULL;
20003158:	687b      	ldr	r3, [r7, #4]
2000315a:	2200      	movs	r2, #0
2000315c:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2000315e:	e024      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
      
    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = NULL;
20003160:	687b      	ldr	r3, [r7, #4]
20003162:	2200      	movs	r2, #0
20003164:	649a      	str	r2, [r3, #72]	; 0x48
      break;
20003166:	e020      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
      
    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = NULL;
20003168:	687b      	ldr	r3, [r7, #4]
2000316a:	2200      	movs	r2, #0
2000316c:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2000316e:	e01c      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
      
    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = NULL;
20003170:	687b      	ldr	r3, [r7, #4]
20003172:	2200      	movs	r2, #0
20003174:	651a      	str	r2, [r3, #80]	; 0x50
      break; 
20003176:	e018      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
      
    case   HAL_DMA_XFER_ALL_CB_ID:
      hdma->XferCpltCallback = NULL;
20003178:	687b      	ldr	r3, [r7, #4]
2000317a:	2200      	movs	r2, #0
2000317c:	63da      	str	r2, [r3, #60]	; 0x3c
      hdma->XferHalfCpltCallback = NULL;
2000317e:	687b      	ldr	r3, [r7, #4]
20003180:	2200      	movs	r2, #0
20003182:	641a      	str	r2, [r3, #64]	; 0x40
      hdma->XferM1CpltCallback = NULL;
20003184:	687b      	ldr	r3, [r7, #4]
20003186:	2200      	movs	r2, #0
20003188:	645a      	str	r2, [r3, #68]	; 0x44
      hdma->XferM1HalfCpltCallback = NULL;
2000318a:	687b      	ldr	r3, [r7, #4]
2000318c:	2200      	movs	r2, #0
2000318e:	649a      	str	r2, [r3, #72]	; 0x48
      hdma->XferErrorCallback = NULL;
20003190:	687b      	ldr	r3, [r7, #4]
20003192:	2200      	movs	r2, #0
20003194:	64da      	str	r2, [r3, #76]	; 0x4c
      hdma->XferAbortCallback = NULL;
20003196:	687b      	ldr	r3, [r7, #4]
20003198:	2200      	movs	r2, #0
2000319a:	651a      	str	r2, [r3, #80]	; 0x50
      break; 
2000319c:	e005      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
      
    default:
      status = HAL_ERROR;
2000319e:	2301      	movs	r3, #1
200031a0:	73fb      	strb	r3, [r7, #15]
      break;
200031a2:	bf00      	nop
200031a4:	e001      	b.n	200031aa <HAL_DMA_UnRegisterCallback+0xbe>
    }
  }
  else
  {
    status = HAL_ERROR;
200031a6:	2301      	movs	r3, #1
200031a8:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hdma);
200031aa:	687b      	ldr	r3, [r7, #4]
200031ac:	2200      	movs	r2, #0
200031ae:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  return status;
200031b2:	7bfb      	ldrb	r3, [r7, #15]
}
200031b4:	4618      	mov	r0, r3
200031b6:	3714      	adds	r7, #20
200031b8:	46bd      	mov	sp, r7
200031ba:	f85d 7b04 	ldr.w	r7, [sp], #4
200031be:	4770      	bx	lr

200031c0 <HAL_DMA_GetState>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
200031c0:	b480      	push	{r7}
200031c2:	b083      	sub	sp, #12
200031c4:	af00      	add	r7, sp, #0
200031c6:	6078      	str	r0, [r7, #4]
  return hdma->State;
200031c8:	687b      	ldr	r3, [r7, #4]
200031ca:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200031ce:	b2db      	uxtb	r3, r3
}
200031d0:	4618      	mov	r0, r3
200031d2:	370c      	adds	r7, #12
200031d4:	46bd      	mov	sp, r7
200031d6:	f85d 7b04 	ldr.w	r7, [sp], #4
200031da:	4770      	bx	lr

200031dc <HAL_DMA_GetError>:
  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
200031dc:	b480      	push	{r7}
200031de:	b083      	sub	sp, #12
200031e0:	af00      	add	r7, sp, #0
200031e2:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
200031e4:	687b      	ldr	r3, [r7, #4]
200031e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
200031e8:	4618      	mov	r0, r3
200031ea:	370c      	adds	r7, #12
200031ec:	46bd      	mov	sp, r7
200031ee:	f85d 7b04 	ldr.w	r7, [sp], #4
200031f2:	4770      	bx	lr

200031f4 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
200031f4:	b480      	push	{r7}
200031f6:	b085      	sub	sp, #20
200031f8:	af00      	add	r7, sp, #0
200031fa:	60f8      	str	r0, [r7, #12]
200031fc:	60b9      	str	r1, [r7, #8]
200031fe:	607a      	str	r2, [r7, #4]
20003200:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
20003202:	68fb      	ldr	r3, [r7, #12]
20003204:	681b      	ldr	r3, [r3, #0]
20003206:	681a      	ldr	r2, [r3, #0]
20003208:	68fb      	ldr	r3, [r7, #12]
2000320a:	681b      	ldr	r3, [r3, #0]
2000320c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
20003210:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
20003212:	68fb      	ldr	r3, [r7, #12]
20003214:	681b      	ldr	r3, [r3, #0]
20003216:	683a      	ldr	r2, [r7, #0]
20003218:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
2000321a:	68fb      	ldr	r3, [r7, #12]
2000321c:	689b      	ldr	r3, [r3, #8]
2000321e:	2b40      	cmp	r3, #64	; 0x40
20003220:	d108      	bne.n	20003234 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
20003222:	68fb      	ldr	r3, [r7, #12]
20003224:	681b      	ldr	r3, [r3, #0]
20003226:	687a      	ldr	r2, [r7, #4]
20003228:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
2000322a:	68fb      	ldr	r3, [r7, #12]
2000322c:	681b      	ldr	r3, [r3, #0]
2000322e:	68ba      	ldr	r2, [r7, #8]
20003230:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
20003232:	e007      	b.n	20003244 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
20003234:	68fb      	ldr	r3, [r7, #12]
20003236:	681b      	ldr	r3, [r3, #0]
20003238:	68ba      	ldr	r2, [r7, #8]
2000323a:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
2000323c:	68fb      	ldr	r3, [r7, #12]
2000323e:	681b      	ldr	r3, [r3, #0]
20003240:	687a      	ldr	r2, [r7, #4]
20003242:	60da      	str	r2, [r3, #12]
}
20003244:	bf00      	nop
20003246:	3714      	adds	r7, #20
20003248:	46bd      	mov	sp, r7
2000324a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000324e:	4770      	bx	lr

20003250 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
20003250:	b480      	push	{r7}
20003252:	b085      	sub	sp, #20
20003254:	af00      	add	r7, sp, #0
20003256:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
20003258:	687b      	ldr	r3, [r7, #4]
2000325a:	681b      	ldr	r3, [r3, #0]
2000325c:	b2db      	uxtb	r3, r3
2000325e:	3b10      	subs	r3, #16
20003260:	4a13      	ldr	r2, [pc, #76]	; (200032b0 <DMA_CalcBaseAndBitshift+0x60>)
20003262:	fba2 2303 	umull	r2, r3, r2, r3
20003266:	091b      	lsrs	r3, r3, #4
20003268:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
2000326a:	4a12      	ldr	r2, [pc, #72]	; (200032b4 <DMA_CalcBaseAndBitshift+0x64>)
2000326c:	68fb      	ldr	r3, [r7, #12]
2000326e:	4413      	add	r3, r2
20003270:	781b      	ldrb	r3, [r3, #0]
20003272:	461a      	mov	r2, r3
20003274:	687b      	ldr	r3, [r7, #4]
20003276:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
20003278:	68fb      	ldr	r3, [r7, #12]
2000327a:	2b03      	cmp	r3, #3
2000327c:	d908      	bls.n	20003290 <DMA_CalcBaseAndBitshift+0x40>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
2000327e:	687b      	ldr	r3, [r7, #4]
20003280:	681b      	ldr	r3, [r3, #0]
20003282:	461a      	mov	r2, r3
20003284:	4b0c      	ldr	r3, [pc, #48]	; (200032b8 <DMA_CalcBaseAndBitshift+0x68>)
20003286:	4013      	ands	r3, r2
20003288:	1d1a      	adds	r2, r3, #4
2000328a:	687b      	ldr	r3, [r7, #4]
2000328c:	659a      	str	r2, [r3, #88]	; 0x58
2000328e:	e006      	b.n	2000329e <DMA_CalcBaseAndBitshift+0x4e>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
20003290:	687b      	ldr	r3, [r7, #4]
20003292:	681b      	ldr	r3, [r3, #0]
20003294:	461a      	mov	r2, r3
20003296:	4b08      	ldr	r3, [pc, #32]	; (200032b8 <DMA_CalcBaseAndBitshift+0x68>)
20003298:	4013      	ands	r3, r2
2000329a:	687a      	ldr	r2, [r7, #4]
2000329c:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
2000329e:	687b      	ldr	r3, [r7, #4]
200032a0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
200032a2:	4618      	mov	r0, r3
200032a4:	3714      	adds	r7, #20
200032a6:	46bd      	mov	sp, r7
200032a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200032ac:	4770      	bx	lr
200032ae:	bf00      	nop
200032b0:	aaaaaaab 	.word	0xaaaaaaab
200032b4:	2000e700 	.word	0x2000e700
200032b8:	fffffc00 	.word	0xfffffc00

200032bc <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
200032bc:	b480      	push	{r7}
200032be:	b085      	sub	sp, #20
200032c0:	af00      	add	r7, sp, #0
200032c2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
200032c4:	2300      	movs	r3, #0
200032c6:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
200032c8:	687b      	ldr	r3, [r7, #4]
200032ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200032cc:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
200032ce:	687b      	ldr	r3, [r7, #4]
200032d0:	699b      	ldr	r3, [r3, #24]
200032d2:	2b00      	cmp	r3, #0
200032d4:	d11f      	bne.n	20003316 <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
200032d6:	68bb      	ldr	r3, [r7, #8]
200032d8:	2b03      	cmp	r3, #3
200032da:	d855      	bhi.n	20003388 <DMA_CheckFifoParam+0xcc>
200032dc:	a201      	add	r2, pc, #4	; (adr r2, 200032e4 <DMA_CheckFifoParam+0x28>)
200032de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200032e2:	bf00      	nop
200032e4:	200032f5 	.word	0x200032f5
200032e8:	20003307 	.word	0x20003307
200032ec:	200032f5 	.word	0x200032f5
200032f0:	20003389 	.word	0x20003389
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
200032f4:	687b      	ldr	r3, [r7, #4]
200032f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200032f8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
200032fc:	2b00      	cmp	r3, #0
200032fe:	d045      	beq.n	2000338c <DMA_CheckFifoParam+0xd0>
      {
        status = HAL_ERROR;
20003300:	2301      	movs	r3, #1
20003302:	73fb      	strb	r3, [r7, #15]
      }
      break;
20003304:	e042      	b.n	2000338c <DMA_CheckFifoParam+0xd0>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
20003306:	687b      	ldr	r3, [r7, #4]
20003308:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000330a:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
2000330e:	d13f      	bne.n	20003390 <DMA_CheckFifoParam+0xd4>
      {
        status = HAL_ERROR;
20003310:	2301      	movs	r3, #1
20003312:	73fb      	strb	r3, [r7, #15]
      }
      break;
20003314:	e03c      	b.n	20003390 <DMA_CheckFifoParam+0xd4>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
20003316:	687b      	ldr	r3, [r7, #4]
20003318:	699b      	ldr	r3, [r3, #24]
2000331a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2000331e:	d121      	bne.n	20003364 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
20003320:	68bb      	ldr	r3, [r7, #8]
20003322:	2b03      	cmp	r3, #3
20003324:	d836      	bhi.n	20003394 <DMA_CheckFifoParam+0xd8>
20003326:	a201      	add	r2, pc, #4	; (adr r2, 2000332c <DMA_CheckFifoParam+0x70>)
20003328:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000332c:	2000333d 	.word	0x2000333d
20003330:	20003343 	.word	0x20003343
20003334:	2000333d 	.word	0x2000333d
20003338:	20003355 	.word	0x20003355
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
2000333c:	2301      	movs	r3, #1
2000333e:	73fb      	strb	r3, [r7, #15]
      break;
20003340:	e02f      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
20003342:	687b      	ldr	r3, [r7, #4]
20003344:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003346:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000334a:	2b00      	cmp	r3, #0
2000334c:	d024      	beq.n	20003398 <DMA_CheckFifoParam+0xdc>
      {
        status = HAL_ERROR;
2000334e:	2301      	movs	r3, #1
20003350:	73fb      	strb	r3, [r7, #15]
      }
      break;
20003352:	e021      	b.n	20003398 <DMA_CheckFifoParam+0xdc>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
20003354:	687b      	ldr	r3, [r7, #4]
20003356:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003358:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
2000335c:	d11e      	bne.n	2000339c <DMA_CheckFifoParam+0xe0>
      {
        status = HAL_ERROR;
2000335e:	2301      	movs	r3, #1
20003360:	73fb      	strb	r3, [r7, #15]
      }
      break;   
20003362:	e01b      	b.n	2000339c <DMA_CheckFifoParam+0xe0>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
20003364:	68bb      	ldr	r3, [r7, #8]
20003366:	2b02      	cmp	r3, #2
20003368:	d902      	bls.n	20003370 <DMA_CheckFifoParam+0xb4>
2000336a:	2b03      	cmp	r3, #3
2000336c:	d003      	beq.n	20003376 <DMA_CheckFifoParam+0xba>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
2000336e:	e018      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      status = HAL_ERROR;
20003370:	2301      	movs	r3, #1
20003372:	73fb      	strb	r3, [r7, #15]
      break;
20003374:	e015      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
20003376:	687b      	ldr	r3, [r7, #4]
20003378:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000337a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000337e:	2b00      	cmp	r3, #0
20003380:	d00e      	beq.n	200033a0 <DMA_CheckFifoParam+0xe4>
        status = HAL_ERROR;
20003382:	2301      	movs	r3, #1
20003384:	73fb      	strb	r3, [r7, #15]
      break;
20003386:	e00b      	b.n	200033a0 <DMA_CheckFifoParam+0xe4>
      break;
20003388:	bf00      	nop
2000338a:	e00a      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      break;
2000338c:	bf00      	nop
2000338e:	e008      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      break;
20003390:	bf00      	nop
20003392:	e006      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      break;
20003394:	bf00      	nop
20003396:	e004      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      break;
20003398:	bf00      	nop
2000339a:	e002      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      break;   
2000339c:	bf00      	nop
2000339e:	e000      	b.n	200033a2 <DMA_CheckFifoParam+0xe6>
      break;
200033a0:	bf00      	nop
    }
  } 
  
  return status; 
200033a2:	7bfb      	ldrb	r3, [r7, #15]
}
200033a4:	4618      	mov	r0, r3
200033a6:	3714      	adds	r7, #20
200033a8:	46bd      	mov	sp, r7
200033aa:	f85d 7b04 	ldr.w	r7, [sp], #4
200033ae:	4770      	bx	lr

200033b0 <HAL_DMAEx_MultiBufferStart>:
  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
200033b0:	b580      	push	{r7, lr}
200033b2:	b086      	sub	sp, #24
200033b4:	af00      	add	r7, sp, #0
200033b6:	60f8      	str	r0, [r7, #12]
200033b8:	60b9      	str	r1, [r7, #8]
200033ba:	607a      	str	r2, [r7, #4]
200033bc:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
200033be:	2300      	movs	r3, #0
200033c0:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
200033c2:	68fb      	ldr	r3, [r7, #12]
200033c4:	689b      	ldr	r3, [r3, #8]
200033c6:	2b80      	cmp	r3, #128	; 0x80
200033c8:	d106      	bne.n	200033d8 <HAL_DMAEx_MultiBufferStart+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
200033ca:	68fb      	ldr	r3, [r7, #12]
200033cc:	f44f 7280 	mov.w	r2, #256	; 0x100
200033d0:	655a      	str	r2, [r3, #84]	; 0x54
    status = HAL_ERROR;
200033d2:	2301      	movs	r3, #1
200033d4:	75fb      	strb	r3, [r7, #23]
200033d6:	e031      	b.n	2000343c <HAL_DMAEx_MultiBufferStart+0x8c>
  }
  else
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
200033d8:	68fb      	ldr	r3, [r7, #12]
200033da:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
200033de:	2b01      	cmp	r3, #1
200033e0:	d101      	bne.n	200033e6 <HAL_DMAEx_MultiBufferStart+0x36>
200033e2:	2302      	movs	r3, #2
200033e4:	e02b      	b.n	2000343e <HAL_DMAEx_MultiBufferStart+0x8e>
200033e6:	68fb      	ldr	r3, [r7, #12]
200033e8:	2201      	movs	r2, #1
200033ea:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    if(HAL_DMA_STATE_READY == hdma->State)
200033ee:	68fb      	ldr	r3, [r7, #12]
200033f0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
200033f4:	b2db      	uxtb	r3, r3
200033f6:	2b01      	cmp	r3, #1
200033f8:	d11e      	bne.n	20003438 <HAL_DMAEx_MultiBufferStart+0x88>
    {
      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_BUSY; 
200033fa:	68fb      	ldr	r3, [r7, #12]
200033fc:	2202      	movs	r2, #2
200033fe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      /* Enable the double buffer mode */
      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
20003402:	68fb      	ldr	r3, [r7, #12]
20003404:	681b      	ldr	r3, [r3, #0]
20003406:	681a      	ldr	r2, [r3, #0]
20003408:	68fb      	ldr	r3, [r7, #12]
2000340a:	681b      	ldr	r3, [r3, #0]
2000340c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
20003410:	601a      	str	r2, [r3, #0]
      
      /* Configure DMA Stream destination address */
      hdma->Instance->M1AR = SecondMemAddress;
20003412:	68fb      	ldr	r3, [r7, #12]
20003414:	681b      	ldr	r3, [r3, #0]
20003416:	683a      	ldr	r2, [r7, #0]
20003418:	611a      	str	r2, [r3, #16]
      
      /* Configure the source, destination address and the data length */
      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
2000341a:	6a3b      	ldr	r3, [r7, #32]
2000341c:	687a      	ldr	r2, [r7, #4]
2000341e:	68b9      	ldr	r1, [r7, #8]
20003420:	68f8      	ldr	r0, [r7, #12]
20003422:	f001 f961 	bl	200046e8 <DMA_MultiBufferSetConfig>
      
      /* Enable the peripheral */
      __HAL_DMA_ENABLE(hdma);
20003426:	68fb      	ldr	r3, [r7, #12]
20003428:	681b      	ldr	r3, [r3, #0]
2000342a:	681a      	ldr	r2, [r3, #0]
2000342c:	68fb      	ldr	r3, [r7, #12]
2000342e:	681b      	ldr	r3, [r3, #0]
20003430:	f042 0201 	orr.w	r2, r2, #1
20003434:	601a      	str	r2, [r3, #0]
20003436:	e001      	b.n	2000343c <HAL_DMAEx_MultiBufferStart+0x8c>
    }
    else
    {
      /* Return error status */
      status = HAL_BUSY;
20003438:	2302      	movs	r3, #2
2000343a:	75fb      	strb	r3, [r7, #23]
    }
  }
  return status;
2000343c:	7dfb      	ldrb	r3, [r7, #23]
}
2000343e:	4618      	mov	r0, r3
20003440:	3718      	adds	r7, #24
20003442:	46bd      	mov	sp, r7
20003444:	bd80      	pop	{r7, pc}
	...

20003448 <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
20003448:	b580      	push	{r7, lr}
2000344a:	b086      	sub	sp, #24
2000344c:	af00      	add	r7, sp, #0
2000344e:	60f8      	str	r0, [r7, #12]
20003450:	60b9      	str	r1, [r7, #8]
20003452:	607a      	str	r2, [r7, #4]
20003454:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20003456:	2300      	movs	r3, #0
20003458:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
2000345a:	68fb      	ldr	r3, [r7, #12]
2000345c:	689b      	ldr	r3, [r3, #8]
2000345e:	2b80      	cmp	r3, #128	; 0x80
20003460:	d106      	bne.n	20003470 <HAL_DMAEx_MultiBufferStart_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
20003462:	68fb      	ldr	r3, [r7, #12]
20003464:	f44f 7280 	mov.w	r2, #256	; 0x100
20003468:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
2000346a:	2301      	movs	r3, #1
2000346c:	f001 b901 	b.w	20004672 <HAL_DMAEx_MultiBufferStart_IT+0x122a>
  }
  
  /* Process locked */
  __HAL_LOCK(hdma);
20003470:	68fb      	ldr	r3, [r7, #12]
20003472:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20003476:	2b01      	cmp	r3, #1
20003478:	d102      	bne.n	20003480 <HAL_DMAEx_MultiBufferStart_IT+0x38>
2000347a:	2302      	movs	r3, #2
2000347c:	f001 b8f9 	b.w	20004672 <HAL_DMAEx_MultiBufferStart_IT+0x122a>
20003480:	68fb      	ldr	r3, [r7, #12]
20003482:	2201      	movs	r2, #1
20003484:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
20003488:	68fb      	ldr	r3, [r7, #12]
2000348a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2000348e:	b2db      	uxtb	r3, r3
20003490:	2b01      	cmp	r3, #1
20003492:	f041 80e7 	bne.w	20004664 <HAL_DMAEx_MultiBufferStart_IT+0x121c>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
20003496:	68fb      	ldr	r3, [r7, #12]
20003498:	2202      	movs	r2, #2
2000349a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2000349e:	68fb      	ldr	r3, [r7, #12]
200034a0:	2200      	movs	r2, #0
200034a2:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Enable the Double buffer mode */
    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
200034a4:	68fb      	ldr	r3, [r7, #12]
200034a6:	681b      	ldr	r3, [r3, #0]
200034a8:	681a      	ldr	r2, [r3, #0]
200034aa:	68fb      	ldr	r3, [r7, #12]
200034ac:	681b      	ldr	r3, [r3, #0]
200034ae:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
200034b2:	601a      	str	r2, [r3, #0]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M1AR = SecondMemAddress;
200034b4:	68fb      	ldr	r3, [r7, #12]
200034b6:	681b      	ldr	r3, [r3, #0]
200034b8:	683a      	ldr	r2, [r7, #0]
200034ba:	611a      	str	r2, [r3, #16]
    
    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); 
200034bc:	6a3b      	ldr	r3, [r7, #32]
200034be:	687a      	ldr	r2, [r7, #4]
200034c0:	68b9      	ldr	r1, [r7, #8]
200034c2:	68f8      	ldr	r0, [r7, #12]
200034c4:	f001 f910 	bl	200046e8 <DMA_MultiBufferSetConfig>
    
    /* Clear all flags */
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
200034c8:	68fb      	ldr	r3, [r7, #12]
200034ca:	681b      	ldr	r3, [r3, #0]
200034cc:	461a      	mov	r2, r3
200034ce:	4b99      	ldr	r3, [pc, #612]	; (20003734 <HAL_DMAEx_MultiBufferStart_IT+0x2ec>)
200034d0:	429a      	cmp	r2, r3
200034d2:	d960      	bls.n	20003596 <HAL_DMAEx_MultiBufferStart_IT+0x14e>
200034d4:	68fb      	ldr	r3, [r7, #12]
200034d6:	681b      	ldr	r3, [r3, #0]
200034d8:	4a97      	ldr	r2, [pc, #604]	; (20003738 <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
200034da:	4293      	cmp	r3, r2
200034dc:	d057      	beq.n	2000358e <HAL_DMAEx_MultiBufferStart_IT+0x146>
200034de:	68fb      	ldr	r3, [r7, #12]
200034e0:	681b      	ldr	r3, [r3, #0]
200034e2:	4a96      	ldr	r2, [pc, #600]	; (2000373c <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
200034e4:	4293      	cmp	r3, r2
200034e6:	d050      	beq.n	2000358a <HAL_DMAEx_MultiBufferStart_IT+0x142>
200034e8:	68fb      	ldr	r3, [r7, #12]
200034ea:	681b      	ldr	r3, [r3, #0]
200034ec:	4a94      	ldr	r2, [pc, #592]	; (20003740 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
200034ee:	4293      	cmp	r3, r2
200034f0:	d049      	beq.n	20003586 <HAL_DMAEx_MultiBufferStart_IT+0x13e>
200034f2:	68fb      	ldr	r3, [r7, #12]
200034f4:	681b      	ldr	r3, [r3, #0]
200034f6:	4a93      	ldr	r2, [pc, #588]	; (20003744 <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
200034f8:	4293      	cmp	r3, r2
200034fa:	d042      	beq.n	20003582 <HAL_DMAEx_MultiBufferStart_IT+0x13a>
200034fc:	68fb      	ldr	r3, [r7, #12]
200034fe:	681b      	ldr	r3, [r3, #0]
20003500:	4a91      	ldr	r2, [pc, #580]	; (20003748 <HAL_DMAEx_MultiBufferStart_IT+0x300>)
20003502:	4293      	cmp	r3, r2
20003504:	d03a      	beq.n	2000357c <HAL_DMAEx_MultiBufferStart_IT+0x134>
20003506:	68fb      	ldr	r3, [r7, #12]
20003508:	681b      	ldr	r3, [r3, #0]
2000350a:	4a90      	ldr	r2, [pc, #576]	; (2000374c <HAL_DMAEx_MultiBufferStart_IT+0x304>)
2000350c:	4293      	cmp	r3, r2
2000350e:	d032      	beq.n	20003576 <HAL_DMAEx_MultiBufferStart_IT+0x12e>
20003510:	68fb      	ldr	r3, [r7, #12]
20003512:	681b      	ldr	r3, [r3, #0]
20003514:	4a8e      	ldr	r2, [pc, #568]	; (20003750 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
20003516:	4293      	cmp	r3, r2
20003518:	d02a      	beq.n	20003570 <HAL_DMAEx_MultiBufferStart_IT+0x128>
2000351a:	68fb      	ldr	r3, [r7, #12]
2000351c:	681b      	ldr	r3, [r3, #0]
2000351e:	4a8d      	ldr	r2, [pc, #564]	; (20003754 <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
20003520:	4293      	cmp	r3, r2
20003522:	d022      	beq.n	2000356a <HAL_DMAEx_MultiBufferStart_IT+0x122>
20003524:	68fb      	ldr	r3, [r7, #12]
20003526:	681b      	ldr	r3, [r3, #0]
20003528:	4a8b      	ldr	r2, [pc, #556]	; (20003758 <HAL_DMAEx_MultiBufferStart_IT+0x310>)
2000352a:	4293      	cmp	r3, r2
2000352c:	d01a      	beq.n	20003564 <HAL_DMAEx_MultiBufferStart_IT+0x11c>
2000352e:	68fb      	ldr	r3, [r7, #12]
20003530:	681b      	ldr	r3, [r3, #0]
20003532:	4a8a      	ldr	r2, [pc, #552]	; (2000375c <HAL_DMAEx_MultiBufferStart_IT+0x314>)
20003534:	4293      	cmp	r3, r2
20003536:	d012      	beq.n	2000355e <HAL_DMAEx_MultiBufferStart_IT+0x116>
20003538:	68fb      	ldr	r3, [r7, #12]
2000353a:	681b      	ldr	r3, [r3, #0]
2000353c:	4a88      	ldr	r2, [pc, #544]	; (20003760 <HAL_DMAEx_MultiBufferStart_IT+0x318>)
2000353e:	4293      	cmp	r3, r2
20003540:	d00a      	beq.n	20003558 <HAL_DMAEx_MultiBufferStart_IT+0x110>
20003542:	68fb      	ldr	r3, [r7, #12]
20003544:	681b      	ldr	r3, [r3, #0]
20003546:	4a87      	ldr	r2, [pc, #540]	; (20003764 <HAL_DMAEx_MultiBufferStart_IT+0x31c>)
20003548:	4293      	cmp	r3, r2
2000354a:	d102      	bne.n	20003552 <HAL_DMAEx_MultiBufferStart_IT+0x10a>
2000354c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003550:	e01e      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
20003552:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
20003556:	e01b      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
20003558:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
2000355c:	e018      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
2000355e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003562:	e015      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
20003564:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003568:	e012      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
2000356a:	f44f 6300 	mov.w	r3, #2048	; 0x800
2000356e:	e00f      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
20003570:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003574:	e00c      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
20003576:	f44f 6300 	mov.w	r3, #2048	; 0x800
2000357a:	e009      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
2000357c:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003580:	e006      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
20003582:	2320      	movs	r3, #32
20003584:	e004      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
20003586:	2320      	movs	r3, #32
20003588:	e002      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
2000358a:	2320      	movs	r3, #32
2000358c:	e000      	b.n	20003590 <HAL_DMAEx_MultiBufferStart_IT+0x148>
2000358e:	2320      	movs	r3, #32
20003590:	4a75      	ldr	r2, [pc, #468]	; (20003768 <HAL_DMAEx_MultiBufferStart_IT+0x320>)
20003592:	60d3      	str	r3, [r2, #12]
20003594:	e150      	b.n	20003838 <HAL_DMAEx_MultiBufferStart_IT+0x3f0>
20003596:	68fb      	ldr	r3, [r7, #12]
20003598:	681b      	ldr	r3, [r3, #0]
2000359a:	461a      	mov	r2, r3
2000359c:	4b73      	ldr	r3, [pc, #460]	; (2000376c <HAL_DMAEx_MultiBufferStart_IT+0x324>)
2000359e:	429a      	cmp	r2, r3
200035a0:	d960      	bls.n	20003664 <HAL_DMAEx_MultiBufferStart_IT+0x21c>
200035a2:	68fb      	ldr	r3, [r7, #12]
200035a4:	681b      	ldr	r3, [r3, #0]
200035a6:	4a64      	ldr	r2, [pc, #400]	; (20003738 <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
200035a8:	4293      	cmp	r3, r2
200035aa:	d057      	beq.n	2000365c <HAL_DMAEx_MultiBufferStart_IT+0x214>
200035ac:	68fb      	ldr	r3, [r7, #12]
200035ae:	681b      	ldr	r3, [r3, #0]
200035b0:	4a62      	ldr	r2, [pc, #392]	; (2000373c <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
200035b2:	4293      	cmp	r3, r2
200035b4:	d050      	beq.n	20003658 <HAL_DMAEx_MultiBufferStart_IT+0x210>
200035b6:	68fb      	ldr	r3, [r7, #12]
200035b8:	681b      	ldr	r3, [r3, #0]
200035ba:	4a61      	ldr	r2, [pc, #388]	; (20003740 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
200035bc:	4293      	cmp	r3, r2
200035be:	d049      	beq.n	20003654 <HAL_DMAEx_MultiBufferStart_IT+0x20c>
200035c0:	68fb      	ldr	r3, [r7, #12]
200035c2:	681b      	ldr	r3, [r3, #0]
200035c4:	4a5f      	ldr	r2, [pc, #380]	; (20003744 <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
200035c6:	4293      	cmp	r3, r2
200035c8:	d042      	beq.n	20003650 <HAL_DMAEx_MultiBufferStart_IT+0x208>
200035ca:	68fb      	ldr	r3, [r7, #12]
200035cc:	681b      	ldr	r3, [r3, #0]
200035ce:	4a5e      	ldr	r2, [pc, #376]	; (20003748 <HAL_DMAEx_MultiBufferStart_IT+0x300>)
200035d0:	4293      	cmp	r3, r2
200035d2:	d03a      	beq.n	2000364a <HAL_DMAEx_MultiBufferStart_IT+0x202>
200035d4:	68fb      	ldr	r3, [r7, #12]
200035d6:	681b      	ldr	r3, [r3, #0]
200035d8:	4a5c      	ldr	r2, [pc, #368]	; (2000374c <HAL_DMAEx_MultiBufferStart_IT+0x304>)
200035da:	4293      	cmp	r3, r2
200035dc:	d032      	beq.n	20003644 <HAL_DMAEx_MultiBufferStart_IT+0x1fc>
200035de:	68fb      	ldr	r3, [r7, #12]
200035e0:	681b      	ldr	r3, [r3, #0]
200035e2:	4a5b      	ldr	r2, [pc, #364]	; (20003750 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
200035e4:	4293      	cmp	r3, r2
200035e6:	d02a      	beq.n	2000363e <HAL_DMAEx_MultiBufferStart_IT+0x1f6>
200035e8:	68fb      	ldr	r3, [r7, #12]
200035ea:	681b      	ldr	r3, [r3, #0]
200035ec:	4a59      	ldr	r2, [pc, #356]	; (20003754 <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
200035ee:	4293      	cmp	r3, r2
200035f0:	d022      	beq.n	20003638 <HAL_DMAEx_MultiBufferStart_IT+0x1f0>
200035f2:	68fb      	ldr	r3, [r7, #12]
200035f4:	681b      	ldr	r3, [r3, #0]
200035f6:	4a58      	ldr	r2, [pc, #352]	; (20003758 <HAL_DMAEx_MultiBufferStart_IT+0x310>)
200035f8:	4293      	cmp	r3, r2
200035fa:	d01a      	beq.n	20003632 <HAL_DMAEx_MultiBufferStart_IT+0x1ea>
200035fc:	68fb      	ldr	r3, [r7, #12]
200035fe:	681b      	ldr	r3, [r3, #0]
20003600:	4a56      	ldr	r2, [pc, #344]	; (2000375c <HAL_DMAEx_MultiBufferStart_IT+0x314>)
20003602:	4293      	cmp	r3, r2
20003604:	d012      	beq.n	2000362c <HAL_DMAEx_MultiBufferStart_IT+0x1e4>
20003606:	68fb      	ldr	r3, [r7, #12]
20003608:	681b      	ldr	r3, [r3, #0]
2000360a:	4a55      	ldr	r2, [pc, #340]	; (20003760 <HAL_DMAEx_MultiBufferStart_IT+0x318>)
2000360c:	4293      	cmp	r3, r2
2000360e:	d00a      	beq.n	20003626 <HAL_DMAEx_MultiBufferStart_IT+0x1de>
20003610:	68fb      	ldr	r3, [r7, #12]
20003612:	681b      	ldr	r3, [r3, #0]
20003614:	4a53      	ldr	r2, [pc, #332]	; (20003764 <HAL_DMAEx_MultiBufferStart_IT+0x31c>)
20003616:	4293      	cmp	r3, r2
20003618:	d102      	bne.n	20003620 <HAL_DMAEx_MultiBufferStart_IT+0x1d8>
2000361a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
2000361e:	e01e      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003620:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
20003624:	e01b      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003626:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
2000362a:	e018      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
2000362c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003630:	e015      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003632:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003636:	e012      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003638:	f44f 6300 	mov.w	r3, #2048	; 0x800
2000363c:	e00f      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
2000363e:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003642:	e00c      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003644:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003648:	e009      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
2000364a:	f44f 6300 	mov.w	r3, #2048	; 0x800
2000364e:	e006      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003650:	2320      	movs	r3, #32
20003652:	e004      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003654:	2320      	movs	r3, #32
20003656:	e002      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
20003658:	2320      	movs	r3, #32
2000365a:	e000      	b.n	2000365e <HAL_DMAEx_MultiBufferStart_IT+0x216>
2000365c:	2320      	movs	r3, #32
2000365e:	4a42      	ldr	r2, [pc, #264]	; (20003768 <HAL_DMAEx_MultiBufferStart_IT+0x320>)
20003660:	6093      	str	r3, [r2, #8]
20003662:	e0e9      	b.n	20003838 <HAL_DMAEx_MultiBufferStart_IT+0x3f0>
20003664:	68fb      	ldr	r3, [r7, #12]
20003666:	681b      	ldr	r3, [r3, #0]
20003668:	461a      	mov	r2, r3
2000366a:	4b41      	ldr	r3, [pc, #260]	; (20003770 <HAL_DMAEx_MultiBufferStart_IT+0x328>)
2000366c:	429a      	cmp	r2, r3
2000366e:	f240 8083 	bls.w	20003778 <HAL_DMAEx_MultiBufferStart_IT+0x330>
20003672:	68fb      	ldr	r3, [r7, #12]
20003674:	681b      	ldr	r3, [r3, #0]
20003676:	4a30      	ldr	r2, [pc, #192]	; (20003738 <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
20003678:	4293      	cmp	r3, r2
2000367a:	d057      	beq.n	2000372c <HAL_DMAEx_MultiBufferStart_IT+0x2e4>
2000367c:	68fb      	ldr	r3, [r7, #12]
2000367e:	681b      	ldr	r3, [r3, #0]
20003680:	4a2e      	ldr	r2, [pc, #184]	; (2000373c <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
20003682:	4293      	cmp	r3, r2
20003684:	d050      	beq.n	20003728 <HAL_DMAEx_MultiBufferStart_IT+0x2e0>
20003686:	68fb      	ldr	r3, [r7, #12]
20003688:	681b      	ldr	r3, [r3, #0]
2000368a:	4a2d      	ldr	r2, [pc, #180]	; (20003740 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
2000368c:	4293      	cmp	r3, r2
2000368e:	d049      	beq.n	20003724 <HAL_DMAEx_MultiBufferStart_IT+0x2dc>
20003690:	68fb      	ldr	r3, [r7, #12]
20003692:	681b      	ldr	r3, [r3, #0]
20003694:	4a2b      	ldr	r2, [pc, #172]	; (20003744 <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
20003696:	4293      	cmp	r3, r2
20003698:	d042      	beq.n	20003720 <HAL_DMAEx_MultiBufferStart_IT+0x2d8>
2000369a:	68fb      	ldr	r3, [r7, #12]
2000369c:	681b      	ldr	r3, [r3, #0]
2000369e:	4a2a      	ldr	r2, [pc, #168]	; (20003748 <HAL_DMAEx_MultiBufferStart_IT+0x300>)
200036a0:	4293      	cmp	r3, r2
200036a2:	d03a      	beq.n	2000371a <HAL_DMAEx_MultiBufferStart_IT+0x2d2>
200036a4:	68fb      	ldr	r3, [r7, #12]
200036a6:	681b      	ldr	r3, [r3, #0]
200036a8:	4a28      	ldr	r2, [pc, #160]	; (2000374c <HAL_DMAEx_MultiBufferStart_IT+0x304>)
200036aa:	4293      	cmp	r3, r2
200036ac:	d032      	beq.n	20003714 <HAL_DMAEx_MultiBufferStart_IT+0x2cc>
200036ae:	68fb      	ldr	r3, [r7, #12]
200036b0:	681b      	ldr	r3, [r3, #0]
200036b2:	4a27      	ldr	r2, [pc, #156]	; (20003750 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
200036b4:	4293      	cmp	r3, r2
200036b6:	d02a      	beq.n	2000370e <HAL_DMAEx_MultiBufferStart_IT+0x2c6>
200036b8:	68fb      	ldr	r3, [r7, #12]
200036ba:	681b      	ldr	r3, [r3, #0]
200036bc:	4a25      	ldr	r2, [pc, #148]	; (20003754 <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
200036be:	4293      	cmp	r3, r2
200036c0:	d022      	beq.n	20003708 <HAL_DMAEx_MultiBufferStart_IT+0x2c0>
200036c2:	68fb      	ldr	r3, [r7, #12]
200036c4:	681b      	ldr	r3, [r3, #0]
200036c6:	4a24      	ldr	r2, [pc, #144]	; (20003758 <HAL_DMAEx_MultiBufferStart_IT+0x310>)
200036c8:	4293      	cmp	r3, r2
200036ca:	d01a      	beq.n	20003702 <HAL_DMAEx_MultiBufferStart_IT+0x2ba>
200036cc:	68fb      	ldr	r3, [r7, #12]
200036ce:	681b      	ldr	r3, [r3, #0]
200036d0:	4a22      	ldr	r2, [pc, #136]	; (2000375c <HAL_DMAEx_MultiBufferStart_IT+0x314>)
200036d2:	4293      	cmp	r3, r2
200036d4:	d012      	beq.n	200036fc <HAL_DMAEx_MultiBufferStart_IT+0x2b4>
200036d6:	68fb      	ldr	r3, [r7, #12]
200036d8:	681b      	ldr	r3, [r3, #0]
200036da:	4a21      	ldr	r2, [pc, #132]	; (20003760 <HAL_DMAEx_MultiBufferStart_IT+0x318>)
200036dc:	4293      	cmp	r3, r2
200036de:	d00a      	beq.n	200036f6 <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
200036e0:	68fb      	ldr	r3, [r7, #12]
200036e2:	681b      	ldr	r3, [r3, #0]
200036e4:	4a1f      	ldr	r2, [pc, #124]	; (20003764 <HAL_DMAEx_MultiBufferStart_IT+0x31c>)
200036e6:	4293      	cmp	r3, r2
200036e8:	d102      	bne.n	200036f0 <HAL_DMAEx_MultiBufferStart_IT+0x2a8>
200036ea:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
200036ee:	e01e      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
200036f0:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
200036f4:	e01b      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
200036f6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
200036fa:	e018      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
200036fc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003700:	e015      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
20003702:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003706:	e012      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
20003708:	f44f 6300 	mov.w	r3, #2048	; 0x800
2000370c:	e00f      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
2000370e:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003712:	e00c      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
20003714:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003718:	e009      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
2000371a:	f44f 6300 	mov.w	r3, #2048	; 0x800
2000371e:	e006      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
20003720:	2320      	movs	r3, #32
20003722:	e004      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
20003724:	2320      	movs	r3, #32
20003726:	e002      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
20003728:	2320      	movs	r3, #32
2000372a:	e000      	b.n	2000372e <HAL_DMAEx_MultiBufferStart_IT+0x2e6>
2000372c:	2320      	movs	r3, #32
2000372e:	4a11      	ldr	r2, [pc, #68]	; (20003774 <HAL_DMAEx_MultiBufferStart_IT+0x32c>)
20003730:	60d3      	str	r3, [r2, #12]
20003732:	e081      	b.n	20003838 <HAL_DMAEx_MultiBufferStart_IT+0x3f0>
20003734:	40026458 	.word	0x40026458
20003738:	40026010 	.word	0x40026010
2000373c:	40026410 	.word	0x40026410
20003740:	40026070 	.word	0x40026070
20003744:	40026470 	.word	0x40026470
20003748:	40026028 	.word	0x40026028
2000374c:	40026428 	.word	0x40026428
20003750:	40026088 	.word	0x40026088
20003754:	40026488 	.word	0x40026488
20003758:	40026040 	.word	0x40026040
2000375c:	40026440 	.word	0x40026440
20003760:	400260a0 	.word	0x400260a0
20003764:	400264a0 	.word	0x400264a0
20003768:	40026400 	.word	0x40026400
2000376c:	400260b8 	.word	0x400260b8
20003770:	40026058 	.word	0x40026058
20003774:	40026000 	.word	0x40026000
20003778:	68fb      	ldr	r3, [r7, #12]
2000377a:	681b      	ldr	r3, [r3, #0]
2000377c:	4a96      	ldr	r2, [pc, #600]	; (200039d8 <HAL_DMAEx_MultiBufferStart_IT+0x590>)
2000377e:	4293      	cmp	r3, r2
20003780:	d057      	beq.n	20003832 <HAL_DMAEx_MultiBufferStart_IT+0x3ea>
20003782:	68fb      	ldr	r3, [r7, #12]
20003784:	681b      	ldr	r3, [r3, #0]
20003786:	4a95      	ldr	r2, [pc, #596]	; (200039dc <HAL_DMAEx_MultiBufferStart_IT+0x594>)
20003788:	4293      	cmp	r3, r2
2000378a:	d050      	beq.n	2000382e <HAL_DMAEx_MultiBufferStart_IT+0x3e6>
2000378c:	68fb      	ldr	r3, [r7, #12]
2000378e:	681b      	ldr	r3, [r3, #0]
20003790:	4a93      	ldr	r2, [pc, #588]	; (200039e0 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
20003792:	4293      	cmp	r3, r2
20003794:	d049      	beq.n	2000382a <HAL_DMAEx_MultiBufferStart_IT+0x3e2>
20003796:	68fb      	ldr	r3, [r7, #12]
20003798:	681b      	ldr	r3, [r3, #0]
2000379a:	4a92      	ldr	r2, [pc, #584]	; (200039e4 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
2000379c:	4293      	cmp	r3, r2
2000379e:	d042      	beq.n	20003826 <HAL_DMAEx_MultiBufferStart_IT+0x3de>
200037a0:	68fb      	ldr	r3, [r7, #12]
200037a2:	681b      	ldr	r3, [r3, #0]
200037a4:	4a90      	ldr	r2, [pc, #576]	; (200039e8 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
200037a6:	4293      	cmp	r3, r2
200037a8:	d03a      	beq.n	20003820 <HAL_DMAEx_MultiBufferStart_IT+0x3d8>
200037aa:	68fb      	ldr	r3, [r7, #12]
200037ac:	681b      	ldr	r3, [r3, #0]
200037ae:	4a8f      	ldr	r2, [pc, #572]	; (200039ec <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
200037b0:	4293      	cmp	r3, r2
200037b2:	d032      	beq.n	2000381a <HAL_DMAEx_MultiBufferStart_IT+0x3d2>
200037b4:	68fb      	ldr	r3, [r7, #12]
200037b6:	681b      	ldr	r3, [r3, #0]
200037b8:	4a8d      	ldr	r2, [pc, #564]	; (200039f0 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
200037ba:	4293      	cmp	r3, r2
200037bc:	d02a      	beq.n	20003814 <HAL_DMAEx_MultiBufferStart_IT+0x3cc>
200037be:	68fb      	ldr	r3, [r7, #12]
200037c0:	681b      	ldr	r3, [r3, #0]
200037c2:	4a8c      	ldr	r2, [pc, #560]	; (200039f4 <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
200037c4:	4293      	cmp	r3, r2
200037c6:	d022      	beq.n	2000380e <HAL_DMAEx_MultiBufferStart_IT+0x3c6>
200037c8:	68fb      	ldr	r3, [r7, #12]
200037ca:	681b      	ldr	r3, [r3, #0]
200037cc:	4a8a      	ldr	r2, [pc, #552]	; (200039f8 <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
200037ce:	4293      	cmp	r3, r2
200037d0:	d01a      	beq.n	20003808 <HAL_DMAEx_MultiBufferStart_IT+0x3c0>
200037d2:	68fb      	ldr	r3, [r7, #12]
200037d4:	681b      	ldr	r3, [r3, #0]
200037d6:	4a89      	ldr	r2, [pc, #548]	; (200039fc <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
200037d8:	4293      	cmp	r3, r2
200037da:	d012      	beq.n	20003802 <HAL_DMAEx_MultiBufferStart_IT+0x3ba>
200037dc:	68fb      	ldr	r3, [r7, #12]
200037de:	681b      	ldr	r3, [r3, #0]
200037e0:	4a87      	ldr	r2, [pc, #540]	; (20003a00 <HAL_DMAEx_MultiBufferStart_IT+0x5b8>)
200037e2:	4293      	cmp	r3, r2
200037e4:	d00a      	beq.n	200037fc <HAL_DMAEx_MultiBufferStart_IT+0x3b4>
200037e6:	68fb      	ldr	r3, [r7, #12]
200037e8:	681b      	ldr	r3, [r3, #0]
200037ea:	4a86      	ldr	r2, [pc, #536]	; (20003a04 <HAL_DMAEx_MultiBufferStart_IT+0x5bc>)
200037ec:	4293      	cmp	r3, r2
200037ee:	d102      	bne.n	200037f6 <HAL_DMAEx_MultiBufferStart_IT+0x3ae>
200037f0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
200037f4:	e01e      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
200037f6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
200037fa:	e01b      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
200037fc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003800:	e018      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
20003802:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
20003806:	e015      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
20003808:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
2000380c:	e012      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
2000380e:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003812:	e00f      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
20003814:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003818:	e00c      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
2000381a:	f44f 6300 	mov.w	r3, #2048	; 0x800
2000381e:	e009      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
20003820:	f44f 6300 	mov.w	r3, #2048	; 0x800
20003824:	e006      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
20003826:	2320      	movs	r3, #32
20003828:	e004      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
2000382a:	2320      	movs	r3, #32
2000382c:	e002      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
2000382e:	2320      	movs	r3, #32
20003830:	e000      	b.n	20003834 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>
20003832:	2320      	movs	r3, #32
20003834:	4a74      	ldr	r2, [pc, #464]	; (20003a08 <HAL_DMAEx_MultiBufferStart_IT+0x5c0>)
20003836:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
20003838:	68fb      	ldr	r3, [r7, #12]
2000383a:	681b      	ldr	r3, [r3, #0]
2000383c:	461a      	mov	r2, r3
2000383e:	4b73      	ldr	r3, [pc, #460]	; (20003a0c <HAL_DMAEx_MultiBufferStart_IT+0x5c4>)
20003840:	429a      	cmp	r2, r3
20003842:	d960      	bls.n	20003906 <HAL_DMAEx_MultiBufferStart_IT+0x4be>
20003844:	68fb      	ldr	r3, [r7, #12]
20003846:	681b      	ldr	r3, [r3, #0]
20003848:	4a63      	ldr	r2, [pc, #396]	; (200039d8 <HAL_DMAEx_MultiBufferStart_IT+0x590>)
2000384a:	4293      	cmp	r3, r2
2000384c:	d057      	beq.n	200038fe <HAL_DMAEx_MultiBufferStart_IT+0x4b6>
2000384e:	68fb      	ldr	r3, [r7, #12]
20003850:	681b      	ldr	r3, [r3, #0]
20003852:	4a62      	ldr	r2, [pc, #392]	; (200039dc <HAL_DMAEx_MultiBufferStart_IT+0x594>)
20003854:	4293      	cmp	r3, r2
20003856:	d050      	beq.n	200038fa <HAL_DMAEx_MultiBufferStart_IT+0x4b2>
20003858:	68fb      	ldr	r3, [r7, #12]
2000385a:	681b      	ldr	r3, [r3, #0]
2000385c:	4a60      	ldr	r2, [pc, #384]	; (200039e0 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
2000385e:	4293      	cmp	r3, r2
20003860:	d049      	beq.n	200038f6 <HAL_DMAEx_MultiBufferStart_IT+0x4ae>
20003862:	68fb      	ldr	r3, [r7, #12]
20003864:	681b      	ldr	r3, [r3, #0]
20003866:	4a5f      	ldr	r2, [pc, #380]	; (200039e4 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
20003868:	4293      	cmp	r3, r2
2000386a:	d042      	beq.n	200038f2 <HAL_DMAEx_MultiBufferStart_IT+0x4aa>
2000386c:	68fb      	ldr	r3, [r7, #12]
2000386e:	681b      	ldr	r3, [r3, #0]
20003870:	4a5d      	ldr	r2, [pc, #372]	; (200039e8 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
20003872:	4293      	cmp	r3, r2
20003874:	d03a      	beq.n	200038ec <HAL_DMAEx_MultiBufferStart_IT+0x4a4>
20003876:	68fb      	ldr	r3, [r7, #12]
20003878:	681b      	ldr	r3, [r3, #0]
2000387a:	4a5c      	ldr	r2, [pc, #368]	; (200039ec <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
2000387c:	4293      	cmp	r3, r2
2000387e:	d032      	beq.n	200038e6 <HAL_DMAEx_MultiBufferStart_IT+0x49e>
20003880:	68fb      	ldr	r3, [r7, #12]
20003882:	681b      	ldr	r3, [r3, #0]
20003884:	4a5a      	ldr	r2, [pc, #360]	; (200039f0 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
20003886:	4293      	cmp	r3, r2
20003888:	d02a      	beq.n	200038e0 <HAL_DMAEx_MultiBufferStart_IT+0x498>
2000388a:	68fb      	ldr	r3, [r7, #12]
2000388c:	681b      	ldr	r3, [r3, #0]
2000388e:	4a59      	ldr	r2, [pc, #356]	; (200039f4 <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
20003890:	4293      	cmp	r3, r2
20003892:	d022      	beq.n	200038da <HAL_DMAEx_MultiBufferStart_IT+0x492>
20003894:	68fb      	ldr	r3, [r7, #12]
20003896:	681b      	ldr	r3, [r3, #0]
20003898:	4a57      	ldr	r2, [pc, #348]	; (200039f8 <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
2000389a:	4293      	cmp	r3, r2
2000389c:	d01a      	beq.n	200038d4 <HAL_DMAEx_MultiBufferStart_IT+0x48c>
2000389e:	68fb      	ldr	r3, [r7, #12]
200038a0:	681b      	ldr	r3, [r3, #0]
200038a2:	4a56      	ldr	r2, [pc, #344]	; (200039fc <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
200038a4:	4293      	cmp	r3, r2
200038a6:	d012      	beq.n	200038ce <HAL_DMAEx_MultiBufferStart_IT+0x486>
200038a8:	68fb      	ldr	r3, [r7, #12]
200038aa:	681b      	ldr	r3, [r3, #0]
200038ac:	4a54      	ldr	r2, [pc, #336]	; (20003a00 <HAL_DMAEx_MultiBufferStart_IT+0x5b8>)
200038ae:	4293      	cmp	r3, r2
200038b0:	d00a      	beq.n	200038c8 <HAL_DMAEx_MultiBufferStart_IT+0x480>
200038b2:	68fb      	ldr	r3, [r7, #12]
200038b4:	681b      	ldr	r3, [r3, #0]
200038b6:	4a53      	ldr	r2, [pc, #332]	; (20003a04 <HAL_DMAEx_MultiBufferStart_IT+0x5bc>)
200038b8:	4293      	cmp	r3, r2
200038ba:	d102      	bne.n	200038c2 <HAL_DMAEx_MultiBufferStart_IT+0x47a>
200038bc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
200038c0:	e01e      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038c2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
200038c6:	e01b      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
200038cc:	e018      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038ce:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
200038d2:	e015      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038d4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
200038d8:	e012      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038da:	f44f 6380 	mov.w	r3, #1024	; 0x400
200038de:	e00f      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038e0:	f44f 6380 	mov.w	r3, #1024	; 0x400
200038e4:	e00c      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
200038ea:	e009      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
200038f0:	e006      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038f2:	2310      	movs	r3, #16
200038f4:	e004      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038f6:	2310      	movs	r3, #16
200038f8:	e002      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038fa:	2310      	movs	r3, #16
200038fc:	e000      	b.n	20003900 <HAL_DMAEx_MultiBufferStart_IT+0x4b8>
200038fe:	2310      	movs	r3, #16
20003900:	4a43      	ldr	r2, [pc, #268]	; (20003a10 <HAL_DMAEx_MultiBufferStart_IT+0x5c8>)
20003902:	60d3      	str	r3, [r2, #12]
20003904:	e14f      	b.n	20003ba6 <HAL_DMAEx_MultiBufferStart_IT+0x75e>
20003906:	68fb      	ldr	r3, [r7, #12]
20003908:	681b      	ldr	r3, [r3, #0]
2000390a:	461a      	mov	r2, r3
2000390c:	4b41      	ldr	r3, [pc, #260]	; (20003a14 <HAL_DMAEx_MultiBufferStart_IT+0x5cc>)
2000390e:	429a      	cmp	r2, r3
20003910:	f240 8082 	bls.w	20003a18 <HAL_DMAEx_MultiBufferStart_IT+0x5d0>
20003914:	68fb      	ldr	r3, [r7, #12]
20003916:	681b      	ldr	r3, [r3, #0]
20003918:	4a2f      	ldr	r2, [pc, #188]	; (200039d8 <HAL_DMAEx_MultiBufferStart_IT+0x590>)
2000391a:	4293      	cmp	r3, r2
2000391c:	d057      	beq.n	200039ce <HAL_DMAEx_MultiBufferStart_IT+0x586>
2000391e:	68fb      	ldr	r3, [r7, #12]
20003920:	681b      	ldr	r3, [r3, #0]
20003922:	4a2e      	ldr	r2, [pc, #184]	; (200039dc <HAL_DMAEx_MultiBufferStart_IT+0x594>)
20003924:	4293      	cmp	r3, r2
20003926:	d050      	beq.n	200039ca <HAL_DMAEx_MultiBufferStart_IT+0x582>
20003928:	68fb      	ldr	r3, [r7, #12]
2000392a:	681b      	ldr	r3, [r3, #0]
2000392c:	4a2c      	ldr	r2, [pc, #176]	; (200039e0 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
2000392e:	4293      	cmp	r3, r2
20003930:	d049      	beq.n	200039c6 <HAL_DMAEx_MultiBufferStart_IT+0x57e>
20003932:	68fb      	ldr	r3, [r7, #12]
20003934:	681b      	ldr	r3, [r3, #0]
20003936:	4a2b      	ldr	r2, [pc, #172]	; (200039e4 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
20003938:	4293      	cmp	r3, r2
2000393a:	d042      	beq.n	200039c2 <HAL_DMAEx_MultiBufferStart_IT+0x57a>
2000393c:	68fb      	ldr	r3, [r7, #12]
2000393e:	681b      	ldr	r3, [r3, #0]
20003940:	4a29      	ldr	r2, [pc, #164]	; (200039e8 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
20003942:	4293      	cmp	r3, r2
20003944:	d03a      	beq.n	200039bc <HAL_DMAEx_MultiBufferStart_IT+0x574>
20003946:	68fb      	ldr	r3, [r7, #12]
20003948:	681b      	ldr	r3, [r3, #0]
2000394a:	4a28      	ldr	r2, [pc, #160]	; (200039ec <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
2000394c:	4293      	cmp	r3, r2
2000394e:	d032      	beq.n	200039b6 <HAL_DMAEx_MultiBufferStart_IT+0x56e>
20003950:	68fb      	ldr	r3, [r7, #12]
20003952:	681b      	ldr	r3, [r3, #0]
20003954:	4a26      	ldr	r2, [pc, #152]	; (200039f0 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
20003956:	4293      	cmp	r3, r2
20003958:	d02a      	beq.n	200039b0 <HAL_DMAEx_MultiBufferStart_IT+0x568>
2000395a:	68fb      	ldr	r3, [r7, #12]
2000395c:	681b      	ldr	r3, [r3, #0]
2000395e:	4a25      	ldr	r2, [pc, #148]	; (200039f4 <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
20003960:	4293      	cmp	r3, r2
20003962:	d022      	beq.n	200039aa <HAL_DMAEx_MultiBufferStart_IT+0x562>
20003964:	68fb      	ldr	r3, [r7, #12]
20003966:	681b      	ldr	r3, [r3, #0]
20003968:	4a23      	ldr	r2, [pc, #140]	; (200039f8 <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
2000396a:	4293      	cmp	r3, r2
2000396c:	d01a      	beq.n	200039a4 <HAL_DMAEx_MultiBufferStart_IT+0x55c>
2000396e:	68fb      	ldr	r3, [r7, #12]
20003970:	681b      	ldr	r3, [r3, #0]
20003972:	4a22      	ldr	r2, [pc, #136]	; (200039fc <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
20003974:	4293      	cmp	r3, r2
20003976:	d012      	beq.n	2000399e <HAL_DMAEx_MultiBufferStart_IT+0x556>
20003978:	68fb      	ldr	r3, [r7, #12]
2000397a:	681b      	ldr	r3, [r3, #0]
2000397c:	4a20      	ldr	r2, [pc, #128]	; (20003a00 <HAL_DMAEx_MultiBufferStart_IT+0x5b8>)
2000397e:	4293      	cmp	r3, r2
20003980:	d00a      	beq.n	20003998 <HAL_DMAEx_MultiBufferStart_IT+0x550>
20003982:	68fb      	ldr	r3, [r7, #12]
20003984:	681b      	ldr	r3, [r3, #0]
20003986:	4a1f      	ldr	r2, [pc, #124]	; (20003a04 <HAL_DMAEx_MultiBufferStart_IT+0x5bc>)
20003988:	4293      	cmp	r3, r2
2000398a:	d102      	bne.n	20003992 <HAL_DMAEx_MultiBufferStart_IT+0x54a>
2000398c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003990:	e01e      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
20003992:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
20003996:	e01b      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
20003998:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
2000399c:	e018      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
2000399e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
200039a2:	e015      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039a4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
200039a8:	e012      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039aa:	f44f 6380 	mov.w	r3, #1024	; 0x400
200039ae:	e00f      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
200039b4:	e00c      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039b6:	f44f 6380 	mov.w	r3, #1024	; 0x400
200039ba:	e009      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
200039c0:	e006      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039c2:	2310      	movs	r3, #16
200039c4:	e004      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039c6:	2310      	movs	r3, #16
200039c8:	e002      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039ca:	2310      	movs	r3, #16
200039cc:	e000      	b.n	200039d0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
200039ce:	2310      	movs	r3, #16
200039d0:	4a0f      	ldr	r2, [pc, #60]	; (20003a10 <HAL_DMAEx_MultiBufferStart_IT+0x5c8>)
200039d2:	6093      	str	r3, [r2, #8]
200039d4:	e0e7      	b.n	20003ba6 <HAL_DMAEx_MultiBufferStart_IT+0x75e>
200039d6:	bf00      	nop
200039d8:	40026010 	.word	0x40026010
200039dc:	40026410 	.word	0x40026410
200039e0:	40026070 	.word	0x40026070
200039e4:	40026470 	.word	0x40026470
200039e8:	40026028 	.word	0x40026028
200039ec:	40026428 	.word	0x40026428
200039f0:	40026088 	.word	0x40026088
200039f4:	40026488 	.word	0x40026488
200039f8:	40026040 	.word	0x40026040
200039fc:	40026440 	.word	0x40026440
20003a00:	400260a0 	.word	0x400260a0
20003a04:	400264a0 	.word	0x400264a0
20003a08:	40026000 	.word	0x40026000
20003a0c:	40026458 	.word	0x40026458
20003a10:	40026400 	.word	0x40026400
20003a14:	400260b8 	.word	0x400260b8
20003a18:	68fb      	ldr	r3, [r7, #12]
20003a1a:	681b      	ldr	r3, [r3, #0]
20003a1c:	461a      	mov	r2, r3
20003a1e:	4b96      	ldr	r3, [pc, #600]	; (20003c78 <HAL_DMAEx_MultiBufferStart_IT+0x830>)
20003a20:	429a      	cmp	r2, r3
20003a22:	d960      	bls.n	20003ae6 <HAL_DMAEx_MultiBufferStart_IT+0x69e>
20003a24:	68fb      	ldr	r3, [r7, #12]
20003a26:	681b      	ldr	r3, [r3, #0]
20003a28:	4a94      	ldr	r2, [pc, #592]	; (20003c7c <HAL_DMAEx_MultiBufferStart_IT+0x834>)
20003a2a:	4293      	cmp	r3, r2
20003a2c:	d057      	beq.n	20003ade <HAL_DMAEx_MultiBufferStart_IT+0x696>
20003a2e:	68fb      	ldr	r3, [r7, #12]
20003a30:	681b      	ldr	r3, [r3, #0]
20003a32:	4a93      	ldr	r2, [pc, #588]	; (20003c80 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
20003a34:	4293      	cmp	r3, r2
20003a36:	d050      	beq.n	20003ada <HAL_DMAEx_MultiBufferStart_IT+0x692>
20003a38:	68fb      	ldr	r3, [r7, #12]
20003a3a:	681b      	ldr	r3, [r3, #0]
20003a3c:	4a91      	ldr	r2, [pc, #580]	; (20003c84 <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
20003a3e:	4293      	cmp	r3, r2
20003a40:	d049      	beq.n	20003ad6 <HAL_DMAEx_MultiBufferStart_IT+0x68e>
20003a42:	68fb      	ldr	r3, [r7, #12]
20003a44:	681b      	ldr	r3, [r3, #0]
20003a46:	4a90      	ldr	r2, [pc, #576]	; (20003c88 <HAL_DMAEx_MultiBufferStart_IT+0x840>)
20003a48:	4293      	cmp	r3, r2
20003a4a:	d042      	beq.n	20003ad2 <HAL_DMAEx_MultiBufferStart_IT+0x68a>
20003a4c:	68fb      	ldr	r3, [r7, #12]
20003a4e:	681b      	ldr	r3, [r3, #0]
20003a50:	4a8e      	ldr	r2, [pc, #568]	; (20003c8c <HAL_DMAEx_MultiBufferStart_IT+0x844>)
20003a52:	4293      	cmp	r3, r2
20003a54:	d03a      	beq.n	20003acc <HAL_DMAEx_MultiBufferStart_IT+0x684>
20003a56:	68fb      	ldr	r3, [r7, #12]
20003a58:	681b      	ldr	r3, [r3, #0]
20003a5a:	4a8d      	ldr	r2, [pc, #564]	; (20003c90 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
20003a5c:	4293      	cmp	r3, r2
20003a5e:	d032      	beq.n	20003ac6 <HAL_DMAEx_MultiBufferStart_IT+0x67e>
20003a60:	68fb      	ldr	r3, [r7, #12]
20003a62:	681b      	ldr	r3, [r3, #0]
20003a64:	4a8b      	ldr	r2, [pc, #556]	; (20003c94 <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
20003a66:	4293      	cmp	r3, r2
20003a68:	d02a      	beq.n	20003ac0 <HAL_DMAEx_MultiBufferStart_IT+0x678>
20003a6a:	68fb      	ldr	r3, [r7, #12]
20003a6c:	681b      	ldr	r3, [r3, #0]
20003a6e:	4a8a      	ldr	r2, [pc, #552]	; (20003c98 <HAL_DMAEx_MultiBufferStart_IT+0x850>)
20003a70:	4293      	cmp	r3, r2
20003a72:	d022      	beq.n	20003aba <HAL_DMAEx_MultiBufferStart_IT+0x672>
20003a74:	68fb      	ldr	r3, [r7, #12]
20003a76:	681b      	ldr	r3, [r3, #0]
20003a78:	4a88      	ldr	r2, [pc, #544]	; (20003c9c <HAL_DMAEx_MultiBufferStart_IT+0x854>)
20003a7a:	4293      	cmp	r3, r2
20003a7c:	d01a      	beq.n	20003ab4 <HAL_DMAEx_MultiBufferStart_IT+0x66c>
20003a7e:	68fb      	ldr	r3, [r7, #12]
20003a80:	681b      	ldr	r3, [r3, #0]
20003a82:	4a87      	ldr	r2, [pc, #540]	; (20003ca0 <HAL_DMAEx_MultiBufferStart_IT+0x858>)
20003a84:	4293      	cmp	r3, r2
20003a86:	d012      	beq.n	20003aae <HAL_DMAEx_MultiBufferStart_IT+0x666>
20003a88:	68fb      	ldr	r3, [r7, #12]
20003a8a:	681b      	ldr	r3, [r3, #0]
20003a8c:	4a85      	ldr	r2, [pc, #532]	; (20003ca4 <HAL_DMAEx_MultiBufferStart_IT+0x85c>)
20003a8e:	4293      	cmp	r3, r2
20003a90:	d00a      	beq.n	20003aa8 <HAL_DMAEx_MultiBufferStart_IT+0x660>
20003a92:	68fb      	ldr	r3, [r7, #12]
20003a94:	681b      	ldr	r3, [r3, #0]
20003a96:	4a84      	ldr	r2, [pc, #528]	; (20003ca8 <HAL_DMAEx_MultiBufferStart_IT+0x860>)
20003a98:	4293      	cmp	r3, r2
20003a9a:	d102      	bne.n	20003aa2 <HAL_DMAEx_MultiBufferStart_IT+0x65a>
20003a9c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003aa0:	e01e      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003aa2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
20003aa6:	e01b      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003aa8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003aac:	e018      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003aae:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003ab2:	e015      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003ab4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003ab8:	e012      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003aba:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003abe:	e00f      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003ac0:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003ac4:	e00c      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003ac6:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003aca:	e009      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003acc:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003ad0:	e006      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003ad2:	2310      	movs	r3, #16
20003ad4:	e004      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003ad6:	2310      	movs	r3, #16
20003ad8:	e002      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003ada:	2310      	movs	r3, #16
20003adc:	e000      	b.n	20003ae0 <HAL_DMAEx_MultiBufferStart_IT+0x698>
20003ade:	2310      	movs	r3, #16
20003ae0:	4a72      	ldr	r2, [pc, #456]	; (20003cac <HAL_DMAEx_MultiBufferStart_IT+0x864>)
20003ae2:	60d3      	str	r3, [r2, #12]
20003ae4:	e05f      	b.n	20003ba6 <HAL_DMAEx_MultiBufferStart_IT+0x75e>
20003ae6:	68fb      	ldr	r3, [r7, #12]
20003ae8:	681b      	ldr	r3, [r3, #0]
20003aea:	4a64      	ldr	r2, [pc, #400]	; (20003c7c <HAL_DMAEx_MultiBufferStart_IT+0x834>)
20003aec:	4293      	cmp	r3, r2
20003aee:	d057      	beq.n	20003ba0 <HAL_DMAEx_MultiBufferStart_IT+0x758>
20003af0:	68fb      	ldr	r3, [r7, #12]
20003af2:	681b      	ldr	r3, [r3, #0]
20003af4:	4a62      	ldr	r2, [pc, #392]	; (20003c80 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
20003af6:	4293      	cmp	r3, r2
20003af8:	d050      	beq.n	20003b9c <HAL_DMAEx_MultiBufferStart_IT+0x754>
20003afa:	68fb      	ldr	r3, [r7, #12]
20003afc:	681b      	ldr	r3, [r3, #0]
20003afe:	4a61      	ldr	r2, [pc, #388]	; (20003c84 <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
20003b00:	4293      	cmp	r3, r2
20003b02:	d049      	beq.n	20003b98 <HAL_DMAEx_MultiBufferStart_IT+0x750>
20003b04:	68fb      	ldr	r3, [r7, #12]
20003b06:	681b      	ldr	r3, [r3, #0]
20003b08:	4a5f      	ldr	r2, [pc, #380]	; (20003c88 <HAL_DMAEx_MultiBufferStart_IT+0x840>)
20003b0a:	4293      	cmp	r3, r2
20003b0c:	d042      	beq.n	20003b94 <HAL_DMAEx_MultiBufferStart_IT+0x74c>
20003b0e:	68fb      	ldr	r3, [r7, #12]
20003b10:	681b      	ldr	r3, [r3, #0]
20003b12:	4a5e      	ldr	r2, [pc, #376]	; (20003c8c <HAL_DMAEx_MultiBufferStart_IT+0x844>)
20003b14:	4293      	cmp	r3, r2
20003b16:	d03a      	beq.n	20003b8e <HAL_DMAEx_MultiBufferStart_IT+0x746>
20003b18:	68fb      	ldr	r3, [r7, #12]
20003b1a:	681b      	ldr	r3, [r3, #0]
20003b1c:	4a5c      	ldr	r2, [pc, #368]	; (20003c90 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
20003b1e:	4293      	cmp	r3, r2
20003b20:	d032      	beq.n	20003b88 <HAL_DMAEx_MultiBufferStart_IT+0x740>
20003b22:	68fb      	ldr	r3, [r7, #12]
20003b24:	681b      	ldr	r3, [r3, #0]
20003b26:	4a5b      	ldr	r2, [pc, #364]	; (20003c94 <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
20003b28:	4293      	cmp	r3, r2
20003b2a:	d02a      	beq.n	20003b82 <HAL_DMAEx_MultiBufferStart_IT+0x73a>
20003b2c:	68fb      	ldr	r3, [r7, #12]
20003b2e:	681b      	ldr	r3, [r3, #0]
20003b30:	4a59      	ldr	r2, [pc, #356]	; (20003c98 <HAL_DMAEx_MultiBufferStart_IT+0x850>)
20003b32:	4293      	cmp	r3, r2
20003b34:	d022      	beq.n	20003b7c <HAL_DMAEx_MultiBufferStart_IT+0x734>
20003b36:	68fb      	ldr	r3, [r7, #12]
20003b38:	681b      	ldr	r3, [r3, #0]
20003b3a:	4a58      	ldr	r2, [pc, #352]	; (20003c9c <HAL_DMAEx_MultiBufferStart_IT+0x854>)
20003b3c:	4293      	cmp	r3, r2
20003b3e:	d01a      	beq.n	20003b76 <HAL_DMAEx_MultiBufferStart_IT+0x72e>
20003b40:	68fb      	ldr	r3, [r7, #12]
20003b42:	681b      	ldr	r3, [r3, #0]
20003b44:	4a56      	ldr	r2, [pc, #344]	; (20003ca0 <HAL_DMAEx_MultiBufferStart_IT+0x858>)
20003b46:	4293      	cmp	r3, r2
20003b48:	d012      	beq.n	20003b70 <HAL_DMAEx_MultiBufferStart_IT+0x728>
20003b4a:	68fb      	ldr	r3, [r7, #12]
20003b4c:	681b      	ldr	r3, [r3, #0]
20003b4e:	4a55      	ldr	r2, [pc, #340]	; (20003ca4 <HAL_DMAEx_MultiBufferStart_IT+0x85c>)
20003b50:	4293      	cmp	r3, r2
20003b52:	d00a      	beq.n	20003b6a <HAL_DMAEx_MultiBufferStart_IT+0x722>
20003b54:	68fb      	ldr	r3, [r7, #12]
20003b56:	681b      	ldr	r3, [r3, #0]
20003b58:	4a53      	ldr	r2, [pc, #332]	; (20003ca8 <HAL_DMAEx_MultiBufferStart_IT+0x860>)
20003b5a:	4293      	cmp	r3, r2
20003b5c:	d102      	bne.n	20003b64 <HAL_DMAEx_MultiBufferStart_IT+0x71c>
20003b5e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003b62:	e01e      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b64:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
20003b68:	e01b      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b6a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003b6e:	e018      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b70:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003b74:	e015      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b76:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
20003b7a:	e012      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b7c:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003b80:	e00f      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b82:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003b86:	e00c      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b88:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003b8c:	e009      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b8e:	f44f 6380 	mov.w	r3, #1024	; 0x400
20003b92:	e006      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b94:	2310      	movs	r3, #16
20003b96:	e004      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b98:	2310      	movs	r3, #16
20003b9a:	e002      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003b9c:	2310      	movs	r3, #16
20003b9e:	e000      	b.n	20003ba2 <HAL_DMAEx_MultiBufferStart_IT+0x75a>
20003ba0:	2310      	movs	r3, #16
20003ba2:	4a42      	ldr	r2, [pc, #264]	; (20003cac <HAL_DMAEx_MultiBufferStart_IT+0x864>)
20003ba4:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
20003ba6:	68fb      	ldr	r3, [r7, #12]
20003ba8:	681b      	ldr	r3, [r3, #0]
20003baa:	461a      	mov	r2, r3
20003bac:	4b40      	ldr	r3, [pc, #256]	; (20003cb0 <HAL_DMAEx_MultiBufferStart_IT+0x868>)
20003bae:	429a      	cmp	r2, r3
20003bb0:	f240 8082 	bls.w	20003cb8 <HAL_DMAEx_MultiBufferStart_IT+0x870>
20003bb4:	68fb      	ldr	r3, [r7, #12]
20003bb6:	681b      	ldr	r3, [r3, #0]
20003bb8:	4a30      	ldr	r2, [pc, #192]	; (20003c7c <HAL_DMAEx_MultiBufferStart_IT+0x834>)
20003bba:	4293      	cmp	r3, r2
20003bbc:	d057      	beq.n	20003c6e <HAL_DMAEx_MultiBufferStart_IT+0x826>
20003bbe:	68fb      	ldr	r3, [r7, #12]
20003bc0:	681b      	ldr	r3, [r3, #0]
20003bc2:	4a2f      	ldr	r2, [pc, #188]	; (20003c80 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
20003bc4:	4293      	cmp	r3, r2
20003bc6:	d050      	beq.n	20003c6a <HAL_DMAEx_MultiBufferStart_IT+0x822>
20003bc8:	68fb      	ldr	r3, [r7, #12]
20003bca:	681b      	ldr	r3, [r3, #0]
20003bcc:	4a2d      	ldr	r2, [pc, #180]	; (20003c84 <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
20003bce:	4293      	cmp	r3, r2
20003bd0:	d049      	beq.n	20003c66 <HAL_DMAEx_MultiBufferStart_IT+0x81e>
20003bd2:	68fb      	ldr	r3, [r7, #12]
20003bd4:	681b      	ldr	r3, [r3, #0]
20003bd6:	4a2c      	ldr	r2, [pc, #176]	; (20003c88 <HAL_DMAEx_MultiBufferStart_IT+0x840>)
20003bd8:	4293      	cmp	r3, r2
20003bda:	d042      	beq.n	20003c62 <HAL_DMAEx_MultiBufferStart_IT+0x81a>
20003bdc:	68fb      	ldr	r3, [r7, #12]
20003bde:	681b      	ldr	r3, [r3, #0]
20003be0:	4a2a      	ldr	r2, [pc, #168]	; (20003c8c <HAL_DMAEx_MultiBufferStart_IT+0x844>)
20003be2:	4293      	cmp	r3, r2
20003be4:	d03a      	beq.n	20003c5c <HAL_DMAEx_MultiBufferStart_IT+0x814>
20003be6:	68fb      	ldr	r3, [r7, #12]
20003be8:	681b      	ldr	r3, [r3, #0]
20003bea:	4a29      	ldr	r2, [pc, #164]	; (20003c90 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
20003bec:	4293      	cmp	r3, r2
20003bee:	d032      	beq.n	20003c56 <HAL_DMAEx_MultiBufferStart_IT+0x80e>
20003bf0:	68fb      	ldr	r3, [r7, #12]
20003bf2:	681b      	ldr	r3, [r3, #0]
20003bf4:	4a27      	ldr	r2, [pc, #156]	; (20003c94 <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
20003bf6:	4293      	cmp	r3, r2
20003bf8:	d02a      	beq.n	20003c50 <HAL_DMAEx_MultiBufferStart_IT+0x808>
20003bfa:	68fb      	ldr	r3, [r7, #12]
20003bfc:	681b      	ldr	r3, [r3, #0]
20003bfe:	4a26      	ldr	r2, [pc, #152]	; (20003c98 <HAL_DMAEx_MultiBufferStart_IT+0x850>)
20003c00:	4293      	cmp	r3, r2
20003c02:	d022      	beq.n	20003c4a <HAL_DMAEx_MultiBufferStart_IT+0x802>
20003c04:	68fb      	ldr	r3, [r7, #12]
20003c06:	681b      	ldr	r3, [r3, #0]
20003c08:	4a24      	ldr	r2, [pc, #144]	; (20003c9c <HAL_DMAEx_MultiBufferStart_IT+0x854>)
20003c0a:	4293      	cmp	r3, r2
20003c0c:	d01a      	beq.n	20003c44 <HAL_DMAEx_MultiBufferStart_IT+0x7fc>
20003c0e:	68fb      	ldr	r3, [r7, #12]
20003c10:	681b      	ldr	r3, [r3, #0]
20003c12:	4a23      	ldr	r2, [pc, #140]	; (20003ca0 <HAL_DMAEx_MultiBufferStart_IT+0x858>)
20003c14:	4293      	cmp	r3, r2
20003c16:	d012      	beq.n	20003c3e <HAL_DMAEx_MultiBufferStart_IT+0x7f6>
20003c18:	68fb      	ldr	r3, [r7, #12]
20003c1a:	681b      	ldr	r3, [r3, #0]
20003c1c:	4a21      	ldr	r2, [pc, #132]	; (20003ca4 <HAL_DMAEx_MultiBufferStart_IT+0x85c>)
20003c1e:	4293      	cmp	r3, r2
20003c20:	d00a      	beq.n	20003c38 <HAL_DMAEx_MultiBufferStart_IT+0x7f0>
20003c22:	68fb      	ldr	r3, [r7, #12]
20003c24:	681b      	ldr	r3, [r3, #0]
20003c26:	4a20      	ldr	r2, [pc, #128]	; (20003ca8 <HAL_DMAEx_MultiBufferStart_IT+0x860>)
20003c28:	4293      	cmp	r3, r2
20003c2a:	d102      	bne.n	20003c32 <HAL_DMAEx_MultiBufferStart_IT+0x7ea>
20003c2c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003c30:	e01e      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c32:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20003c36:	e01b      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c38:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003c3c:	e018      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c3e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003c42:	e015      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c44:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003c48:	e012      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c4a:	f44f 7300 	mov.w	r3, #512	; 0x200
20003c4e:	e00f      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c50:	f44f 7300 	mov.w	r3, #512	; 0x200
20003c54:	e00c      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c56:	f44f 7300 	mov.w	r3, #512	; 0x200
20003c5a:	e009      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c5c:	f44f 7300 	mov.w	r3, #512	; 0x200
20003c60:	e006      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c62:	2308      	movs	r3, #8
20003c64:	e004      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c66:	2308      	movs	r3, #8
20003c68:	e002      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c6a:	2308      	movs	r3, #8
20003c6c:	e000      	b.n	20003c70 <HAL_DMAEx_MultiBufferStart_IT+0x828>
20003c6e:	2308      	movs	r3, #8
20003c70:	4a10      	ldr	r2, [pc, #64]	; (20003cb4 <HAL_DMAEx_MultiBufferStart_IT+0x86c>)
20003c72:	60d3      	str	r3, [r2, #12]
20003c74:	e16f      	b.n	20003f56 <HAL_DMAEx_MultiBufferStart_IT+0xb0e>
20003c76:	bf00      	nop
20003c78:	40026058 	.word	0x40026058
20003c7c:	40026010 	.word	0x40026010
20003c80:	40026410 	.word	0x40026410
20003c84:	40026070 	.word	0x40026070
20003c88:	40026470 	.word	0x40026470
20003c8c:	40026028 	.word	0x40026028
20003c90:	40026428 	.word	0x40026428
20003c94:	40026088 	.word	0x40026088
20003c98:	40026488 	.word	0x40026488
20003c9c:	40026040 	.word	0x40026040
20003ca0:	40026440 	.word	0x40026440
20003ca4:	400260a0 	.word	0x400260a0
20003ca8:	400264a0 	.word	0x400264a0
20003cac:	40026000 	.word	0x40026000
20003cb0:	40026458 	.word	0x40026458
20003cb4:	40026400 	.word	0x40026400
20003cb8:	68fb      	ldr	r3, [r7, #12]
20003cba:	681b      	ldr	r3, [r3, #0]
20003cbc:	461a      	mov	r2, r3
20003cbe:	4b94      	ldr	r3, [pc, #592]	; (20003f10 <HAL_DMAEx_MultiBufferStart_IT+0xac8>)
20003cc0:	429a      	cmp	r2, r3
20003cc2:	d960      	bls.n	20003d86 <HAL_DMAEx_MultiBufferStart_IT+0x93e>
20003cc4:	68fb      	ldr	r3, [r7, #12]
20003cc6:	681b      	ldr	r3, [r3, #0]
20003cc8:	4a92      	ldr	r2, [pc, #584]	; (20003f14 <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
20003cca:	4293      	cmp	r3, r2
20003ccc:	d057      	beq.n	20003d7e <HAL_DMAEx_MultiBufferStart_IT+0x936>
20003cce:	68fb      	ldr	r3, [r7, #12]
20003cd0:	681b      	ldr	r3, [r3, #0]
20003cd2:	4a91      	ldr	r2, [pc, #580]	; (20003f18 <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
20003cd4:	4293      	cmp	r3, r2
20003cd6:	d050      	beq.n	20003d7a <HAL_DMAEx_MultiBufferStart_IT+0x932>
20003cd8:	68fb      	ldr	r3, [r7, #12]
20003cda:	681b      	ldr	r3, [r3, #0]
20003cdc:	4a8f      	ldr	r2, [pc, #572]	; (20003f1c <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
20003cde:	4293      	cmp	r3, r2
20003ce0:	d049      	beq.n	20003d76 <HAL_DMAEx_MultiBufferStart_IT+0x92e>
20003ce2:	68fb      	ldr	r3, [r7, #12]
20003ce4:	681b      	ldr	r3, [r3, #0]
20003ce6:	4a8e      	ldr	r2, [pc, #568]	; (20003f20 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
20003ce8:	4293      	cmp	r3, r2
20003cea:	d042      	beq.n	20003d72 <HAL_DMAEx_MultiBufferStart_IT+0x92a>
20003cec:	68fb      	ldr	r3, [r7, #12]
20003cee:	681b      	ldr	r3, [r3, #0]
20003cf0:	4a8c      	ldr	r2, [pc, #560]	; (20003f24 <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
20003cf2:	4293      	cmp	r3, r2
20003cf4:	d03a      	beq.n	20003d6c <HAL_DMAEx_MultiBufferStart_IT+0x924>
20003cf6:	68fb      	ldr	r3, [r7, #12]
20003cf8:	681b      	ldr	r3, [r3, #0]
20003cfa:	4a8b      	ldr	r2, [pc, #556]	; (20003f28 <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
20003cfc:	4293      	cmp	r3, r2
20003cfe:	d032      	beq.n	20003d66 <HAL_DMAEx_MultiBufferStart_IT+0x91e>
20003d00:	68fb      	ldr	r3, [r7, #12]
20003d02:	681b      	ldr	r3, [r3, #0]
20003d04:	4a89      	ldr	r2, [pc, #548]	; (20003f2c <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
20003d06:	4293      	cmp	r3, r2
20003d08:	d02a      	beq.n	20003d60 <HAL_DMAEx_MultiBufferStart_IT+0x918>
20003d0a:	68fb      	ldr	r3, [r7, #12]
20003d0c:	681b      	ldr	r3, [r3, #0]
20003d0e:	4a88      	ldr	r2, [pc, #544]	; (20003f30 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
20003d10:	4293      	cmp	r3, r2
20003d12:	d022      	beq.n	20003d5a <HAL_DMAEx_MultiBufferStart_IT+0x912>
20003d14:	68fb      	ldr	r3, [r7, #12]
20003d16:	681b      	ldr	r3, [r3, #0]
20003d18:	4a86      	ldr	r2, [pc, #536]	; (20003f34 <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
20003d1a:	4293      	cmp	r3, r2
20003d1c:	d01a      	beq.n	20003d54 <HAL_DMAEx_MultiBufferStart_IT+0x90c>
20003d1e:	68fb      	ldr	r3, [r7, #12]
20003d20:	681b      	ldr	r3, [r3, #0]
20003d22:	4a85      	ldr	r2, [pc, #532]	; (20003f38 <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
20003d24:	4293      	cmp	r3, r2
20003d26:	d012      	beq.n	20003d4e <HAL_DMAEx_MultiBufferStart_IT+0x906>
20003d28:	68fb      	ldr	r3, [r7, #12]
20003d2a:	681b      	ldr	r3, [r3, #0]
20003d2c:	4a83      	ldr	r2, [pc, #524]	; (20003f3c <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
20003d2e:	4293      	cmp	r3, r2
20003d30:	d00a      	beq.n	20003d48 <HAL_DMAEx_MultiBufferStart_IT+0x900>
20003d32:	68fb      	ldr	r3, [r7, #12]
20003d34:	681b      	ldr	r3, [r3, #0]
20003d36:	4a82      	ldr	r2, [pc, #520]	; (20003f40 <HAL_DMAEx_MultiBufferStart_IT+0xaf8>)
20003d38:	4293      	cmp	r3, r2
20003d3a:	d102      	bne.n	20003d42 <HAL_DMAEx_MultiBufferStart_IT+0x8fa>
20003d3c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003d40:	e01e      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d42:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20003d46:	e01b      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d48:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003d4c:	e018      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d4e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003d52:	e015      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d54:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003d58:	e012      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d5a:	f44f 7300 	mov.w	r3, #512	; 0x200
20003d5e:	e00f      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d60:	f44f 7300 	mov.w	r3, #512	; 0x200
20003d64:	e00c      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d66:	f44f 7300 	mov.w	r3, #512	; 0x200
20003d6a:	e009      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d6c:	f44f 7300 	mov.w	r3, #512	; 0x200
20003d70:	e006      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d72:	2308      	movs	r3, #8
20003d74:	e004      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d76:	2308      	movs	r3, #8
20003d78:	e002      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d7a:	2308      	movs	r3, #8
20003d7c:	e000      	b.n	20003d80 <HAL_DMAEx_MultiBufferStart_IT+0x938>
20003d7e:	2308      	movs	r3, #8
20003d80:	4a70      	ldr	r2, [pc, #448]	; (20003f44 <HAL_DMAEx_MultiBufferStart_IT+0xafc>)
20003d82:	6093      	str	r3, [r2, #8]
20003d84:	e0e7      	b.n	20003f56 <HAL_DMAEx_MultiBufferStart_IT+0xb0e>
20003d86:	68fb      	ldr	r3, [r7, #12]
20003d88:	681b      	ldr	r3, [r3, #0]
20003d8a:	461a      	mov	r2, r3
20003d8c:	4b6e      	ldr	r3, [pc, #440]	; (20003f48 <HAL_DMAEx_MultiBufferStart_IT+0xb00>)
20003d8e:	429a      	cmp	r2, r3
20003d90:	d960      	bls.n	20003e54 <HAL_DMAEx_MultiBufferStart_IT+0xa0c>
20003d92:	68fb      	ldr	r3, [r7, #12]
20003d94:	681b      	ldr	r3, [r3, #0]
20003d96:	4a5f      	ldr	r2, [pc, #380]	; (20003f14 <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
20003d98:	4293      	cmp	r3, r2
20003d9a:	d057      	beq.n	20003e4c <HAL_DMAEx_MultiBufferStart_IT+0xa04>
20003d9c:	68fb      	ldr	r3, [r7, #12]
20003d9e:	681b      	ldr	r3, [r3, #0]
20003da0:	4a5d      	ldr	r2, [pc, #372]	; (20003f18 <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
20003da2:	4293      	cmp	r3, r2
20003da4:	d050      	beq.n	20003e48 <HAL_DMAEx_MultiBufferStart_IT+0xa00>
20003da6:	68fb      	ldr	r3, [r7, #12]
20003da8:	681b      	ldr	r3, [r3, #0]
20003daa:	4a5c      	ldr	r2, [pc, #368]	; (20003f1c <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
20003dac:	4293      	cmp	r3, r2
20003dae:	d049      	beq.n	20003e44 <HAL_DMAEx_MultiBufferStart_IT+0x9fc>
20003db0:	68fb      	ldr	r3, [r7, #12]
20003db2:	681b      	ldr	r3, [r3, #0]
20003db4:	4a5a      	ldr	r2, [pc, #360]	; (20003f20 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
20003db6:	4293      	cmp	r3, r2
20003db8:	d042      	beq.n	20003e40 <HAL_DMAEx_MultiBufferStart_IT+0x9f8>
20003dba:	68fb      	ldr	r3, [r7, #12]
20003dbc:	681b      	ldr	r3, [r3, #0]
20003dbe:	4a59      	ldr	r2, [pc, #356]	; (20003f24 <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
20003dc0:	4293      	cmp	r3, r2
20003dc2:	d03a      	beq.n	20003e3a <HAL_DMAEx_MultiBufferStart_IT+0x9f2>
20003dc4:	68fb      	ldr	r3, [r7, #12]
20003dc6:	681b      	ldr	r3, [r3, #0]
20003dc8:	4a57      	ldr	r2, [pc, #348]	; (20003f28 <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
20003dca:	4293      	cmp	r3, r2
20003dcc:	d032      	beq.n	20003e34 <HAL_DMAEx_MultiBufferStart_IT+0x9ec>
20003dce:	68fb      	ldr	r3, [r7, #12]
20003dd0:	681b      	ldr	r3, [r3, #0]
20003dd2:	4a56      	ldr	r2, [pc, #344]	; (20003f2c <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
20003dd4:	4293      	cmp	r3, r2
20003dd6:	d02a      	beq.n	20003e2e <HAL_DMAEx_MultiBufferStart_IT+0x9e6>
20003dd8:	68fb      	ldr	r3, [r7, #12]
20003dda:	681b      	ldr	r3, [r3, #0]
20003ddc:	4a54      	ldr	r2, [pc, #336]	; (20003f30 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
20003dde:	4293      	cmp	r3, r2
20003de0:	d022      	beq.n	20003e28 <HAL_DMAEx_MultiBufferStart_IT+0x9e0>
20003de2:	68fb      	ldr	r3, [r7, #12]
20003de4:	681b      	ldr	r3, [r3, #0]
20003de6:	4a53      	ldr	r2, [pc, #332]	; (20003f34 <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
20003de8:	4293      	cmp	r3, r2
20003dea:	d01a      	beq.n	20003e22 <HAL_DMAEx_MultiBufferStart_IT+0x9da>
20003dec:	68fb      	ldr	r3, [r7, #12]
20003dee:	681b      	ldr	r3, [r3, #0]
20003df0:	4a51      	ldr	r2, [pc, #324]	; (20003f38 <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
20003df2:	4293      	cmp	r3, r2
20003df4:	d012      	beq.n	20003e1c <HAL_DMAEx_MultiBufferStart_IT+0x9d4>
20003df6:	68fb      	ldr	r3, [r7, #12]
20003df8:	681b      	ldr	r3, [r3, #0]
20003dfa:	4a50      	ldr	r2, [pc, #320]	; (20003f3c <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
20003dfc:	4293      	cmp	r3, r2
20003dfe:	d00a      	beq.n	20003e16 <HAL_DMAEx_MultiBufferStart_IT+0x9ce>
20003e00:	68fb      	ldr	r3, [r7, #12]
20003e02:	681b      	ldr	r3, [r3, #0]
20003e04:	4a4e      	ldr	r2, [pc, #312]	; (20003f40 <HAL_DMAEx_MultiBufferStart_IT+0xaf8>)
20003e06:	4293      	cmp	r3, r2
20003e08:	d102      	bne.n	20003e10 <HAL_DMAEx_MultiBufferStart_IT+0x9c8>
20003e0a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003e0e:	e01e      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e10:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20003e14:	e01b      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e16:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003e1a:	e018      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e1c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003e20:	e015      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e22:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003e26:	e012      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e28:	f44f 7300 	mov.w	r3, #512	; 0x200
20003e2c:	e00f      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e2e:	f44f 7300 	mov.w	r3, #512	; 0x200
20003e32:	e00c      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e34:	f44f 7300 	mov.w	r3, #512	; 0x200
20003e38:	e009      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e3a:	f44f 7300 	mov.w	r3, #512	; 0x200
20003e3e:	e006      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e40:	2308      	movs	r3, #8
20003e42:	e004      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e44:	2308      	movs	r3, #8
20003e46:	e002      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e48:	2308      	movs	r3, #8
20003e4a:	e000      	b.n	20003e4e <HAL_DMAEx_MultiBufferStart_IT+0xa06>
20003e4c:	2308      	movs	r3, #8
20003e4e:	4a3f      	ldr	r2, [pc, #252]	; (20003f4c <HAL_DMAEx_MultiBufferStart_IT+0xb04>)
20003e50:	60d3      	str	r3, [r2, #12]
20003e52:	e080      	b.n	20003f56 <HAL_DMAEx_MultiBufferStart_IT+0xb0e>
20003e54:	68fb      	ldr	r3, [r7, #12]
20003e56:	681b      	ldr	r3, [r3, #0]
20003e58:	4a2e      	ldr	r2, [pc, #184]	; (20003f14 <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
20003e5a:	4293      	cmp	r3, r2
20003e5c:	d078      	beq.n	20003f50 <HAL_DMAEx_MultiBufferStart_IT+0xb08>
20003e5e:	68fb      	ldr	r3, [r7, #12]
20003e60:	681b      	ldr	r3, [r3, #0]
20003e62:	4a2d      	ldr	r2, [pc, #180]	; (20003f18 <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
20003e64:	4293      	cmp	r3, r2
20003e66:	d050      	beq.n	20003f0a <HAL_DMAEx_MultiBufferStart_IT+0xac2>
20003e68:	68fb      	ldr	r3, [r7, #12]
20003e6a:	681b      	ldr	r3, [r3, #0]
20003e6c:	4a2b      	ldr	r2, [pc, #172]	; (20003f1c <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
20003e6e:	4293      	cmp	r3, r2
20003e70:	d049      	beq.n	20003f06 <HAL_DMAEx_MultiBufferStart_IT+0xabe>
20003e72:	68fb      	ldr	r3, [r7, #12]
20003e74:	681b      	ldr	r3, [r3, #0]
20003e76:	4a2a      	ldr	r2, [pc, #168]	; (20003f20 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
20003e78:	4293      	cmp	r3, r2
20003e7a:	d042      	beq.n	20003f02 <HAL_DMAEx_MultiBufferStart_IT+0xaba>
20003e7c:	68fb      	ldr	r3, [r7, #12]
20003e7e:	681b      	ldr	r3, [r3, #0]
20003e80:	4a28      	ldr	r2, [pc, #160]	; (20003f24 <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
20003e82:	4293      	cmp	r3, r2
20003e84:	d03a      	beq.n	20003efc <HAL_DMAEx_MultiBufferStart_IT+0xab4>
20003e86:	68fb      	ldr	r3, [r7, #12]
20003e88:	681b      	ldr	r3, [r3, #0]
20003e8a:	4a27      	ldr	r2, [pc, #156]	; (20003f28 <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
20003e8c:	4293      	cmp	r3, r2
20003e8e:	d032      	beq.n	20003ef6 <HAL_DMAEx_MultiBufferStart_IT+0xaae>
20003e90:	68fb      	ldr	r3, [r7, #12]
20003e92:	681b      	ldr	r3, [r3, #0]
20003e94:	4a25      	ldr	r2, [pc, #148]	; (20003f2c <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
20003e96:	4293      	cmp	r3, r2
20003e98:	d02a      	beq.n	20003ef0 <HAL_DMAEx_MultiBufferStart_IT+0xaa8>
20003e9a:	68fb      	ldr	r3, [r7, #12]
20003e9c:	681b      	ldr	r3, [r3, #0]
20003e9e:	4a24      	ldr	r2, [pc, #144]	; (20003f30 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
20003ea0:	4293      	cmp	r3, r2
20003ea2:	d022      	beq.n	20003eea <HAL_DMAEx_MultiBufferStart_IT+0xaa2>
20003ea4:	68fb      	ldr	r3, [r7, #12]
20003ea6:	681b      	ldr	r3, [r3, #0]
20003ea8:	4a22      	ldr	r2, [pc, #136]	; (20003f34 <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
20003eaa:	4293      	cmp	r3, r2
20003eac:	d01a      	beq.n	20003ee4 <HAL_DMAEx_MultiBufferStart_IT+0xa9c>
20003eae:	68fb      	ldr	r3, [r7, #12]
20003eb0:	681b      	ldr	r3, [r3, #0]
20003eb2:	4a21      	ldr	r2, [pc, #132]	; (20003f38 <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
20003eb4:	4293      	cmp	r3, r2
20003eb6:	d012      	beq.n	20003ede <HAL_DMAEx_MultiBufferStart_IT+0xa96>
20003eb8:	68fb      	ldr	r3, [r7, #12]
20003eba:	681b      	ldr	r3, [r3, #0]
20003ebc:	4a1f      	ldr	r2, [pc, #124]	; (20003f3c <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
20003ebe:	4293      	cmp	r3, r2
20003ec0:	d00a      	beq.n	20003ed8 <HAL_DMAEx_MultiBufferStart_IT+0xa90>
20003ec2:	68fb      	ldr	r3, [r7, #12]
20003ec4:	681b      	ldr	r3, [r3, #0]
20003ec6:	4a1e      	ldr	r2, [pc, #120]	; (20003f40 <HAL_DMAEx_MultiBufferStart_IT+0xaf8>)
20003ec8:	4293      	cmp	r3, r2
20003eca:	d102      	bne.n	20003ed2 <HAL_DMAEx_MultiBufferStart_IT+0xa8a>
20003ecc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003ed0:	e03f      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003ed2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20003ed6:	e03c      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003ed8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003edc:	e039      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003ede:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003ee2:	e036      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003ee4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
20003ee8:	e033      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003eea:	f44f 7300 	mov.w	r3, #512	; 0x200
20003eee:	e030      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003ef0:	f44f 7300 	mov.w	r3, #512	; 0x200
20003ef4:	e02d      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003ef6:	f44f 7300 	mov.w	r3, #512	; 0x200
20003efa:	e02a      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003efc:	f44f 7300 	mov.w	r3, #512	; 0x200
20003f00:	e027      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003f02:	2308      	movs	r3, #8
20003f04:	e025      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003f06:	2308      	movs	r3, #8
20003f08:	e023      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003f0a:	2308      	movs	r3, #8
20003f0c:	e021      	b.n	20003f52 <HAL_DMAEx_MultiBufferStart_IT+0xb0a>
20003f0e:	bf00      	nop
20003f10:	400260b8 	.word	0x400260b8
20003f14:	40026010 	.word	0x40026010
20003f18:	40026410 	.word	0x40026410
20003f1c:	40026070 	.word	0x40026070
20003f20:	40026470 	.word	0x40026470
20003f24:	40026028 	.word	0x40026028
20003f28:	40026428 	.word	0x40026428
20003f2c:	40026088 	.word	0x40026088
20003f30:	40026488 	.word	0x40026488
20003f34:	40026040 	.word	0x40026040
20003f38:	40026440 	.word	0x40026440
20003f3c:	400260a0 	.word	0x400260a0
20003f40:	400264a0 	.word	0x400264a0
20003f44:	40026400 	.word	0x40026400
20003f48:	40026058 	.word	0x40026058
20003f4c:	40026000 	.word	0x40026000
20003f50:	2308      	movs	r3, #8
20003f52:	4a9a      	ldr	r2, [pc, #616]	; (200041bc <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
20003f54:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
20003f56:	68fb      	ldr	r3, [r7, #12]
20003f58:	681b      	ldr	r3, [r3, #0]
20003f5a:	461a      	mov	r2, r3
20003f5c:	4b98      	ldr	r3, [pc, #608]	; (200041c0 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
20003f5e:	429a      	cmp	r2, r3
20003f60:	d960      	bls.n	20004024 <HAL_DMAEx_MultiBufferStart_IT+0xbdc>
20003f62:	68fb      	ldr	r3, [r7, #12]
20003f64:	681b      	ldr	r3, [r3, #0]
20003f66:	4a97      	ldr	r2, [pc, #604]	; (200041c4 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
20003f68:	4293      	cmp	r3, r2
20003f6a:	d057      	beq.n	2000401c <HAL_DMAEx_MultiBufferStart_IT+0xbd4>
20003f6c:	68fb      	ldr	r3, [r7, #12]
20003f6e:	681b      	ldr	r3, [r3, #0]
20003f70:	4a95      	ldr	r2, [pc, #596]	; (200041c8 <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
20003f72:	4293      	cmp	r3, r2
20003f74:	d050      	beq.n	20004018 <HAL_DMAEx_MultiBufferStart_IT+0xbd0>
20003f76:	68fb      	ldr	r3, [r7, #12]
20003f78:	681b      	ldr	r3, [r3, #0]
20003f7a:	4a94      	ldr	r2, [pc, #592]	; (200041cc <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
20003f7c:	4293      	cmp	r3, r2
20003f7e:	d049      	beq.n	20004014 <HAL_DMAEx_MultiBufferStart_IT+0xbcc>
20003f80:	68fb      	ldr	r3, [r7, #12]
20003f82:	681b      	ldr	r3, [r3, #0]
20003f84:	4a92      	ldr	r2, [pc, #584]	; (200041d0 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
20003f86:	4293      	cmp	r3, r2
20003f88:	d042      	beq.n	20004010 <HAL_DMAEx_MultiBufferStart_IT+0xbc8>
20003f8a:	68fb      	ldr	r3, [r7, #12]
20003f8c:	681b      	ldr	r3, [r3, #0]
20003f8e:	4a91      	ldr	r2, [pc, #580]	; (200041d4 <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
20003f90:	4293      	cmp	r3, r2
20003f92:	d03a      	beq.n	2000400a <HAL_DMAEx_MultiBufferStart_IT+0xbc2>
20003f94:	68fb      	ldr	r3, [r7, #12]
20003f96:	681b      	ldr	r3, [r3, #0]
20003f98:	4a8f      	ldr	r2, [pc, #572]	; (200041d8 <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
20003f9a:	4293      	cmp	r3, r2
20003f9c:	d032      	beq.n	20004004 <HAL_DMAEx_MultiBufferStart_IT+0xbbc>
20003f9e:	68fb      	ldr	r3, [r7, #12]
20003fa0:	681b      	ldr	r3, [r3, #0]
20003fa2:	4a8e      	ldr	r2, [pc, #568]	; (200041dc <HAL_DMAEx_MultiBufferStart_IT+0xd94>)
20003fa4:	4293      	cmp	r3, r2
20003fa6:	d02a      	beq.n	20003ffe <HAL_DMAEx_MultiBufferStart_IT+0xbb6>
20003fa8:	68fb      	ldr	r3, [r7, #12]
20003faa:	681b      	ldr	r3, [r3, #0]
20003fac:	4a8c      	ldr	r2, [pc, #560]	; (200041e0 <HAL_DMAEx_MultiBufferStart_IT+0xd98>)
20003fae:	4293      	cmp	r3, r2
20003fb0:	d022      	beq.n	20003ff8 <HAL_DMAEx_MultiBufferStart_IT+0xbb0>
20003fb2:	68fb      	ldr	r3, [r7, #12]
20003fb4:	681b      	ldr	r3, [r3, #0]
20003fb6:	4a8b      	ldr	r2, [pc, #556]	; (200041e4 <HAL_DMAEx_MultiBufferStart_IT+0xd9c>)
20003fb8:	4293      	cmp	r3, r2
20003fba:	d01a      	beq.n	20003ff2 <HAL_DMAEx_MultiBufferStart_IT+0xbaa>
20003fbc:	68fb      	ldr	r3, [r7, #12]
20003fbe:	681b      	ldr	r3, [r3, #0]
20003fc0:	4a89      	ldr	r2, [pc, #548]	; (200041e8 <HAL_DMAEx_MultiBufferStart_IT+0xda0>)
20003fc2:	4293      	cmp	r3, r2
20003fc4:	d012      	beq.n	20003fec <HAL_DMAEx_MultiBufferStart_IT+0xba4>
20003fc6:	68fb      	ldr	r3, [r7, #12]
20003fc8:	681b      	ldr	r3, [r3, #0]
20003fca:	4a88      	ldr	r2, [pc, #544]	; (200041ec <HAL_DMAEx_MultiBufferStart_IT+0xda4>)
20003fcc:	4293      	cmp	r3, r2
20003fce:	d00a      	beq.n	20003fe6 <HAL_DMAEx_MultiBufferStart_IT+0xb9e>
20003fd0:	68fb      	ldr	r3, [r7, #12]
20003fd2:	681b      	ldr	r3, [r3, #0]
20003fd4:	4a86      	ldr	r2, [pc, #536]	; (200041f0 <HAL_DMAEx_MultiBufferStart_IT+0xda8>)
20003fd6:	4293      	cmp	r3, r2
20003fd8:	d102      	bne.n	20003fe0 <HAL_DMAEx_MultiBufferStart_IT+0xb98>
20003fda:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20003fde:	e01e      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20003fe0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20003fe4:	e01b      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20003fe6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20003fea:	e018      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20003fec:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20003ff0:	e015      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20003ff2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20003ff6:	e012      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20003ff8:	f44f 7380 	mov.w	r3, #256	; 0x100
20003ffc:	e00f      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20003ffe:	f44f 7380 	mov.w	r3, #256	; 0x100
20004002:	e00c      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20004004:	f44f 7380 	mov.w	r3, #256	; 0x100
20004008:	e009      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
2000400a:	f44f 7380 	mov.w	r3, #256	; 0x100
2000400e:	e006      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20004010:	2304      	movs	r3, #4
20004012:	e004      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20004014:	2304      	movs	r3, #4
20004016:	e002      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
20004018:	2304      	movs	r3, #4
2000401a:	e000      	b.n	2000401e <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
2000401c:	2304      	movs	r3, #4
2000401e:	4a75      	ldr	r2, [pc, #468]	; (200041f4 <HAL_DMAEx_MultiBufferStart_IT+0xdac>)
20004020:	60d3      	str	r3, [r2, #12]
20004022:	e151      	b.n	200042c8 <HAL_DMAEx_MultiBufferStart_IT+0xe80>
20004024:	68fb      	ldr	r3, [r7, #12]
20004026:	681b      	ldr	r3, [r3, #0]
20004028:	461a      	mov	r2, r3
2000402a:	4b73      	ldr	r3, [pc, #460]	; (200041f8 <HAL_DMAEx_MultiBufferStart_IT+0xdb0>)
2000402c:	429a      	cmp	r2, r3
2000402e:	d960      	bls.n	200040f2 <HAL_DMAEx_MultiBufferStart_IT+0xcaa>
20004030:	68fb      	ldr	r3, [r7, #12]
20004032:	681b      	ldr	r3, [r3, #0]
20004034:	4a63      	ldr	r2, [pc, #396]	; (200041c4 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
20004036:	4293      	cmp	r3, r2
20004038:	d057      	beq.n	200040ea <HAL_DMAEx_MultiBufferStart_IT+0xca2>
2000403a:	68fb      	ldr	r3, [r7, #12]
2000403c:	681b      	ldr	r3, [r3, #0]
2000403e:	4a62      	ldr	r2, [pc, #392]	; (200041c8 <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
20004040:	4293      	cmp	r3, r2
20004042:	d050      	beq.n	200040e6 <HAL_DMAEx_MultiBufferStart_IT+0xc9e>
20004044:	68fb      	ldr	r3, [r7, #12]
20004046:	681b      	ldr	r3, [r3, #0]
20004048:	4a60      	ldr	r2, [pc, #384]	; (200041cc <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
2000404a:	4293      	cmp	r3, r2
2000404c:	d049      	beq.n	200040e2 <HAL_DMAEx_MultiBufferStart_IT+0xc9a>
2000404e:	68fb      	ldr	r3, [r7, #12]
20004050:	681b      	ldr	r3, [r3, #0]
20004052:	4a5f      	ldr	r2, [pc, #380]	; (200041d0 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
20004054:	4293      	cmp	r3, r2
20004056:	d042      	beq.n	200040de <HAL_DMAEx_MultiBufferStart_IT+0xc96>
20004058:	68fb      	ldr	r3, [r7, #12]
2000405a:	681b      	ldr	r3, [r3, #0]
2000405c:	4a5d      	ldr	r2, [pc, #372]	; (200041d4 <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
2000405e:	4293      	cmp	r3, r2
20004060:	d03a      	beq.n	200040d8 <HAL_DMAEx_MultiBufferStart_IT+0xc90>
20004062:	68fb      	ldr	r3, [r7, #12]
20004064:	681b      	ldr	r3, [r3, #0]
20004066:	4a5c      	ldr	r2, [pc, #368]	; (200041d8 <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
20004068:	4293      	cmp	r3, r2
2000406a:	d032      	beq.n	200040d2 <HAL_DMAEx_MultiBufferStart_IT+0xc8a>
2000406c:	68fb      	ldr	r3, [r7, #12]
2000406e:	681b      	ldr	r3, [r3, #0]
20004070:	4a5a      	ldr	r2, [pc, #360]	; (200041dc <HAL_DMAEx_MultiBufferStart_IT+0xd94>)
20004072:	4293      	cmp	r3, r2
20004074:	d02a      	beq.n	200040cc <HAL_DMAEx_MultiBufferStart_IT+0xc84>
20004076:	68fb      	ldr	r3, [r7, #12]
20004078:	681b      	ldr	r3, [r3, #0]
2000407a:	4a59      	ldr	r2, [pc, #356]	; (200041e0 <HAL_DMAEx_MultiBufferStart_IT+0xd98>)
2000407c:	4293      	cmp	r3, r2
2000407e:	d022      	beq.n	200040c6 <HAL_DMAEx_MultiBufferStart_IT+0xc7e>
20004080:	68fb      	ldr	r3, [r7, #12]
20004082:	681b      	ldr	r3, [r3, #0]
20004084:	4a57      	ldr	r2, [pc, #348]	; (200041e4 <HAL_DMAEx_MultiBufferStart_IT+0xd9c>)
20004086:	4293      	cmp	r3, r2
20004088:	d01a      	beq.n	200040c0 <HAL_DMAEx_MultiBufferStart_IT+0xc78>
2000408a:	68fb      	ldr	r3, [r7, #12]
2000408c:	681b      	ldr	r3, [r3, #0]
2000408e:	4a56      	ldr	r2, [pc, #344]	; (200041e8 <HAL_DMAEx_MultiBufferStart_IT+0xda0>)
20004090:	4293      	cmp	r3, r2
20004092:	d012      	beq.n	200040ba <HAL_DMAEx_MultiBufferStart_IT+0xc72>
20004094:	68fb      	ldr	r3, [r7, #12]
20004096:	681b      	ldr	r3, [r3, #0]
20004098:	4a54      	ldr	r2, [pc, #336]	; (200041ec <HAL_DMAEx_MultiBufferStart_IT+0xda4>)
2000409a:	4293      	cmp	r3, r2
2000409c:	d00a      	beq.n	200040b4 <HAL_DMAEx_MultiBufferStart_IT+0xc6c>
2000409e:	68fb      	ldr	r3, [r7, #12]
200040a0:	681b      	ldr	r3, [r3, #0]
200040a2:	4a53      	ldr	r2, [pc, #332]	; (200041f0 <HAL_DMAEx_MultiBufferStart_IT+0xda8>)
200040a4:	4293      	cmp	r3, r2
200040a6:	d102      	bne.n	200040ae <HAL_DMAEx_MultiBufferStart_IT+0xc66>
200040a8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
200040ac:	e01e      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040ae:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200040b2:	e01b      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040b4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
200040b8:	e018      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040ba:	f44f 2380 	mov.w	r3, #262144	; 0x40000
200040be:	e015      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040c0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
200040c4:	e012      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040c6:	f44f 7380 	mov.w	r3, #256	; 0x100
200040ca:	e00f      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040cc:	f44f 7380 	mov.w	r3, #256	; 0x100
200040d0:	e00c      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040d2:	f44f 7380 	mov.w	r3, #256	; 0x100
200040d6:	e009      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040d8:	f44f 7380 	mov.w	r3, #256	; 0x100
200040dc:	e006      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040de:	2304      	movs	r3, #4
200040e0:	e004      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040e2:	2304      	movs	r3, #4
200040e4:	e002      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040e6:	2304      	movs	r3, #4
200040e8:	e000      	b.n	200040ec <HAL_DMAEx_MultiBufferStart_IT+0xca4>
200040ea:	2304      	movs	r3, #4
200040ec:	4a41      	ldr	r2, [pc, #260]	; (200041f4 <HAL_DMAEx_MultiBufferStart_IT+0xdac>)
200040ee:	6093      	str	r3, [r2, #8]
200040f0:	e0ea      	b.n	200042c8 <HAL_DMAEx_MultiBufferStart_IT+0xe80>
200040f2:	68fb      	ldr	r3, [r7, #12]
200040f4:	681b      	ldr	r3, [r3, #0]
200040f6:	461a      	mov	r2, r3
200040f8:	4b40      	ldr	r3, [pc, #256]	; (200041fc <HAL_DMAEx_MultiBufferStart_IT+0xdb4>)
200040fa:	429a      	cmp	r2, r3
200040fc:	f240 8084 	bls.w	20004208 <HAL_DMAEx_MultiBufferStart_IT+0xdc0>
20004100:	68fb      	ldr	r3, [r7, #12]
20004102:	681b      	ldr	r3, [r3, #0]
20004104:	4a2f      	ldr	r2, [pc, #188]	; (200041c4 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
20004106:	4293      	cmp	r3, r2
20004108:	d07a      	beq.n	20004200 <HAL_DMAEx_MultiBufferStart_IT+0xdb8>
2000410a:	68fb      	ldr	r3, [r7, #12]
2000410c:	681b      	ldr	r3, [r3, #0]
2000410e:	4a2e      	ldr	r2, [pc, #184]	; (200041c8 <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
20004110:	4293      	cmp	r3, r2
20004112:	d050      	beq.n	200041b6 <HAL_DMAEx_MultiBufferStart_IT+0xd6e>
20004114:	68fb      	ldr	r3, [r7, #12]
20004116:	681b      	ldr	r3, [r3, #0]
20004118:	4a2c      	ldr	r2, [pc, #176]	; (200041cc <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
2000411a:	4293      	cmp	r3, r2
2000411c:	d049      	beq.n	200041b2 <HAL_DMAEx_MultiBufferStart_IT+0xd6a>
2000411e:	68fb      	ldr	r3, [r7, #12]
20004120:	681b      	ldr	r3, [r3, #0]
20004122:	4a2b      	ldr	r2, [pc, #172]	; (200041d0 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
20004124:	4293      	cmp	r3, r2
20004126:	d042      	beq.n	200041ae <HAL_DMAEx_MultiBufferStart_IT+0xd66>
20004128:	68fb      	ldr	r3, [r7, #12]
2000412a:	681b      	ldr	r3, [r3, #0]
2000412c:	4a29      	ldr	r2, [pc, #164]	; (200041d4 <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
2000412e:	4293      	cmp	r3, r2
20004130:	d03a      	beq.n	200041a8 <HAL_DMAEx_MultiBufferStart_IT+0xd60>
20004132:	68fb      	ldr	r3, [r7, #12]
20004134:	681b      	ldr	r3, [r3, #0]
20004136:	4a28      	ldr	r2, [pc, #160]	; (200041d8 <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
20004138:	4293      	cmp	r3, r2
2000413a:	d032      	beq.n	200041a2 <HAL_DMAEx_MultiBufferStart_IT+0xd5a>
2000413c:	68fb      	ldr	r3, [r7, #12]
2000413e:	681b      	ldr	r3, [r3, #0]
20004140:	4a26      	ldr	r2, [pc, #152]	; (200041dc <HAL_DMAEx_MultiBufferStart_IT+0xd94>)
20004142:	4293      	cmp	r3, r2
20004144:	d02a      	beq.n	2000419c <HAL_DMAEx_MultiBufferStart_IT+0xd54>
20004146:	68fb      	ldr	r3, [r7, #12]
20004148:	681b      	ldr	r3, [r3, #0]
2000414a:	4a25      	ldr	r2, [pc, #148]	; (200041e0 <HAL_DMAEx_MultiBufferStart_IT+0xd98>)
2000414c:	4293      	cmp	r3, r2
2000414e:	d022      	beq.n	20004196 <HAL_DMAEx_MultiBufferStart_IT+0xd4e>
20004150:	68fb      	ldr	r3, [r7, #12]
20004152:	681b      	ldr	r3, [r3, #0]
20004154:	4a23      	ldr	r2, [pc, #140]	; (200041e4 <HAL_DMAEx_MultiBufferStart_IT+0xd9c>)
20004156:	4293      	cmp	r3, r2
20004158:	d01a      	beq.n	20004190 <HAL_DMAEx_MultiBufferStart_IT+0xd48>
2000415a:	68fb      	ldr	r3, [r7, #12]
2000415c:	681b      	ldr	r3, [r3, #0]
2000415e:	4a22      	ldr	r2, [pc, #136]	; (200041e8 <HAL_DMAEx_MultiBufferStart_IT+0xda0>)
20004160:	4293      	cmp	r3, r2
20004162:	d012      	beq.n	2000418a <HAL_DMAEx_MultiBufferStart_IT+0xd42>
20004164:	68fb      	ldr	r3, [r7, #12]
20004166:	681b      	ldr	r3, [r3, #0]
20004168:	4a20      	ldr	r2, [pc, #128]	; (200041ec <HAL_DMAEx_MultiBufferStart_IT+0xda4>)
2000416a:	4293      	cmp	r3, r2
2000416c:	d00a      	beq.n	20004184 <HAL_DMAEx_MultiBufferStart_IT+0xd3c>
2000416e:	68fb      	ldr	r3, [r7, #12]
20004170:	681b      	ldr	r3, [r3, #0]
20004172:	4a1f      	ldr	r2, [pc, #124]	; (200041f0 <HAL_DMAEx_MultiBufferStart_IT+0xda8>)
20004174:	4293      	cmp	r3, r2
20004176:	d102      	bne.n	2000417e <HAL_DMAEx_MultiBufferStart_IT+0xd36>
20004178:	f44f 2380 	mov.w	r3, #262144	; 0x40000
2000417c:	e041      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
2000417e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20004182:	e03e      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
20004184:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20004188:	e03b      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
2000418a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
2000418e:	e038      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
20004190:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20004194:	e035      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
20004196:	f44f 7380 	mov.w	r3, #256	; 0x100
2000419a:	e032      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
2000419c:	f44f 7380 	mov.w	r3, #256	; 0x100
200041a0:	e02f      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
200041a2:	f44f 7380 	mov.w	r3, #256	; 0x100
200041a6:	e02c      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
200041a8:	f44f 7380 	mov.w	r3, #256	; 0x100
200041ac:	e029      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
200041ae:	2304      	movs	r3, #4
200041b0:	e027      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
200041b2:	2304      	movs	r3, #4
200041b4:	e025      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
200041b6:	2304      	movs	r3, #4
200041b8:	e023      	b.n	20004202 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
200041ba:	bf00      	nop
200041bc:	40026000 	.word	0x40026000
200041c0:	40026458 	.word	0x40026458
200041c4:	40026010 	.word	0x40026010
200041c8:	40026410 	.word	0x40026410
200041cc:	40026070 	.word	0x40026070
200041d0:	40026470 	.word	0x40026470
200041d4:	40026028 	.word	0x40026028
200041d8:	40026428 	.word	0x40026428
200041dc:	40026088 	.word	0x40026088
200041e0:	40026488 	.word	0x40026488
200041e4:	40026040 	.word	0x40026040
200041e8:	40026440 	.word	0x40026440
200041ec:	400260a0 	.word	0x400260a0
200041f0:	400264a0 	.word	0x400264a0
200041f4:	40026400 	.word	0x40026400
200041f8:	400260b8 	.word	0x400260b8
200041fc:	40026058 	.word	0x40026058
20004200:	2304      	movs	r3, #4
20004202:	4a94      	ldr	r2, [pc, #592]	; (20004454 <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
20004204:	60d3      	str	r3, [r2, #12]
20004206:	e05f      	b.n	200042c8 <HAL_DMAEx_MultiBufferStart_IT+0xe80>
20004208:	68fb      	ldr	r3, [r7, #12]
2000420a:	681b      	ldr	r3, [r3, #0]
2000420c:	4a92      	ldr	r2, [pc, #584]	; (20004458 <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
2000420e:	4293      	cmp	r3, r2
20004210:	d057      	beq.n	200042c2 <HAL_DMAEx_MultiBufferStart_IT+0xe7a>
20004212:	68fb      	ldr	r3, [r7, #12]
20004214:	681b      	ldr	r3, [r3, #0]
20004216:	4a91      	ldr	r2, [pc, #580]	; (2000445c <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
20004218:	4293      	cmp	r3, r2
2000421a:	d050      	beq.n	200042be <HAL_DMAEx_MultiBufferStart_IT+0xe76>
2000421c:	68fb      	ldr	r3, [r7, #12]
2000421e:	681b      	ldr	r3, [r3, #0]
20004220:	4a8f      	ldr	r2, [pc, #572]	; (20004460 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
20004222:	4293      	cmp	r3, r2
20004224:	d049      	beq.n	200042ba <HAL_DMAEx_MultiBufferStart_IT+0xe72>
20004226:	68fb      	ldr	r3, [r7, #12]
20004228:	681b      	ldr	r3, [r3, #0]
2000422a:	4a8e      	ldr	r2, [pc, #568]	; (20004464 <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
2000422c:	4293      	cmp	r3, r2
2000422e:	d042      	beq.n	200042b6 <HAL_DMAEx_MultiBufferStart_IT+0xe6e>
20004230:	68fb      	ldr	r3, [r7, #12]
20004232:	681b      	ldr	r3, [r3, #0]
20004234:	4a8c      	ldr	r2, [pc, #560]	; (20004468 <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
20004236:	4293      	cmp	r3, r2
20004238:	d03a      	beq.n	200042b0 <HAL_DMAEx_MultiBufferStart_IT+0xe68>
2000423a:	68fb      	ldr	r3, [r7, #12]
2000423c:	681b      	ldr	r3, [r3, #0]
2000423e:	4a8b      	ldr	r2, [pc, #556]	; (2000446c <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
20004240:	4293      	cmp	r3, r2
20004242:	d032      	beq.n	200042aa <HAL_DMAEx_MultiBufferStart_IT+0xe62>
20004244:	68fb      	ldr	r3, [r7, #12]
20004246:	681b      	ldr	r3, [r3, #0]
20004248:	4a89      	ldr	r2, [pc, #548]	; (20004470 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
2000424a:	4293      	cmp	r3, r2
2000424c:	d02a      	beq.n	200042a4 <HAL_DMAEx_MultiBufferStart_IT+0xe5c>
2000424e:	68fb      	ldr	r3, [r7, #12]
20004250:	681b      	ldr	r3, [r3, #0]
20004252:	4a88      	ldr	r2, [pc, #544]	; (20004474 <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
20004254:	4293      	cmp	r3, r2
20004256:	d022      	beq.n	2000429e <HAL_DMAEx_MultiBufferStart_IT+0xe56>
20004258:	68fb      	ldr	r3, [r7, #12]
2000425a:	681b      	ldr	r3, [r3, #0]
2000425c:	4a86      	ldr	r2, [pc, #536]	; (20004478 <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
2000425e:	4293      	cmp	r3, r2
20004260:	d01a      	beq.n	20004298 <HAL_DMAEx_MultiBufferStart_IT+0xe50>
20004262:	68fb      	ldr	r3, [r7, #12]
20004264:	681b      	ldr	r3, [r3, #0]
20004266:	4a85      	ldr	r2, [pc, #532]	; (2000447c <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
20004268:	4293      	cmp	r3, r2
2000426a:	d012      	beq.n	20004292 <HAL_DMAEx_MultiBufferStart_IT+0xe4a>
2000426c:	68fb      	ldr	r3, [r7, #12]
2000426e:	681b      	ldr	r3, [r3, #0]
20004270:	4a83      	ldr	r2, [pc, #524]	; (20004480 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
20004272:	4293      	cmp	r3, r2
20004274:	d00a      	beq.n	2000428c <HAL_DMAEx_MultiBufferStart_IT+0xe44>
20004276:	68fb      	ldr	r3, [r7, #12]
20004278:	681b      	ldr	r3, [r3, #0]
2000427a:	4a82      	ldr	r2, [pc, #520]	; (20004484 <HAL_DMAEx_MultiBufferStart_IT+0x103c>)
2000427c:	4293      	cmp	r3, r2
2000427e:	d102      	bne.n	20004286 <HAL_DMAEx_MultiBufferStart_IT+0xe3e>
20004280:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20004284:	e01e      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
20004286:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000428a:	e01b      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
2000428c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20004290:	e018      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
20004292:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20004296:	e015      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
20004298:	f44f 2380 	mov.w	r3, #262144	; 0x40000
2000429c:	e012      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
2000429e:	f44f 7380 	mov.w	r3, #256	; 0x100
200042a2:	e00f      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
200042a4:	f44f 7380 	mov.w	r3, #256	; 0x100
200042a8:	e00c      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
200042aa:	f44f 7380 	mov.w	r3, #256	; 0x100
200042ae:	e009      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
200042b0:	f44f 7380 	mov.w	r3, #256	; 0x100
200042b4:	e006      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
200042b6:	2304      	movs	r3, #4
200042b8:	e004      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
200042ba:	2304      	movs	r3, #4
200042bc:	e002      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
200042be:	2304      	movs	r3, #4
200042c0:	e000      	b.n	200042c4 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
200042c2:	2304      	movs	r3, #4
200042c4:	4a63      	ldr	r2, [pc, #396]	; (20004454 <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
200042c6:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
200042c8:	68fb      	ldr	r3, [r7, #12]
200042ca:	681b      	ldr	r3, [r3, #0]
200042cc:	461a      	mov	r2, r3
200042ce:	4b6e      	ldr	r3, [pc, #440]	; (20004488 <HAL_DMAEx_MultiBufferStart_IT+0x1040>)
200042d0:	429a      	cmp	r2, r3
200042d2:	d95c      	bls.n	2000438e <HAL_DMAEx_MultiBufferStart_IT+0xf46>
200042d4:	68fb      	ldr	r3, [r7, #12]
200042d6:	681b      	ldr	r3, [r3, #0]
200042d8:	4a5f      	ldr	r2, [pc, #380]	; (20004458 <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
200042da:	4293      	cmp	r3, r2
200042dc:	d053      	beq.n	20004386 <HAL_DMAEx_MultiBufferStart_IT+0xf3e>
200042de:	68fb      	ldr	r3, [r7, #12]
200042e0:	681b      	ldr	r3, [r3, #0]
200042e2:	4a5e      	ldr	r2, [pc, #376]	; (2000445c <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
200042e4:	4293      	cmp	r3, r2
200042e6:	d04c      	beq.n	20004382 <HAL_DMAEx_MultiBufferStart_IT+0xf3a>
200042e8:	68fb      	ldr	r3, [r7, #12]
200042ea:	681b      	ldr	r3, [r3, #0]
200042ec:	4a5c      	ldr	r2, [pc, #368]	; (20004460 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
200042ee:	4293      	cmp	r3, r2
200042f0:	d045      	beq.n	2000437e <HAL_DMAEx_MultiBufferStart_IT+0xf36>
200042f2:	68fb      	ldr	r3, [r7, #12]
200042f4:	681b      	ldr	r3, [r3, #0]
200042f6:	4a5b      	ldr	r2, [pc, #364]	; (20004464 <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
200042f8:	4293      	cmp	r3, r2
200042fa:	d03e      	beq.n	2000437a <HAL_DMAEx_MultiBufferStart_IT+0xf32>
200042fc:	68fb      	ldr	r3, [r7, #12]
200042fe:	681b      	ldr	r3, [r3, #0]
20004300:	4a59      	ldr	r2, [pc, #356]	; (20004468 <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
20004302:	4293      	cmp	r3, r2
20004304:	d037      	beq.n	20004376 <HAL_DMAEx_MultiBufferStart_IT+0xf2e>
20004306:	68fb      	ldr	r3, [r7, #12]
20004308:	681b      	ldr	r3, [r3, #0]
2000430a:	4a58      	ldr	r2, [pc, #352]	; (2000446c <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
2000430c:	4293      	cmp	r3, r2
2000430e:	d030      	beq.n	20004372 <HAL_DMAEx_MultiBufferStart_IT+0xf2a>
20004310:	68fb      	ldr	r3, [r7, #12]
20004312:	681b      	ldr	r3, [r3, #0]
20004314:	4a56      	ldr	r2, [pc, #344]	; (20004470 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
20004316:	4293      	cmp	r3, r2
20004318:	d029      	beq.n	2000436e <HAL_DMAEx_MultiBufferStart_IT+0xf26>
2000431a:	68fb      	ldr	r3, [r7, #12]
2000431c:	681b      	ldr	r3, [r3, #0]
2000431e:	4a55      	ldr	r2, [pc, #340]	; (20004474 <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
20004320:	4293      	cmp	r3, r2
20004322:	d022      	beq.n	2000436a <HAL_DMAEx_MultiBufferStart_IT+0xf22>
20004324:	68fb      	ldr	r3, [r7, #12]
20004326:	681b      	ldr	r3, [r3, #0]
20004328:	4a53      	ldr	r2, [pc, #332]	; (20004478 <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
2000432a:	4293      	cmp	r3, r2
2000432c:	d01a      	beq.n	20004364 <HAL_DMAEx_MultiBufferStart_IT+0xf1c>
2000432e:	68fb      	ldr	r3, [r7, #12]
20004330:	681b      	ldr	r3, [r3, #0]
20004332:	4a52      	ldr	r2, [pc, #328]	; (2000447c <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
20004334:	4293      	cmp	r3, r2
20004336:	d012      	beq.n	2000435e <HAL_DMAEx_MultiBufferStart_IT+0xf16>
20004338:	68fb      	ldr	r3, [r7, #12]
2000433a:	681b      	ldr	r3, [r3, #0]
2000433c:	4a50      	ldr	r2, [pc, #320]	; (20004480 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
2000433e:	4293      	cmp	r3, r2
20004340:	d00a      	beq.n	20004358 <HAL_DMAEx_MultiBufferStart_IT+0xf10>
20004342:	68fb      	ldr	r3, [r7, #12]
20004344:	681b      	ldr	r3, [r3, #0]
20004346:	4a4f      	ldr	r2, [pc, #316]	; (20004484 <HAL_DMAEx_MultiBufferStart_IT+0x103c>)
20004348:	4293      	cmp	r3, r2
2000434a:	d102      	bne.n	20004352 <HAL_DMAEx_MultiBufferStart_IT+0xf0a>
2000434c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004350:	e01a      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
20004352:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
20004356:	e017      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
20004358:	f44f 3380 	mov.w	r3, #65536	; 0x10000
2000435c:	e014      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
2000435e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004362:	e011      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
20004364:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004368:	e00e      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
2000436a:	2340      	movs	r3, #64	; 0x40
2000436c:	e00c      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
2000436e:	2340      	movs	r3, #64	; 0x40
20004370:	e00a      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
20004372:	2340      	movs	r3, #64	; 0x40
20004374:	e008      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
20004376:	2340      	movs	r3, #64	; 0x40
20004378:	e006      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
2000437a:	2301      	movs	r3, #1
2000437c:	e004      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
2000437e:	2301      	movs	r3, #1
20004380:	e002      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
20004382:	2301      	movs	r3, #1
20004384:	e000      	b.n	20004388 <HAL_DMAEx_MultiBufferStart_IT+0xf40>
20004386:	2301      	movs	r3, #1
20004388:	4a40      	ldr	r2, [pc, #256]	; (2000448c <HAL_DMAEx_MultiBufferStart_IT+0x1044>)
2000438a:	60d3      	str	r3, [r2, #12]
2000438c:	e141      	b.n	20004612 <HAL_DMAEx_MultiBufferStart_IT+0x11ca>
2000438e:	68fb      	ldr	r3, [r7, #12]
20004390:	681b      	ldr	r3, [r3, #0]
20004392:	461a      	mov	r2, r3
20004394:	4b3e      	ldr	r3, [pc, #248]	; (20004490 <HAL_DMAEx_MultiBufferStart_IT+0x1048>)
20004396:	429a      	cmp	r2, r3
20004398:	d97c      	bls.n	20004494 <HAL_DMAEx_MultiBufferStart_IT+0x104c>
2000439a:	68fb      	ldr	r3, [r7, #12]
2000439c:	681b      	ldr	r3, [r3, #0]
2000439e:	4a2e      	ldr	r2, [pc, #184]	; (20004458 <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
200043a0:	4293      	cmp	r3, r2
200043a2:	d053      	beq.n	2000444c <HAL_DMAEx_MultiBufferStart_IT+0x1004>
200043a4:	68fb      	ldr	r3, [r7, #12]
200043a6:	681b      	ldr	r3, [r3, #0]
200043a8:	4a2c      	ldr	r2, [pc, #176]	; (2000445c <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
200043aa:	4293      	cmp	r3, r2
200043ac:	d04c      	beq.n	20004448 <HAL_DMAEx_MultiBufferStart_IT+0x1000>
200043ae:	68fb      	ldr	r3, [r7, #12]
200043b0:	681b      	ldr	r3, [r3, #0]
200043b2:	4a2b      	ldr	r2, [pc, #172]	; (20004460 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
200043b4:	4293      	cmp	r3, r2
200043b6:	d045      	beq.n	20004444 <HAL_DMAEx_MultiBufferStart_IT+0xffc>
200043b8:	68fb      	ldr	r3, [r7, #12]
200043ba:	681b      	ldr	r3, [r3, #0]
200043bc:	4a29      	ldr	r2, [pc, #164]	; (20004464 <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
200043be:	4293      	cmp	r3, r2
200043c0:	d03e      	beq.n	20004440 <HAL_DMAEx_MultiBufferStart_IT+0xff8>
200043c2:	68fb      	ldr	r3, [r7, #12]
200043c4:	681b      	ldr	r3, [r3, #0]
200043c6:	4a28      	ldr	r2, [pc, #160]	; (20004468 <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
200043c8:	4293      	cmp	r3, r2
200043ca:	d037      	beq.n	2000443c <HAL_DMAEx_MultiBufferStart_IT+0xff4>
200043cc:	68fb      	ldr	r3, [r7, #12]
200043ce:	681b      	ldr	r3, [r3, #0]
200043d0:	4a26      	ldr	r2, [pc, #152]	; (2000446c <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
200043d2:	4293      	cmp	r3, r2
200043d4:	d030      	beq.n	20004438 <HAL_DMAEx_MultiBufferStart_IT+0xff0>
200043d6:	68fb      	ldr	r3, [r7, #12]
200043d8:	681b      	ldr	r3, [r3, #0]
200043da:	4a25      	ldr	r2, [pc, #148]	; (20004470 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
200043dc:	4293      	cmp	r3, r2
200043de:	d029      	beq.n	20004434 <HAL_DMAEx_MultiBufferStart_IT+0xfec>
200043e0:	68fb      	ldr	r3, [r7, #12]
200043e2:	681b      	ldr	r3, [r3, #0]
200043e4:	4a23      	ldr	r2, [pc, #140]	; (20004474 <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
200043e6:	4293      	cmp	r3, r2
200043e8:	d022      	beq.n	20004430 <HAL_DMAEx_MultiBufferStart_IT+0xfe8>
200043ea:	68fb      	ldr	r3, [r7, #12]
200043ec:	681b      	ldr	r3, [r3, #0]
200043ee:	4a22      	ldr	r2, [pc, #136]	; (20004478 <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
200043f0:	4293      	cmp	r3, r2
200043f2:	d01a      	beq.n	2000442a <HAL_DMAEx_MultiBufferStart_IT+0xfe2>
200043f4:	68fb      	ldr	r3, [r7, #12]
200043f6:	681b      	ldr	r3, [r3, #0]
200043f8:	4a20      	ldr	r2, [pc, #128]	; (2000447c <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
200043fa:	4293      	cmp	r3, r2
200043fc:	d012      	beq.n	20004424 <HAL_DMAEx_MultiBufferStart_IT+0xfdc>
200043fe:	68fb      	ldr	r3, [r7, #12]
20004400:	681b      	ldr	r3, [r3, #0]
20004402:	4a1f      	ldr	r2, [pc, #124]	; (20004480 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
20004404:	4293      	cmp	r3, r2
20004406:	d00a      	beq.n	2000441e <HAL_DMAEx_MultiBufferStart_IT+0xfd6>
20004408:	68fb      	ldr	r3, [r7, #12]
2000440a:	681b      	ldr	r3, [r3, #0]
2000440c:	4a1d      	ldr	r2, [pc, #116]	; (20004484 <HAL_DMAEx_MultiBufferStart_IT+0x103c>)
2000440e:	4293      	cmp	r3, r2
20004410:	d102      	bne.n	20004418 <HAL_DMAEx_MultiBufferStart_IT+0xfd0>
20004412:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004416:	e01a      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004418:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2000441c:	e017      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
2000441e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004422:	e014      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004424:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004428:	e011      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
2000442a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
2000442e:	e00e      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004430:	2340      	movs	r3, #64	; 0x40
20004432:	e00c      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004434:	2340      	movs	r3, #64	; 0x40
20004436:	e00a      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004438:	2340      	movs	r3, #64	; 0x40
2000443a:	e008      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
2000443c:	2340      	movs	r3, #64	; 0x40
2000443e:	e006      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004440:	2301      	movs	r3, #1
20004442:	e004      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004444:	2301      	movs	r3, #1
20004446:	e002      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
20004448:	2301      	movs	r3, #1
2000444a:	e000      	b.n	2000444e <HAL_DMAEx_MultiBufferStart_IT+0x1006>
2000444c:	2301      	movs	r3, #1
2000444e:	4a0f      	ldr	r2, [pc, #60]	; (2000448c <HAL_DMAEx_MultiBufferStart_IT+0x1044>)
20004450:	6093      	str	r3, [r2, #8]
20004452:	e0de      	b.n	20004612 <HAL_DMAEx_MultiBufferStart_IT+0x11ca>
20004454:	40026000 	.word	0x40026000
20004458:	40026010 	.word	0x40026010
2000445c:	40026410 	.word	0x40026410
20004460:	40026070 	.word	0x40026070
20004464:	40026470 	.word	0x40026470
20004468:	40026028 	.word	0x40026028
2000446c:	40026428 	.word	0x40026428
20004470:	40026088 	.word	0x40026088
20004474:	40026488 	.word	0x40026488
20004478:	40026040 	.word	0x40026040
2000447c:	40026440 	.word	0x40026440
20004480:	400260a0 	.word	0x400260a0
20004484:	400264a0 	.word	0x400264a0
20004488:	40026458 	.word	0x40026458
2000448c:	40026400 	.word	0x40026400
20004490:	400260b8 	.word	0x400260b8
20004494:	68fb      	ldr	r3, [r7, #12]
20004496:	681b      	ldr	r3, [r3, #0]
20004498:	461a      	mov	r2, r3
2000449a:	4b78      	ldr	r3, [pc, #480]	; (2000467c <HAL_DMAEx_MultiBufferStart_IT+0x1234>)
2000449c:	429a      	cmp	r2, r3
2000449e:	d95c      	bls.n	2000455a <HAL_DMAEx_MultiBufferStart_IT+0x1112>
200044a0:	68fb      	ldr	r3, [r7, #12]
200044a2:	681b      	ldr	r3, [r3, #0]
200044a4:	4a76      	ldr	r2, [pc, #472]	; (20004680 <HAL_DMAEx_MultiBufferStart_IT+0x1238>)
200044a6:	4293      	cmp	r3, r2
200044a8:	d053      	beq.n	20004552 <HAL_DMAEx_MultiBufferStart_IT+0x110a>
200044aa:	68fb      	ldr	r3, [r7, #12]
200044ac:	681b      	ldr	r3, [r3, #0]
200044ae:	4a75      	ldr	r2, [pc, #468]	; (20004684 <HAL_DMAEx_MultiBufferStart_IT+0x123c>)
200044b0:	4293      	cmp	r3, r2
200044b2:	d04c      	beq.n	2000454e <HAL_DMAEx_MultiBufferStart_IT+0x1106>
200044b4:	68fb      	ldr	r3, [r7, #12]
200044b6:	681b      	ldr	r3, [r3, #0]
200044b8:	4a73      	ldr	r2, [pc, #460]	; (20004688 <HAL_DMAEx_MultiBufferStart_IT+0x1240>)
200044ba:	4293      	cmp	r3, r2
200044bc:	d045      	beq.n	2000454a <HAL_DMAEx_MultiBufferStart_IT+0x1102>
200044be:	68fb      	ldr	r3, [r7, #12]
200044c0:	681b      	ldr	r3, [r3, #0]
200044c2:	4a72      	ldr	r2, [pc, #456]	; (2000468c <HAL_DMAEx_MultiBufferStart_IT+0x1244>)
200044c4:	4293      	cmp	r3, r2
200044c6:	d03e      	beq.n	20004546 <HAL_DMAEx_MultiBufferStart_IT+0x10fe>
200044c8:	68fb      	ldr	r3, [r7, #12]
200044ca:	681b      	ldr	r3, [r3, #0]
200044cc:	4a70      	ldr	r2, [pc, #448]	; (20004690 <HAL_DMAEx_MultiBufferStart_IT+0x1248>)
200044ce:	4293      	cmp	r3, r2
200044d0:	d037      	beq.n	20004542 <HAL_DMAEx_MultiBufferStart_IT+0x10fa>
200044d2:	68fb      	ldr	r3, [r7, #12]
200044d4:	681b      	ldr	r3, [r3, #0]
200044d6:	4a6f      	ldr	r2, [pc, #444]	; (20004694 <HAL_DMAEx_MultiBufferStart_IT+0x124c>)
200044d8:	4293      	cmp	r3, r2
200044da:	d030      	beq.n	2000453e <HAL_DMAEx_MultiBufferStart_IT+0x10f6>
200044dc:	68fb      	ldr	r3, [r7, #12]
200044de:	681b      	ldr	r3, [r3, #0]
200044e0:	4a6d      	ldr	r2, [pc, #436]	; (20004698 <HAL_DMAEx_MultiBufferStart_IT+0x1250>)
200044e2:	4293      	cmp	r3, r2
200044e4:	d029      	beq.n	2000453a <HAL_DMAEx_MultiBufferStart_IT+0x10f2>
200044e6:	68fb      	ldr	r3, [r7, #12]
200044e8:	681b      	ldr	r3, [r3, #0]
200044ea:	4a6c      	ldr	r2, [pc, #432]	; (2000469c <HAL_DMAEx_MultiBufferStart_IT+0x1254>)
200044ec:	4293      	cmp	r3, r2
200044ee:	d022      	beq.n	20004536 <HAL_DMAEx_MultiBufferStart_IT+0x10ee>
200044f0:	68fb      	ldr	r3, [r7, #12]
200044f2:	681b      	ldr	r3, [r3, #0]
200044f4:	4a6a      	ldr	r2, [pc, #424]	; (200046a0 <HAL_DMAEx_MultiBufferStart_IT+0x1258>)
200044f6:	4293      	cmp	r3, r2
200044f8:	d01a      	beq.n	20004530 <HAL_DMAEx_MultiBufferStart_IT+0x10e8>
200044fa:	68fb      	ldr	r3, [r7, #12]
200044fc:	681b      	ldr	r3, [r3, #0]
200044fe:	4a69      	ldr	r2, [pc, #420]	; (200046a4 <HAL_DMAEx_MultiBufferStart_IT+0x125c>)
20004500:	4293      	cmp	r3, r2
20004502:	d012      	beq.n	2000452a <HAL_DMAEx_MultiBufferStart_IT+0x10e2>
20004504:	68fb      	ldr	r3, [r7, #12]
20004506:	681b      	ldr	r3, [r3, #0]
20004508:	4a67      	ldr	r2, [pc, #412]	; (200046a8 <HAL_DMAEx_MultiBufferStart_IT+0x1260>)
2000450a:	4293      	cmp	r3, r2
2000450c:	d00a      	beq.n	20004524 <HAL_DMAEx_MultiBufferStart_IT+0x10dc>
2000450e:	68fb      	ldr	r3, [r7, #12]
20004510:	681b      	ldr	r3, [r3, #0]
20004512:	4a66      	ldr	r2, [pc, #408]	; (200046ac <HAL_DMAEx_MultiBufferStart_IT+0x1264>)
20004514:	4293      	cmp	r3, r2
20004516:	d102      	bne.n	2000451e <HAL_DMAEx_MultiBufferStart_IT+0x10d6>
20004518:	f44f 3380 	mov.w	r3, #65536	; 0x10000
2000451c:	e01a      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
2000451e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
20004522:	e017      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
20004524:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004528:	e014      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
2000452a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
2000452e:	e011      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
20004530:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20004534:	e00e      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
20004536:	2340      	movs	r3, #64	; 0x40
20004538:	e00c      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
2000453a:	2340      	movs	r3, #64	; 0x40
2000453c:	e00a      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
2000453e:	2340      	movs	r3, #64	; 0x40
20004540:	e008      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
20004542:	2340      	movs	r3, #64	; 0x40
20004544:	e006      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
20004546:	2301      	movs	r3, #1
20004548:	e004      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
2000454a:	2301      	movs	r3, #1
2000454c:	e002      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
2000454e:	2301      	movs	r3, #1
20004550:	e000      	b.n	20004554 <HAL_DMAEx_MultiBufferStart_IT+0x110c>
20004552:	2301      	movs	r3, #1
20004554:	4a56      	ldr	r2, [pc, #344]	; (200046b0 <HAL_DMAEx_MultiBufferStart_IT+0x1268>)
20004556:	60d3      	str	r3, [r2, #12]
20004558:	e05b      	b.n	20004612 <HAL_DMAEx_MultiBufferStart_IT+0x11ca>
2000455a:	68fb      	ldr	r3, [r7, #12]
2000455c:	681b      	ldr	r3, [r3, #0]
2000455e:	4a48      	ldr	r2, [pc, #288]	; (20004680 <HAL_DMAEx_MultiBufferStart_IT+0x1238>)
20004560:	4293      	cmp	r3, r2
20004562:	d053      	beq.n	2000460c <HAL_DMAEx_MultiBufferStart_IT+0x11c4>
20004564:	68fb      	ldr	r3, [r7, #12]
20004566:	681b      	ldr	r3, [r3, #0]
20004568:	4a46      	ldr	r2, [pc, #280]	; (20004684 <HAL_DMAEx_MultiBufferStart_IT+0x123c>)
2000456a:	4293      	cmp	r3, r2
2000456c:	d04c      	beq.n	20004608 <HAL_DMAEx_MultiBufferStart_IT+0x11c0>
2000456e:	68fb      	ldr	r3, [r7, #12]
20004570:	681b      	ldr	r3, [r3, #0]
20004572:	4a45      	ldr	r2, [pc, #276]	; (20004688 <HAL_DMAEx_MultiBufferStart_IT+0x1240>)
20004574:	4293      	cmp	r3, r2
20004576:	d045      	beq.n	20004604 <HAL_DMAEx_MultiBufferStart_IT+0x11bc>
20004578:	68fb      	ldr	r3, [r7, #12]
2000457a:	681b      	ldr	r3, [r3, #0]
2000457c:	4a43      	ldr	r2, [pc, #268]	; (2000468c <HAL_DMAEx_MultiBufferStart_IT+0x1244>)
2000457e:	4293      	cmp	r3, r2
20004580:	d03e      	beq.n	20004600 <HAL_DMAEx_MultiBufferStart_IT+0x11b8>
20004582:	68fb      	ldr	r3, [r7, #12]
20004584:	681b      	ldr	r3, [r3, #0]
20004586:	4a42      	ldr	r2, [pc, #264]	; (20004690 <HAL_DMAEx_MultiBufferStart_IT+0x1248>)
20004588:	4293      	cmp	r3, r2
2000458a:	d037      	beq.n	200045fc <HAL_DMAEx_MultiBufferStart_IT+0x11b4>
2000458c:	68fb      	ldr	r3, [r7, #12]
2000458e:	681b      	ldr	r3, [r3, #0]
20004590:	4a40      	ldr	r2, [pc, #256]	; (20004694 <HAL_DMAEx_MultiBufferStart_IT+0x124c>)
20004592:	4293      	cmp	r3, r2
20004594:	d030      	beq.n	200045f8 <HAL_DMAEx_MultiBufferStart_IT+0x11b0>
20004596:	68fb      	ldr	r3, [r7, #12]
20004598:	681b      	ldr	r3, [r3, #0]
2000459a:	4a3f      	ldr	r2, [pc, #252]	; (20004698 <HAL_DMAEx_MultiBufferStart_IT+0x1250>)
2000459c:	4293      	cmp	r3, r2
2000459e:	d029      	beq.n	200045f4 <HAL_DMAEx_MultiBufferStart_IT+0x11ac>
200045a0:	68fb      	ldr	r3, [r7, #12]
200045a2:	681b      	ldr	r3, [r3, #0]
200045a4:	4a3d      	ldr	r2, [pc, #244]	; (2000469c <HAL_DMAEx_MultiBufferStart_IT+0x1254>)
200045a6:	4293      	cmp	r3, r2
200045a8:	d022      	beq.n	200045f0 <HAL_DMAEx_MultiBufferStart_IT+0x11a8>
200045aa:	68fb      	ldr	r3, [r7, #12]
200045ac:	681b      	ldr	r3, [r3, #0]
200045ae:	4a3c      	ldr	r2, [pc, #240]	; (200046a0 <HAL_DMAEx_MultiBufferStart_IT+0x1258>)
200045b0:	4293      	cmp	r3, r2
200045b2:	d01a      	beq.n	200045ea <HAL_DMAEx_MultiBufferStart_IT+0x11a2>
200045b4:	68fb      	ldr	r3, [r7, #12]
200045b6:	681b      	ldr	r3, [r3, #0]
200045b8:	4a3a      	ldr	r2, [pc, #232]	; (200046a4 <HAL_DMAEx_MultiBufferStart_IT+0x125c>)
200045ba:	4293      	cmp	r3, r2
200045bc:	d012      	beq.n	200045e4 <HAL_DMAEx_MultiBufferStart_IT+0x119c>
200045be:	68fb      	ldr	r3, [r7, #12]
200045c0:	681b      	ldr	r3, [r3, #0]
200045c2:	4a39      	ldr	r2, [pc, #228]	; (200046a8 <HAL_DMAEx_MultiBufferStart_IT+0x1260>)
200045c4:	4293      	cmp	r3, r2
200045c6:	d00a      	beq.n	200045de <HAL_DMAEx_MultiBufferStart_IT+0x1196>
200045c8:	68fb      	ldr	r3, [r7, #12]
200045ca:	681b      	ldr	r3, [r3, #0]
200045cc:	4a37      	ldr	r2, [pc, #220]	; (200046ac <HAL_DMAEx_MultiBufferStart_IT+0x1264>)
200045ce:	4293      	cmp	r3, r2
200045d0:	d102      	bne.n	200045d8 <HAL_DMAEx_MultiBufferStart_IT+0x1190>
200045d2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
200045d6:	e01a      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045d8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
200045dc:	e017      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045de:	f44f 3380 	mov.w	r3, #65536	; 0x10000
200045e2:	e014      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045e4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
200045e8:	e011      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045ea:	f44f 3380 	mov.w	r3, #65536	; 0x10000
200045ee:	e00e      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045f0:	2340      	movs	r3, #64	; 0x40
200045f2:	e00c      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045f4:	2340      	movs	r3, #64	; 0x40
200045f6:	e00a      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045f8:	2340      	movs	r3, #64	; 0x40
200045fa:	e008      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
200045fc:	2340      	movs	r3, #64	; 0x40
200045fe:	e006      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
20004600:	2301      	movs	r3, #1
20004602:	e004      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
20004604:	2301      	movs	r3, #1
20004606:	e002      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
20004608:	2301      	movs	r3, #1
2000460a:	e000      	b.n	2000460e <HAL_DMAEx_MultiBufferStart_IT+0x11c6>
2000460c:	2301      	movs	r3, #1
2000460e:	4a28      	ldr	r2, [pc, #160]	; (200046b0 <HAL_DMAEx_MultiBufferStart_IT+0x1268>)
20004610:	6093      	str	r3, [r2, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
20004612:	68fb      	ldr	r3, [r7, #12]
20004614:	681b      	ldr	r3, [r3, #0]
20004616:	681a      	ldr	r2, [r3, #0]
20004618:	68fb      	ldr	r3, [r7, #12]
2000461a:	681b      	ldr	r3, [r3, #0]
2000461c:	f042 0216 	orr.w	r2, r2, #22
20004620:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
20004622:	68fb      	ldr	r3, [r7, #12]
20004624:	681b      	ldr	r3, [r3, #0]
20004626:	695a      	ldr	r2, [r3, #20]
20004628:	68fb      	ldr	r3, [r7, #12]
2000462a:	681b      	ldr	r3, [r3, #0]
2000462c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20004630:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
20004632:	68fb      	ldr	r3, [r7, #12]
20004634:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20004636:	2b00      	cmp	r3, #0
20004638:	d103      	bne.n	20004642 <HAL_DMAEx_MultiBufferStart_IT+0x11fa>
2000463a:	68fb      	ldr	r3, [r7, #12]
2000463c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000463e:	2b00      	cmp	r3, #0
20004640:	d007      	beq.n	20004652 <HAL_DMAEx_MultiBufferStart_IT+0x120a>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
20004642:	68fb      	ldr	r3, [r7, #12]
20004644:	681b      	ldr	r3, [r3, #0]
20004646:	681a      	ldr	r2, [r3, #0]
20004648:	68fb      	ldr	r3, [r7, #12]
2000464a:	681b      	ldr	r3, [r3, #0]
2000464c:	f042 0208 	orr.w	r2, r2, #8
20004650:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma); 
20004652:	68fb      	ldr	r3, [r7, #12]
20004654:	681b      	ldr	r3, [r3, #0]
20004656:	681a      	ldr	r2, [r3, #0]
20004658:	68fb      	ldr	r3, [r7, #12]
2000465a:	681b      	ldr	r3, [r3, #0]
2000465c:	f042 0201 	orr.w	r2, r2, #1
20004660:	601a      	str	r2, [r3, #0]
20004662:	e005      	b.n	20004670 <HAL_DMAEx_MultiBufferStart_IT+0x1228>
  }
  else
  {     
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
20004664:	68fb      	ldr	r3, [r7, #12]
20004666:	2200      	movs	r2, #0
20004668:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
2000466c:	2302      	movs	r3, #2
2000466e:	75fb      	strb	r3, [r7, #23]
  }  
  return status; 
20004670:	7dfb      	ldrb	r3, [r7, #23]
}
20004672:	4618      	mov	r0, r3
20004674:	3718      	adds	r7, #24
20004676:	46bd      	mov	sp, r7
20004678:	bd80      	pop	{r7, pc}
2000467a:	bf00      	nop
2000467c:	40026058 	.word	0x40026058
20004680:	40026010 	.word	0x40026010
20004684:	40026410 	.word	0x40026410
20004688:	40026070 	.word	0x40026070
2000468c:	40026470 	.word	0x40026470
20004690:	40026028 	.word	0x40026028
20004694:	40026428 	.word	0x40026428
20004698:	40026088 	.word	0x40026088
2000469c:	40026488 	.word	0x40026488
200046a0:	40026040 	.word	0x40026040
200046a4:	40026440 	.word	0x40026440
200046a8:	400260a0 	.word	0x400260a0
200046ac:	400264a0 	.word	0x400264a0
200046b0:	40026000 	.word	0x40026000

200046b4 <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current 
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
200046b4:	b480      	push	{r7}
200046b6:	b085      	sub	sp, #20
200046b8:	af00      	add	r7, sp, #0
200046ba:	60f8      	str	r0, [r7, #12]
200046bc:	60b9      	str	r1, [r7, #8]
200046be:	4613      	mov	r3, r2
200046c0:	71fb      	strb	r3, [r7, #7]
  if(memory == MEMORY0)
200046c2:	79fb      	ldrb	r3, [r7, #7]
200046c4:	2b00      	cmp	r3, #0
200046c6:	d104      	bne.n	200046d2 <HAL_DMAEx_ChangeMemory+0x1e>
  {
    /* change the memory0 address */
    hdma->Instance->M0AR = Address;
200046c8:	68fb      	ldr	r3, [r7, #12]
200046ca:	681b      	ldr	r3, [r3, #0]
200046cc:	68ba      	ldr	r2, [r7, #8]
200046ce:	60da      	str	r2, [r3, #12]
200046d0:	e003      	b.n	200046da <HAL_DMAEx_ChangeMemory+0x26>
  }
  else
  {
    /* change the memory1 address */
    hdma->Instance->M1AR = Address;
200046d2:	68fb      	ldr	r3, [r7, #12]
200046d4:	681b      	ldr	r3, [r3, #0]
200046d6:	68ba      	ldr	r2, [r7, #8]
200046d8:	611a      	str	r2, [r3, #16]
  }
  
  return HAL_OK;
200046da:	2300      	movs	r3, #0
}
200046dc:	4618      	mov	r0, r3
200046de:	3714      	adds	r7, #20
200046e0:	46bd      	mov	sp, r7
200046e2:	f85d 7b04 	ldr.w	r7, [sp], #4
200046e6:	4770      	bx	lr

200046e8 <DMA_MultiBufferSetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
200046e8:	b480      	push	{r7}
200046ea:	b085      	sub	sp, #20
200046ec:	af00      	add	r7, sp, #0
200046ee:	60f8      	str	r0, [r7, #12]
200046f0:	60b9      	str	r1, [r7, #8]
200046f2:	607a      	str	r2, [r7, #4]
200046f4:	603b      	str	r3, [r7, #0]
  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
200046f6:	68fb      	ldr	r3, [r7, #12]
200046f8:	681b      	ldr	r3, [r3, #0]
200046fa:	683a      	ldr	r2, [r7, #0]
200046fc:	605a      	str	r2, [r3, #4]
  
  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
200046fe:	68fb      	ldr	r3, [r7, #12]
20004700:	689b      	ldr	r3, [r3, #8]
20004702:	2b40      	cmp	r3, #64	; 0x40
20004704:	d108      	bne.n	20004718 <DMA_MultiBufferSetConfig+0x30>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
20004706:	68fb      	ldr	r3, [r7, #12]
20004708:	681b      	ldr	r3, [r3, #0]
2000470a:	687a      	ldr	r2, [r7, #4]
2000470c:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
2000470e:	68fb      	ldr	r3, [r7, #12]
20004710:	681b      	ldr	r3, [r3, #0]
20004712:	68ba      	ldr	r2, [r7, #8]
20004714:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
20004716:	e007      	b.n	20004728 <DMA_MultiBufferSetConfig+0x40>
    hdma->Instance->PAR = SrcAddress;
20004718:	68fb      	ldr	r3, [r7, #12]
2000471a:	681b      	ldr	r3, [r3, #0]
2000471c:	68ba      	ldr	r2, [r7, #8]
2000471e:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
20004720:	68fb      	ldr	r3, [r7, #12]
20004722:	681b      	ldr	r3, [r3, #0]
20004724:	687a      	ldr	r2, [r7, #4]
20004726:	60da      	str	r2, [r3, #12]
}
20004728:	bf00      	nop
2000472a:	3714      	adds	r7, #20
2000472c:	46bd      	mov	sp, r7
2000472e:	f85d 7b04 	ldr.w	r7, [sp], #4
20004732:	4770      	bx	lr

20004734 <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
20004734:	b480      	push	{r7}
20004736:	b085      	sub	sp, #20
20004738:	af00      	add	r7, sp, #0
2000473a:	6078      	str	r0, [r7, #4]
2000473c:	6039      	str	r1, [r7, #0]
  uint32_t regval;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
2000473e:	687b      	ldr	r3, [r7, #4]
20004740:	2b00      	cmp	r3, #0
20004742:	d002      	beq.n	2000474a <HAL_EXTI_SetConfigLine+0x16>
20004744:	683b      	ldr	r3, [r7, #0]
20004746:	2b00      	cmp	r3, #0
20004748:	d101      	bne.n	2000474e <HAL_EXTI_SetConfigLine+0x1a>
  {
    return HAL_ERROR;
2000474a:	2301      	movs	r3, #1
2000474c:	e053      	b.n	200047f6 <HAL_EXTI_SetConfigLine+0xc2>
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));
  assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));  
  
  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
2000474e:	683b      	ldr	r3, [r7, #0]
20004750:	681a      	ldr	r2, [r3, #0]
20004752:	687b      	ldr	r3, [r7, #4]
20004754:	601a      	str	r2, [r3, #0]
  
  /* Clear EXTI line configuration */
  EXTI->IMR &= ~pExtiConfig->Line;
20004756:	4b2b      	ldr	r3, [pc, #172]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
20004758:	681a      	ldr	r2, [r3, #0]
2000475a:	683b      	ldr	r3, [r7, #0]
2000475c:	681b      	ldr	r3, [r3, #0]
2000475e:	43db      	mvns	r3, r3
20004760:	4928      	ldr	r1, [pc, #160]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
20004762:	4013      	ands	r3, r2
20004764:	600b      	str	r3, [r1, #0]
  EXTI->EMR &= ~pExtiConfig->Line;
20004766:	4b27      	ldr	r3, [pc, #156]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
20004768:	685a      	ldr	r2, [r3, #4]
2000476a:	683b      	ldr	r3, [r7, #0]
2000476c:	681b      	ldr	r3, [r3, #0]
2000476e:	43db      	mvns	r3, r3
20004770:	4924      	ldr	r1, [pc, #144]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
20004772:	4013      	ands	r3, r2
20004774:	604b      	str	r3, [r1, #4]
  
  /* Select the Mode for the selected external interrupts */
  regval = (uint32_t)EXTI_BASE;
20004776:	4b23      	ldr	r3, [pc, #140]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
20004778:	60fb      	str	r3, [r7, #12]
  regval += pExtiConfig->Mode;
2000477a:	683b      	ldr	r3, [r7, #0]
2000477c:	685b      	ldr	r3, [r3, #4]
2000477e:	68fa      	ldr	r2, [r7, #12]
20004780:	4413      	add	r3, r2
20004782:	60fb      	str	r3, [r7, #12]
  *(__IO uint32_t *) regval |= pExtiConfig->Line;
20004784:	68fb      	ldr	r3, [r7, #12]
20004786:	6819      	ldr	r1, [r3, #0]
20004788:	683b      	ldr	r3, [r7, #0]
2000478a:	681a      	ldr	r2, [r3, #0]
2000478c:	68fb      	ldr	r3, [r7, #12]
2000478e:	430a      	orrs	r2, r1
20004790:	601a      	str	r2, [r3, #0]
  
  /* Clear Rising Falling edge configuration */
  EXTI->RTSR &= ~pExtiConfig->Line;
20004792:	4b1c      	ldr	r3, [pc, #112]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
20004794:	689a      	ldr	r2, [r3, #8]
20004796:	683b      	ldr	r3, [r7, #0]
20004798:	681b      	ldr	r3, [r3, #0]
2000479a:	43db      	mvns	r3, r3
2000479c:	4919      	ldr	r1, [pc, #100]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
2000479e:	4013      	ands	r3, r2
200047a0:	608b      	str	r3, [r1, #8]
  EXTI->FTSR &= ~pExtiConfig->Line;
200047a2:	4b18      	ldr	r3, [pc, #96]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
200047a4:	68da      	ldr	r2, [r3, #12]
200047a6:	683b      	ldr	r3, [r7, #0]
200047a8:	681b      	ldr	r3, [r3, #0]
200047aa:	43db      	mvns	r3, r3
200047ac:	4915      	ldr	r1, [pc, #84]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
200047ae:	4013      	ands	r3, r2
200047b0:	60cb      	str	r3, [r1, #12]
  
  /* Select the trigger for the selected external interrupts */
  if (pExtiConfig->Trigger == EXTI_TRIGGER_RISING_FALLING)
200047b2:	683b      	ldr	r3, [r7, #0]
200047b4:	689b      	ldr	r3, [r3, #8]
200047b6:	2b03      	cmp	r3, #3
200047b8:	d10e      	bne.n	200047d8 <HAL_EXTI_SetConfigLine+0xa4>
  {
    /* Rising Falling edge */
    EXTI->RTSR |= pExtiConfig->Line;
200047ba:	4b12      	ldr	r3, [pc, #72]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
200047bc:	689a      	ldr	r2, [r3, #8]
200047be:	683b      	ldr	r3, [r7, #0]
200047c0:	681b      	ldr	r3, [r3, #0]
200047c2:	4910      	ldr	r1, [pc, #64]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
200047c4:	4313      	orrs	r3, r2
200047c6:	608b      	str	r3, [r1, #8]
    EXTI->FTSR |= pExtiConfig->Line;
200047c8:	4b0e      	ldr	r3, [pc, #56]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
200047ca:	68da      	ldr	r2, [r3, #12]
200047cc:	683b      	ldr	r3, [r7, #0]
200047ce:	681b      	ldr	r3, [r3, #0]
200047d0:	490c      	ldr	r1, [pc, #48]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
200047d2:	4313      	orrs	r3, r2
200047d4:	60cb      	str	r3, [r1, #12]
200047d6:	e00d      	b.n	200047f4 <HAL_EXTI_SetConfigLine+0xc0>
  }
  else
  {
    regval = (uint32_t)EXTI_BASE;
200047d8:	4b0a      	ldr	r3, [pc, #40]	; (20004804 <HAL_EXTI_SetConfigLine+0xd0>)
200047da:	60fb      	str	r3, [r7, #12]
    regval += pExtiConfig->Trigger;
200047dc:	683b      	ldr	r3, [r7, #0]
200047de:	689b      	ldr	r3, [r3, #8]
200047e0:	68fa      	ldr	r2, [r7, #12]
200047e2:	4413      	add	r3, r2
200047e4:	60fb      	str	r3, [r7, #12]
    *(__IO uint32_t *) regval |= pExtiConfig->Line;
200047e6:	68fb      	ldr	r3, [r7, #12]
200047e8:	6819      	ldr	r1, [r3, #0]
200047ea:	683b      	ldr	r3, [r7, #0]
200047ec:	681a      	ldr	r2, [r3, #0]
200047ee:	68fb      	ldr	r3, [r7, #12]
200047f0:	430a      	orrs	r2, r1
200047f2:	601a      	str	r2, [r3, #0]
  }
  return HAL_OK;
200047f4:	2300      	movs	r3, #0
}
200047f6:	4618      	mov	r0, r3
200047f8:	3714      	adds	r7, #20
200047fa:	46bd      	mov	sp, r7
200047fc:	f85d 7b04 	ldr.w	r7, [sp], #4
20004800:	4770      	bx	lr
20004802:	bf00      	nop
20004804:	40013c00 	.word	0x40013c00

20004808 <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
20004808:	b480      	push	{r7}
2000480a:	b083      	sub	sp, #12
2000480c:	af00      	add	r7, sp, #0
2000480e:	6078      	str	r0, [r7, #4]
20004810:	6039      	str	r1, [r7, #0]
  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
20004812:	687b      	ldr	r3, [r7, #4]
20004814:	2b00      	cmp	r3, #0
20004816:	d002      	beq.n	2000481e <HAL_EXTI_GetConfigLine+0x16>
20004818:	683b      	ldr	r3, [r7, #0]
2000481a:	2b00      	cmp	r3, #0
2000481c:	d101      	bne.n	20004822 <HAL_EXTI_GetConfigLine+0x1a>
  {
    return HAL_ERROR;
2000481e:	2301      	movs	r3, #1
20004820:	e04b      	b.n	200048ba <HAL_EXTI_GetConfigLine+0xb2>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
20004822:	687b      	ldr	r3, [r7, #4]
20004824:	681a      	ldr	r2, [r3, #0]
20004826:	683b      	ldr	r3, [r7, #0]
20004828:	601a      	str	r2, [r3, #0]

  /* Get EXTI mode to configiguration structure */
  if ((EXTI->IMR & hexti->Line) == hexti->Line)
2000482a:	4b27      	ldr	r3, [pc, #156]	; (200048c8 <HAL_EXTI_GetConfigLine+0xc0>)
2000482c:	681a      	ldr	r2, [r3, #0]
2000482e:	687b      	ldr	r3, [r7, #4]
20004830:	681b      	ldr	r3, [r3, #0]
20004832:	401a      	ands	r2, r3
20004834:	687b      	ldr	r3, [r7, #4]
20004836:	681b      	ldr	r3, [r3, #0]
20004838:	429a      	cmp	r2, r3
2000483a:	d103      	bne.n	20004844 <HAL_EXTI_GetConfigLine+0x3c>
  {
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
2000483c:	683b      	ldr	r3, [r7, #0]
2000483e:	2201      	movs	r2, #1
20004840:	605a      	str	r2, [r3, #4]
20004842:	e00f      	b.n	20004864 <HAL_EXTI_GetConfigLine+0x5c>
  }
  else if ((EXTI->EMR & hexti->Line) == hexti->Line)
20004844:	4b20      	ldr	r3, [pc, #128]	; (200048c8 <HAL_EXTI_GetConfigLine+0xc0>)
20004846:	685a      	ldr	r2, [r3, #4]
20004848:	687b      	ldr	r3, [r7, #4]
2000484a:	681b      	ldr	r3, [r3, #0]
2000484c:	401a      	ands	r2, r3
2000484e:	687b      	ldr	r3, [r7, #4]
20004850:	681b      	ldr	r3, [r3, #0]
20004852:	429a      	cmp	r2, r3
20004854:	d103      	bne.n	2000485e <HAL_EXTI_GetConfigLine+0x56>
  {
    pExtiConfig->Mode = EXTI_MODE_EVENT;
20004856:	683b      	ldr	r3, [r7, #0]
20004858:	2202      	movs	r2, #2
2000485a:	605a      	str	r2, [r3, #4]
2000485c:	e002      	b.n	20004864 <HAL_EXTI_GetConfigLine+0x5c>
  }
  else
  {
    /* No MODE selected */
    pExtiConfig->Mode = 0x0Bu;
2000485e:	683b      	ldr	r3, [r7, #0]
20004860:	220b      	movs	r2, #11
20004862:	605a      	str	r2, [r3, #4]
  }

  /* Get EXTI Trigger to configiguration structure */
  if ((EXTI->RTSR & hexti->Line) == hexti->Line)
20004864:	4b18      	ldr	r3, [pc, #96]	; (200048c8 <HAL_EXTI_GetConfigLine+0xc0>)
20004866:	689a      	ldr	r2, [r3, #8]
20004868:	687b      	ldr	r3, [r7, #4]
2000486a:	681b      	ldr	r3, [r3, #0]
2000486c:	401a      	ands	r2, r3
2000486e:	687b      	ldr	r3, [r7, #4]
20004870:	681b      	ldr	r3, [r3, #0]
20004872:	429a      	cmp	r2, r3
20004874:	d110      	bne.n	20004898 <HAL_EXTI_GetConfigLine+0x90>
  {
    if ((EXTI->FTSR & hexti->Line) == hexti->Line)
20004876:	4b14      	ldr	r3, [pc, #80]	; (200048c8 <HAL_EXTI_GetConfigLine+0xc0>)
20004878:	68da      	ldr	r2, [r3, #12]
2000487a:	687b      	ldr	r3, [r7, #4]
2000487c:	681b      	ldr	r3, [r3, #0]
2000487e:	401a      	ands	r2, r3
20004880:	687b      	ldr	r3, [r7, #4]
20004882:	681b      	ldr	r3, [r3, #0]
20004884:	429a      	cmp	r2, r3
20004886:	d103      	bne.n	20004890 <HAL_EXTI_GetConfigLine+0x88>
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING_FALLING;
20004888:	683b      	ldr	r3, [r7, #0]
2000488a:	2203      	movs	r2, #3
2000488c:	609a      	str	r2, [r3, #8]
2000488e:	e013      	b.n	200048b8 <HAL_EXTI_GetConfigLine+0xb0>
    }
    else
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
20004890:	683b      	ldr	r3, [r7, #0]
20004892:	2201      	movs	r2, #1
20004894:	609a      	str	r2, [r3, #8]
20004896:	e00f      	b.n	200048b8 <HAL_EXTI_GetConfigLine+0xb0>
    }
  }
  else if ((EXTI->FTSR & hexti->Line) == hexti->Line)
20004898:	4b0b      	ldr	r3, [pc, #44]	; (200048c8 <HAL_EXTI_GetConfigLine+0xc0>)
2000489a:	68da      	ldr	r2, [r3, #12]
2000489c:	687b      	ldr	r3, [r7, #4]
2000489e:	681b      	ldr	r3, [r3, #0]
200048a0:	401a      	ands	r2, r3
200048a2:	687b      	ldr	r3, [r7, #4]
200048a4:	681b      	ldr	r3, [r3, #0]
200048a6:	429a      	cmp	r2, r3
200048a8:	d103      	bne.n	200048b2 <HAL_EXTI_GetConfigLine+0xaa>
  {
    pExtiConfig->Trigger = EXTI_TRIGGER_FALLING;
200048aa:	683b      	ldr	r3, [r7, #0]
200048ac:	2202      	movs	r2, #2
200048ae:	609a      	str	r2, [r3, #8]
200048b0:	e002      	b.n	200048b8 <HAL_EXTI_GetConfigLine+0xb0>
  }
  else
  {
    /* No Trigger selected */
    pExtiConfig->Trigger = 0x00u;
200048b2:	683b      	ldr	r3, [r7, #0]
200048b4:	2200      	movs	r2, #0
200048b6:	609a      	str	r2, [r3, #8]
  }

  return HAL_OK;
200048b8:	2300      	movs	r3, #0
}
200048ba:	4618      	mov	r0, r3
200048bc:	370c      	adds	r7, #12
200048be:	46bd      	mov	sp, r7
200048c0:	f85d 7b04 	ldr.w	r7, [sp], #4
200048c4:	4770      	bx	lr
200048c6:	bf00      	nop
200048c8:	40013c00 	.word	0x40013c00

200048cc <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
200048cc:	b480      	push	{r7}
200048ce:	b083      	sub	sp, #12
200048d0:	af00      	add	r7, sp, #0
200048d2:	6078      	str	r0, [r7, #4]
  /* Check null pointer */
  if (hexti == NULL)
200048d4:	687b      	ldr	r3, [r7, #4]
200048d6:	2b00      	cmp	r3, #0
200048d8:	d101      	bne.n	200048de <HAL_EXTI_ClearConfigLine+0x12>
  {
    return HAL_ERROR;
200048da:	2301      	movs	r3, #1
200048dc:	e020      	b.n	20004920 <HAL_EXTI_ClearConfigLine+0x54>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* 1] Clear interrupt mode */
  EXTI->IMR = (EXTI->IMR & ~hexti->Line);
200048de:	4b13      	ldr	r3, [pc, #76]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
200048e0:	681a      	ldr	r2, [r3, #0]
200048e2:	687b      	ldr	r3, [r7, #4]
200048e4:	681b      	ldr	r3, [r3, #0]
200048e6:	43db      	mvns	r3, r3
200048e8:	4910      	ldr	r1, [pc, #64]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
200048ea:	4013      	ands	r3, r2
200048ec:	600b      	str	r3, [r1, #0]

  /* 2] Clear event mode */
  EXTI->EMR = (EXTI->EMR & ~hexti->Line);
200048ee:	4b0f      	ldr	r3, [pc, #60]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
200048f0:	685a      	ldr	r2, [r3, #4]
200048f2:	687b      	ldr	r3, [r7, #4]
200048f4:	681b      	ldr	r3, [r3, #0]
200048f6:	43db      	mvns	r3, r3
200048f8:	490c      	ldr	r1, [pc, #48]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
200048fa:	4013      	ands	r3, r2
200048fc:	604b      	str	r3, [r1, #4]

  /* 3] Clear triggers */
  EXTI->RTSR = (EXTI->RTSR & ~hexti->Line);
200048fe:	4b0b      	ldr	r3, [pc, #44]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
20004900:	689a      	ldr	r2, [r3, #8]
20004902:	687b      	ldr	r3, [r7, #4]
20004904:	681b      	ldr	r3, [r3, #0]
20004906:	43db      	mvns	r3, r3
20004908:	4908      	ldr	r1, [pc, #32]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
2000490a:	4013      	ands	r3, r2
2000490c:	608b      	str	r3, [r1, #8]
  EXTI->FTSR = (EXTI->FTSR & ~hexti->Line);
2000490e:	4b07      	ldr	r3, [pc, #28]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
20004910:	68da      	ldr	r2, [r3, #12]
20004912:	687b      	ldr	r3, [r7, #4]
20004914:	681b      	ldr	r3, [r3, #0]
20004916:	43db      	mvns	r3, r3
20004918:	4904      	ldr	r1, [pc, #16]	; (2000492c <HAL_EXTI_ClearConfigLine+0x60>)
2000491a:	4013      	ands	r3, r2
2000491c:	60cb      	str	r3, [r1, #12]

  return HAL_OK;
2000491e:	2300      	movs	r3, #0
}
20004920:	4618      	mov	r0, r3
20004922:	370c      	adds	r7, #12
20004924:	46bd      	mov	sp, r7
20004926:	f85d 7b04 	ldr.w	r7, [sp], #4
2000492a:	4770      	bx	lr
2000492c:	40013c00 	.word	0x40013c00

20004930 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
20004930:	b480      	push	{r7}
20004932:	b087      	sub	sp, #28
20004934:	af00      	add	r7, sp, #0
20004936:	60f8      	str	r0, [r7, #12]
20004938:	460b      	mov	r3, r1
2000493a:	607a      	str	r2, [r7, #4]
2000493c:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
2000493e:	2300      	movs	r3, #0
20004940:	75fb      	strb	r3, [r7, #23]

  switch (CallbackID)
20004942:	7afb      	ldrb	r3, [r7, #11]
20004944:	2b00      	cmp	r3, #0
20004946:	d103      	bne.n	20004950 <HAL_EXTI_RegisterCallback+0x20>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
20004948:	68fb      	ldr	r3, [r7, #12]
2000494a:	687a      	ldr	r2, [r7, #4]
2000494c:	605a      	str	r2, [r3, #4]
      break;
2000494e:	e002      	b.n	20004956 <HAL_EXTI_RegisterCallback+0x26>

    default:
      status = HAL_ERROR;
20004950:	2301      	movs	r3, #1
20004952:	75fb      	strb	r3, [r7, #23]
      break;
20004954:	bf00      	nop
  }

  return status;
20004956:	7dfb      	ldrb	r3, [r7, #23]
}
20004958:	4618      	mov	r0, r3
2000495a:	371c      	adds	r7, #28
2000495c:	46bd      	mov	sp, r7
2000495e:	f85d 7b04 	ldr.w	r7, [sp], #4
20004962:	4770      	bx	lr

20004964 <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
20004964:	b480      	push	{r7}
20004966:	b083      	sub	sp, #12
20004968:	af00      	add	r7, sp, #0
2000496a:	6078      	str	r0, [r7, #4]
2000496c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
2000496e:	687b      	ldr	r3, [r7, #4]
20004970:	2b00      	cmp	r3, #0
20004972:	d101      	bne.n	20004978 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
20004974:	2301      	movs	r3, #1
20004976:	e003      	b.n	20004980 <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
20004978:	687b      	ldr	r3, [r7, #4]
2000497a:	683a      	ldr	r2, [r7, #0]
2000497c:	601a      	str	r2, [r3, #0]

    return HAL_OK;
2000497e:	2300      	movs	r3, #0
  }
}
20004980:	4618      	mov	r0, r3
20004982:	370c      	adds	r7, #12
20004984:	46bd      	mov	sp, r7
20004986:	f85d 7b04 	ldr.w	r7, [sp], #4
2000498a:	4770      	bx	lr

2000498c <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
2000498c:	b580      	push	{r7, lr}
2000498e:	b084      	sub	sp, #16
20004990:	af00      	add	r7, sp, #0
20004992:	6078      	str	r0, [r7, #4]
  __IO uint32_t *regaddr;
  uint32_t regval;

  /* Get pending bit  */
  regaddr = (&EXTI->PR);
20004994:	4b0c      	ldr	r3, [pc, #48]	; (200049c8 <HAL_EXTI_IRQHandler+0x3c>)
20004996:	60fb      	str	r3, [r7, #12]
  regval = (*regaddr & hexti->Line);
20004998:	68fb      	ldr	r3, [r7, #12]
2000499a:	681a      	ldr	r2, [r3, #0]
2000499c:	687b      	ldr	r3, [r7, #4]
2000499e:	681b      	ldr	r3, [r3, #0]
200049a0:	4013      	ands	r3, r2
200049a2:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00u)
200049a4:	68bb      	ldr	r3, [r7, #8]
200049a6:	2b00      	cmp	r3, #0
200049a8:	d00a      	beq.n	200049c0 <HAL_EXTI_IRQHandler+0x34>
  {
    /* Clear pending bit */
    *regaddr = hexti->Line;
200049aa:	687b      	ldr	r3, [r7, #4]
200049ac:	681a      	ldr	r2, [r3, #0]
200049ae:	68fb      	ldr	r3, [r7, #12]
200049b0:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
200049b2:	687b      	ldr	r3, [r7, #4]
200049b4:	685b      	ldr	r3, [r3, #4]
200049b6:	2b00      	cmp	r3, #0
200049b8:	d002      	beq.n	200049c0 <HAL_EXTI_IRQHandler+0x34>
    {
      hexti->PendingCallback();
200049ba:	687b      	ldr	r3, [r7, #4]
200049bc:	685b      	ldr	r3, [r3, #4]
200049be:	4798      	blx	r3
    }
  }
}
200049c0:	bf00      	nop
200049c2:	3710      	adds	r7, #16
200049c4:	46bd      	mov	sp, r7
200049c6:	bd80      	pop	{r7, pc}
200049c8:	40013c14 	.word	0x40013c14

200049cc <HAL_EXTI_GetPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval 1 if interrupt is pending else 0.
  */
uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
200049cc:	b480      	push	{r7}
200049ce:	b087      	sub	sp, #28
200049d0:	af00      	add	r7, sp, #0
200049d2:	6078      	str	r0, [r7, #4]
200049d4:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* Get pending bit */
  regaddr = &EXTI->PR;
200049d6:	4b0d      	ldr	r3, [pc, #52]	; (20004a0c <HAL_EXTI_GetPending+0x40>)
200049d8:	617b      	str	r3, [r7, #20]

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & hexti->Line) >> POSITION_VAL(hexti->Line));
200049da:	697b      	ldr	r3, [r7, #20]
200049dc:	681a      	ldr	r2, [r3, #0]
200049de:	687b      	ldr	r3, [r7, #4]
200049e0:	681b      	ldr	r3, [r3, #0]
200049e2:	4013      	ands	r3, r2
200049e4:	687a      	ldr	r2, [r7, #4]
200049e6:	6812      	ldr	r2, [r2, #0]
200049e8:	60fa      	str	r2, [r7, #12]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
200049ea:	68fa      	ldr	r2, [r7, #12]
200049ec:	fa92 f2a2 	rbit	r2, r2
200049f0:	60ba      	str	r2, [r7, #8]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
200049f2:	68ba      	ldr	r2, [r7, #8]
200049f4:	fab2 f282 	clz	r2, r2
200049f8:	b2d2      	uxtb	r2, r2
200049fa:	40d3      	lsrs	r3, r2
200049fc:	613b      	str	r3, [r7, #16]

  return regval;
200049fe:	693b      	ldr	r3, [r7, #16]
}
20004a00:	4618      	mov	r0, r3
20004a02:	371c      	adds	r7, #28
20004a04:	46bd      	mov	sp, r7
20004a06:	f85d 7b04 	ldr.w	r7, [sp], #4
20004a0a:	4770      	bx	lr
20004a0c:	40013c14 	.word	0x40013c14

20004a10 <HAL_EXTI_ClearPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval None.
  */
void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
20004a10:	b480      	push	{r7}
20004a12:	b083      	sub	sp, #12
20004a14:	af00      	add	r7, sp, #0
20004a16:	6078      	str	r0, [r7, #4]
20004a18:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));
  
  /* Clear Pending bit */
  EXTI->PR =  hexti->Line;
20004a1a:	4a05      	ldr	r2, [pc, #20]	; (20004a30 <HAL_EXTI_ClearPending+0x20>)
20004a1c:	687b      	ldr	r3, [r7, #4]
20004a1e:	681b      	ldr	r3, [r3, #0]
20004a20:	6153      	str	r3, [r2, #20]
}
20004a22:	bf00      	nop
20004a24:	370c      	adds	r7, #12
20004a26:	46bd      	mov	sp, r7
20004a28:	f85d 7b04 	ldr.w	r7, [sp], #4
20004a2c:	4770      	bx	lr
20004a2e:	bf00      	nop
20004a30:	40013c00 	.word	0x40013c00

20004a34 <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
20004a34:	b480      	push	{r7}
20004a36:	b083      	sub	sp, #12
20004a38:	af00      	add	r7, sp, #0
20004a3a:	6078      	str	r0, [r7, #4]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));

  EXTI->SWIER = hexti->Line;
20004a3c:	4a04      	ldr	r2, [pc, #16]	; (20004a50 <HAL_EXTI_GenerateSWI+0x1c>)
20004a3e:	687b      	ldr	r3, [r7, #4]
20004a40:	681b      	ldr	r3, [r3, #0]
20004a42:	6113      	str	r3, [r2, #16]
}
20004a44:	bf00      	nop
20004a46:	370c      	adds	r7, #12
20004a48:	46bd      	mov	sp, r7
20004a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
20004a4e:	4770      	bx	lr
20004a50:	40013c00 	.word	0x40013c00

20004a54 <HAL_FLASH_Program>:
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
20004a54:	b580      	push	{r7, lr}
20004a56:	b086      	sub	sp, #24
20004a58:	af00      	add	r7, sp, #0
20004a5a:	60f8      	str	r0, [r7, #12]
20004a5c:	60b9      	str	r1, [r7, #8]
20004a5e:	e9c7 2300 	strd	r2, r3, [r7]
  HAL_StatusTypeDef status = HAL_ERROR;
20004a62:	2301      	movs	r3, #1
20004a64:	75fb      	strb	r3, [r7, #23]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004a66:	4b27      	ldr	r3, [pc, #156]	; (20004b04 <HAL_FLASH_Program+0xb0>)
20004a68:	7d1b      	ldrb	r3, [r3, #20]
20004a6a:	2b01      	cmp	r3, #1
20004a6c:	d101      	bne.n	20004a72 <HAL_FLASH_Program+0x1e>
20004a6e:	2302      	movs	r3, #2
20004a70:	e043      	b.n	20004afa <HAL_FLASH_Program+0xa6>
20004a72:	4b24      	ldr	r3, [pc, #144]	; (20004b04 <HAL_FLASH_Program+0xb0>)
20004a74:	2201      	movs	r2, #1
20004a76:	751a      	strb	r2, [r3, #20]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004a78:	f24c 3050 	movw	r0, #50000	; 0xc350
20004a7c:	f000 f9de 	bl	20004e3c <FLASH_WaitForLastOperation>
20004a80:	4603      	mov	r3, r0
20004a82:	75fb      	strb	r3, [r7, #23]
  
  if(status == HAL_OK)
20004a84:	7dfb      	ldrb	r3, [r7, #23]
20004a86:	2b00      	cmp	r3, #0
20004a88:	d133      	bne.n	20004af2 <HAL_FLASH_Program+0x9e>
  {
    switch(TypeProgram)
20004a8a:	68fb      	ldr	r3, [r7, #12]
20004a8c:	2b03      	cmp	r3, #3
20004a8e:	d823      	bhi.n	20004ad8 <HAL_FLASH_Program+0x84>
20004a90:	a201      	add	r2, pc, #4	; (adr r2, 20004a98 <HAL_FLASH_Program+0x44>)
20004a92:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20004a96:	bf00      	nop
20004a98:	20004aa9 	.word	0x20004aa9
20004a9c:	20004ab5 	.word	0x20004ab5
20004aa0:	20004ac1 	.word	0x20004ac1
20004aa4:	20004acd 	.word	0x20004acd
    {
      case FLASH_TYPEPROGRAM_BYTE :
      {
        /*Program byte (8-bit) at a specified address.*/
        FLASH_Program_Byte(Address, (uint8_t) Data);
20004aa8:	783b      	ldrb	r3, [r7, #0]
20004aaa:	4619      	mov	r1, r3
20004aac:	68b8      	ldr	r0, [r7, #8]
20004aae:	f000 fa7f 	bl	20004fb0 <FLASH_Program_Byte>
        break;
20004ab2:	e012      	b.n	20004ada <HAL_FLASH_Program+0x86>
      }
      
      case FLASH_TYPEPROGRAM_HALFWORD :
      {
        /*Program halfword (16-bit) at a specified address.*/
        FLASH_Program_HalfWord(Address, (uint16_t) Data);
20004ab4:	883b      	ldrh	r3, [r7, #0]
20004ab6:	4619      	mov	r1, r3
20004ab8:	68b8      	ldr	r0, [r7, #8]
20004aba:	f000 fa53 	bl	20004f64 <FLASH_Program_HalfWord>
        break;
20004abe:	e00c      	b.n	20004ada <HAL_FLASH_Program+0x86>
      }
      
      case FLASH_TYPEPROGRAM_WORD :
      {
        /*Program word (32-bit) at a specified address.*/
        FLASH_Program_Word(Address, (uint32_t) Data);
20004ac0:	683b      	ldr	r3, [r7, #0]
20004ac2:	4619      	mov	r1, r3
20004ac4:	68b8      	ldr	r0, [r7, #8]
20004ac6:	f000 fa29 	bl	20004f1c <FLASH_Program_Word>
        break;
20004aca:	e006      	b.n	20004ada <HAL_FLASH_Program+0x86>
      }
      
      case FLASH_TYPEPROGRAM_DOUBLEWORD :
      {
        /*Program double word (64-bit) at a specified address.*/
        FLASH_Program_DoubleWord(Address, Data);
20004acc:	e9d7 2300 	ldrd	r2, r3, [r7]
20004ad0:	68b8      	ldr	r0, [r7, #8]
20004ad2:	f000 f9f3 	bl	20004ebc <FLASH_Program_DoubleWord>
        break;
20004ad6:	e000      	b.n	20004ada <HAL_FLASH_Program+0x86>
      }
      default :
        break;
20004ad8:	bf00      	nop
    }
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004ada:	f24c 3050 	movw	r0, #50000	; 0xc350
20004ade:	f000 f9ad 	bl	20004e3c <FLASH_WaitForLastOperation>
20004ae2:	4603      	mov	r3, r0
20004ae4:	75fb      	strb	r3, [r7, #23]
    
    /* If the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
20004ae6:	4b08      	ldr	r3, [pc, #32]	; (20004b08 <HAL_FLASH_Program+0xb4>)
20004ae8:	691b      	ldr	r3, [r3, #16]
20004aea:	4a07      	ldr	r2, [pc, #28]	; (20004b08 <HAL_FLASH_Program+0xb4>)
20004aec:	f023 0301 	bic.w	r3, r3, #1
20004af0:	6113      	str	r3, [r2, #16]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20004af2:	4b04      	ldr	r3, [pc, #16]	; (20004b04 <HAL_FLASH_Program+0xb0>)
20004af4:	2200      	movs	r2, #0
20004af6:	751a      	strb	r2, [r3, #20]

  return status;
20004af8:	7dfb      	ldrb	r3, [r7, #23]
}
20004afa:	4618      	mov	r0, r3
20004afc:	3718      	adds	r7, #24
20004afe:	46bd      	mov	sp, r7
20004b00:	bd80      	pop	{r7, pc}
20004b02:	bf00      	nop
20004b04:	200004f4 	.word	0x200004f4
20004b08:	40023c00 	.word	0x40023c00

20004b0c <HAL_FLASH_Program_IT>:
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
20004b0c:	b580      	push	{r7, lr}
20004b0e:	b086      	sub	sp, #24
20004b10:	af00      	add	r7, sp, #0
20004b12:	60f8      	str	r0, [r7, #12]
20004b14:	60b9      	str	r1, [r7, #8]
20004b16:	e9c7 2300 	strd	r2, r3, [r7]
  HAL_StatusTypeDef status = HAL_OK;
20004b1a:	2300      	movs	r3, #0
20004b1c:	75fb      	strb	r3, [r7, #23]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
20004b1e:	4b25      	ldr	r3, [pc, #148]	; (20004bb4 <HAL_FLASH_Program_IT+0xa8>)
20004b20:	7d1b      	ldrb	r3, [r3, #20]
20004b22:	2b01      	cmp	r3, #1
20004b24:	d101      	bne.n	20004b2a <HAL_FLASH_Program_IT+0x1e>
20004b26:	2302      	movs	r3, #2
20004b28:	e040      	b.n	20004bac <HAL_FLASH_Program_IT+0xa0>
20004b2a:	4b22      	ldr	r3, [pc, #136]	; (20004bb4 <HAL_FLASH_Program_IT+0xa8>)
20004b2c:	2201      	movs	r2, #1
20004b2e:	751a      	strb	r2, [r3, #20]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Enable End of FLASH Operation interrupt */
  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
20004b30:	4b21      	ldr	r3, [pc, #132]	; (20004bb8 <HAL_FLASH_Program_IT+0xac>)
20004b32:	691b      	ldr	r3, [r3, #16]
20004b34:	4a20      	ldr	r2, [pc, #128]	; (20004bb8 <HAL_FLASH_Program_IT+0xac>)
20004b36:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
20004b3a:	6113      	str	r3, [r2, #16]
  
  /* Enable Error source interrupt */
  __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
20004b3c:	4b1e      	ldr	r3, [pc, #120]	; (20004bb8 <HAL_FLASH_Program_IT+0xac>)
20004b3e:	691b      	ldr	r3, [r3, #16]
20004b40:	4a1d      	ldr	r2, [pc, #116]	; (20004bb8 <HAL_FLASH_Program_IT+0xac>)
20004b42:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
20004b46:	6113      	str	r3, [r2, #16]
  
  /* Clear pending flags (if any) */  
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
20004b48:	4b1b      	ldr	r3, [pc, #108]	; (20004bb8 <HAL_FLASH_Program_IT+0xac>)
20004b4a:	22f3      	movs	r2, #243	; 0xf3
20004b4c:	60da      	str	r2, [r3, #12]
                         FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  

  pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
20004b4e:	4b19      	ldr	r3, [pc, #100]	; (20004bb4 <HAL_FLASH_Program_IT+0xa8>)
20004b50:	2203      	movs	r2, #3
20004b52:	701a      	strb	r2, [r3, #0]
  pFlash.Address = Address;
20004b54:	4a17      	ldr	r2, [pc, #92]	; (20004bb4 <HAL_FLASH_Program_IT+0xa8>)
20004b56:	68bb      	ldr	r3, [r7, #8]
20004b58:	6113      	str	r3, [r2, #16]
  
  switch(TypeProgram)
20004b5a:	68fb      	ldr	r3, [r7, #12]
20004b5c:	2b03      	cmp	r3, #3
20004b5e:	d823      	bhi.n	20004ba8 <HAL_FLASH_Program_IT+0x9c>
20004b60:	a201      	add	r2, pc, #4	; (adr r2, 20004b68 <HAL_FLASH_Program_IT+0x5c>)
20004b62:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20004b66:	bf00      	nop
20004b68:	20004b79 	.word	0x20004b79
20004b6c:	20004b85 	.word	0x20004b85
20004b70:	20004b91 	.word	0x20004b91
20004b74:	20004b9d 	.word	0x20004b9d
  {
    case FLASH_TYPEPROGRAM_BYTE :
    {
      /*Program byte (8-bit) at a specified address.*/
      FLASH_Program_Byte(Address, (uint8_t) Data);
20004b78:	783b      	ldrb	r3, [r7, #0]
20004b7a:	4619      	mov	r1, r3
20004b7c:	68b8      	ldr	r0, [r7, #8]
20004b7e:	f000 fa17 	bl	20004fb0 <FLASH_Program_Byte>
      break;
20004b82:	e012      	b.n	20004baa <HAL_FLASH_Program_IT+0x9e>
    }
    
    case FLASH_TYPEPROGRAM_HALFWORD :
    {
      /*Program halfword (16-bit) at a specified address.*/
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
20004b84:	883b      	ldrh	r3, [r7, #0]
20004b86:	4619      	mov	r1, r3
20004b88:	68b8      	ldr	r0, [r7, #8]
20004b8a:	f000 f9eb 	bl	20004f64 <FLASH_Program_HalfWord>
      break;
20004b8e:	e00c      	b.n	20004baa <HAL_FLASH_Program_IT+0x9e>
    }
    
    case FLASH_TYPEPROGRAM_WORD :
    {
      /*Program word (32-bit) at a specified address.*/
      FLASH_Program_Word(Address, (uint32_t) Data);
20004b90:	683b      	ldr	r3, [r7, #0]
20004b92:	4619      	mov	r1, r3
20004b94:	68b8      	ldr	r0, [r7, #8]
20004b96:	f000 f9c1 	bl	20004f1c <FLASH_Program_Word>
      break;
20004b9a:	e006      	b.n	20004baa <HAL_FLASH_Program_IT+0x9e>
    }
    
    case FLASH_TYPEPROGRAM_DOUBLEWORD :
    {
      /*Program double word (64-bit) at a specified address.*/
      FLASH_Program_DoubleWord(Address, Data);
20004b9c:	e9d7 2300 	ldrd	r2, r3, [r7]
20004ba0:	68b8      	ldr	r0, [r7, #8]
20004ba2:	f000 f98b 	bl	20004ebc <FLASH_Program_DoubleWord>
      break;
20004ba6:	e000      	b.n	20004baa <HAL_FLASH_Program_IT+0x9e>
    }
    default :
      break;
20004ba8:	bf00      	nop
  }
  return status;
20004baa:	7dfb      	ldrb	r3, [r7, #23]
}
20004bac:	4618      	mov	r0, r3
20004bae:	3718      	adds	r7, #24
20004bb0:	46bd      	mov	sp, r7
20004bb2:	bd80      	pop	{r7, pc}
20004bb4:	200004f4 	.word	0x200004f4
20004bb8:	40023c00 	.word	0x40023c00

20004bbc <HAL_FLASH_IRQHandler>:
/**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
20004bbc:	b580      	push	{r7, lr}
20004bbe:	b082      	sub	sp, #8
20004bc0:	af00      	add	r7, sp, #0
  uint32_t temp = 0;
20004bc2:	2300      	movs	r3, #0
20004bc4:	607b      	str	r3, [r7, #4]
  
  /* If the program operation is completed, disable the PG Bit */
  FLASH->CR &= (~FLASH_CR_PG);
20004bc6:	4b52      	ldr	r3, [pc, #328]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004bc8:	691b      	ldr	r3, [r3, #16]
20004bca:	4a51      	ldr	r2, [pc, #324]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004bcc:	f023 0301 	bic.w	r3, r3, #1
20004bd0:	6113      	str	r3, [r2, #16]

  /* If the erase operation is completed, disable the SER Bit */
  FLASH->CR &= (~FLASH_CR_SER);
20004bd2:	4b4f      	ldr	r3, [pc, #316]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004bd4:	691b      	ldr	r3, [r3, #16]
20004bd6:	4a4e      	ldr	r2, [pc, #312]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004bd8:	f023 0302 	bic.w	r3, r3, #2
20004bdc:	6113      	str	r3, [r2, #16]
  FLASH->CR &= SECTOR_MASK; 
20004bde:	4b4c      	ldr	r3, [pc, #304]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004be0:	691b      	ldr	r3, [r3, #16]
20004be2:	4a4b      	ldr	r2, [pc, #300]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004be4:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
20004be8:	6113      	str	r3, [r2, #16]

  /* if the erase operation is completed, disable the MER Bit */
  FLASH->CR &= (~FLASH_MER_BIT);
20004bea:	4b49      	ldr	r3, [pc, #292]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004bec:	691a      	ldr	r2, [r3, #16]
20004bee:	4948      	ldr	r1, [pc, #288]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004bf0:	4b48      	ldr	r3, [pc, #288]	; (20004d14 <HAL_FLASH_IRQHandler+0x158>)
20004bf2:	4013      	ands	r3, r2
20004bf4:	610b      	str	r3, [r1, #16]

  /* Check FLASH End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
20004bf6:	4b46      	ldr	r3, [pc, #280]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004bf8:	68db      	ldr	r3, [r3, #12]
20004bfa:	f003 0301 	and.w	r3, r3, #1
20004bfe:	2b00      	cmp	r3, #0
20004c00:	d046      	beq.n	20004c90 <HAL_FLASH_IRQHandler+0xd4>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20004c02:	4b43      	ldr	r3, [pc, #268]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004c04:	2201      	movs	r2, #1
20004c06:	60da      	str	r2, [r3, #12]
    
    switch (pFlash.ProcedureOnGoing)
20004c08:	4b43      	ldr	r3, [pc, #268]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c0a:	781b      	ldrb	r3, [r3, #0]
20004c0c:	b2db      	uxtb	r3, r3
20004c0e:	2b02      	cmp	r3, #2
20004c10:	d02e      	beq.n	20004c70 <HAL_FLASH_IRQHandler+0xb4>
20004c12:	2b03      	cmp	r3, #3
20004c14:	d033      	beq.n	20004c7e <HAL_FLASH_IRQHandler+0xc2>
20004c16:	2b01      	cmp	r3, #1
20004c18:	d000      	beq.n	20004c1c <HAL_FLASH_IRQHandler+0x60>
        /* Programming procedure is completed */
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
        break;
      }
      default :
        break;
20004c1a:	e03a      	b.n	20004c92 <HAL_FLASH_IRQHandler+0xd6>
        pFlash.NbSectorsToErase--;
20004c1c:	4b3e      	ldr	r3, [pc, #248]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c1e:	685b      	ldr	r3, [r3, #4]
20004c20:	3b01      	subs	r3, #1
20004c22:	4a3d      	ldr	r2, [pc, #244]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c24:	6053      	str	r3, [r2, #4]
        if(pFlash.NbSectorsToErase != 0)
20004c26:	4b3c      	ldr	r3, [pc, #240]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c28:	685b      	ldr	r3, [r3, #4]
20004c2a:	2b00      	cmp	r3, #0
20004c2c:	d013      	beq.n	20004c56 <HAL_FLASH_IRQHandler+0x9a>
          temp = pFlash.Sector;
20004c2e:	4b3a      	ldr	r3, [pc, #232]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c30:	68db      	ldr	r3, [r3, #12]
20004c32:	607b      	str	r3, [r7, #4]
          HAL_FLASH_EndOfOperationCallback(temp);
20004c34:	6878      	ldr	r0, [r7, #4]
20004c36:	f000 f871 	bl	20004d1c <HAL_FLASH_EndOfOperationCallback>
          temp = ++pFlash.Sector;
20004c3a:	4b37      	ldr	r3, [pc, #220]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c3c:	68db      	ldr	r3, [r3, #12]
20004c3e:	3301      	adds	r3, #1
20004c40:	4a35      	ldr	r2, [pc, #212]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c42:	60d3      	str	r3, [r2, #12]
20004c44:	607b      	str	r3, [r7, #4]
          FLASH_Erase_Sector(temp, pFlash.VoltageForErase);
20004c46:	4b34      	ldr	r3, [pc, #208]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c48:	7a1b      	ldrb	r3, [r3, #8]
20004c4a:	b2db      	uxtb	r3, r3
20004c4c:	4619      	mov	r1, r3
20004c4e:	6878      	ldr	r0, [r7, #4]
20004c50:	f000 fbe0 	bl	20005414 <FLASH_Erase_Sector>
        break;
20004c54:	e01d      	b.n	20004c92 <HAL_FLASH_IRQHandler+0xd6>
          pFlash.Sector = temp = 0xFFFFFFFFU;
20004c56:	f04f 33ff 	mov.w	r3, #4294967295
20004c5a:	607b      	str	r3, [r7, #4]
20004c5c:	4a2e      	ldr	r2, [pc, #184]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c5e:	687b      	ldr	r3, [r7, #4]
20004c60:	60d3      	str	r3, [r2, #12]
          HAL_FLASH_EndOfOperationCallback(temp);
20004c62:	6878      	ldr	r0, [r7, #4]
20004c64:	f000 f85a 	bl	20004d1c <HAL_FLASH_EndOfOperationCallback>
          pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
20004c68:	4b2b      	ldr	r3, [pc, #172]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c6a:	2200      	movs	r2, #0
20004c6c:	701a      	strb	r2, [r3, #0]
        break;
20004c6e:	e010      	b.n	20004c92 <HAL_FLASH_IRQHandler+0xd6>
        HAL_FLASH_EndOfOperationCallback(0);
20004c70:	2000      	movs	r0, #0
20004c72:	f000 f853 	bl	20004d1c <HAL_FLASH_EndOfOperationCallback>
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
20004c76:	4b28      	ldr	r3, [pc, #160]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c78:	2200      	movs	r2, #0
20004c7a:	701a      	strb	r2, [r3, #0]
        break;
20004c7c:	e009      	b.n	20004c92 <HAL_FLASH_IRQHandler+0xd6>
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
20004c7e:	4b26      	ldr	r3, [pc, #152]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c80:	691b      	ldr	r3, [r3, #16]
20004c82:	4618      	mov	r0, r3
20004c84:	f000 f84a 	bl	20004d1c <HAL_FLASH_EndOfOperationCallback>
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
20004c88:	4b23      	ldr	r3, [pc, #140]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004c8a:	2200      	movs	r2, #0
20004c8c:	701a      	strb	r2, [r3, #0]
        break;
20004c8e:	e000      	b.n	20004c92 <HAL_FLASH_IRQHandler+0xd6>
    }
  }
20004c90:	bf00      	nop
  
  /* Check FLASH operation error flags */
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
20004c92:	4b1f      	ldr	r3, [pc, #124]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004c94:	68db      	ldr	r3, [r3, #12]
20004c96:	f003 03f2 	and.w	r3, r3, #242	; 0xf2
20004c9a:	2b00      	cmp	r3, #0
20004c9c:	d020      	beq.n	20004ce0 <HAL_FLASH_IRQHandler+0x124>
  {
    switch (pFlash.ProcedureOnGoing)
20004c9e:	4b1e      	ldr	r3, [pc, #120]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004ca0:	781b      	ldrb	r3, [r3, #0]
20004ca2:	b2db      	uxtb	r3, r3
20004ca4:	2b02      	cmp	r3, #2
20004ca6:	d00c      	beq.n	20004cc2 <HAL_FLASH_IRQHandler+0x106>
20004ca8:	2b03      	cmp	r3, #3
20004caa:	d00d      	beq.n	20004cc8 <HAL_FLASH_IRQHandler+0x10c>
20004cac:	2b01      	cmp	r3, #1
20004cae:	d000      	beq.n	20004cb2 <HAL_FLASH_IRQHandler+0xf6>
        /*return the faulty address*/
        temp = pFlash.Address;
        break;
      }
    default :
      break;
20004cb0:	e00e      	b.n	20004cd0 <HAL_FLASH_IRQHandler+0x114>
        temp = pFlash.Sector;
20004cb2:	4b19      	ldr	r3, [pc, #100]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004cb4:	68db      	ldr	r3, [r3, #12]
20004cb6:	607b      	str	r3, [r7, #4]
        pFlash.Sector = 0xFFFFFFFFU;
20004cb8:	4b17      	ldr	r3, [pc, #92]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004cba:	f04f 32ff 	mov.w	r2, #4294967295
20004cbe:	60da      	str	r2, [r3, #12]
        break;
20004cc0:	e006      	b.n	20004cd0 <HAL_FLASH_IRQHandler+0x114>
        temp = 0;
20004cc2:	2300      	movs	r3, #0
20004cc4:	607b      	str	r3, [r7, #4]
        break;
20004cc6:	e003      	b.n	20004cd0 <HAL_FLASH_IRQHandler+0x114>
        temp = pFlash.Address;
20004cc8:	4b13      	ldr	r3, [pc, #76]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004cca:	691b      	ldr	r3, [r3, #16]
20004ccc:	607b      	str	r3, [r7, #4]
        break;
20004cce:	bf00      	nop
    }
    /*Save the Error code*/
    FLASH_SetErrorCode();
20004cd0:	f000 f992 	bl	20004ff8 <FLASH_SetErrorCode>

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
20004cd4:	6878      	ldr	r0, [r7, #4]
20004cd6:	f000 f82b 	bl	20004d30 <HAL_FLASH_OperationErrorCallback>

    /*Stop the procedure ongoing */
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
20004cda:	4b0f      	ldr	r3, [pc, #60]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004cdc:	2200      	movs	r2, #0
20004cde:	701a      	strb	r2, [r3, #0]
  }
  
  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
20004ce0:	4b0d      	ldr	r3, [pc, #52]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004ce2:	781b      	ldrb	r3, [r3, #0]
20004ce4:	b2db      	uxtb	r3, r3
20004ce6:	2b00      	cmp	r3, #0
20004ce8:	d10e      	bne.n	20004d08 <HAL_FLASH_IRQHandler+0x14c>
  {
    /* Disable End of FLASH Operation interrupt */
    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
20004cea:	4b09      	ldr	r3, [pc, #36]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004cec:	691b      	ldr	r3, [r3, #16]
20004cee:	4a08      	ldr	r2, [pc, #32]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004cf0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
20004cf4:	6113      	str	r3, [r2, #16]

    /* Disable Error source interrupt */
    __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
20004cf6:	4b06      	ldr	r3, [pc, #24]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004cf8:	691b      	ldr	r3, [r3, #16]
20004cfa:	4a05      	ldr	r2, [pc, #20]	; (20004d10 <HAL_FLASH_IRQHandler+0x154>)
20004cfc:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
20004d00:	6113      	str	r3, [r2, #16]

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
20004d02:	4b05      	ldr	r3, [pc, #20]	; (20004d18 <HAL_FLASH_IRQHandler+0x15c>)
20004d04:	2200      	movs	r2, #0
20004d06:	751a      	strb	r2, [r3, #20]
  }
  
}
20004d08:	bf00      	nop
20004d0a:	3708      	adds	r7, #8
20004d0c:	46bd      	mov	sp, r7
20004d0e:	bd80      	pop	{r7, pc}
20004d10:	40023c00 	.word	0x40023c00
20004d14:	ffff7ffb 	.word	0xffff7ffb
20004d18:	200004f4 	.word	0x200004f4

20004d1c <HAL_FLASH_EndOfOperationCallback>:
  *                 - Program      : Address which was selected for data program
  *                 - Mass Erase   : No return value expected
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
20004d1c:	b480      	push	{r7}
20004d1e:	b083      	sub	sp, #12
20004d20:	af00      	add	r7, sp, #0
20004d22:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(ReturnValue);
  /* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
  */ 
}
20004d24:	bf00      	nop
20004d26:	370c      	adds	r7, #12
20004d28:	46bd      	mov	sp, r7
20004d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
20004d2e:	4770      	bx	lr

20004d30 <HAL_FLASH_OperationErrorCallback>:
  *                 - Program      : Address which was selected for data program
  *                 - Mass Erase   : No return value expected
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
20004d30:	b480      	push	{r7}
20004d32:	b083      	sub	sp, #12
20004d34:	af00      	add	r7, sp, #0
20004d36:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(ReturnValue);
  /* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */ 
}
20004d38:	bf00      	nop
20004d3a:	370c      	adds	r7, #12
20004d3c:	46bd      	mov	sp, r7
20004d3e:	f85d 7b04 	ldr.w	r7, [sp], #4
20004d42:	4770      	bx	lr

20004d44 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
20004d44:	b480      	push	{r7}
20004d46:	b083      	sub	sp, #12
20004d48:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
20004d4a:	2300      	movs	r3, #0
20004d4c:	71fb      	strb	r3, [r7, #7]

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
20004d4e:	4b0b      	ldr	r3, [pc, #44]	; (20004d7c <HAL_FLASH_Unlock+0x38>)
20004d50:	691b      	ldr	r3, [r3, #16]
20004d52:	2b00      	cmp	r3, #0
20004d54:	da0b      	bge.n	20004d6e <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
20004d56:	4b09      	ldr	r3, [pc, #36]	; (20004d7c <HAL_FLASH_Unlock+0x38>)
20004d58:	4a09      	ldr	r2, [pc, #36]	; (20004d80 <HAL_FLASH_Unlock+0x3c>)
20004d5a:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
20004d5c:	4b07      	ldr	r3, [pc, #28]	; (20004d7c <HAL_FLASH_Unlock+0x38>)
20004d5e:	4a09      	ldr	r2, [pc, #36]	; (20004d84 <HAL_FLASH_Unlock+0x40>)
20004d60:	605a      	str	r2, [r3, #4]

    /* Verify Flash is unlocked */
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
20004d62:	4b06      	ldr	r3, [pc, #24]	; (20004d7c <HAL_FLASH_Unlock+0x38>)
20004d64:	691b      	ldr	r3, [r3, #16]
20004d66:	2b00      	cmp	r3, #0
20004d68:	da01      	bge.n	20004d6e <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
20004d6a:	2301      	movs	r3, #1
20004d6c:	71fb      	strb	r3, [r7, #7]
    }
  }

  return status;
20004d6e:	79fb      	ldrb	r3, [r7, #7]
}
20004d70:	4618      	mov	r0, r3
20004d72:	370c      	adds	r7, #12
20004d74:	46bd      	mov	sp, r7
20004d76:	f85d 7b04 	ldr.w	r7, [sp], #4
20004d7a:	4770      	bx	lr
20004d7c:	40023c00 	.word	0x40023c00
20004d80:	45670123 	.word	0x45670123
20004d84:	cdef89ab 	.word	0xcdef89ab

20004d88 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
20004d88:	b480      	push	{r7}
20004d8a:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
20004d8c:	4b05      	ldr	r3, [pc, #20]	; (20004da4 <HAL_FLASH_Lock+0x1c>)
20004d8e:	691b      	ldr	r3, [r3, #16]
20004d90:	4a04      	ldr	r2, [pc, #16]	; (20004da4 <HAL_FLASH_Lock+0x1c>)
20004d92:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
20004d96:	6113      	str	r3, [r2, #16]
  
  return HAL_OK;  
20004d98:	2300      	movs	r3, #0
}
20004d9a:	4618      	mov	r0, r3
20004d9c:	46bd      	mov	sp, r7
20004d9e:	f85d 7b04 	ldr.w	r7, [sp], #4
20004da2:	4770      	bx	lr
20004da4:	40023c00 	.word	0x40023c00

20004da8 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
20004da8:	b480      	push	{r7}
20004daa:	af00      	add	r7, sp, #0
  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
20004dac:	4b09      	ldr	r3, [pc, #36]	; (20004dd4 <HAL_FLASH_OB_Unlock+0x2c>)
20004dae:	695b      	ldr	r3, [r3, #20]
20004db0:	f003 0301 	and.w	r3, r3, #1
20004db4:	2b00      	cmp	r3, #0
20004db6:	d007      	beq.n	20004dc8 <HAL_FLASH_OB_Unlock+0x20>
  {
    /* Authorizes the Option Byte register programming */
    FLASH->OPTKEYR = FLASH_OPT_KEY1;
20004db8:	4b06      	ldr	r3, [pc, #24]	; (20004dd4 <HAL_FLASH_OB_Unlock+0x2c>)
20004dba:	4a07      	ldr	r2, [pc, #28]	; (20004dd8 <HAL_FLASH_OB_Unlock+0x30>)
20004dbc:	609a      	str	r2, [r3, #8]
    FLASH->OPTKEYR = FLASH_OPT_KEY2;
20004dbe:	4b05      	ldr	r3, [pc, #20]	; (20004dd4 <HAL_FLASH_OB_Unlock+0x2c>)
20004dc0:	4a06      	ldr	r2, [pc, #24]	; (20004ddc <HAL_FLASH_OB_Unlock+0x34>)
20004dc2:	609a      	str	r2, [r3, #8]
  else
  {
    return HAL_ERROR;
  }  
  
  return HAL_OK;  
20004dc4:	2300      	movs	r3, #0
20004dc6:	e000      	b.n	20004dca <HAL_FLASH_OB_Unlock+0x22>
    return HAL_ERROR;
20004dc8:	2301      	movs	r3, #1
}
20004dca:	4618      	mov	r0, r3
20004dcc:	46bd      	mov	sp, r7
20004dce:	f85d 7b04 	ldr.w	r7, [sp], #4
20004dd2:	4770      	bx	lr
20004dd4:	40023c00 	.word	0x40023c00
20004dd8:	08192a3b 	.word	0x08192a3b
20004ddc:	4c5d6e7f 	.word	0x4c5d6e7f

20004de0 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status 
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
20004de0:	b480      	push	{r7}
20004de2:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
20004de4:	4b05      	ldr	r3, [pc, #20]	; (20004dfc <HAL_FLASH_OB_Lock+0x1c>)
20004de6:	695b      	ldr	r3, [r3, #20]
20004de8:	4a04      	ldr	r2, [pc, #16]	; (20004dfc <HAL_FLASH_OB_Lock+0x1c>)
20004dea:	f043 0301 	orr.w	r3, r3, #1
20004dee:	6153      	str	r3, [r2, #20]
  
  return HAL_OK;  
20004df0:	2300      	movs	r3, #0
}
20004df2:	4618      	mov	r0, r3
20004df4:	46bd      	mov	sp, r7
20004df6:	f85d 7b04 	ldr.w	r7, [sp], #4
20004dfa:	4770      	bx	lr
20004dfc:	40023c00 	.word	0x40023c00

20004e00 <HAL_FLASH_OB_Launch>:
/**
  * @brief  Launch the option byte loading.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
20004e00:	b580      	push	{r7, lr}
20004e02:	af00      	add	r7, sp, #0
  /* Set the OPTSTRT bit in OPTCR register */
  FLASH->OPTCR |= FLASH_OPTCR_OPTSTRT;
20004e04:	4b06      	ldr	r3, [pc, #24]	; (20004e20 <HAL_FLASH_OB_Launch+0x20>)
20004e06:	695b      	ldr	r3, [r3, #20]
20004e08:	4a05      	ldr	r2, [pc, #20]	; (20004e20 <HAL_FLASH_OB_Launch+0x20>)
20004e0a:	f043 0302 	orr.w	r3, r3, #2
20004e0e:	6153      	str	r3, [r2, #20]

  /* Wait for last operation to be completed */
  return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); 
20004e10:	f24c 3050 	movw	r0, #50000	; 0xc350
20004e14:	f000 f812 	bl	20004e3c <FLASH_WaitForLastOperation>
20004e18:	4603      	mov	r3, r0
}
20004e1a:	4618      	mov	r0, r3
20004e1c:	bd80      	pop	{r7, pc}
20004e1e:	bf00      	nop
20004e20:	40023c00 	.word	0x40023c00

20004e24 <HAL_FLASH_GetError>:
  *            @arg FLASH_ERROR_PGA: FLASH Programming Alignment error flag
  *            @arg FLASH_ERROR_WRP: FLASH Write protected error flag
  *            @arg FLASH_ERROR_OPERATION: FLASH operation Error flag 
  */
uint32_t HAL_FLASH_GetError(void)
{ 
20004e24:	b480      	push	{r7}
20004e26:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
20004e28:	4b03      	ldr	r3, [pc, #12]	; (20004e38 <HAL_FLASH_GetError+0x14>)
20004e2a:	699b      	ldr	r3, [r3, #24]
}  
20004e2c:	4618      	mov	r0, r3
20004e2e:	46bd      	mov	sp, r7
20004e30:	f85d 7b04 	ldr.w	r7, [sp], #4
20004e34:	4770      	bx	lr
20004e36:	bf00      	nop
20004e38:	200004f4 	.word	0x200004f4

20004e3c <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
20004e3c:	b580      	push	{r7, lr}
20004e3e:	b084      	sub	sp, #16
20004e40:	af00      	add	r7, sp, #0
20004e42:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
20004e44:	2300      	movs	r3, #0
20004e46:	60fb      	str	r3, [r7, #12]
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20004e48:	4b1a      	ldr	r3, [pc, #104]	; (20004eb4 <FLASH_WaitForLastOperation+0x78>)
20004e4a:	2200      	movs	r2, #0
20004e4c:	619a      	str	r2, [r3, #24]
  
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  /* Get tick */
  tickstart = HAL_GetTick();
20004e4e:	f7fc ff97 	bl	20001d80 <HAL_GetTick>
20004e52:	60f8      	str	r0, [r7, #12]

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
20004e54:	e010      	b.n	20004e78 <FLASH_WaitForLastOperation+0x3c>
  { 
    if(Timeout != HAL_MAX_DELAY)
20004e56:	687b      	ldr	r3, [r7, #4]
20004e58:	f1b3 3fff 	cmp.w	r3, #4294967295
20004e5c:	d00c      	beq.n	20004e78 <FLASH_WaitForLastOperation+0x3c>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
20004e5e:	687b      	ldr	r3, [r7, #4]
20004e60:	2b00      	cmp	r3, #0
20004e62:	d007      	beq.n	20004e74 <FLASH_WaitForLastOperation+0x38>
20004e64:	f7fc ff8c 	bl	20001d80 <HAL_GetTick>
20004e68:	4602      	mov	r2, r0
20004e6a:	68fb      	ldr	r3, [r7, #12]
20004e6c:	1ad3      	subs	r3, r2, r3
20004e6e:	687a      	ldr	r2, [r7, #4]
20004e70:	429a      	cmp	r2, r3
20004e72:	d201      	bcs.n	20004e78 <FLASH_WaitForLastOperation+0x3c>
      {
        return HAL_TIMEOUT;
20004e74:	2303      	movs	r3, #3
20004e76:	e019      	b.n	20004eac <FLASH_WaitForLastOperation+0x70>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
20004e78:	4b0f      	ldr	r3, [pc, #60]	; (20004eb8 <FLASH_WaitForLastOperation+0x7c>)
20004e7a:	68db      	ldr	r3, [r3, #12]
20004e7c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20004e80:	2b00      	cmp	r3, #0
20004e82:	d1e8      	bne.n	20004e56 <FLASH_WaitForLastOperation+0x1a>
      }
    } 
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
20004e84:	4b0c      	ldr	r3, [pc, #48]	; (20004eb8 <FLASH_WaitForLastOperation+0x7c>)
20004e86:	68db      	ldr	r3, [r3, #12]
20004e88:	f003 03f2 	and.w	r3, r3, #242	; 0xf2
20004e8c:	2b00      	cmp	r3, #0
20004e8e:	d003      	beq.n	20004e98 <FLASH_WaitForLastOperation+0x5c>
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
20004e90:	f000 f8b2 	bl	20004ff8 <FLASH_SetErrorCode>
    return HAL_ERROR;
20004e94:	2301      	movs	r3, #1
20004e96:	e009      	b.n	20004eac <FLASH_WaitForLastOperation+0x70>
  }
  
  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
20004e98:	4b07      	ldr	r3, [pc, #28]	; (20004eb8 <FLASH_WaitForLastOperation+0x7c>)
20004e9a:	68db      	ldr	r3, [r3, #12]
20004e9c:	f003 0301 	and.w	r3, r3, #1
20004ea0:	2b00      	cmp	r3, #0
20004ea2:	d002      	beq.n	20004eaa <FLASH_WaitForLastOperation+0x6e>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20004ea4:	4b04      	ldr	r3, [pc, #16]	; (20004eb8 <FLASH_WaitForLastOperation+0x7c>)
20004ea6:	2201      	movs	r2, #1
20004ea8:	60da      	str	r2, [r3, #12]
  }

  /* If there is an error flag set */
  return HAL_OK;
20004eaa:	2300      	movs	r3, #0
  
}  
20004eac:	4618      	mov	r0, r3
20004eae:	3710      	adds	r7, #16
20004eb0:	46bd      	mov	sp, r7
20004eb2:	bd80      	pop	{r7, pc}
20004eb4:	200004f4 	.word	0x200004f4
20004eb8:	40023c00 	.word	0x40023c00

20004ebc <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
20004ebc:	b490      	push	{r4, r7}
20004ebe:	b084      	sub	sp, #16
20004ec0:	af00      	add	r7, sp, #0
20004ec2:	60f8      	str	r0, [r7, #12]
20004ec4:	e9c7 2300 	strd	r2, r3, [r7]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
20004ec8:	4b13      	ldr	r3, [pc, #76]	; (20004f18 <FLASH_Program_DoubleWord+0x5c>)
20004eca:	691b      	ldr	r3, [r3, #16]
20004ecc:	4a12      	ldr	r2, [pc, #72]	; (20004f18 <FLASH_Program_DoubleWord+0x5c>)
20004ece:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20004ed2:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
20004ed4:	4b10      	ldr	r3, [pc, #64]	; (20004f18 <FLASH_Program_DoubleWord+0x5c>)
20004ed6:	691b      	ldr	r3, [r3, #16]
20004ed8:	4a0f      	ldr	r2, [pc, #60]	; (20004f18 <FLASH_Program_DoubleWord+0x5c>)
20004eda:	f443 7340 	orr.w	r3, r3, #768	; 0x300
20004ede:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
20004ee0:	4b0d      	ldr	r3, [pc, #52]	; (20004f18 <FLASH_Program_DoubleWord+0x5c>)
20004ee2:	691b      	ldr	r3, [r3, #16]
20004ee4:	4a0c      	ldr	r2, [pc, #48]	; (20004f18 <FLASH_Program_DoubleWord+0x5c>)
20004ee6:	f043 0301 	orr.w	r3, r3, #1
20004eea:	6113      	str	r3, [r2, #16]

  /* Program the double-word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
20004eec:	68fb      	ldr	r3, [r7, #12]
20004eee:	683a      	ldr	r2, [r7, #0]
20004ef0:	601a      	str	r2, [r3, #0]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
20004ef2:	e9d7 1200 	ldrd	r1, r2, [r7]
20004ef6:	f04f 0300 	mov.w	r3, #0
20004efa:	f04f 0400 	mov.w	r4, #0
20004efe:	0013      	movs	r3, r2
20004f00:	2400      	movs	r4, #0
20004f02:	68fa      	ldr	r2, [r7, #12]
20004f04:	3204      	adds	r2, #4
20004f06:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
20004f08:	f3bf 8f4f 	dsb	sy

  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
20004f0c:	bf00      	nop
20004f0e:	3710      	adds	r7, #16
20004f10:	46bd      	mov	sp, r7
20004f12:	bc90      	pop	{r4, r7}
20004f14:	4770      	bx	lr
20004f16:	bf00      	nop
20004f18:	40023c00 	.word	0x40023c00

20004f1c <FLASH_Program_Word>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
{
20004f1c:	b480      	push	{r7}
20004f1e:	b083      	sub	sp, #12
20004f20:	af00      	add	r7, sp, #0
20004f22:	6078      	str	r0, [r7, #4]
20004f24:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
20004f26:	4b0e      	ldr	r3, [pc, #56]	; (20004f60 <FLASH_Program_Word+0x44>)
20004f28:	691b      	ldr	r3, [r3, #16]
20004f2a:	4a0d      	ldr	r2, [pc, #52]	; (20004f60 <FLASH_Program_Word+0x44>)
20004f2c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20004f30:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
20004f32:	4b0b      	ldr	r3, [pc, #44]	; (20004f60 <FLASH_Program_Word+0x44>)
20004f34:	691b      	ldr	r3, [r3, #16]
20004f36:	4a0a      	ldr	r2, [pc, #40]	; (20004f60 <FLASH_Program_Word+0x44>)
20004f38:	f443 7300 	orr.w	r3, r3, #512	; 0x200
20004f3c:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
20004f3e:	4b08      	ldr	r3, [pc, #32]	; (20004f60 <FLASH_Program_Word+0x44>)
20004f40:	691b      	ldr	r3, [r3, #16]
20004f42:	4a07      	ldr	r2, [pc, #28]	; (20004f60 <FLASH_Program_Word+0x44>)
20004f44:	f043 0301 	orr.w	r3, r3, #1
20004f48:	6113      	str	r3, [r2, #16]

  *(__IO uint32_t*)Address = Data;
20004f4a:	687b      	ldr	r3, [r7, #4]
20004f4c:	683a      	ldr	r2, [r7, #0]
20004f4e:	601a      	str	r2, [r3, #0]
20004f50:	f3bf 8f4f 	dsb	sy
  
  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
20004f54:	bf00      	nop
20004f56:	370c      	adds	r7, #12
20004f58:	46bd      	mov	sp, r7
20004f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
20004f5e:	4770      	bx	lr
20004f60:	40023c00 	.word	0x40023c00

20004f64 <FLASH_Program_HalfWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
20004f64:	b480      	push	{r7}
20004f66:	b083      	sub	sp, #12
20004f68:	af00      	add	r7, sp, #0
20004f6a:	6078      	str	r0, [r7, #4]
20004f6c:	460b      	mov	r3, r1
20004f6e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
20004f70:	4b0e      	ldr	r3, [pc, #56]	; (20004fac <FLASH_Program_HalfWord+0x48>)
20004f72:	691b      	ldr	r3, [r3, #16]
20004f74:	4a0d      	ldr	r2, [pc, #52]	; (20004fac <FLASH_Program_HalfWord+0x48>)
20004f76:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20004f7a:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
20004f7c:	4b0b      	ldr	r3, [pc, #44]	; (20004fac <FLASH_Program_HalfWord+0x48>)
20004f7e:	691b      	ldr	r3, [r3, #16]
20004f80:	4a0a      	ldr	r2, [pc, #40]	; (20004fac <FLASH_Program_HalfWord+0x48>)
20004f82:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20004f86:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
20004f88:	4b08      	ldr	r3, [pc, #32]	; (20004fac <FLASH_Program_HalfWord+0x48>)
20004f8a:	691b      	ldr	r3, [r3, #16]
20004f8c:	4a07      	ldr	r2, [pc, #28]	; (20004fac <FLASH_Program_HalfWord+0x48>)
20004f8e:	f043 0301 	orr.w	r3, r3, #1
20004f92:	6113      	str	r3, [r2, #16]

  *(__IO uint16_t*)Address = Data;
20004f94:	687b      	ldr	r3, [r7, #4]
20004f96:	887a      	ldrh	r2, [r7, #2]
20004f98:	801a      	strh	r2, [r3, #0]
20004f9a:	f3bf 8f4f 	dsb	sy

  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
  
}
20004f9e:	bf00      	nop
20004fa0:	370c      	adds	r7, #12
20004fa2:	46bd      	mov	sp, r7
20004fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
20004fa8:	4770      	bx	lr
20004faa:	bf00      	nop
20004fac:	40023c00 	.word	0x40023c00

20004fb0 <FLASH_Program_Byte>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
{
20004fb0:	b480      	push	{r7}
20004fb2:	b083      	sub	sp, #12
20004fb4:	af00      	add	r7, sp, #0
20004fb6:	6078      	str	r0, [r7, #4]
20004fb8:	460b      	mov	r3, r1
20004fba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
20004fbc:	4b0d      	ldr	r3, [pc, #52]	; (20004ff4 <FLASH_Program_Byte+0x44>)
20004fbe:	691b      	ldr	r3, [r3, #16]
20004fc0:	4a0c      	ldr	r2, [pc, #48]	; (20004ff4 <FLASH_Program_Byte+0x44>)
20004fc2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20004fc6:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
20004fc8:	4b0a      	ldr	r3, [pc, #40]	; (20004ff4 <FLASH_Program_Byte+0x44>)
20004fca:	4a0a      	ldr	r2, [pc, #40]	; (20004ff4 <FLASH_Program_Byte+0x44>)
20004fcc:	691b      	ldr	r3, [r3, #16]
20004fce:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
20004fd0:	4b08      	ldr	r3, [pc, #32]	; (20004ff4 <FLASH_Program_Byte+0x44>)
20004fd2:	691b      	ldr	r3, [r3, #16]
20004fd4:	4a07      	ldr	r2, [pc, #28]	; (20004ff4 <FLASH_Program_Byte+0x44>)
20004fd6:	f043 0301 	orr.w	r3, r3, #1
20004fda:	6113      	str	r3, [r2, #16]

  *(__IO uint8_t*)Address = Data;
20004fdc:	687b      	ldr	r3, [r7, #4]
20004fde:	78fa      	ldrb	r2, [r7, #3]
20004fe0:	701a      	strb	r2, [r3, #0]
20004fe2:	f3bf 8f4f 	dsb	sy

  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
20004fe6:	bf00      	nop
20004fe8:	370c      	adds	r7, #12
20004fea:	46bd      	mov	sp, r7
20004fec:	f85d 7b04 	ldr.w	r7, [sp], #4
20004ff0:	4770      	bx	lr
20004ff2:	bf00      	nop
20004ff4:	40023c00 	.word	0x40023c00

20004ff8 <FLASH_SetErrorCode>:
/**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{
20004ff8:	b480      	push	{r7}
20004ffa:	af00      	add	r7, sp, #0
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
20004ffc:	4b21      	ldr	r3, [pc, #132]	; (20005084 <FLASH_SetErrorCode+0x8c>)
20004ffe:	68db      	ldr	r3, [r3, #12]
20005000:	f003 0302 	and.w	r3, r3, #2
20005004:	2b00      	cmp	r3, #0
20005006:	d005      	beq.n	20005014 <FLASH_SetErrorCode+0x1c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
20005008:	4b1f      	ldr	r3, [pc, #124]	; (20005088 <FLASH_SetErrorCode+0x90>)
2000500a:	699b      	ldr	r3, [r3, #24]
2000500c:	f043 0320 	orr.w	r3, r3, #32
20005010:	4a1d      	ldr	r2, [pc, #116]	; (20005088 <FLASH_SetErrorCode+0x90>)
20005012:	6193      	str	r3, [r2, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
20005014:	4b1b      	ldr	r3, [pc, #108]	; (20005084 <FLASH_SetErrorCode+0x8c>)
20005016:	68db      	ldr	r3, [r3, #12]
20005018:	f003 0310 	and.w	r3, r3, #16
2000501c:	2b00      	cmp	r3, #0
2000501e:	d005      	beq.n	2000502c <FLASH_SetErrorCode+0x34>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
20005020:	4b19      	ldr	r3, [pc, #100]	; (20005088 <FLASH_SetErrorCode+0x90>)
20005022:	699b      	ldr	r3, [r3, #24]
20005024:	f043 0310 	orr.w	r3, r3, #16
20005028:	4a17      	ldr	r2, [pc, #92]	; (20005088 <FLASH_SetErrorCode+0x90>)
2000502a:	6193      	str	r3, [r2, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
2000502c:	4b15      	ldr	r3, [pc, #84]	; (20005084 <FLASH_SetErrorCode+0x8c>)
2000502e:	68db      	ldr	r3, [r3, #12]
20005030:	f003 0320 	and.w	r3, r3, #32
20005034:	2b00      	cmp	r3, #0
20005036:	d005      	beq.n	20005044 <FLASH_SetErrorCode+0x4c>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
20005038:	4b13      	ldr	r3, [pc, #76]	; (20005088 <FLASH_SetErrorCode+0x90>)
2000503a:	699b      	ldr	r3, [r3, #24]
2000503c:	f043 0308 	orr.w	r3, r3, #8
20005040:	4a11      	ldr	r2, [pc, #68]	; (20005088 <FLASH_SetErrorCode+0x90>)
20005042:	6193      	str	r3, [r2, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
20005044:	4b0f      	ldr	r3, [pc, #60]	; (20005084 <FLASH_SetErrorCode+0x8c>)
20005046:	68db      	ldr	r3, [r3, #12]
20005048:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000504c:	2b00      	cmp	r3, #0
2000504e:	d005      	beq.n	2000505c <FLASH_SetErrorCode+0x64>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
20005050:	4b0d      	ldr	r3, [pc, #52]	; (20005088 <FLASH_SetErrorCode+0x90>)
20005052:	699b      	ldr	r3, [r3, #24]
20005054:	f043 0304 	orr.w	r3, r3, #4
20005058:	4a0b      	ldr	r2, [pc, #44]	; (20005088 <FLASH_SetErrorCode+0x90>)
2000505a:	6193      	str	r3, [r2, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
2000505c:	4b09      	ldr	r3, [pc, #36]	; (20005084 <FLASH_SetErrorCode+0x8c>)
2000505e:	68db      	ldr	r3, [r3, #12]
20005060:	f003 0380 	and.w	r3, r3, #128	; 0x80
20005064:	2b00      	cmp	r3, #0
20005066:	d005      	beq.n	20005074 <FLASH_SetErrorCode+0x7c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
20005068:	4b07      	ldr	r3, [pc, #28]	; (20005088 <FLASH_SetErrorCode+0x90>)
2000506a:	699b      	ldr	r3, [r3, #24]
2000506c:	f043 0302 	orr.w	r3, r3, #2
20005070:	4a05      	ldr	r2, [pc, #20]	; (20005088 <FLASH_SetErrorCode+0x90>)
20005072:	6193      	str	r3, [r2, #24]
   pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
  }  
#endif /* FLASH_OPTCR2_PCROP */
  
  /* Clear error programming flags */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
20005074:	4b03      	ldr	r3, [pc, #12]	; (20005084 <FLASH_SetErrorCode+0x8c>)
20005076:	22f2      	movs	r2, #242	; 0xf2
20005078:	60da      	str	r2, [r3, #12]
}
2000507a:	bf00      	nop
2000507c:	46bd      	mov	sp, r7
2000507e:	f85d 7b04 	ldr.w	r7, [sp], #4
20005082:	4770      	bx	lr
20005084:	40023c00 	.word	0x40023c00
20005088:	200004f4 	.word	0x200004f4

2000508c <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFF means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
2000508c:	b580      	push	{r7, lr}
2000508e:	b084      	sub	sp, #16
20005090:	af00      	add	r7, sp, #0
20005092:	6078      	str	r0, [r7, #4]
20005094:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
20005096:	2301      	movs	r3, #1
20005098:	73fb      	strb	r3, [r7, #15]
  uint32_t index = 0;
2000509a:	2300      	movs	r3, #0
2000509c:	60bb      	str	r3, [r7, #8]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
2000509e:	4b30      	ldr	r3, [pc, #192]	; (20005160 <HAL_FLASHEx_Erase+0xd4>)
200050a0:	7d1b      	ldrb	r3, [r3, #20]
200050a2:	2b01      	cmp	r3, #1
200050a4:	d101      	bne.n	200050aa <HAL_FLASHEx_Erase+0x1e>
200050a6:	2302      	movs	r3, #2
200050a8:	e056      	b.n	20005158 <HAL_FLASHEx_Erase+0xcc>
200050aa:	4b2d      	ldr	r3, [pc, #180]	; (20005160 <HAL_FLASHEx_Erase+0xd4>)
200050ac:	2201      	movs	r2, #1
200050ae:	751a      	strb	r2, [r3, #20]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200050b0:	f24c 3050 	movw	r0, #50000	; 0xc350
200050b4:	f7ff fec2 	bl	20004e3c <FLASH_WaitForLastOperation>
200050b8:	4603      	mov	r3, r0
200050ba:	73fb      	strb	r3, [r7, #15]

  if(status == HAL_OK)
200050bc:	7bfb      	ldrb	r3, [r7, #15]
200050be:	2b00      	cmp	r3, #0
200050c0:	d146      	bne.n	20005150 <HAL_FLASHEx_Erase+0xc4>
  {
    /*Initialization of SectorError variable*/
    *SectorError = 0xFFFFFFFFU;
200050c2:	683b      	ldr	r3, [r7, #0]
200050c4:	f04f 32ff 	mov.w	r2, #4294967295
200050c8:	601a      	str	r2, [r3, #0]
    
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
200050ca:	687b      	ldr	r3, [r7, #4]
200050cc:	681b      	ldr	r3, [r3, #0]
200050ce:	2b01      	cmp	r3, #1
200050d0:	d115      	bne.n	200050fe <HAL_FLASHEx_Erase+0x72>
    {
      /*Mass erase to be done*/
#if defined (FLASH_OPTCR_nDBANK)      
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
200050d2:	687b      	ldr	r3, [r7, #4]
200050d4:	691b      	ldr	r3, [r3, #16]
200050d6:	b2da      	uxtb	r2, r3
200050d8:	687b      	ldr	r3, [r7, #4]
200050da:	685b      	ldr	r3, [r3, #4]
200050dc:	4619      	mov	r1, r3
200050de:	4610      	mov	r0, r2
200050e0:	f000 f95e 	bl	200053a0 <FLASH_MassErase>
#else
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange);      
#endif /* FLASH_OPTCR_nDBANK */
                      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200050e4:	f24c 3050 	movw	r0, #50000	; 0xc350
200050e8:	f7ff fea8 	bl	20004e3c <FLASH_WaitForLastOperation>
200050ec:	4603      	mov	r3, r0
200050ee:	73fb      	strb	r3, [r7, #15]
      
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= (~FLASH_MER_BIT);
200050f0:	4b1c      	ldr	r3, [pc, #112]	; (20005164 <HAL_FLASHEx_Erase+0xd8>)
200050f2:	691a      	ldr	r2, [r3, #16]
200050f4:	491b      	ldr	r1, [pc, #108]	; (20005164 <HAL_FLASHEx_Erase+0xd8>)
200050f6:	4b1c      	ldr	r3, [pc, #112]	; (20005168 <HAL_FLASHEx_Erase+0xdc>)
200050f8:	4013      	ands	r3, r2
200050fa:	610b      	str	r3, [r1, #16]
200050fc:	e028      	b.n	20005150 <HAL_FLASHEx_Erase+0xc4>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
200050fe:	687b      	ldr	r3, [r7, #4]
20005100:	689b      	ldr	r3, [r3, #8]
20005102:	60bb      	str	r3, [r7, #8]
20005104:	e01c      	b.n	20005140 <HAL_FLASHEx_Erase+0xb4>
      {
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
20005106:	687b      	ldr	r3, [r7, #4]
20005108:	691b      	ldr	r3, [r3, #16]
2000510a:	b2db      	uxtb	r3, r3
2000510c:	4619      	mov	r1, r3
2000510e:	68b8      	ldr	r0, [r7, #8]
20005110:	f000 f980 	bl	20005414 <FLASH_Erase_Sector>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20005114:	f24c 3050 	movw	r0, #50000	; 0xc350
20005118:	f7ff fe90 	bl	20004e3c <FLASH_WaitForLastOperation>
2000511c:	4603      	mov	r3, r0
2000511e:	73fb      	strb	r3, [r7, #15]
        
        /* If the erase operation is completed, disable the SER Bit and SNB Bits */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB)); 
20005120:	4b10      	ldr	r3, [pc, #64]	; (20005164 <HAL_FLASHEx_Erase+0xd8>)
20005122:	691b      	ldr	r3, [r3, #16]
20005124:	4a0f      	ldr	r2, [pc, #60]	; (20005164 <HAL_FLASHEx_Erase+0xd8>)
20005126:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
2000512a:	6113      	str	r3, [r2, #16]

        if(status != HAL_OK) 
2000512c:	7bfb      	ldrb	r3, [r7, #15]
2000512e:	2b00      	cmp	r3, #0
20005130:	d003      	beq.n	2000513a <HAL_FLASHEx_Erase+0xae>
        {
          /* In case of error, stop erase procedure and return the faulty sector*/
          *SectorError = index;
20005132:	683b      	ldr	r3, [r7, #0]
20005134:	68ba      	ldr	r2, [r7, #8]
20005136:	601a      	str	r2, [r3, #0]
          break;
20005138:	e00a      	b.n	20005150 <HAL_FLASHEx_Erase+0xc4>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
2000513a:	68bb      	ldr	r3, [r7, #8]
2000513c:	3301      	adds	r3, #1
2000513e:	60bb      	str	r3, [r7, #8]
20005140:	687b      	ldr	r3, [r7, #4]
20005142:	68da      	ldr	r2, [r3, #12]
20005144:	687b      	ldr	r3, [r7, #4]
20005146:	689b      	ldr	r3, [r3, #8]
20005148:	4413      	add	r3, r2
2000514a:	68ba      	ldr	r2, [r7, #8]
2000514c:	429a      	cmp	r2, r3
2000514e:	d3da      	bcc.n	20005106 <HAL_FLASHEx_Erase+0x7a>
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20005150:	4b03      	ldr	r3, [pc, #12]	; (20005160 <HAL_FLASHEx_Erase+0xd4>)
20005152:	2200      	movs	r2, #0
20005154:	751a      	strb	r2, [r3, #20]

  return status;
20005156:	7bfb      	ldrb	r3, [r7, #15]
}
20005158:	4618      	mov	r0, r3
2000515a:	3710      	adds	r7, #16
2000515c:	46bd      	mov	sp, r7
2000515e:	bd80      	pop	{r7, pc}
20005160:	200004f4 	.word	0x200004f4
20005164:	40023c00 	.word	0x40023c00
20005168:	ffff7ffb 	.word	0xffff7ffb

2000516c <HAL_FLASHEx_Erase_IT>:
  *         contains the configuration information for the erasing.
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
{
2000516c:	b580      	push	{r7, lr}
2000516e:	b084      	sub	sp, #16
20005170:	af00      	add	r7, sp, #0
20005172:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20005174:	2300      	movs	r3, #0
20005176:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20005178:	4b23      	ldr	r3, [pc, #140]	; (20005208 <HAL_FLASHEx_Erase_IT+0x9c>)
2000517a:	7d1b      	ldrb	r3, [r3, #20]
2000517c:	2b01      	cmp	r3, #1
2000517e:	d101      	bne.n	20005184 <HAL_FLASHEx_Erase_IT+0x18>
20005180:	2302      	movs	r3, #2
20005182:	e03c      	b.n	200051fe <HAL_FLASHEx_Erase_IT+0x92>
20005184:	4b20      	ldr	r3, [pc, #128]	; (20005208 <HAL_FLASHEx_Erase_IT+0x9c>)
20005186:	2201      	movs	r2, #1
20005188:	751a      	strb	r2, [r3, #20]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Enable End of FLASH Operation interrupt */
  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
2000518a:	4b20      	ldr	r3, [pc, #128]	; (2000520c <HAL_FLASHEx_Erase_IT+0xa0>)
2000518c:	691b      	ldr	r3, [r3, #16]
2000518e:	4a1f      	ldr	r2, [pc, #124]	; (2000520c <HAL_FLASHEx_Erase_IT+0xa0>)
20005190:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
20005194:	6113      	str	r3, [r2, #16]
  
  /* Enable Error source interrupt */
  __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
20005196:	4b1d      	ldr	r3, [pc, #116]	; (2000520c <HAL_FLASHEx_Erase_IT+0xa0>)
20005198:	691b      	ldr	r3, [r3, #16]
2000519a:	4a1c      	ldr	r2, [pc, #112]	; (2000520c <HAL_FLASHEx_Erase_IT+0xa0>)
2000519c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
200051a0:	6113      	str	r3, [r2, #16]
  
  /* Clear pending flags (if any) */  
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
200051a2:	4b1a      	ldr	r3, [pc, #104]	; (2000520c <HAL_FLASHEx_Erase_IT+0xa0>)
200051a4:	22f3      	movs	r2, #243	; 0xf3
200051a6:	60da      	str	r2, [r3, #12]
                         FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  
  
  if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
200051a8:	687b      	ldr	r3, [r7, #4]
200051aa:	681b      	ldr	r3, [r3, #0]
200051ac:	2b01      	cmp	r3, #1
200051ae:	d10c      	bne.n	200051ca <HAL_FLASHEx_Erase_IT+0x5e>
  {
    /*Mass erase to be done*/
    pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
200051b0:	4b15      	ldr	r3, [pc, #84]	; (20005208 <HAL_FLASHEx_Erase_IT+0x9c>)
200051b2:	2202      	movs	r2, #2
200051b4:	701a      	strb	r2, [r3, #0]
#if defined (FLASH_OPTCR_nDBANK)    
    FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
200051b6:	687b      	ldr	r3, [r7, #4]
200051b8:	691b      	ldr	r3, [r3, #16]
200051ba:	b2da      	uxtb	r2, r3
200051bc:	687b      	ldr	r3, [r7, #4]
200051be:	685b      	ldr	r3, [r3, #4]
200051c0:	4619      	mov	r1, r3
200051c2:	4610      	mov	r0, r2
200051c4:	f000 f8ec 	bl	200053a0 <FLASH_MassErase>
200051c8:	e018      	b.n	200051fc <HAL_FLASHEx_Erase_IT+0x90>
    /* Erase by sector to be done*/

    /* Check the parameters */
    assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

    pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;
200051ca:	4b0f      	ldr	r3, [pc, #60]	; (20005208 <HAL_FLASHEx_Erase_IT+0x9c>)
200051cc:	2201      	movs	r2, #1
200051ce:	701a      	strb	r2, [r3, #0]
    pFlash.NbSectorsToErase = pEraseInit->NbSectors;
200051d0:	687b      	ldr	r3, [r7, #4]
200051d2:	68db      	ldr	r3, [r3, #12]
200051d4:	4a0c      	ldr	r2, [pc, #48]	; (20005208 <HAL_FLASHEx_Erase_IT+0x9c>)
200051d6:	6053      	str	r3, [r2, #4]
    pFlash.Sector = pEraseInit->Sector;
200051d8:	687b      	ldr	r3, [r7, #4]
200051da:	689b      	ldr	r3, [r3, #8]
200051dc:	4a0a      	ldr	r2, [pc, #40]	; (20005208 <HAL_FLASHEx_Erase_IT+0x9c>)
200051de:	60d3      	str	r3, [r2, #12]
    pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;
200051e0:	687b      	ldr	r3, [r7, #4]
200051e2:	691b      	ldr	r3, [r3, #16]
200051e4:	b2da      	uxtb	r2, r3
200051e6:	4b08      	ldr	r3, [pc, #32]	; (20005208 <HAL_FLASHEx_Erase_IT+0x9c>)
200051e8:	721a      	strb	r2, [r3, #8]

    /*Erase 1st sector and wait for IT*/
    FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);
200051ea:	687b      	ldr	r3, [r7, #4]
200051ec:	689a      	ldr	r2, [r3, #8]
200051ee:	687b      	ldr	r3, [r7, #4]
200051f0:	691b      	ldr	r3, [r3, #16]
200051f2:	b2db      	uxtb	r3, r3
200051f4:	4619      	mov	r1, r3
200051f6:	4610      	mov	r0, r2
200051f8:	f000 f90c 	bl	20005414 <FLASH_Erase_Sector>
  }

  return status;
200051fc:	7bfb      	ldrb	r3, [r7, #15]
}
200051fe:	4618      	mov	r0, r3
20005200:	3710      	adds	r7, #16
20005202:	46bd      	mov	sp, r7
20005204:	bd80      	pop	{r7, pc}
20005206:	bf00      	nop
20005208:	200004f4 	.word	0x200004f4
2000520c:	40023c00 	.word	0x40023c00

20005210 <HAL_FLASHEx_OBProgram>:
  *         contains the configuration information for the programming.
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
20005210:	b5f0      	push	{r4, r5, r6, r7, lr}
20005212:	b089      	sub	sp, #36	; 0x24
20005214:	af04      	add	r7, sp, #16
20005216:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
20005218:	2301      	movs	r3, #1
2000521a:	73fb      	strb	r3, [r7, #15]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
2000521c:	4b49      	ldr	r3, [pc, #292]	; (20005344 <HAL_FLASHEx_OBProgram+0x134>)
2000521e:	7d1b      	ldrb	r3, [r3, #20]
20005220:	2b01      	cmp	r3, #1
20005222:	d101      	bne.n	20005228 <HAL_FLASHEx_OBProgram+0x18>
20005224:	2302      	movs	r3, #2
20005226:	e089      	b.n	2000533c <HAL_FLASHEx_OBProgram+0x12c>
20005228:	4b46      	ldr	r3, [pc, #280]	; (20005344 <HAL_FLASHEx_OBProgram+0x134>)
2000522a:	2201      	movs	r2, #1
2000522c:	751a      	strb	r2, [r3, #20]

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));

  /* Write protection configuration */
  if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
2000522e:	687b      	ldr	r3, [r7, #4]
20005230:	681b      	ldr	r3, [r3, #0]
20005232:	f003 0301 	and.w	r3, r3, #1
20005236:	2b00      	cmp	r3, #0
20005238:	d012      	beq.n	20005260 <HAL_FLASHEx_OBProgram+0x50>
  {
    assert_param(IS_WRPSTATE(pOBInit->WRPState));
    if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
2000523a:	687b      	ldr	r3, [r7, #4]
2000523c:	685b      	ldr	r3, [r3, #4]
2000523e:	2b01      	cmp	r3, #1
20005240:	d107      	bne.n	20005252 <HAL_FLASHEx_OBProgram+0x42>
    {
      /*Enable of Write protection on the selected Sector*/
      status = FLASH_OB_EnableWRP(pOBInit->WRPSector);
20005242:	687b      	ldr	r3, [r7, #4]
20005244:	689b      	ldr	r3, [r3, #8]
20005246:	4618      	mov	r0, r3
20005248:	f000 f98e 	bl	20005568 <FLASH_OB_EnableWRP>
2000524c:	4603      	mov	r3, r0
2000524e:	73fb      	strb	r3, [r7, #15]
20005250:	e006      	b.n	20005260 <HAL_FLASHEx_OBProgram+0x50>
    }
    else
    {
      /*Disable of Write protection on the selected Sector*/
      status = FLASH_OB_DisableWRP(pOBInit->WRPSector);
20005252:	687b      	ldr	r3, [r7, #4]
20005254:	689b      	ldr	r3, [r3, #8]
20005256:	4618      	mov	r0, r3
20005258:	f000 f9a4 	bl	200055a4 <FLASH_OB_DisableWRP>
2000525c:	4603      	mov	r3, r0
2000525e:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* Read protection configuration */
  if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
20005260:	687b      	ldr	r3, [r7, #4]
20005262:	681b      	ldr	r3, [r3, #0]
20005264:	f003 0302 	and.w	r3, r3, #2
20005268:	2b00      	cmp	r3, #0
2000526a:	d007      	beq.n	2000527c <HAL_FLASHEx_OBProgram+0x6c>
  {
    status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
2000526c:	687b      	ldr	r3, [r7, #4]
2000526e:	68db      	ldr	r3, [r3, #12]
20005270:	b2db      	uxtb	r3, r3
20005272:	4618      	mov	r0, r3
20005274:	f000 f9b2 	bl	200055dc <FLASH_OB_RDP_LevelConfig>
20005278:	4603      	mov	r3, r0
2000527a:	73fb      	strb	r3, [r7, #15]
  }

  /* USER  configuration */
  if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
2000527c:	687b      	ldr	r3, [r7, #4]
2000527e:	681b      	ldr	r3, [r3, #0]
20005280:	f003 0304 	and.w	r3, r3, #4
20005284:	2b00      	cmp	r3, #0
20005286:	d02b      	beq.n	200052e0 <HAL_FLASHEx_OBProgram+0xd0>
  {
#if defined (FLASH_OPTCR_nDBANK)
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
20005288:	687b      	ldr	r3, [r7, #4]
2000528a:	695b      	ldr	r3, [r3, #20]
2000528c:	f003 0410 	and.w	r4, r3, #16
                                 pOBInit->USERConfig & OB_IWDG_SW,
20005290:	687b      	ldr	r3, [r7, #4]
20005292:	695b      	ldr	r3, [r3, #20]
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
20005294:	f003 0520 	and.w	r5, r3, #32
                                 pOBInit->USERConfig & OB_STOP_NO_RST,
20005298:	687b      	ldr	r3, [r7, #4]
2000529a:	695b      	ldr	r3, [r3, #20]
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
2000529c:	f003 0640 	and.w	r6, r3, #64	; 0x40
                                 pOBInit->USERConfig & OB_STDBY_NO_RST, 
200052a0:	687b      	ldr	r3, [r7, #4]
200052a2:	695b      	ldr	r3, [r3, #20]
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
200052a4:	f003 0c80 	and.w	ip, r3, #128	; 0x80
                                 pOBInit->USERConfig & OB_IWDG_STOP_ACTIVE,
200052a8:	687b      	ldr	r3, [r7, #4]
200052aa:	695b      	ldr	r3, [r3, #20]
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
200052ac:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
                                 pOBInit->USERConfig & OB_IWDG_STDBY_ACTIVE,
200052b0:	687a      	ldr	r2, [r7, #4]
200052b2:	6952      	ldr	r2, [r2, #20]
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
200052b4:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
                                 pOBInit->USERConfig & OB_NDBANK_SINGLE_BANK,
200052b8:	6879      	ldr	r1, [r7, #4]
200052ba:	6949      	ldr	r1, [r1, #20]
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
200052bc:	f001 5100 	and.w	r1, r1, #536870912	; 0x20000000
                                 pOBInit->USERConfig & OB_DUAL_BOOT_DISABLE);
200052c0:	6878      	ldr	r0, [r7, #4]
200052c2:	6940      	ldr	r0, [r0, #20]
    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
200052c4:	f000 5080 	and.w	r0, r0, #268435456	; 0x10000000
200052c8:	9003      	str	r0, [sp, #12]
200052ca:	9102      	str	r1, [sp, #8]
200052cc:	9201      	str	r2, [sp, #4]
200052ce:	9300      	str	r3, [sp, #0]
200052d0:	4663      	mov	r3, ip
200052d2:	4632      	mov	r2, r6
200052d4:	4629      	mov	r1, r5
200052d6:	4620      	mov	r0, r4
200052d8:	f000 f8fc 	bl	200054d4 <FLASH_OB_UserConfig>
200052dc:	4603      	mov	r3, r0
200052de:	73fb      	strb	r3, [r7, #15]
                                 pOBInit->USERConfig & OB_IWDG_STDBY_ACTIVE);    
#endif /* FLASH_OPTCR_nDBANK */
  }
  
  /* BOR Level  configuration */
  if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
200052e0:	687b      	ldr	r3, [r7, #4]
200052e2:	681b      	ldr	r3, [r3, #0]
200052e4:	f003 0308 	and.w	r3, r3, #8
200052e8:	2b00      	cmp	r3, #0
200052ea:	d007      	beq.n	200052fc <HAL_FLASHEx_OBProgram+0xec>
  {
    status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
200052ec:	687b      	ldr	r3, [r7, #4]
200052ee:	691b      	ldr	r3, [r3, #16]
200052f0:	b2db      	uxtb	r3, r3
200052f2:	4618      	mov	r0, r3
200052f4:	f000 f98c 	bl	20005610 <FLASH_OB_BOR_LevelConfig>
200052f8:	4603      	mov	r3, r0
200052fa:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Boot 0 Address configuration */
  if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR_0) == OPTIONBYTE_BOOTADDR_0)
200052fc:	687b      	ldr	r3, [r7, #4]
200052fe:	681b      	ldr	r3, [r3, #0]
20005300:	f003 0310 	and.w	r3, r3, #16
20005304:	2b00      	cmp	r3, #0
20005306:	d007      	beq.n	20005318 <HAL_FLASHEx_OBProgram+0x108>
  {
    status = FLASH_OB_BootAddressConfig(OPTIONBYTE_BOOTADDR_0, pOBInit->BootAddr0);
20005308:	687b      	ldr	r3, [r7, #4]
2000530a:	699b      	ldr	r3, [r3, #24]
2000530c:	4619      	mov	r1, r3
2000530e:	2010      	movs	r0, #16
20005310:	f000 f994 	bl	2000563c <FLASH_OB_BootAddressConfig>
20005314:	4603      	mov	r3, r0
20005316:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Boot 1 Address configuration */
  if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR_1) == OPTIONBYTE_BOOTADDR_1)
20005318:	687b      	ldr	r3, [r7, #4]
2000531a:	681b      	ldr	r3, [r3, #0]
2000531c:	f003 0320 	and.w	r3, r3, #32
20005320:	2b00      	cmp	r3, #0
20005322:	d007      	beq.n	20005334 <HAL_FLASHEx_OBProgram+0x124>
  {
    status = FLASH_OB_BootAddressConfig(OPTIONBYTE_BOOTADDR_1, pOBInit->BootAddr1);
20005324:	687b      	ldr	r3, [r7, #4]
20005326:	69db      	ldr	r3, [r3, #28]
20005328:	4619      	mov	r1, r3
2000532a:	2020      	movs	r0, #32
2000532c:	f000 f986 	bl	2000563c <FLASH_OB_BootAddressConfig>
20005330:	4603      	mov	r3, r0
20005332:	73fb      	strb	r3, [r7, #15]
    status = FLASH_OB_PCROP_RDP_Config(pOBInit->PCROPRdp);
  }
#endif /* FLASH_OPTCR2_PCROP */

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20005334:	4b03      	ldr	r3, [pc, #12]	; (20005344 <HAL_FLASHEx_OBProgram+0x134>)
20005336:	2200      	movs	r2, #0
20005338:	751a      	strb	r2, [r3, #20]

  return status;
2000533a:	7bfb      	ldrb	r3, [r7, #15]
}
2000533c:	4618      	mov	r0, r3
2000533e:	3714      	adds	r7, #20
20005340:	46bd      	mov	sp, r7
20005342:	bdf0      	pop	{r4, r5, r6, r7, pc}
20005344:	200004f4 	.word	0x200004f4

20005348 <HAL_FLASHEx_OBGetConfig>:
  *         contains the configuration information for the programming.
  * 
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
20005348:	b580      	push	{r7, lr}
2000534a:	b082      	sub	sp, #8
2000534c:	af00      	add	r7, sp, #0
2000534e:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER |\
20005350:	687b      	ldr	r3, [r7, #4]
20005352:	223f      	movs	r2, #63	; 0x3f
20005354:	601a      	str	r2, [r3, #0]
	                OPTIONBYTE_BOR | OPTIONBYTE_BOOTADDR_0 | OPTIONBYTE_BOOTADDR_1;

  /*Get WRP*/
  pOBInit->WRPSector = FLASH_OB_GetWRP();
20005356:	f000 f8ad 	bl	200054b4 <FLASH_OB_GetWRP>
2000535a:	4602      	mov	r2, r0
2000535c:	687b      	ldr	r3, [r7, #4]
2000535e:	609a      	str	r2, [r3, #8]

  /*Get RDP Level*/
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
20005360:	f000 f99a 	bl	20005698 <FLASH_OB_GetRDP>
20005364:	4603      	mov	r3, r0
20005366:	461a      	mov	r2, r3
20005368:	687b      	ldr	r3, [r7, #4]
2000536a:	60da      	str	r2, [r3, #12]

  /*Get USER*/
  pOBInit->USERConfig = FLASH_OB_GetUser();
2000536c:	f000 f8ec 	bl	20005548 <FLASH_OB_GetUser>
20005370:	4602      	mov	r2, r0
20005372:	687b      	ldr	r3, [r7, #4]
20005374:	615a      	str	r2, [r3, #20]

  /*Get BOR Level*/
  pOBInit->BORLevel = FLASH_OB_GetBOR();
20005376:	f000 f9af 	bl	200056d8 <FLASH_OB_GetBOR>
2000537a:	4602      	mov	r2, r0
2000537c:	687b      	ldr	r3, [r7, #4]
2000537e:	611a      	str	r2, [r3, #16]
  
  /*Get Boot Address when Boot pin = 0 */
  pOBInit->BootAddr0 = FLASH_OB_GetBootAddress(OPTIONBYTE_BOOTADDR_0);
20005380:	2010      	movs	r0, #16
20005382:	f000 f9b7 	bl	200056f4 <FLASH_OB_GetBootAddress>
20005386:	4602      	mov	r2, r0
20005388:	687b      	ldr	r3, [r7, #4]
2000538a:	619a      	str	r2, [r3, #24]
  
  /*Get Boot Address when Boot pin = 1 */
  pOBInit->BootAddr1 = FLASH_OB_GetBootAddress(OPTIONBYTE_BOOTADDR_1);
2000538c:	2020      	movs	r0, #32
2000538e:	f000 f9b1 	bl	200056f4 <FLASH_OB_GetBootAddress>
20005392:	4602      	mov	r2, r0
20005394:	687b      	ldr	r3, [r7, #4]
20005396:	61da      	str	r2, [r3, #28]
  pOBInit->PCROPSector = FLASH_OB_GetPCROP();
  
  /*Get PCROP_RDP Value */
  pOBInit->PCROPRdp = FLASH_OB_GetPCROPRDP();
#endif /* FLASH_OPTCR2_PCROP */
}
20005398:	bf00      	nop
2000539a:	3708      	adds	r7, #8
2000539c:	46bd      	mov	sp, r7
2000539e:	bd80      	pop	{r7, pc}

200053a0 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
{
200053a0:	b480      	push	{r7}
200053a2:	b083      	sub	sp, #12
200053a4:	af00      	add	r7, sp, #0
200053a6:	4603      	mov	r3, r0
200053a8:	6039      	str	r1, [r7, #0]
200053aa:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));

  /* if the previous operation is completed, proceed to erase all sectors */
  FLASH->CR &= CR_PSIZE_MASK;
200053ac:	4b18      	ldr	r3, [pc, #96]	; (20005410 <FLASH_MassErase+0x70>)
200053ae:	691b      	ldr	r3, [r3, #16]
200053b0:	4a17      	ldr	r2, [pc, #92]	; (20005410 <FLASH_MassErase+0x70>)
200053b2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
200053b6:	6113      	str	r3, [r2, #16]
  if(Banks == FLASH_BANK_BOTH)
200053b8:	683b      	ldr	r3, [r7, #0]
200053ba:	2b03      	cmp	r3, #3
200053bc:	d107      	bne.n	200053ce <FLASH_MassErase+0x2e>
  {
    /* bank1 & bank2 will be erased*/
    FLASH->CR |= FLASH_MER_BIT;
200053be:	4b14      	ldr	r3, [pc, #80]	; (20005410 <FLASH_MassErase+0x70>)
200053c0:	691a      	ldr	r2, [r3, #16]
200053c2:	4913      	ldr	r1, [pc, #76]	; (20005410 <FLASH_MassErase+0x70>)
200053c4:	f248 0304 	movw	r3, #32772	; 0x8004
200053c8:	4313      	orrs	r3, r2
200053ca:	610b      	str	r3, [r1, #16]
200053cc:	e00f      	b.n	200053ee <FLASH_MassErase+0x4e>
  }
  else if(Banks == FLASH_BANK_2)
200053ce:	683b      	ldr	r3, [r7, #0]
200053d0:	2b02      	cmp	r3, #2
200053d2:	d106      	bne.n	200053e2 <FLASH_MassErase+0x42>
  {
    /*Only bank2 will be erased*/
    FLASH->CR |= FLASH_CR_MER2;
200053d4:	4b0e      	ldr	r3, [pc, #56]	; (20005410 <FLASH_MassErase+0x70>)
200053d6:	691b      	ldr	r3, [r3, #16]
200053d8:	4a0d      	ldr	r2, [pc, #52]	; (20005410 <FLASH_MassErase+0x70>)
200053da:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
200053de:	6113      	str	r3, [r2, #16]
200053e0:	e005      	b.n	200053ee <FLASH_MassErase+0x4e>
  }
  else
  {
    /*Only bank1 will be erased*/
    FLASH->CR |= FLASH_CR_MER1;    
200053e2:	4b0b      	ldr	r3, [pc, #44]	; (20005410 <FLASH_MassErase+0x70>)
200053e4:	691b      	ldr	r3, [r3, #16]
200053e6:	4a0a      	ldr	r2, [pc, #40]	; (20005410 <FLASH_MassErase+0x70>)
200053e8:	f043 0304 	orr.w	r3, r3, #4
200053ec:	6113      	str	r3, [r2, #16]
  }
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8);
200053ee:	4b08      	ldr	r3, [pc, #32]	; (20005410 <FLASH_MassErase+0x70>)
200053f0:	691a      	ldr	r2, [r3, #16]
200053f2:	79fb      	ldrb	r3, [r7, #7]
200053f4:	021b      	lsls	r3, r3, #8
200053f6:	4313      	orrs	r3, r2
200053f8:	4a05      	ldr	r2, [pc, #20]	; (20005410 <FLASH_MassErase+0x70>)
200053fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200053fe:	6113      	str	r3, [r2, #16]
20005400:	f3bf 8f4f 	dsb	sy
  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
20005404:	bf00      	nop
20005406:	370c      	adds	r7, #12
20005408:	46bd      	mov	sp, r7
2000540a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000540e:	4770      	bx	lr
20005410:	40023c00 	.word	0x40023c00

20005414 <FLASH_Erase_Sector>:
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
{
20005414:	b480      	push	{r7}
20005416:	b085      	sub	sp, #20
20005418:	af00      	add	r7, sp, #0
2000541a:	6078      	str	r0, [r7, #4]
2000541c:	460b      	mov	r3, r1
2000541e:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0;
20005420:	2300      	movs	r3, #0
20005422:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
20005424:	78fb      	ldrb	r3, [r7, #3]
20005426:	2b00      	cmp	r3, #0
20005428:	d102      	bne.n	20005430 <FLASH_Erase_Sector+0x1c>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
2000542a:	2300      	movs	r3, #0
2000542c:	60fb      	str	r3, [r7, #12]
2000542e:	e010      	b.n	20005452 <FLASH_Erase_Sector+0x3e>
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
20005430:	78fb      	ldrb	r3, [r7, #3]
20005432:	2b01      	cmp	r3, #1
20005434:	d103      	bne.n	2000543e <FLASH_Erase_Sector+0x2a>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
20005436:	f44f 7380 	mov.w	r3, #256	; 0x100
2000543a:	60fb      	str	r3, [r7, #12]
2000543c:	e009      	b.n	20005452 <FLASH_Erase_Sector+0x3e>
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
2000543e:	78fb      	ldrb	r3, [r7, #3]
20005440:	2b02      	cmp	r3, #2
20005442:	d103      	bne.n	2000544c <FLASH_Erase_Sector+0x38>
  {
    tmp_psize = FLASH_PSIZE_WORD;
20005444:	f44f 7300 	mov.w	r3, #512	; 0x200
20005448:	60fb      	str	r3, [r7, #12]
2000544a:	e002      	b.n	20005452 <FLASH_Erase_Sector+0x3e>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
2000544c:	f44f 7340 	mov.w	r3, #768	; 0x300
20005450:	60fb      	str	r3, [r7, #12]
  }
  
  /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */
  if(Sector > FLASH_SECTOR_11) 
20005452:	687b      	ldr	r3, [r7, #4]
20005454:	2b0b      	cmp	r3, #11
20005456:	d902      	bls.n	2000545e <FLASH_Erase_Sector+0x4a>
  {
    Sector += 4;
20005458:	687b      	ldr	r3, [r7, #4]
2000545a:	3304      	adds	r3, #4
2000545c:	607b      	str	r3, [r7, #4]
  }  

  /* If the previous operation is completed, proceed to erase the sector */
  FLASH->CR &= CR_PSIZE_MASK;
2000545e:	4b14      	ldr	r3, [pc, #80]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
20005460:	691b      	ldr	r3, [r3, #16]
20005462:	4a13      	ldr	r2, [pc, #76]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
20005464:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20005468:	6113      	str	r3, [r2, #16]
  FLASH->CR |= tmp_psize;
2000546a:	4b11      	ldr	r3, [pc, #68]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
2000546c:	691a      	ldr	r2, [r3, #16]
2000546e:	4910      	ldr	r1, [pc, #64]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
20005470:	68fb      	ldr	r3, [r7, #12]
20005472:	4313      	orrs	r3, r2
20005474:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
20005476:	4b0e      	ldr	r3, [pc, #56]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
20005478:	691b      	ldr	r3, [r3, #16]
2000547a:	4a0d      	ldr	r2, [pc, #52]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
2000547c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
20005480:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
20005482:	4b0b      	ldr	r3, [pc, #44]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
20005484:	691a      	ldr	r2, [r3, #16]
20005486:	687b      	ldr	r3, [r7, #4]
20005488:	00db      	lsls	r3, r3, #3
2000548a:	4313      	orrs	r3, r2
2000548c:	4a08      	ldr	r2, [pc, #32]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
2000548e:	f043 0302 	orr.w	r3, r3, #2
20005492:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT;
20005494:	4b06      	ldr	r3, [pc, #24]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
20005496:	691b      	ldr	r3, [r3, #16]
20005498:	4a05      	ldr	r2, [pc, #20]	; (200054b0 <FLASH_Erase_Sector+0x9c>)
2000549a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000549e:	6113      	str	r3, [r2, #16]
200054a0:	f3bf 8f4f 	dsb	sy
  
  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
200054a4:	bf00      	nop
200054a6:	3714      	adds	r7, #20
200054a8:	46bd      	mov	sp, r7
200054aa:	f85d 7b04 	ldr.w	r7, [sp], #4
200054ae:	4770      	bx	lr
200054b0:	40023c00 	.word	0x40023c00

200054b4 <FLASH_OB_GetWRP>:
/**
  * @brief  Return the FLASH Write Protection Option Bytes value.
  * @retval uint32_t FLASH Write Protection Option Bytes value
  */
static uint32_t FLASH_OB_GetWRP(void)
{
200054b4:	b480      	push	{r7}
200054b6:	af00      	add	r7, sp, #0
  /* Return the FLASH write protection Register value */
  return ((uint32_t)(FLASH->OPTCR & 0x0FFF0000));
200054b8:	4b04      	ldr	r3, [pc, #16]	; (200054cc <FLASH_OB_GetWRP+0x18>)
200054ba:	695a      	ldr	r2, [r3, #20]
200054bc:	4b04      	ldr	r3, [pc, #16]	; (200054d0 <FLASH_OB_GetWRP+0x1c>)
200054be:	4013      	ands	r3, r2
}
200054c0:	4618      	mov	r0, r3
200054c2:	46bd      	mov	sp, r7
200054c4:	f85d 7b04 	ldr.w	r7, [sp], #4
200054c8:	4770      	bx	lr
200054ca:	bf00      	nop
200054cc:	40023c00 	.word	0x40023c00
200054d0:	0fff0000 	.word	0x0fff0000

200054d4 <FLASH_OB_UserConfig>:

  * @retval HAL Status
  */
static HAL_StatusTypeDef FLASH_OB_UserConfig(uint32_t Wwdg, uint32_t Iwdg, uint32_t Stop, uint32_t Stdby, uint32_t Iwdgstop, \
                                             uint32_t Iwdgstdby, uint32_t NDBank, uint32_t NDBoot)
{
200054d4:	b580      	push	{r7, lr}
200054d6:	b088      	sub	sp, #32
200054d8:	af00      	add	r7, sp, #0
200054da:	60f8      	str	r0, [r7, #12]
200054dc:	60b9      	str	r1, [r7, #8]
200054de:	607a      	str	r2, [r7, #4]
200054e0:	603b      	str	r3, [r7, #0]
  uint32_t useroptionmask = 0x00;
200054e2:	2300      	movs	r3, #0
200054e4:	61fb      	str	r3, [r7, #28]
  uint32_t useroptionvalue = 0x00;
200054e6:	2300      	movs	r3, #0
200054e8:	61bb      	str	r3, [r7, #24]

  HAL_StatusTypeDef status = HAL_OK;
200054ea:	2300      	movs	r3, #0
200054ec:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_OB_IWDG_STDBY_FREEZE(Iwdgstdby));
  assert_param(IS_OB_NDBANK(NDBank));
  assert_param(IS_OB_NDBOOT(NDBoot));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200054ee:	f24c 3050 	movw	r0, #50000	; 0xc350
200054f2:	f7ff fca3 	bl	20004e3c <FLASH_WaitForLastOperation>
200054f6:	4603      	mov	r3, r0
200054f8:	75fb      	strb	r3, [r7, #23]
  
  if(status == HAL_OK)
200054fa:	7dfb      	ldrb	r3, [r7, #23]
200054fc:	2b00      	cmp	r3, #0
200054fe:	d11a      	bne.n	20005536 <FLASH_OB_UserConfig+0x62>
  {
    useroptionmask = (FLASH_OPTCR_WWDG_SW | FLASH_OPTCR_IWDG_SW | FLASH_OPTCR_nRST_STOP | \
20005500:	4b0f      	ldr	r3, [pc, #60]	; (20005540 <FLASH_OB_UserConfig+0x6c>)
20005502:	61fb      	str	r3, [r7, #28]
                      FLASH_OPTCR_nRST_STDBY | FLASH_OPTCR_IWDG_STOP | FLASH_OPTCR_IWDG_STDBY | \
                      FLASH_OPTCR_nDBOOT | FLASH_OPTCR_nDBANK);
                      
    useroptionvalue = (Iwdg | Wwdg | Stop | Stdby | Iwdgstop | Iwdgstdby | NDBoot | NDBank);
20005504:	68ba      	ldr	r2, [r7, #8]
20005506:	68fb      	ldr	r3, [r7, #12]
20005508:	431a      	orrs	r2, r3
2000550a:	687b      	ldr	r3, [r7, #4]
2000550c:	431a      	orrs	r2, r3
2000550e:	683b      	ldr	r3, [r7, #0]
20005510:	431a      	orrs	r2, r3
20005512:	6abb      	ldr	r3, [r7, #40]	; 0x28
20005514:	431a      	orrs	r2, r3
20005516:	6afb      	ldr	r3, [r7, #44]	; 0x2c
20005518:	431a      	orrs	r2, r3
2000551a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2000551c:	4313      	orrs	r3, r2
2000551e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
20005520:	4313      	orrs	r3, r2
20005522:	61bb      	str	r3, [r7, #24]
        
    /* Update User Option Byte */               
    MODIFY_REG(FLASH->OPTCR, useroptionmask, useroptionvalue);
20005524:	4b07      	ldr	r3, [pc, #28]	; (20005544 <FLASH_OB_UserConfig+0x70>)
20005526:	695a      	ldr	r2, [r3, #20]
20005528:	69fb      	ldr	r3, [r7, #28]
2000552a:	43db      	mvns	r3, r3
2000552c:	401a      	ands	r2, r3
2000552e:	4905      	ldr	r1, [pc, #20]	; (20005544 <FLASH_OB_UserConfig+0x70>)
20005530:	69bb      	ldr	r3, [r7, #24]
20005532:	4313      	orrs	r3, r2
20005534:	614b      	str	r3, [r1, #20]
  }
  
  return status; 
20005536:	7dfb      	ldrb	r3, [r7, #23]
}
20005538:	4618      	mov	r0, r3
2000553a:	3720      	adds	r7, #32
2000553c:	46bd      	mov	sp, r7
2000553e:	bd80      	pop	{r7, pc}
20005540:	f00000f0 	.word	0xf00000f0
20005544:	40023c00 	.word	0x40023c00

20005548 <FLASH_OB_GetUser>:
  * @brief  Return the FLASH User Option Byte value.
  * @retval uint32_t FLASH User Option Bytes values: WWDG_SW(Bit4), IWDG_SW(Bit5), nRST_STOP(Bit6), 
  *         nRST_STDBY(Bit7), nDBOOT(Bit28), nDBANK(Bit29), IWDG_STDBY(Bit30) and IWDG_STOP(Bit31).
  */
static uint32_t FLASH_OB_GetUser(void)
{
20005548:	b480      	push	{r7}
2000554a:	af00      	add	r7, sp, #0
  /* Return the User Option Byte */
  return ((uint32_t)(FLASH->OPTCR & 0xF00000F0U));
2000554c:	4b04      	ldr	r3, [pc, #16]	; (20005560 <FLASH_OB_GetUser+0x18>)
2000554e:	695a      	ldr	r2, [r3, #20]
20005550:	4b04      	ldr	r3, [pc, #16]	; (20005564 <FLASH_OB_GetUser+0x1c>)
20005552:	4013      	ands	r3, r2
}
20005554:	4618      	mov	r0, r3
20005556:	46bd      	mov	sp, r7
20005558:	f85d 7b04 	ldr.w	r7, [sp], #4
2000555c:	4770      	bx	lr
2000555e:	bf00      	nop
20005560:	40023c00 	.word	0x40023c00
20005564:	f00000f0 	.word	0xf00000f0

20005568 <FLASH_OB_EnableWRP>:
  *            @arg OB_WRP_SECTOR_All
  *
  * @retval HAL FLASH State   
  */
static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector)
{
20005568:	b580      	push	{r7, lr}
2000556a:	b084      	sub	sp, #16
2000556c:	af00      	add	r7, sp, #0
2000556e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20005570:	2300      	movs	r3, #0
20005572:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
    
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20005574:	f24c 3050 	movw	r0, #50000	; 0xc350
20005578:	f7ff fc60 	bl	20004e3c <FLASH_WaitForLastOperation>
2000557c:	4603      	mov	r3, r0
2000557e:	73fb      	strb	r3, [r7, #15]

  if(status == HAL_OK)
20005580:	7bfb      	ldrb	r3, [r7, #15]
20005582:	2b00      	cmp	r3, #0
20005584:	d106      	bne.n	20005594 <FLASH_OB_EnableWRP+0x2c>
  {
    /*Write protection enabled on sectors */
    FLASH->OPTCR &= (~WRPSector);  
20005586:	4b06      	ldr	r3, [pc, #24]	; (200055a0 <FLASH_OB_EnableWRP+0x38>)
20005588:	695a      	ldr	r2, [r3, #20]
2000558a:	687b      	ldr	r3, [r7, #4]
2000558c:	43db      	mvns	r3, r3
2000558e:	4904      	ldr	r1, [pc, #16]	; (200055a0 <FLASH_OB_EnableWRP+0x38>)
20005590:	4013      	ands	r3, r2
20005592:	614b      	str	r3, [r1, #20]
  }
  
  return status;
20005594:	7bfb      	ldrb	r3, [r7, #15]
}
20005596:	4618      	mov	r0, r3
20005598:	3710      	adds	r7, #16
2000559a:	46bd      	mov	sp, r7
2000559c:	bd80      	pop	{r7, pc}
2000559e:	bf00      	nop
200055a0:	40023c00 	.word	0x40023c00

200055a4 <FLASH_OB_DisableWRP>:
  *
  *
  * @retval HAL Status   
  */
static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector)
{
200055a4:	b580      	push	{r7, lr}
200055a6:	b084      	sub	sp, #16
200055a8:	af00      	add	r7, sp, #0
200055aa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
200055ac:	2300      	movs	r3, #0
200055ae:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
    
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200055b0:	f24c 3050 	movw	r0, #50000	; 0xc350
200055b4:	f7ff fc42 	bl	20004e3c <FLASH_WaitForLastOperation>
200055b8:	4603      	mov	r3, r0
200055ba:	73fb      	strb	r3, [r7, #15]

  if(status == HAL_OK)
200055bc:	7bfb      	ldrb	r3, [r7, #15]
200055be:	2b00      	cmp	r3, #0
200055c0:	d105      	bne.n	200055ce <FLASH_OB_DisableWRP+0x2a>
  {
    /* Write protection disabled on sectors */
    FLASH->OPTCR |= (WRPSector); 
200055c2:	4b05      	ldr	r3, [pc, #20]	; (200055d8 <FLASH_OB_DisableWRP+0x34>)
200055c4:	695a      	ldr	r2, [r3, #20]
200055c6:	4904      	ldr	r1, [pc, #16]	; (200055d8 <FLASH_OB_DisableWRP+0x34>)
200055c8:	687b      	ldr	r3, [r7, #4]
200055ca:	4313      	orrs	r3, r2
200055cc:	614b      	str	r3, [r1, #20]
  }

  return status;
200055ce:	7bfb      	ldrb	r3, [r7, #15]
}
200055d0:	4618      	mov	r0, r3
200055d2:	3710      	adds	r7, #16
200055d4:	46bd      	mov	sp, r7
200055d6:	bd80      	pop	{r7, pc}
200055d8:	40023c00 	.word	0x40023c00

200055dc <FLASH_OB_RDP_LevelConfig>:
  * @note WARNING: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  *    
  * @retval HAL Status
  */
static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t Level)
{
200055dc:	b580      	push	{r7, lr}
200055de:	b084      	sub	sp, #16
200055e0:	af00      	add	r7, sp, #0
200055e2:	4603      	mov	r3, r0
200055e4:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status = HAL_OK;
200055e6:	2300      	movs	r3, #0
200055e8:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(Level));
    
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200055ea:	f24c 3050 	movw	r0, #50000	; 0xc350
200055ee:	f7ff fc25 	bl	20004e3c <FLASH_WaitForLastOperation>
200055f2:	4603      	mov	r3, r0
200055f4:	73fb      	strb	r3, [r7, #15]

  if(status == HAL_OK)
200055f6:	7bfb      	ldrb	r3, [r7, #15]
200055f8:	2b00      	cmp	r3, #0
200055fa:	d102      	bne.n	20005602 <FLASH_OB_RDP_LevelConfig+0x26>
  { 
    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = Level;
200055fc:	4a03      	ldr	r2, [pc, #12]	; (2000560c <FLASH_OB_RDP_LevelConfig+0x30>)
200055fe:	79fb      	ldrb	r3, [r7, #7]
20005600:	7013      	strb	r3, [r2, #0]
  }
  
  return status;
20005602:	7bfb      	ldrb	r3, [r7, #15]
}
20005604:	4618      	mov	r0, r3
20005606:	3710      	adds	r7, #16
20005608:	46bd      	mov	sp, r7
2000560a:	bd80      	pop	{r7, pc}
2000560c:	40023c15 	.word	0x40023c15

20005610 <FLASH_OB_BOR_LevelConfig>:
  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
  * @retval HAL Status
  */
static HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)
{
20005610:	b480      	push	{r7}
20005612:	b083      	sub	sp, #12
20005614:	af00      	add	r7, sp, #0
20005616:	4603      	mov	r3, r0
20005618:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Set the BOR Level */
  MODIFY_REG(FLASH->OPTCR, FLASH_OPTCR_BOR_LEV, Level);
2000561a:	4b07      	ldr	r3, [pc, #28]	; (20005638 <FLASH_OB_BOR_LevelConfig+0x28>)
2000561c:	695b      	ldr	r3, [r3, #20]
2000561e:	f023 020c 	bic.w	r2, r3, #12
20005622:	79fb      	ldrb	r3, [r7, #7]
20005624:	4904      	ldr	r1, [pc, #16]	; (20005638 <FLASH_OB_BOR_LevelConfig+0x28>)
20005626:	4313      	orrs	r3, r2
20005628:	614b      	str	r3, [r1, #20]
  
  return HAL_OK;
2000562a:	2300      	movs	r3, #0
  
}
2000562c:	4618      	mov	r0, r3
2000562e:	370c      	adds	r7, #12
20005630:	46bd      	mov	sp, r7
20005632:	f85d 7b04 	ldr.w	r7, [sp], #4
20005636:	4770      	bx	lr
20005638:	40023c00 	.word	0x40023c00

2000563c <FLASH_OB_BootAddressConfig>:
  *            @arg OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000)              
  *    
  * @retval HAL Status
  */
static HAL_StatusTypeDef FLASH_OB_BootAddressConfig(uint32_t BootOption, uint32_t Address)
{
2000563c:	b580      	push	{r7, lr}
2000563e:	b084      	sub	sp, #16
20005640:	af00      	add	r7, sp, #0
20005642:	6078      	str	r0, [r7, #4]
20005644:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20005646:	2300      	movs	r3, #0
20005648:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADDRESS(Address));
    
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2000564a:	f24c 3050 	movw	r0, #50000	; 0xc350
2000564e:	f7ff fbf5 	bl	20004e3c <FLASH_WaitForLastOperation>
20005652:	4603      	mov	r3, r0
20005654:	73fb      	strb	r3, [r7, #15]
  
  if(status == HAL_OK)
20005656:	7bfb      	ldrb	r3, [r7, #15]
20005658:	2b00      	cmp	r3, #0
2000565a:	d113      	bne.n	20005684 <FLASH_OB_BootAddressConfig+0x48>
  {
    if(BootOption == OPTIONBYTE_BOOTADDR_0)
2000565c:	687b      	ldr	r3, [r7, #4]
2000565e:	2b10      	cmp	r3, #16
20005660:	d108      	bne.n	20005674 <FLASH_OB_BootAddressConfig+0x38>
    {			
      MODIFY_REG(FLASH->OPTCR1, FLASH_OPTCR1_BOOT_ADD0, Address);
20005662:	4b0b      	ldr	r3, [pc, #44]	; (20005690 <FLASH_OB_BootAddressConfig+0x54>)
20005664:	699a      	ldr	r2, [r3, #24]
20005666:	4b0b      	ldr	r3, [pc, #44]	; (20005694 <FLASH_OB_BootAddressConfig+0x58>)
20005668:	4013      	ands	r3, r2
2000566a:	4909      	ldr	r1, [pc, #36]	; (20005690 <FLASH_OB_BootAddressConfig+0x54>)
2000566c:	683a      	ldr	r2, [r7, #0]
2000566e:	4313      	orrs	r3, r2
20005670:	618b      	str	r3, [r1, #24]
20005672:	e007      	b.n	20005684 <FLASH_OB_BootAddressConfig+0x48>
    }
    else
    {
      MODIFY_REG(FLASH->OPTCR1, FLASH_OPTCR1_BOOT_ADD1, (Address << 16));
20005674:	4b06      	ldr	r3, [pc, #24]	; (20005690 <FLASH_OB_BootAddressConfig+0x54>)
20005676:	699b      	ldr	r3, [r3, #24]
20005678:	b29a      	uxth	r2, r3
2000567a:	683b      	ldr	r3, [r7, #0]
2000567c:	041b      	lsls	r3, r3, #16
2000567e:	4904      	ldr	r1, [pc, #16]	; (20005690 <FLASH_OB_BootAddressConfig+0x54>)
20005680:	4313      	orrs	r3, r2
20005682:	618b      	str	r3, [r1, #24]
    }
  }
  
  return status;
20005684:	7bfb      	ldrb	r3, [r7, #15]
}
20005686:	4618      	mov	r0, r3
20005688:	3710      	adds	r7, #16
2000568a:	46bd      	mov	sp, r7
2000568c:	bd80      	pop	{r7, pc}
2000568e:	bf00      	nop
20005690:	40023c00 	.word	0x40023c00
20005694:	ffff0000 	.word	0xffff0000

20005698 <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint8_t FLASH_OB_GetRDP(void)
{
20005698:	b480      	push	{r7}
2000569a:	b083      	sub	sp, #12
2000569c:	af00      	add	r7, sp, #0
  uint8_t readstatus = OB_RDP_LEVEL_0;
2000569e:	23aa      	movs	r3, #170	; 0xaa
200056a0:	71fb      	strb	r3, [r7, #7]
  
  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS)) == OB_RDP_LEVEL_0)
200056a2:	4b0c      	ldr	r3, [pc, #48]	; (200056d4 <FLASH_OB_GetRDP+0x3c>)
200056a4:	781b      	ldrb	r3, [r3, #0]
200056a6:	b2db      	uxtb	r3, r3
200056a8:	2baa      	cmp	r3, #170	; 0xaa
200056aa:	d102      	bne.n	200056b2 <FLASH_OB_GetRDP+0x1a>
  {
    readstatus = OB_RDP_LEVEL_0;
200056ac:	23aa      	movs	r3, #170	; 0xaa
200056ae:	71fb      	strb	r3, [r7, #7]
200056b0:	e009      	b.n	200056c6 <FLASH_OB_GetRDP+0x2e>
  }
  else if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS)) == OB_RDP_LEVEL_2)
200056b2:	4b08      	ldr	r3, [pc, #32]	; (200056d4 <FLASH_OB_GetRDP+0x3c>)
200056b4:	781b      	ldrb	r3, [r3, #0]
200056b6:	b2db      	uxtb	r3, r3
200056b8:	2bcc      	cmp	r3, #204	; 0xcc
200056ba:	d102      	bne.n	200056c2 <FLASH_OB_GetRDP+0x2a>
  {
    readstatus = OB_RDP_LEVEL_2;
200056bc:	23cc      	movs	r3, #204	; 0xcc
200056be:	71fb      	strb	r3, [r7, #7]
200056c0:	e001      	b.n	200056c6 <FLASH_OB_GetRDP+0x2e>
  }
  else 
  {
    readstatus = OB_RDP_LEVEL_1;
200056c2:	2355      	movs	r3, #85	; 0x55
200056c4:	71fb      	strb	r3, [r7, #7]
  }

  return readstatus;
200056c6:	79fb      	ldrb	r3, [r7, #7]
}
200056c8:	4618      	mov	r0, r3
200056ca:	370c      	adds	r7, #12
200056cc:	46bd      	mov	sp, r7
200056ce:	f85d 7b04 	ldr.w	r7, [sp], #4
200056d2:	4770      	bx	lr
200056d4:	40023c15 	.word	0x40023c15

200056d8 <FLASH_OB_GetBOR>:
  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  */
static uint32_t FLASH_OB_GetBOR(void)
{
200056d8:	b480      	push	{r7}
200056da:	af00      	add	r7, sp, #0
  /* Return the FLASH BOR level */
  return ((uint32_t)(FLASH->OPTCR & 0x0C));
200056dc:	4b04      	ldr	r3, [pc, #16]	; (200056f0 <FLASH_OB_GetBOR+0x18>)
200056de:	695b      	ldr	r3, [r3, #20]
200056e0:	f003 030c 	and.w	r3, r3, #12
}
200056e4:	4618      	mov	r0, r3
200056e6:	46bd      	mov	sp, r7
200056e8:	f85d 7b04 	ldr.w	r7, [sp], #4
200056ec:	4770      	bx	lr
200056ee:	bf00      	nop
200056f0:	40023c00 	.word	0x40023c00

200056f4 <FLASH_OB_GetBootAddress>:
  *            - OB_BOOTADDR_DTCM_RAM : Boot from DTCM RAM (0x20000000)                 
  *            - OB_BOOTADDR_SRAM1 : Boot from SRAM1 (0x20010000)                    
  *            - OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000) 
  */
static uint32_t FLASH_OB_GetBootAddress(uint32_t BootOption)
{  
200056f4:	b480      	push	{r7}
200056f6:	b085      	sub	sp, #20
200056f8:	af00      	add	r7, sp, #0
200056fa:	6078      	str	r0, [r7, #4]
  uint32_t Address = 0;
200056fc:	2300      	movs	r3, #0
200056fe:	60fb      	str	r3, [r7, #12]
    
	/* Return the Boot base Address */
  if(BootOption == OPTIONBYTE_BOOTADDR_0)
20005700:	687b      	ldr	r3, [r7, #4]
20005702:	2b10      	cmp	r3, #16
20005704:	d104      	bne.n	20005710 <FLASH_OB_GetBootAddress+0x1c>
  {			
    Address = FLASH->OPTCR1 & FLASH_OPTCR1_BOOT_ADD0;
20005706:	4b08      	ldr	r3, [pc, #32]	; (20005728 <FLASH_OB_GetBootAddress+0x34>)
20005708:	699b      	ldr	r3, [r3, #24]
2000570a:	b29b      	uxth	r3, r3
2000570c:	60fb      	str	r3, [r7, #12]
2000570e:	e004      	b.n	2000571a <FLASH_OB_GetBootAddress+0x26>
	}
  else
	{
		Address = ((FLASH->OPTCR1 & FLASH_OPTCR1_BOOT_ADD1) >> 16);
20005710:	4b05      	ldr	r3, [pc, #20]	; (20005728 <FLASH_OB_GetBootAddress+0x34>)
20005712:	699b      	ldr	r3, [r3, #24]
20005714:	0c1b      	lsrs	r3, r3, #16
20005716:	b29b      	uxth	r3, r3
20005718:	60fb      	str	r3, [r7, #12]
	}

  return Address;
2000571a:	68fb      	ldr	r3, [r7, #12]
}
2000571c:	4618      	mov	r0, r3
2000571e:	3714      	adds	r7, #20
20005720:	46bd      	mov	sp, r7
20005722:	f85d 7b04 	ldr.w	r7, [sp], #4
20005726:	4770      	bx	lr
20005728:	40023c00 	.word	0x40023c00

2000572c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
2000572c:	b480      	push	{r7}
2000572e:	b089      	sub	sp, #36	; 0x24
20005730:	af00      	add	r7, sp, #0
20005732:	6078      	str	r0, [r7, #4]
20005734:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
20005736:	2300      	movs	r3, #0
20005738:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
2000573a:	2300      	movs	r3, #0
2000573c:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
2000573e:	2300      	movs	r3, #0
20005740:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
20005742:	2300      	movs	r3, #0
20005744:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
20005746:	2300      	movs	r3, #0
20005748:	61fb      	str	r3, [r7, #28]
2000574a:	e175      	b.n	20005a38 <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
2000574c:	2201      	movs	r2, #1
2000574e:	69fb      	ldr	r3, [r7, #28]
20005750:	fa02 f303 	lsl.w	r3, r2, r3
20005754:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
20005756:	683b      	ldr	r3, [r7, #0]
20005758:	681b      	ldr	r3, [r3, #0]
2000575a:	697a      	ldr	r2, [r7, #20]
2000575c:	4013      	ands	r3, r2
2000575e:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
20005760:	693a      	ldr	r2, [r7, #16]
20005762:	697b      	ldr	r3, [r7, #20]
20005764:	429a      	cmp	r2, r3
20005766:	f040 8164 	bne.w	20005a32 <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2000576a:	683b      	ldr	r3, [r7, #0]
2000576c:	685b      	ldr	r3, [r3, #4]
2000576e:	2b02      	cmp	r3, #2
20005770:	d003      	beq.n	2000577a <HAL_GPIO_Init+0x4e>
20005772:	683b      	ldr	r3, [r7, #0]
20005774:	685b      	ldr	r3, [r3, #4]
20005776:	2b12      	cmp	r3, #18
20005778:	d123      	bne.n	200057c2 <HAL_GPIO_Init+0x96>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
2000577a:	69fb      	ldr	r3, [r7, #28]
2000577c:	08da      	lsrs	r2, r3, #3
2000577e:	687b      	ldr	r3, [r7, #4]
20005780:	3208      	adds	r2, #8
20005782:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20005786:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
20005788:	69fb      	ldr	r3, [r7, #28]
2000578a:	f003 0307 	and.w	r3, r3, #7
2000578e:	009b      	lsls	r3, r3, #2
20005790:	220f      	movs	r2, #15
20005792:	fa02 f303 	lsl.w	r3, r2, r3
20005796:	43db      	mvns	r3, r3
20005798:	69ba      	ldr	r2, [r7, #24]
2000579a:	4013      	ands	r3, r2
2000579c:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
2000579e:	683b      	ldr	r3, [r7, #0]
200057a0:	691a      	ldr	r2, [r3, #16]
200057a2:	69fb      	ldr	r3, [r7, #28]
200057a4:	f003 0307 	and.w	r3, r3, #7
200057a8:	009b      	lsls	r3, r3, #2
200057aa:	fa02 f303 	lsl.w	r3, r2, r3
200057ae:	69ba      	ldr	r2, [r7, #24]
200057b0:	4313      	orrs	r3, r2
200057b2:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
200057b4:	69fb      	ldr	r3, [r7, #28]
200057b6:	08da      	lsrs	r2, r3, #3
200057b8:	687b      	ldr	r3, [r7, #4]
200057ba:	3208      	adds	r2, #8
200057bc:	69b9      	ldr	r1, [r7, #24]
200057be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
200057c2:	687b      	ldr	r3, [r7, #4]
200057c4:	681b      	ldr	r3, [r3, #0]
200057c6:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
200057c8:	69fb      	ldr	r3, [r7, #28]
200057ca:	005b      	lsls	r3, r3, #1
200057cc:	2203      	movs	r2, #3
200057ce:	fa02 f303 	lsl.w	r3, r2, r3
200057d2:	43db      	mvns	r3, r3
200057d4:	69ba      	ldr	r2, [r7, #24]
200057d6:	4013      	ands	r3, r2
200057d8:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
200057da:	683b      	ldr	r3, [r7, #0]
200057dc:	685b      	ldr	r3, [r3, #4]
200057de:	f003 0203 	and.w	r2, r3, #3
200057e2:	69fb      	ldr	r3, [r7, #28]
200057e4:	005b      	lsls	r3, r3, #1
200057e6:	fa02 f303 	lsl.w	r3, r2, r3
200057ea:	69ba      	ldr	r2, [r7, #24]
200057ec:	4313      	orrs	r3, r2
200057ee:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
200057f0:	687b      	ldr	r3, [r7, #4]
200057f2:	69ba      	ldr	r2, [r7, #24]
200057f4:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
200057f6:	683b      	ldr	r3, [r7, #0]
200057f8:	685b      	ldr	r3, [r3, #4]
200057fa:	2b01      	cmp	r3, #1
200057fc:	d00b      	beq.n	20005816 <HAL_GPIO_Init+0xea>
200057fe:	683b      	ldr	r3, [r7, #0]
20005800:	685b      	ldr	r3, [r3, #4]
20005802:	2b02      	cmp	r3, #2
20005804:	d007      	beq.n	20005816 <HAL_GPIO_Init+0xea>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
20005806:	683b      	ldr	r3, [r7, #0]
20005808:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
2000580a:	2b11      	cmp	r3, #17
2000580c:	d003      	beq.n	20005816 <HAL_GPIO_Init+0xea>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2000580e:	683b      	ldr	r3, [r7, #0]
20005810:	685b      	ldr	r3, [r3, #4]
20005812:	2b12      	cmp	r3, #18
20005814:	d130      	bne.n	20005878 <HAL_GPIO_Init+0x14c>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
20005816:	687b      	ldr	r3, [r7, #4]
20005818:	689b      	ldr	r3, [r3, #8]
2000581a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
2000581c:	69fb      	ldr	r3, [r7, #28]
2000581e:	005b      	lsls	r3, r3, #1
20005820:	2203      	movs	r2, #3
20005822:	fa02 f303 	lsl.w	r3, r2, r3
20005826:	43db      	mvns	r3, r3
20005828:	69ba      	ldr	r2, [r7, #24]
2000582a:	4013      	ands	r3, r2
2000582c:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
2000582e:	683b      	ldr	r3, [r7, #0]
20005830:	68da      	ldr	r2, [r3, #12]
20005832:	69fb      	ldr	r3, [r7, #28]
20005834:	005b      	lsls	r3, r3, #1
20005836:	fa02 f303 	lsl.w	r3, r2, r3
2000583a:	69ba      	ldr	r2, [r7, #24]
2000583c:	4313      	orrs	r3, r2
2000583e:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
20005840:	687b      	ldr	r3, [r7, #4]
20005842:	69ba      	ldr	r2, [r7, #24]
20005844:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
20005846:	687b      	ldr	r3, [r7, #4]
20005848:	685b      	ldr	r3, [r3, #4]
2000584a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
2000584c:	2201      	movs	r2, #1
2000584e:	69fb      	ldr	r3, [r7, #28]
20005850:	fa02 f303 	lsl.w	r3, r2, r3
20005854:	43db      	mvns	r3, r3
20005856:	69ba      	ldr	r2, [r7, #24]
20005858:	4013      	ands	r3, r2
2000585a:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
2000585c:	683b      	ldr	r3, [r7, #0]
2000585e:	685b      	ldr	r3, [r3, #4]
20005860:	091b      	lsrs	r3, r3, #4
20005862:	f003 0201 	and.w	r2, r3, #1
20005866:	69fb      	ldr	r3, [r7, #28]
20005868:	fa02 f303 	lsl.w	r3, r2, r3
2000586c:	69ba      	ldr	r2, [r7, #24]
2000586e:	4313      	orrs	r3, r2
20005870:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
20005872:	687b      	ldr	r3, [r7, #4]
20005874:	69ba      	ldr	r2, [r7, #24]
20005876:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
20005878:	687b      	ldr	r3, [r7, #4]
2000587a:	68db      	ldr	r3, [r3, #12]
2000587c:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
2000587e:	69fb      	ldr	r3, [r7, #28]
20005880:	005b      	lsls	r3, r3, #1
20005882:	2203      	movs	r2, #3
20005884:	fa02 f303 	lsl.w	r3, r2, r3
20005888:	43db      	mvns	r3, r3
2000588a:	69ba      	ldr	r2, [r7, #24]
2000588c:	4013      	ands	r3, r2
2000588e:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
20005890:	683b      	ldr	r3, [r7, #0]
20005892:	689a      	ldr	r2, [r3, #8]
20005894:	69fb      	ldr	r3, [r7, #28]
20005896:	005b      	lsls	r3, r3, #1
20005898:	fa02 f303 	lsl.w	r3, r2, r3
2000589c:	69ba      	ldr	r2, [r7, #24]
2000589e:	4313      	orrs	r3, r2
200058a0:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
200058a2:	687b      	ldr	r3, [r7, #4]
200058a4:	69ba      	ldr	r2, [r7, #24]
200058a6:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
200058a8:	683b      	ldr	r3, [r7, #0]
200058aa:	685b      	ldr	r3, [r3, #4]
200058ac:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
200058b0:	2b00      	cmp	r3, #0
200058b2:	f000 80be 	beq.w	20005a32 <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
200058b6:	4b65      	ldr	r3, [pc, #404]	; (20005a4c <HAL_GPIO_Init+0x320>)
200058b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200058ba:	4a64      	ldr	r2, [pc, #400]	; (20005a4c <HAL_GPIO_Init+0x320>)
200058bc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
200058c0:	6453      	str	r3, [r2, #68]	; 0x44
200058c2:	4b62      	ldr	r3, [pc, #392]	; (20005a4c <HAL_GPIO_Init+0x320>)
200058c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200058c6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
200058ca:	60fb      	str	r3, [r7, #12]
200058cc:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
200058ce:	4a60      	ldr	r2, [pc, #384]	; (20005a50 <HAL_GPIO_Init+0x324>)
200058d0:	69fb      	ldr	r3, [r7, #28]
200058d2:	089b      	lsrs	r3, r3, #2
200058d4:	3302      	adds	r3, #2
200058d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200058da:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
200058dc:	69fb      	ldr	r3, [r7, #28]
200058de:	f003 0303 	and.w	r3, r3, #3
200058e2:	009b      	lsls	r3, r3, #2
200058e4:	220f      	movs	r2, #15
200058e6:	fa02 f303 	lsl.w	r3, r2, r3
200058ea:	43db      	mvns	r3, r3
200058ec:	69ba      	ldr	r2, [r7, #24]
200058ee:	4013      	ands	r3, r2
200058f0:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
200058f2:	687b      	ldr	r3, [r7, #4]
200058f4:	4a57      	ldr	r2, [pc, #348]	; (20005a54 <HAL_GPIO_Init+0x328>)
200058f6:	4293      	cmp	r3, r2
200058f8:	d037      	beq.n	2000596a <HAL_GPIO_Init+0x23e>
200058fa:	687b      	ldr	r3, [r7, #4]
200058fc:	4a56      	ldr	r2, [pc, #344]	; (20005a58 <HAL_GPIO_Init+0x32c>)
200058fe:	4293      	cmp	r3, r2
20005900:	d031      	beq.n	20005966 <HAL_GPIO_Init+0x23a>
20005902:	687b      	ldr	r3, [r7, #4]
20005904:	4a55      	ldr	r2, [pc, #340]	; (20005a5c <HAL_GPIO_Init+0x330>)
20005906:	4293      	cmp	r3, r2
20005908:	d02b      	beq.n	20005962 <HAL_GPIO_Init+0x236>
2000590a:	687b      	ldr	r3, [r7, #4]
2000590c:	4a54      	ldr	r2, [pc, #336]	; (20005a60 <HAL_GPIO_Init+0x334>)
2000590e:	4293      	cmp	r3, r2
20005910:	d025      	beq.n	2000595e <HAL_GPIO_Init+0x232>
20005912:	687b      	ldr	r3, [r7, #4]
20005914:	4a53      	ldr	r2, [pc, #332]	; (20005a64 <HAL_GPIO_Init+0x338>)
20005916:	4293      	cmp	r3, r2
20005918:	d01f      	beq.n	2000595a <HAL_GPIO_Init+0x22e>
2000591a:	687b      	ldr	r3, [r7, #4]
2000591c:	4a52      	ldr	r2, [pc, #328]	; (20005a68 <HAL_GPIO_Init+0x33c>)
2000591e:	4293      	cmp	r3, r2
20005920:	d019      	beq.n	20005956 <HAL_GPIO_Init+0x22a>
20005922:	687b      	ldr	r3, [r7, #4]
20005924:	4a51      	ldr	r2, [pc, #324]	; (20005a6c <HAL_GPIO_Init+0x340>)
20005926:	4293      	cmp	r3, r2
20005928:	d013      	beq.n	20005952 <HAL_GPIO_Init+0x226>
2000592a:	687b      	ldr	r3, [r7, #4]
2000592c:	4a50      	ldr	r2, [pc, #320]	; (20005a70 <HAL_GPIO_Init+0x344>)
2000592e:	4293      	cmp	r3, r2
20005930:	d00d      	beq.n	2000594e <HAL_GPIO_Init+0x222>
20005932:	687b      	ldr	r3, [r7, #4]
20005934:	4a4f      	ldr	r2, [pc, #316]	; (20005a74 <HAL_GPIO_Init+0x348>)
20005936:	4293      	cmp	r3, r2
20005938:	d007      	beq.n	2000594a <HAL_GPIO_Init+0x21e>
2000593a:	687b      	ldr	r3, [r7, #4]
2000593c:	4a4e      	ldr	r2, [pc, #312]	; (20005a78 <HAL_GPIO_Init+0x34c>)
2000593e:	4293      	cmp	r3, r2
20005940:	d101      	bne.n	20005946 <HAL_GPIO_Init+0x21a>
20005942:	2309      	movs	r3, #9
20005944:	e012      	b.n	2000596c <HAL_GPIO_Init+0x240>
20005946:	230a      	movs	r3, #10
20005948:	e010      	b.n	2000596c <HAL_GPIO_Init+0x240>
2000594a:	2308      	movs	r3, #8
2000594c:	e00e      	b.n	2000596c <HAL_GPIO_Init+0x240>
2000594e:	2307      	movs	r3, #7
20005950:	e00c      	b.n	2000596c <HAL_GPIO_Init+0x240>
20005952:	2306      	movs	r3, #6
20005954:	e00a      	b.n	2000596c <HAL_GPIO_Init+0x240>
20005956:	2305      	movs	r3, #5
20005958:	e008      	b.n	2000596c <HAL_GPIO_Init+0x240>
2000595a:	2304      	movs	r3, #4
2000595c:	e006      	b.n	2000596c <HAL_GPIO_Init+0x240>
2000595e:	2303      	movs	r3, #3
20005960:	e004      	b.n	2000596c <HAL_GPIO_Init+0x240>
20005962:	2302      	movs	r3, #2
20005964:	e002      	b.n	2000596c <HAL_GPIO_Init+0x240>
20005966:	2301      	movs	r3, #1
20005968:	e000      	b.n	2000596c <HAL_GPIO_Init+0x240>
2000596a:	2300      	movs	r3, #0
2000596c:	69fa      	ldr	r2, [r7, #28]
2000596e:	f002 0203 	and.w	r2, r2, #3
20005972:	0092      	lsls	r2, r2, #2
20005974:	4093      	lsls	r3, r2
20005976:	69ba      	ldr	r2, [r7, #24]
20005978:	4313      	orrs	r3, r2
2000597a:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
2000597c:	4934      	ldr	r1, [pc, #208]	; (20005a50 <HAL_GPIO_Init+0x324>)
2000597e:	69fb      	ldr	r3, [r7, #28]
20005980:	089b      	lsrs	r3, r3, #2
20005982:	3302      	adds	r3, #2
20005984:	69ba      	ldr	r2, [r7, #24]
20005986:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
2000598a:	4b3c      	ldr	r3, [pc, #240]	; (20005a7c <HAL_GPIO_Init+0x350>)
2000598c:	681b      	ldr	r3, [r3, #0]
2000598e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
20005990:	693b      	ldr	r3, [r7, #16]
20005992:	43db      	mvns	r3, r3
20005994:	69ba      	ldr	r2, [r7, #24]
20005996:	4013      	ands	r3, r2
20005998:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
2000599a:	683b      	ldr	r3, [r7, #0]
2000599c:	685b      	ldr	r3, [r3, #4]
2000599e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
200059a2:	2b00      	cmp	r3, #0
200059a4:	d003      	beq.n	200059ae <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
200059a6:	69ba      	ldr	r2, [r7, #24]
200059a8:	693b      	ldr	r3, [r7, #16]
200059aa:	4313      	orrs	r3, r2
200059ac:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
200059ae:	4a33      	ldr	r2, [pc, #204]	; (20005a7c <HAL_GPIO_Init+0x350>)
200059b0:	69bb      	ldr	r3, [r7, #24]
200059b2:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
200059b4:	4b31      	ldr	r3, [pc, #196]	; (20005a7c <HAL_GPIO_Init+0x350>)
200059b6:	685b      	ldr	r3, [r3, #4]
200059b8:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
200059ba:	693b      	ldr	r3, [r7, #16]
200059bc:	43db      	mvns	r3, r3
200059be:	69ba      	ldr	r2, [r7, #24]
200059c0:	4013      	ands	r3, r2
200059c2:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
200059c4:	683b      	ldr	r3, [r7, #0]
200059c6:	685b      	ldr	r3, [r3, #4]
200059c8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
200059cc:	2b00      	cmp	r3, #0
200059ce:	d003      	beq.n	200059d8 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
200059d0:	69ba      	ldr	r2, [r7, #24]
200059d2:	693b      	ldr	r3, [r7, #16]
200059d4:	4313      	orrs	r3, r2
200059d6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
200059d8:	4a28      	ldr	r2, [pc, #160]	; (20005a7c <HAL_GPIO_Init+0x350>)
200059da:	69bb      	ldr	r3, [r7, #24]
200059dc:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
200059de:	4b27      	ldr	r3, [pc, #156]	; (20005a7c <HAL_GPIO_Init+0x350>)
200059e0:	689b      	ldr	r3, [r3, #8]
200059e2:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
200059e4:	693b      	ldr	r3, [r7, #16]
200059e6:	43db      	mvns	r3, r3
200059e8:	69ba      	ldr	r2, [r7, #24]
200059ea:	4013      	ands	r3, r2
200059ec:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
200059ee:	683b      	ldr	r3, [r7, #0]
200059f0:	685b      	ldr	r3, [r3, #4]
200059f2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
200059f6:	2b00      	cmp	r3, #0
200059f8:	d003      	beq.n	20005a02 <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
200059fa:	69ba      	ldr	r2, [r7, #24]
200059fc:	693b      	ldr	r3, [r7, #16]
200059fe:	4313      	orrs	r3, r2
20005a00:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
20005a02:	4a1e      	ldr	r2, [pc, #120]	; (20005a7c <HAL_GPIO_Init+0x350>)
20005a04:	69bb      	ldr	r3, [r7, #24]
20005a06:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
20005a08:	4b1c      	ldr	r3, [pc, #112]	; (20005a7c <HAL_GPIO_Init+0x350>)
20005a0a:	68db      	ldr	r3, [r3, #12]
20005a0c:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
20005a0e:	693b      	ldr	r3, [r7, #16]
20005a10:	43db      	mvns	r3, r3
20005a12:	69ba      	ldr	r2, [r7, #24]
20005a14:	4013      	ands	r3, r2
20005a16:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
20005a18:	683b      	ldr	r3, [r7, #0]
20005a1a:	685b      	ldr	r3, [r3, #4]
20005a1c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
20005a20:	2b00      	cmp	r3, #0
20005a22:	d003      	beq.n	20005a2c <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
20005a24:	69ba      	ldr	r2, [r7, #24]
20005a26:	693b      	ldr	r3, [r7, #16]
20005a28:	4313      	orrs	r3, r2
20005a2a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
20005a2c:	4a13      	ldr	r2, [pc, #76]	; (20005a7c <HAL_GPIO_Init+0x350>)
20005a2e:	69bb      	ldr	r3, [r7, #24]
20005a30:	60d3      	str	r3, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
20005a32:	69fb      	ldr	r3, [r7, #28]
20005a34:	3301      	adds	r3, #1
20005a36:	61fb      	str	r3, [r7, #28]
20005a38:	69fb      	ldr	r3, [r7, #28]
20005a3a:	2b0f      	cmp	r3, #15
20005a3c:	f67f ae86 	bls.w	2000574c <HAL_GPIO_Init+0x20>
      }
    }
  }
}
20005a40:	bf00      	nop
20005a42:	3724      	adds	r7, #36	; 0x24
20005a44:	46bd      	mov	sp, r7
20005a46:	f85d 7b04 	ldr.w	r7, [sp], #4
20005a4a:	4770      	bx	lr
20005a4c:	40023800 	.word	0x40023800
20005a50:	40013800 	.word	0x40013800
20005a54:	40020000 	.word	0x40020000
20005a58:	40020400 	.word	0x40020400
20005a5c:	40020800 	.word	0x40020800
20005a60:	40020c00 	.word	0x40020c00
20005a64:	40021000 	.word	0x40021000
20005a68:	40021400 	.word	0x40021400
20005a6c:	40021800 	.word	0x40021800
20005a70:	40021c00 	.word	0x40021c00
20005a74:	40022000 	.word	0x40022000
20005a78:	40022400 	.word	0x40022400
20005a7c:	40013c00 	.word	0x40013c00

20005a80 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
20005a80:	b480      	push	{r7}
20005a82:	b087      	sub	sp, #28
20005a84:	af00      	add	r7, sp, #0
20005a86:	6078      	str	r0, [r7, #4]
20005a88:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00;
20005a8a:	2300      	movs	r3, #0
20005a8c:	613b      	str	r3, [r7, #16]
  uint32_t iocurrent = 0x00;
20005a8e:	2300      	movs	r3, #0
20005a90:	60fb      	str	r3, [r7, #12]
  uint32_t tmp = 0x00;
20005a92:	2300      	movs	r3, #0
20005a94:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
20005a96:	2300      	movs	r3, #0
20005a98:	617b      	str	r3, [r7, #20]
20005a9a:	e0d9      	b.n	20005c50 <HAL_GPIO_DeInit+0x1d0>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
20005a9c:	2201      	movs	r2, #1
20005a9e:	697b      	ldr	r3, [r7, #20]
20005aa0:	fa02 f303 	lsl.w	r3, r2, r3
20005aa4:	613b      	str	r3, [r7, #16]
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;
20005aa6:	683a      	ldr	r2, [r7, #0]
20005aa8:	693b      	ldr	r3, [r7, #16]
20005aaa:	4013      	ands	r3, r2
20005aac:	60fb      	str	r3, [r7, #12]

    if(iocurrent == ioposition)
20005aae:	68fa      	ldr	r2, [r7, #12]
20005ab0:	693b      	ldr	r3, [r7, #16]
20005ab2:	429a      	cmp	r2, r3
20005ab4:	f040 80c9 	bne.w	20005c4a <HAL_GPIO_DeInit+0x1ca>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2];
20005ab8:	4a6a      	ldr	r2, [pc, #424]	; (20005c64 <HAL_GPIO_DeInit+0x1e4>)
20005aba:	697b      	ldr	r3, [r7, #20]
20005abc:	089b      	lsrs	r3, r3, #2
20005abe:	3302      	adds	r3, #2
20005ac0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20005ac4:	60bb      	str	r3, [r7, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
20005ac6:	697b      	ldr	r3, [r7, #20]
20005ac8:	f003 0303 	and.w	r3, r3, #3
20005acc:	009b      	lsls	r3, r3, #2
20005ace:	220f      	movs	r2, #15
20005ad0:	fa02 f303 	lsl.w	r3, r2, r3
20005ad4:	68ba      	ldr	r2, [r7, #8]
20005ad6:	4013      	ands	r3, r2
20005ad8:	60bb      	str	r3, [r7, #8]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
20005ada:	687b      	ldr	r3, [r7, #4]
20005adc:	4a62      	ldr	r2, [pc, #392]	; (20005c68 <HAL_GPIO_DeInit+0x1e8>)
20005ade:	4293      	cmp	r3, r2
20005ae0:	d037      	beq.n	20005b52 <HAL_GPIO_DeInit+0xd2>
20005ae2:	687b      	ldr	r3, [r7, #4]
20005ae4:	4a61      	ldr	r2, [pc, #388]	; (20005c6c <HAL_GPIO_DeInit+0x1ec>)
20005ae6:	4293      	cmp	r3, r2
20005ae8:	d031      	beq.n	20005b4e <HAL_GPIO_DeInit+0xce>
20005aea:	687b      	ldr	r3, [r7, #4]
20005aec:	4a60      	ldr	r2, [pc, #384]	; (20005c70 <HAL_GPIO_DeInit+0x1f0>)
20005aee:	4293      	cmp	r3, r2
20005af0:	d02b      	beq.n	20005b4a <HAL_GPIO_DeInit+0xca>
20005af2:	687b      	ldr	r3, [r7, #4]
20005af4:	4a5f      	ldr	r2, [pc, #380]	; (20005c74 <HAL_GPIO_DeInit+0x1f4>)
20005af6:	4293      	cmp	r3, r2
20005af8:	d025      	beq.n	20005b46 <HAL_GPIO_DeInit+0xc6>
20005afa:	687b      	ldr	r3, [r7, #4]
20005afc:	4a5e      	ldr	r2, [pc, #376]	; (20005c78 <HAL_GPIO_DeInit+0x1f8>)
20005afe:	4293      	cmp	r3, r2
20005b00:	d01f      	beq.n	20005b42 <HAL_GPIO_DeInit+0xc2>
20005b02:	687b      	ldr	r3, [r7, #4]
20005b04:	4a5d      	ldr	r2, [pc, #372]	; (20005c7c <HAL_GPIO_DeInit+0x1fc>)
20005b06:	4293      	cmp	r3, r2
20005b08:	d019      	beq.n	20005b3e <HAL_GPIO_DeInit+0xbe>
20005b0a:	687b      	ldr	r3, [r7, #4]
20005b0c:	4a5c      	ldr	r2, [pc, #368]	; (20005c80 <HAL_GPIO_DeInit+0x200>)
20005b0e:	4293      	cmp	r3, r2
20005b10:	d013      	beq.n	20005b3a <HAL_GPIO_DeInit+0xba>
20005b12:	687b      	ldr	r3, [r7, #4]
20005b14:	4a5b      	ldr	r2, [pc, #364]	; (20005c84 <HAL_GPIO_DeInit+0x204>)
20005b16:	4293      	cmp	r3, r2
20005b18:	d00d      	beq.n	20005b36 <HAL_GPIO_DeInit+0xb6>
20005b1a:	687b      	ldr	r3, [r7, #4]
20005b1c:	4a5a      	ldr	r2, [pc, #360]	; (20005c88 <HAL_GPIO_DeInit+0x208>)
20005b1e:	4293      	cmp	r3, r2
20005b20:	d007      	beq.n	20005b32 <HAL_GPIO_DeInit+0xb2>
20005b22:	687b      	ldr	r3, [r7, #4]
20005b24:	4a59      	ldr	r2, [pc, #356]	; (20005c8c <HAL_GPIO_DeInit+0x20c>)
20005b26:	4293      	cmp	r3, r2
20005b28:	d101      	bne.n	20005b2e <HAL_GPIO_DeInit+0xae>
20005b2a:	2309      	movs	r3, #9
20005b2c:	e012      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b2e:	230a      	movs	r3, #10
20005b30:	e010      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b32:	2308      	movs	r3, #8
20005b34:	e00e      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b36:	2307      	movs	r3, #7
20005b38:	e00c      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b3a:	2306      	movs	r3, #6
20005b3c:	e00a      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b3e:	2305      	movs	r3, #5
20005b40:	e008      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b42:	2304      	movs	r3, #4
20005b44:	e006      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b46:	2303      	movs	r3, #3
20005b48:	e004      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b4a:	2302      	movs	r3, #2
20005b4c:	e002      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b4e:	2301      	movs	r3, #1
20005b50:	e000      	b.n	20005b54 <HAL_GPIO_DeInit+0xd4>
20005b52:	2300      	movs	r3, #0
20005b54:	697a      	ldr	r2, [r7, #20]
20005b56:	f002 0203 	and.w	r2, r2, #3
20005b5a:	0092      	lsls	r2, r2, #2
20005b5c:	4093      	lsls	r3, r2
20005b5e:	68ba      	ldr	r2, [r7, #8]
20005b60:	429a      	cmp	r2, r3
20005b62:	d132      	bne.n	20005bca <HAL_GPIO_DeInit+0x14a>
      {
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
20005b64:	697b      	ldr	r3, [r7, #20]
20005b66:	f003 0303 	and.w	r3, r3, #3
20005b6a:	009b      	lsls	r3, r3, #2
20005b6c:	220f      	movs	r2, #15
20005b6e:	fa02 f303 	lsl.w	r3, r2, r3
20005b72:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
20005b74:	4a3b      	ldr	r2, [pc, #236]	; (20005c64 <HAL_GPIO_DeInit+0x1e4>)
20005b76:	697b      	ldr	r3, [r7, #20]
20005b78:	089b      	lsrs	r3, r3, #2
20005b7a:	3302      	adds	r3, #2
20005b7c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
20005b80:	68bb      	ldr	r3, [r7, #8]
20005b82:	43da      	mvns	r2, r3
20005b84:	4837      	ldr	r0, [pc, #220]	; (20005c64 <HAL_GPIO_DeInit+0x1e4>)
20005b86:	697b      	ldr	r3, [r7, #20]
20005b88:	089b      	lsrs	r3, r3, #2
20005b8a:	400a      	ands	r2, r1
20005b8c:	3302      	adds	r3, #2
20005b8e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
20005b92:	4b3f      	ldr	r3, [pc, #252]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005b94:	681a      	ldr	r2, [r3, #0]
20005b96:	68fb      	ldr	r3, [r7, #12]
20005b98:	43db      	mvns	r3, r3
20005b9a:	493d      	ldr	r1, [pc, #244]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005b9c:	4013      	ands	r3, r2
20005b9e:	600b      	str	r3, [r1, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
20005ba0:	4b3b      	ldr	r3, [pc, #236]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005ba2:	685a      	ldr	r2, [r3, #4]
20005ba4:	68fb      	ldr	r3, [r7, #12]
20005ba6:	43db      	mvns	r3, r3
20005ba8:	4939      	ldr	r1, [pc, #228]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005baa:	4013      	ands	r3, r2
20005bac:	604b      	str	r3, [r1, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
20005bae:	4b38      	ldr	r3, [pc, #224]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005bb0:	689a      	ldr	r2, [r3, #8]
20005bb2:	68fb      	ldr	r3, [r7, #12]
20005bb4:	43db      	mvns	r3, r3
20005bb6:	4936      	ldr	r1, [pc, #216]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005bb8:	4013      	ands	r3, r2
20005bba:	608b      	str	r3, [r1, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
20005bbc:	4b34      	ldr	r3, [pc, #208]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005bbe:	68da      	ldr	r2, [r3, #12]
20005bc0:	68fb      	ldr	r3, [r7, #12]
20005bc2:	43db      	mvns	r3, r3
20005bc4:	4932      	ldr	r1, [pc, #200]	; (20005c90 <HAL_GPIO_DeInit+0x210>)
20005bc6:	4013      	ands	r3, r2
20005bc8:	60cb      	str	r3, [r1, #12]
      }
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
20005bca:	687b      	ldr	r3, [r7, #4]
20005bcc:	681a      	ldr	r2, [r3, #0]
20005bce:	697b      	ldr	r3, [r7, #20]
20005bd0:	005b      	lsls	r3, r3, #1
20005bd2:	2103      	movs	r1, #3
20005bd4:	fa01 f303 	lsl.w	r3, r1, r3
20005bd8:	43db      	mvns	r3, r3
20005bda:	401a      	ands	r2, r3
20005bdc:	687b      	ldr	r3, [r7, #4]
20005bde:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
20005be0:	697b      	ldr	r3, [r7, #20]
20005be2:	08da      	lsrs	r2, r3, #3
20005be4:	687b      	ldr	r3, [r7, #4]
20005be6:	3208      	adds	r2, #8
20005be8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
20005bec:	697b      	ldr	r3, [r7, #20]
20005bee:	f003 0307 	and.w	r3, r3, #7
20005bf2:	009b      	lsls	r3, r3, #2
20005bf4:	220f      	movs	r2, #15
20005bf6:	fa02 f303 	lsl.w	r3, r2, r3
20005bfa:	43db      	mvns	r3, r3
20005bfc:	697a      	ldr	r2, [r7, #20]
20005bfe:	08d2      	lsrs	r2, r2, #3
20005c00:	4019      	ands	r1, r3
20005c02:	687b      	ldr	r3, [r7, #4]
20005c04:	3208      	adds	r2, #8
20005c06:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
20005c0a:	687b      	ldr	r3, [r7, #4]
20005c0c:	689a      	ldr	r2, [r3, #8]
20005c0e:	697b      	ldr	r3, [r7, #20]
20005c10:	005b      	lsls	r3, r3, #1
20005c12:	2103      	movs	r1, #3
20005c14:	fa01 f303 	lsl.w	r3, r1, r3
20005c18:	43db      	mvns	r3, r3
20005c1a:	401a      	ands	r2, r3
20005c1c:	687b      	ldr	r3, [r7, #4]
20005c1e:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
20005c20:	687b      	ldr	r3, [r7, #4]
20005c22:	685a      	ldr	r2, [r3, #4]
20005c24:	2101      	movs	r1, #1
20005c26:	697b      	ldr	r3, [r7, #20]
20005c28:	fa01 f303 	lsl.w	r3, r1, r3
20005c2c:	43db      	mvns	r3, r3
20005c2e:	401a      	ands	r2, r3
20005c30:	687b      	ldr	r3, [r7, #4]
20005c32:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
20005c34:	687b      	ldr	r3, [r7, #4]
20005c36:	68da      	ldr	r2, [r3, #12]
20005c38:	697b      	ldr	r3, [r7, #20]
20005c3a:	005b      	lsls	r3, r3, #1
20005c3c:	2103      	movs	r1, #3
20005c3e:	fa01 f303 	lsl.w	r3, r1, r3
20005c42:	43db      	mvns	r3, r3
20005c44:	401a      	ands	r2, r3
20005c46:	687b      	ldr	r3, [r7, #4]
20005c48:	60da      	str	r2, [r3, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
20005c4a:	697b      	ldr	r3, [r7, #20]
20005c4c:	3301      	adds	r3, #1
20005c4e:	617b      	str	r3, [r7, #20]
20005c50:	697b      	ldr	r3, [r7, #20]
20005c52:	2b0f      	cmp	r3, #15
20005c54:	f67f af22 	bls.w	20005a9c <HAL_GPIO_DeInit+0x1c>
    }
  }
}
20005c58:	bf00      	nop
20005c5a:	371c      	adds	r7, #28
20005c5c:	46bd      	mov	sp, r7
20005c5e:	f85d 7b04 	ldr.w	r7, [sp], #4
20005c62:	4770      	bx	lr
20005c64:	40013800 	.word	0x40013800
20005c68:	40020000 	.word	0x40020000
20005c6c:	40020400 	.word	0x40020400
20005c70:	40020800 	.word	0x40020800
20005c74:	40020c00 	.word	0x40020c00
20005c78:	40021000 	.word	0x40021000
20005c7c:	40021400 	.word	0x40021400
20005c80:	40021800 	.word	0x40021800
20005c84:	40021c00 	.word	0x40021c00
20005c88:	40022000 	.word	0x40022000
20005c8c:	40022400 	.word	0x40022400
20005c90:	40013c00 	.word	0x40013c00

20005c94 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
20005c94:	b480      	push	{r7}
20005c96:	b085      	sub	sp, #20
20005c98:	af00      	add	r7, sp, #0
20005c9a:	6078      	str	r0, [r7, #4]
20005c9c:	460b      	mov	r3, r1
20005c9e:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
20005ca0:	687b      	ldr	r3, [r7, #4]
20005ca2:	691a      	ldr	r2, [r3, #16]
20005ca4:	887b      	ldrh	r3, [r7, #2]
20005ca6:	4013      	ands	r3, r2
20005ca8:	2b00      	cmp	r3, #0
20005caa:	d002      	beq.n	20005cb2 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
20005cac:	2301      	movs	r3, #1
20005cae:	73fb      	strb	r3, [r7, #15]
20005cb0:	e001      	b.n	20005cb6 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
20005cb2:	2300      	movs	r3, #0
20005cb4:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
20005cb6:	7bfb      	ldrb	r3, [r7, #15]
}
20005cb8:	4618      	mov	r0, r3
20005cba:	3714      	adds	r7, #20
20005cbc:	46bd      	mov	sp, r7
20005cbe:	f85d 7b04 	ldr.w	r7, [sp], #4
20005cc2:	4770      	bx	lr

20005cc4 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
20005cc4:	b480      	push	{r7}
20005cc6:	b083      	sub	sp, #12
20005cc8:	af00      	add	r7, sp, #0
20005cca:	6078      	str	r0, [r7, #4]
20005ccc:	460b      	mov	r3, r1
20005cce:	807b      	strh	r3, [r7, #2]
20005cd0:	4613      	mov	r3, r2
20005cd2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
20005cd4:	787b      	ldrb	r3, [r7, #1]
20005cd6:	2b00      	cmp	r3, #0
20005cd8:	d003      	beq.n	20005ce2 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
20005cda:	887a      	ldrh	r2, [r7, #2]
20005cdc:	687b      	ldr	r3, [r7, #4]
20005cde:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  }
}
20005ce0:	e003      	b.n	20005cea <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
20005ce2:	887b      	ldrh	r3, [r7, #2]
20005ce4:	041a      	lsls	r2, r3, #16
20005ce6:	687b      	ldr	r3, [r7, #4]
20005ce8:	619a      	str	r2, [r3, #24]
}
20005cea:	bf00      	nop
20005cec:	370c      	adds	r7, #12
20005cee:	46bd      	mov	sp, r7
20005cf0:	f85d 7b04 	ldr.w	r7, [sp], #4
20005cf4:	4770      	bx	lr

20005cf6 <HAL_GPIO_TogglePin>:
  * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
20005cf6:	b480      	push	{r7}
20005cf8:	b083      	sub	sp, #12
20005cfa:	af00      	add	r7, sp, #0
20005cfc:	6078      	str	r0, [r7, #4]
20005cfe:	460b      	mov	r3, r1
20005d00:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
20005d02:	687b      	ldr	r3, [r7, #4]
20005d04:	695a      	ldr	r2, [r3, #20]
20005d06:	887b      	ldrh	r3, [r7, #2]
20005d08:	401a      	ands	r2, r3
20005d0a:	887b      	ldrh	r3, [r7, #2]
20005d0c:	429a      	cmp	r2, r3
20005d0e:	d104      	bne.n	20005d1a <HAL_GPIO_TogglePin+0x24>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
20005d10:	887b      	ldrh	r3, [r7, #2]
20005d12:	041a      	lsls	r2, r3, #16
20005d14:	687b      	ldr	r3, [r7, #4]
20005d16:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
  }
}
20005d18:	e002      	b.n	20005d20 <HAL_GPIO_TogglePin+0x2a>
    GPIOx->BSRR = GPIO_Pin;
20005d1a:	887a      	ldrh	r2, [r7, #2]
20005d1c:	687b      	ldr	r3, [r7, #4]
20005d1e:	619a      	str	r2, [r3, #24]
}
20005d20:	bf00      	nop
20005d22:	370c      	adds	r7, #12
20005d24:	46bd      	mov	sp, r7
20005d26:	f85d 7b04 	ldr.w	r7, [sp], #4
20005d2a:	4770      	bx	lr

20005d2c <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
20005d2c:	b480      	push	{r7}
20005d2e:	b085      	sub	sp, #20
20005d30:	af00      	add	r7, sp, #0
20005d32:	6078      	str	r0, [r7, #4]
20005d34:	460b      	mov	r3, r1
20005d36:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
20005d38:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20005d3c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
20005d3e:	887a      	ldrh	r2, [r7, #2]
20005d40:	68fb      	ldr	r3, [r7, #12]
20005d42:	4313      	orrs	r3, r2
20005d44:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
20005d46:	68fa      	ldr	r2, [r7, #12]
20005d48:	687b      	ldr	r3, [r7, #4]
20005d4a:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
20005d4c:	887a      	ldrh	r2, [r7, #2]
20005d4e:	687b      	ldr	r3, [r7, #4]
20005d50:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
20005d52:	68fa      	ldr	r2, [r7, #12]
20005d54:	687b      	ldr	r3, [r7, #4]
20005d56:	61da      	str	r2, [r3, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
20005d58:	687b      	ldr	r3, [r7, #4]
20005d5a:	69db      	ldr	r3, [r3, #28]
20005d5c:	60fb      	str	r3, [r7, #12]

 if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
20005d5e:	687b      	ldr	r3, [r7, #4]
20005d60:	69db      	ldr	r3, [r3, #28]
20005d62:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20005d66:	2b00      	cmp	r3, #0
20005d68:	d001      	beq.n	20005d6e <HAL_GPIO_LockPin+0x42>
  {
    return HAL_OK;
20005d6a:	2300      	movs	r3, #0
20005d6c:	e000      	b.n	20005d70 <HAL_GPIO_LockPin+0x44>
  }
  else
  {
    return HAL_ERROR;
20005d6e:	2301      	movs	r3, #1
  }
}
20005d70:	4618      	mov	r0, r3
20005d72:	3714      	adds	r7, #20
20005d74:	46bd      	mov	sp, r7
20005d76:	f85d 7b04 	ldr.w	r7, [sp], #4
20005d7a:	4770      	bx	lr

20005d7c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
20005d7c:	b580      	push	{r7, lr}
20005d7e:	b082      	sub	sp, #8
20005d80:	af00      	add	r7, sp, #0
20005d82:	4603      	mov	r3, r0
20005d84:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
20005d86:	4b08      	ldr	r3, [pc, #32]	; (20005da8 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
20005d88:	695a      	ldr	r2, [r3, #20]
20005d8a:	88fb      	ldrh	r3, [r7, #6]
20005d8c:	4013      	ands	r3, r2
20005d8e:	2b00      	cmp	r3, #0
20005d90:	d006      	beq.n	20005da0 <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
20005d92:	4a05      	ldr	r2, [pc, #20]	; (20005da8 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
20005d94:	88fb      	ldrh	r3, [r7, #6]
20005d96:	6153      	str	r3, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
20005d98:	88fb      	ldrh	r3, [r7, #6]
20005d9a:	4618      	mov	r0, r3
20005d9c:	f000 f806 	bl	20005dac <HAL_GPIO_EXTI_Callback>
  }
}
20005da0:	bf00      	nop
20005da2:	3708      	adds	r7, #8
20005da4:	46bd      	mov	sp, r7
20005da6:	bd80      	pop	{r7, pc}
20005da8:	40013c00 	.word	0x40013c00

20005dac <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
20005dac:	b480      	push	{r7}
20005dae:	b083      	sub	sp, #12
20005db0:	af00      	add	r7, sp, #0
20005db2:	4603      	mov	r3, r0
20005db4:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);
  
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
20005db6:	bf00      	nop
20005db8:	370c      	adds	r7, #12
20005dba:	46bd      	mov	sp, r7
20005dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
20005dc0:	4770      	bx	lr
	...

20005dc4 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
20005dc4:	b580      	push	{r7, lr}
20005dc6:	b082      	sub	sp, #8
20005dc8:	af00      	add	r7, sp, #0
20005dca:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
20005dcc:	687b      	ldr	r3, [r7, #4]
20005dce:	2b00      	cmp	r3, #0
20005dd0:	d101      	bne.n	20005dd6 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
20005dd2:	2301      	movs	r3, #1
20005dd4:	e07f      	b.n	20005ed6 <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
20005dd6:	687b      	ldr	r3, [r7, #4]
20005dd8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20005ddc:	b2db      	uxtb	r3, r3
20005dde:	2b00      	cmp	r3, #0
20005de0:	d106      	bne.n	20005df0 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
20005de2:	687b      	ldr	r3, [r7, #4]
20005de4:	2200      	movs	r2, #0
20005de6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
20005dea:	6878      	ldr	r0, [r7, #4]
20005dec:	f000 f8a9 	bl	20005f42 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
20005df0:	687b      	ldr	r3, [r7, #4]
20005df2:	2224      	movs	r2, #36	; 0x24
20005df4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
20005df8:	687b      	ldr	r3, [r7, #4]
20005dfa:	681b      	ldr	r3, [r3, #0]
20005dfc:	681a      	ldr	r2, [r3, #0]
20005dfe:	687b      	ldr	r3, [r7, #4]
20005e00:	681b      	ldr	r3, [r3, #0]
20005e02:	f022 0201 	bic.w	r2, r2, #1
20005e06:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
20005e08:	687b      	ldr	r3, [r7, #4]
20005e0a:	685a      	ldr	r2, [r3, #4]
20005e0c:	687b      	ldr	r3, [r7, #4]
20005e0e:	681b      	ldr	r3, [r3, #0]
20005e10:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
20005e14:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
20005e16:	687b      	ldr	r3, [r7, #4]
20005e18:	681b      	ldr	r3, [r3, #0]
20005e1a:	689a      	ldr	r2, [r3, #8]
20005e1c:	687b      	ldr	r3, [r7, #4]
20005e1e:	681b      	ldr	r3, [r3, #0]
20005e20:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20005e24:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
20005e26:	687b      	ldr	r3, [r7, #4]
20005e28:	68db      	ldr	r3, [r3, #12]
20005e2a:	2b01      	cmp	r3, #1
20005e2c:	d107      	bne.n	20005e3e <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
20005e2e:	687b      	ldr	r3, [r7, #4]
20005e30:	689a      	ldr	r2, [r3, #8]
20005e32:	687b      	ldr	r3, [r7, #4]
20005e34:	681b      	ldr	r3, [r3, #0]
20005e36:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20005e3a:	609a      	str	r2, [r3, #8]
20005e3c:	e006      	b.n	20005e4c <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
20005e3e:	687b      	ldr	r3, [r7, #4]
20005e40:	689a      	ldr	r2, [r3, #8]
20005e42:	687b      	ldr	r3, [r7, #4]
20005e44:	681b      	ldr	r3, [r3, #0]
20005e46:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
20005e4a:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
20005e4c:	687b      	ldr	r3, [r7, #4]
20005e4e:	68db      	ldr	r3, [r3, #12]
20005e50:	2b02      	cmp	r3, #2
20005e52:	d104      	bne.n	20005e5e <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
20005e54:	687b      	ldr	r3, [r7, #4]
20005e56:	681b      	ldr	r3, [r3, #0]
20005e58:	f44f 6200 	mov.w	r2, #2048	; 0x800
20005e5c:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
20005e5e:	687b      	ldr	r3, [r7, #4]
20005e60:	681b      	ldr	r3, [r3, #0]
20005e62:	6859      	ldr	r1, [r3, #4]
20005e64:	687b      	ldr	r3, [r7, #4]
20005e66:	681a      	ldr	r2, [r3, #0]
20005e68:	4b1d      	ldr	r3, [pc, #116]	; (20005ee0 <HAL_I2C_Init+0x11c>)
20005e6a:	430b      	orrs	r3, r1
20005e6c:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
20005e6e:	687b      	ldr	r3, [r7, #4]
20005e70:	681b      	ldr	r3, [r3, #0]
20005e72:	68da      	ldr	r2, [r3, #12]
20005e74:	687b      	ldr	r3, [r7, #4]
20005e76:	681b      	ldr	r3, [r3, #0]
20005e78:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20005e7c:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
20005e7e:	687b      	ldr	r3, [r7, #4]
20005e80:	691a      	ldr	r2, [r3, #16]
20005e82:	687b      	ldr	r3, [r7, #4]
20005e84:	695b      	ldr	r3, [r3, #20]
20005e86:	ea42 0103 	orr.w	r1, r2, r3
20005e8a:	687b      	ldr	r3, [r7, #4]
20005e8c:	699b      	ldr	r3, [r3, #24]
20005e8e:	021a      	lsls	r2, r3, #8
20005e90:	687b      	ldr	r3, [r7, #4]
20005e92:	681b      	ldr	r3, [r3, #0]
20005e94:	430a      	orrs	r2, r1
20005e96:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
20005e98:	687b      	ldr	r3, [r7, #4]
20005e9a:	69d9      	ldr	r1, [r3, #28]
20005e9c:	687b      	ldr	r3, [r7, #4]
20005e9e:	6a1a      	ldr	r2, [r3, #32]
20005ea0:	687b      	ldr	r3, [r7, #4]
20005ea2:	681b      	ldr	r3, [r3, #0]
20005ea4:	430a      	orrs	r2, r1
20005ea6:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
20005ea8:	687b      	ldr	r3, [r7, #4]
20005eaa:	681b      	ldr	r3, [r3, #0]
20005eac:	681a      	ldr	r2, [r3, #0]
20005eae:	687b      	ldr	r3, [r7, #4]
20005eb0:	681b      	ldr	r3, [r3, #0]
20005eb2:	f042 0201 	orr.w	r2, r2, #1
20005eb6:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20005eb8:	687b      	ldr	r3, [r7, #4]
20005eba:	2200      	movs	r2, #0
20005ebc:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
20005ebe:	687b      	ldr	r3, [r7, #4]
20005ec0:	2220      	movs	r2, #32
20005ec2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
20005ec6:	687b      	ldr	r3, [r7, #4]
20005ec8:	2200      	movs	r2, #0
20005eca:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
20005ecc:	687b      	ldr	r3, [r7, #4]
20005ece:	2200      	movs	r2, #0
20005ed0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
20005ed4:	2300      	movs	r3, #0
}
20005ed6:	4618      	mov	r0, r3
20005ed8:	3708      	adds	r7, #8
20005eda:	46bd      	mov	sp, r7
20005edc:	bd80      	pop	{r7, pc}
20005ede:	bf00      	nop
20005ee0:	02008000 	.word	0x02008000

20005ee4 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
20005ee4:	b580      	push	{r7, lr}
20005ee6:	b082      	sub	sp, #8
20005ee8:	af00      	add	r7, sp, #0
20005eea:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
20005eec:	687b      	ldr	r3, [r7, #4]
20005eee:	2b00      	cmp	r3, #0
20005ef0:	d101      	bne.n	20005ef6 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
20005ef2:	2301      	movs	r3, #1
20005ef4:	e021      	b.n	20005f3a <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
20005ef6:	687b      	ldr	r3, [r7, #4]
20005ef8:	2224      	movs	r2, #36	; 0x24
20005efa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
20005efe:	687b      	ldr	r3, [r7, #4]
20005f00:	681b      	ldr	r3, [r3, #0]
20005f02:	681a      	ldr	r2, [r3, #0]
20005f04:	687b      	ldr	r3, [r7, #4]
20005f06:	681b      	ldr	r3, [r3, #0]
20005f08:	f022 0201 	bic.w	r2, r2, #1
20005f0c:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
20005f0e:	6878      	ldr	r0, [r7, #4]
20005f10:	f000 f821 	bl	20005f56 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20005f14:	687b      	ldr	r3, [r7, #4]
20005f16:	2200      	movs	r2, #0
20005f18:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
20005f1a:	687b      	ldr	r3, [r7, #4]
20005f1c:	2200      	movs	r2, #0
20005f1e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
20005f22:	687b      	ldr	r3, [r7, #4]
20005f24:	2200      	movs	r2, #0
20005f26:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
20005f28:	687b      	ldr	r3, [r7, #4]
20005f2a:	2200      	movs	r2, #0
20005f2c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
20005f30:	687b      	ldr	r3, [r7, #4]
20005f32:	2200      	movs	r2, #0
20005f34:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
20005f38:	2300      	movs	r3, #0
}
20005f3a:	4618      	mov	r0, r3
20005f3c:	3708      	adds	r7, #8
20005f3e:	46bd      	mov	sp, r7
20005f40:	bd80      	pop	{r7, pc}

20005f42 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
20005f42:	b480      	push	{r7}
20005f44:	b083      	sub	sp, #12
20005f46:	af00      	add	r7, sp, #0
20005f48:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
20005f4a:	bf00      	nop
20005f4c:	370c      	adds	r7, #12
20005f4e:	46bd      	mov	sp, r7
20005f50:	f85d 7b04 	ldr.w	r7, [sp], #4
20005f54:	4770      	bx	lr

20005f56 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
20005f56:	b480      	push	{r7}
20005f58:	b083      	sub	sp, #12
20005f5a:	af00      	add	r7, sp, #0
20005f5c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
20005f5e:	bf00      	nop
20005f60:	370c      	adds	r7, #12
20005f62:	46bd      	mov	sp, r7
20005f64:	f85d 7b04 	ldr.w	r7, [sp], #4
20005f68:	4770      	bx	lr
	...

20005f6c <HAL_I2C_Master_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
20005f6c:	b580      	push	{r7, lr}
20005f6e:	b088      	sub	sp, #32
20005f70:	af02      	add	r7, sp, #8
20005f72:	60f8      	str	r0, [r7, #12]
20005f74:	607a      	str	r2, [r7, #4]
20005f76:	461a      	mov	r2, r3
20005f78:	460b      	mov	r3, r1
20005f7a:	817b      	strh	r3, [r7, #10]
20005f7c:	4613      	mov	r3, r2
20005f7e:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
20005f80:	68fb      	ldr	r3, [r7, #12]
20005f82:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20005f86:	b2db      	uxtb	r3, r3
20005f88:	2b20      	cmp	r3, #32
20005f8a:	f040 80da 	bne.w	20006142 <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20005f8e:	68fb      	ldr	r3, [r7, #12]
20005f90:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20005f94:	2b01      	cmp	r3, #1
20005f96:	d101      	bne.n	20005f9c <HAL_I2C_Master_Transmit+0x30>
20005f98:	2302      	movs	r3, #2
20005f9a:	e0d3      	b.n	20006144 <HAL_I2C_Master_Transmit+0x1d8>
20005f9c:	68fb      	ldr	r3, [r7, #12]
20005f9e:	2201      	movs	r2, #1
20005fa0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
20005fa4:	f7fb feec 	bl	20001d80 <HAL_GetTick>
20005fa8:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
20005faa:	697b      	ldr	r3, [r7, #20]
20005fac:	9300      	str	r3, [sp, #0]
20005fae:	2319      	movs	r3, #25
20005fb0:	2201      	movs	r2, #1
20005fb2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
20005fb6:	68f8      	ldr	r0, [r7, #12]
20005fb8:	f004 f8ad 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20005fbc:	4603      	mov	r3, r0
20005fbe:	2b00      	cmp	r3, #0
20005fc0:	d001      	beq.n	20005fc6 <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
20005fc2:	2301      	movs	r3, #1
20005fc4:	e0be      	b.n	20006144 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
20005fc6:	68fb      	ldr	r3, [r7, #12]
20005fc8:	2221      	movs	r2, #33	; 0x21
20005fca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
20005fce:	68fb      	ldr	r3, [r7, #12]
20005fd0:	2210      	movs	r2, #16
20005fd2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20005fd6:	68fb      	ldr	r3, [r7, #12]
20005fd8:	2200      	movs	r2, #0
20005fda:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
20005fdc:	68fb      	ldr	r3, [r7, #12]
20005fde:	687a      	ldr	r2, [r7, #4]
20005fe0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
20005fe2:	68fb      	ldr	r3, [r7, #12]
20005fe4:	893a      	ldrh	r2, [r7, #8]
20005fe6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
20005fe8:	68fb      	ldr	r3, [r7, #12]
20005fea:	2200      	movs	r2, #0
20005fec:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20005fee:	68fb      	ldr	r3, [r7, #12]
20005ff0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20005ff2:	b29b      	uxth	r3, r3
20005ff4:	2bff      	cmp	r3, #255	; 0xff
20005ff6:	d90e      	bls.n	20006016 <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20005ff8:	68fb      	ldr	r3, [r7, #12]
20005ffa:	22ff      	movs	r2, #255	; 0xff
20005ffc:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
20005ffe:	68fb      	ldr	r3, [r7, #12]
20006000:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006002:	b2da      	uxtb	r2, r3
20006004:	8979      	ldrh	r1, [r7, #10]
20006006:	4b51      	ldr	r3, [pc, #324]	; (2000614c <HAL_I2C_Master_Transmit+0x1e0>)
20006008:	9300      	str	r3, [sp, #0]
2000600a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000600e:	68f8      	ldr	r0, [r7, #12]
20006010:	f004 fa10 	bl	2000a434 <I2C_TransferConfig>
20006014:	e06c      	b.n	200060f0 <HAL_I2C_Master_Transmit+0x184>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20006016:	68fb      	ldr	r3, [r7, #12]
20006018:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000601a:	b29a      	uxth	r2, r3
2000601c:	68fb      	ldr	r3, [r7, #12]
2000601e:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
20006020:	68fb      	ldr	r3, [r7, #12]
20006022:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006024:	b2da      	uxtb	r2, r3
20006026:	8979      	ldrh	r1, [r7, #10]
20006028:	4b48      	ldr	r3, [pc, #288]	; (2000614c <HAL_I2C_Master_Transmit+0x1e0>)
2000602a:	9300      	str	r3, [sp, #0]
2000602c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20006030:	68f8      	ldr	r0, [r7, #12]
20006032:	f004 f9ff 	bl	2000a434 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
20006036:	e05b      	b.n	200060f0 <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
20006038:	697a      	ldr	r2, [r7, #20]
2000603a:	6a39      	ldr	r1, [r7, #32]
2000603c:	68f8      	ldr	r0, [r7, #12]
2000603e:	f004 f8aa 	bl	2000a196 <I2C_WaitOnTXISFlagUntilTimeout>
20006042:	4603      	mov	r3, r0
20006044:	2b00      	cmp	r3, #0
20006046:	d001      	beq.n	2000604c <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
20006048:	2301      	movs	r3, #1
2000604a:	e07b      	b.n	20006144 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2000604c:	68fb      	ldr	r3, [r7, #12]
2000604e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20006050:	781a      	ldrb	r2, [r3, #0]
20006052:	68fb      	ldr	r3, [r7, #12]
20006054:	681b      	ldr	r3, [r3, #0]
20006056:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
20006058:	68fb      	ldr	r3, [r7, #12]
2000605a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000605c:	1c5a      	adds	r2, r3, #1
2000605e:	68fb      	ldr	r3, [r7, #12]
20006060:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
20006062:	68fb      	ldr	r3, [r7, #12]
20006064:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006066:	b29b      	uxth	r3, r3
20006068:	3b01      	subs	r3, #1
2000606a:	b29a      	uxth	r2, r3
2000606c:	68fb      	ldr	r3, [r7, #12]
2000606e:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
20006070:	68fb      	ldr	r3, [r7, #12]
20006072:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006074:	3b01      	subs	r3, #1
20006076:	b29a      	uxth	r2, r3
20006078:	68fb      	ldr	r3, [r7, #12]
2000607a:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000607c:	68fb      	ldr	r3, [r7, #12]
2000607e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006080:	b29b      	uxth	r3, r3
20006082:	2b00      	cmp	r3, #0
20006084:	d034      	beq.n	200060f0 <HAL_I2C_Master_Transmit+0x184>
20006086:	68fb      	ldr	r3, [r7, #12]
20006088:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000608a:	2b00      	cmp	r3, #0
2000608c:	d130      	bne.n	200060f0 <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2000608e:	697b      	ldr	r3, [r7, #20]
20006090:	9300      	str	r3, [sp, #0]
20006092:	6a3b      	ldr	r3, [r7, #32]
20006094:	2200      	movs	r2, #0
20006096:	2180      	movs	r1, #128	; 0x80
20006098:	68f8      	ldr	r0, [r7, #12]
2000609a:	f004 f83c 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
2000609e:	4603      	mov	r3, r0
200060a0:	2b00      	cmp	r3, #0
200060a2:	d001      	beq.n	200060a8 <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
200060a4:	2301      	movs	r3, #1
200060a6:	e04d      	b.n	20006144 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
200060a8:	68fb      	ldr	r3, [r7, #12]
200060aa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200060ac:	b29b      	uxth	r3, r3
200060ae:	2bff      	cmp	r3, #255	; 0xff
200060b0:	d90e      	bls.n	200060d0 <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
200060b2:	68fb      	ldr	r3, [r7, #12]
200060b4:	22ff      	movs	r2, #255	; 0xff
200060b6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
200060b8:	68fb      	ldr	r3, [r7, #12]
200060ba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200060bc:	b2da      	uxtb	r2, r3
200060be:	8979      	ldrh	r1, [r7, #10]
200060c0:	2300      	movs	r3, #0
200060c2:	9300      	str	r3, [sp, #0]
200060c4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200060c8:	68f8      	ldr	r0, [r7, #12]
200060ca:	f004 f9b3 	bl	2000a434 <I2C_TransferConfig>
200060ce:	e00f      	b.n	200060f0 <HAL_I2C_Master_Transmit+0x184>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
200060d0:	68fb      	ldr	r3, [r7, #12]
200060d2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200060d4:	b29a      	uxth	r2, r3
200060d6:	68fb      	ldr	r3, [r7, #12]
200060d8:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
200060da:	68fb      	ldr	r3, [r7, #12]
200060dc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200060de:	b2da      	uxtb	r2, r3
200060e0:	8979      	ldrh	r1, [r7, #10]
200060e2:	2300      	movs	r3, #0
200060e4:	9300      	str	r3, [sp, #0]
200060e6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
200060ea:	68f8      	ldr	r0, [r7, #12]
200060ec:	f004 f9a2 	bl	2000a434 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
200060f0:	68fb      	ldr	r3, [r7, #12]
200060f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200060f4:	b29b      	uxth	r3, r3
200060f6:	2b00      	cmp	r3, #0
200060f8:	d19e      	bne.n	20006038 <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
200060fa:	697a      	ldr	r2, [r7, #20]
200060fc:	6a39      	ldr	r1, [r7, #32]
200060fe:	68f8      	ldr	r0, [r7, #12]
20006100:	f004 f889 	bl	2000a216 <I2C_WaitOnSTOPFlagUntilTimeout>
20006104:	4603      	mov	r3, r0
20006106:	2b00      	cmp	r3, #0
20006108:	d001      	beq.n	2000610e <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
2000610a:	2301      	movs	r3, #1
2000610c:	e01a      	b.n	20006144 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000610e:	68fb      	ldr	r3, [r7, #12]
20006110:	681b      	ldr	r3, [r3, #0]
20006112:	2220      	movs	r2, #32
20006114:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
20006116:	68fb      	ldr	r3, [r7, #12]
20006118:	681b      	ldr	r3, [r3, #0]
2000611a:	6859      	ldr	r1, [r3, #4]
2000611c:	68fb      	ldr	r3, [r7, #12]
2000611e:	681a      	ldr	r2, [r3, #0]
20006120:	4b0b      	ldr	r3, [pc, #44]	; (20006150 <HAL_I2C_Master_Transmit+0x1e4>)
20006122:	400b      	ands	r3, r1
20006124:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
20006126:	68fb      	ldr	r3, [r7, #12]
20006128:	2220      	movs	r2, #32
2000612a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000612e:	68fb      	ldr	r3, [r7, #12]
20006130:	2200      	movs	r2, #0
20006132:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20006136:	68fb      	ldr	r3, [r7, #12]
20006138:	2200      	movs	r2, #0
2000613a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000613e:	2300      	movs	r3, #0
20006140:	e000      	b.n	20006144 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
20006142:	2302      	movs	r3, #2
  }
}
20006144:	4618      	mov	r0, r3
20006146:	3718      	adds	r7, #24
20006148:	46bd      	mov	sp, r7
2000614a:	bd80      	pop	{r7, pc}
2000614c:	80002000 	.word	0x80002000
20006150:	fe00e800 	.word	0xfe00e800

20006154 <HAL_I2C_Master_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
20006154:	b580      	push	{r7, lr}
20006156:	b088      	sub	sp, #32
20006158:	af02      	add	r7, sp, #8
2000615a:	60f8      	str	r0, [r7, #12]
2000615c:	607a      	str	r2, [r7, #4]
2000615e:	461a      	mov	r2, r3
20006160:	460b      	mov	r3, r1
20006162:	817b      	strh	r3, [r7, #10]
20006164:	4613      	mov	r3, r2
20006166:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006168:	68fb      	ldr	r3, [r7, #12]
2000616a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000616e:	b2db      	uxtb	r3, r3
20006170:	2b20      	cmp	r3, #32
20006172:	f040 80db 	bne.w	2000632c <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20006176:	68fb      	ldr	r3, [r7, #12]
20006178:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000617c:	2b01      	cmp	r3, #1
2000617e:	d101      	bne.n	20006184 <HAL_I2C_Master_Receive+0x30>
20006180:	2302      	movs	r3, #2
20006182:	e0d4      	b.n	2000632e <HAL_I2C_Master_Receive+0x1da>
20006184:	68fb      	ldr	r3, [r7, #12]
20006186:	2201      	movs	r2, #1
20006188:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000618c:	f7fb fdf8 	bl	20001d80 <HAL_GetTick>
20006190:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
20006192:	697b      	ldr	r3, [r7, #20]
20006194:	9300      	str	r3, [sp, #0]
20006196:	2319      	movs	r3, #25
20006198:	2201      	movs	r2, #1
2000619a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2000619e:	68f8      	ldr	r0, [r7, #12]
200061a0:	f003 ffb9 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
200061a4:	4603      	mov	r3, r0
200061a6:	2b00      	cmp	r3, #0
200061a8:	d001      	beq.n	200061ae <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
200061aa:	2301      	movs	r3, #1
200061ac:	e0bf      	b.n	2000632e <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
200061ae:	68fb      	ldr	r3, [r7, #12]
200061b0:	2222      	movs	r2, #34	; 0x22
200061b2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
200061b6:	68fb      	ldr	r3, [r7, #12]
200061b8:	2210      	movs	r2, #16
200061ba:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
200061be:	68fb      	ldr	r3, [r7, #12]
200061c0:	2200      	movs	r2, #0
200061c2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
200061c4:	68fb      	ldr	r3, [r7, #12]
200061c6:	687a      	ldr	r2, [r7, #4]
200061c8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
200061ca:	68fb      	ldr	r3, [r7, #12]
200061cc:	893a      	ldrh	r2, [r7, #8]
200061ce:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
200061d0:	68fb      	ldr	r3, [r7, #12]
200061d2:	2200      	movs	r2, #0
200061d4:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200061d6:	68fb      	ldr	r3, [r7, #12]
200061d8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200061da:	b29b      	uxth	r3, r3
200061dc:	2bff      	cmp	r3, #255	; 0xff
200061de:	d90e      	bls.n	200061fe <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
200061e0:	68fb      	ldr	r3, [r7, #12]
200061e2:	22ff      	movs	r2, #255	; 0xff
200061e4:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
200061e6:	68fb      	ldr	r3, [r7, #12]
200061e8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200061ea:	b2da      	uxtb	r2, r3
200061ec:	8979      	ldrh	r1, [r7, #10]
200061ee:	4b52      	ldr	r3, [pc, #328]	; (20006338 <HAL_I2C_Master_Receive+0x1e4>)
200061f0:	9300      	str	r3, [sp, #0]
200061f2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200061f6:	68f8      	ldr	r0, [r7, #12]
200061f8:	f004 f91c 	bl	2000a434 <I2C_TransferConfig>
200061fc:	e06d      	b.n	200062da <HAL_I2C_Master_Receive+0x186>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
200061fe:	68fb      	ldr	r3, [r7, #12]
20006200:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006202:	b29a      	uxth	r2, r3
20006204:	68fb      	ldr	r3, [r7, #12]
20006206:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
20006208:	68fb      	ldr	r3, [r7, #12]
2000620a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000620c:	b2da      	uxtb	r2, r3
2000620e:	8979      	ldrh	r1, [r7, #10]
20006210:	4b49      	ldr	r3, [pc, #292]	; (20006338 <HAL_I2C_Master_Receive+0x1e4>)
20006212:	9300      	str	r3, [sp, #0]
20006214:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20006218:	68f8      	ldr	r0, [r7, #12]
2000621a:	f004 f90b 	bl	2000a434 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
2000621e:	e05c      	b.n	200062da <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
20006220:	697a      	ldr	r2, [r7, #20]
20006222:	6a39      	ldr	r1, [r7, #32]
20006224:	68f8      	ldr	r0, [r7, #12]
20006226:	f004 f833 	bl	2000a290 <I2C_WaitOnRXNEFlagUntilTimeout>
2000622a:	4603      	mov	r3, r0
2000622c:	2b00      	cmp	r3, #0
2000622e:	d001      	beq.n	20006234 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
20006230:	2301      	movs	r3, #1
20006232:	e07c      	b.n	2000632e <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20006234:	68fb      	ldr	r3, [r7, #12]
20006236:	681b      	ldr	r3, [r3, #0]
20006238:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000623a:	68fb      	ldr	r3, [r7, #12]
2000623c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000623e:	b2d2      	uxtb	r2, r2
20006240:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
20006242:	68fb      	ldr	r3, [r7, #12]
20006244:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20006246:	1c5a      	adds	r2, r3, #1
20006248:	68fb      	ldr	r3, [r7, #12]
2000624a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2000624c:	68fb      	ldr	r3, [r7, #12]
2000624e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006250:	3b01      	subs	r3, #1
20006252:	b29a      	uxth	r2, r3
20006254:	68fb      	ldr	r3, [r7, #12]
20006256:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
20006258:	68fb      	ldr	r3, [r7, #12]
2000625a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000625c:	b29b      	uxth	r3, r3
2000625e:	3b01      	subs	r3, #1
20006260:	b29a      	uxth	r2, r3
20006262:	68fb      	ldr	r3, [r7, #12]
20006264:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
20006266:	68fb      	ldr	r3, [r7, #12]
20006268:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000626a:	b29b      	uxth	r3, r3
2000626c:	2b00      	cmp	r3, #0
2000626e:	d034      	beq.n	200062da <HAL_I2C_Master_Receive+0x186>
20006270:	68fb      	ldr	r3, [r7, #12]
20006272:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006274:	2b00      	cmp	r3, #0
20006276:	d130      	bne.n	200062da <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
20006278:	697b      	ldr	r3, [r7, #20]
2000627a:	9300      	str	r3, [sp, #0]
2000627c:	6a3b      	ldr	r3, [r7, #32]
2000627e:	2200      	movs	r2, #0
20006280:	2180      	movs	r1, #128	; 0x80
20006282:	68f8      	ldr	r0, [r7, #12]
20006284:	f003 ff47 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20006288:	4603      	mov	r3, r0
2000628a:	2b00      	cmp	r3, #0
2000628c:	d001      	beq.n	20006292 <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
2000628e:	2301      	movs	r3, #1
20006290:	e04d      	b.n	2000632e <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
20006292:	68fb      	ldr	r3, [r7, #12]
20006294:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006296:	b29b      	uxth	r3, r3
20006298:	2bff      	cmp	r3, #255	; 0xff
2000629a:	d90e      	bls.n	200062ba <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2000629c:	68fb      	ldr	r3, [r7, #12]
2000629e:	22ff      	movs	r2, #255	; 0xff
200062a0:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
200062a2:	68fb      	ldr	r3, [r7, #12]
200062a4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200062a6:	b2da      	uxtb	r2, r3
200062a8:	8979      	ldrh	r1, [r7, #10]
200062aa:	2300      	movs	r3, #0
200062ac:	9300      	str	r3, [sp, #0]
200062ae:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200062b2:	68f8      	ldr	r0, [r7, #12]
200062b4:	f004 f8be 	bl	2000a434 <I2C_TransferConfig>
200062b8:	e00f      	b.n	200062da <HAL_I2C_Master_Receive+0x186>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
200062ba:	68fb      	ldr	r3, [r7, #12]
200062bc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200062be:	b29a      	uxth	r2, r3
200062c0:	68fb      	ldr	r3, [r7, #12]
200062c2:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
200062c4:	68fb      	ldr	r3, [r7, #12]
200062c6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200062c8:	b2da      	uxtb	r2, r3
200062ca:	8979      	ldrh	r1, [r7, #10]
200062cc:	2300      	movs	r3, #0
200062ce:	9300      	str	r3, [sp, #0]
200062d0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
200062d4:	68f8      	ldr	r0, [r7, #12]
200062d6:	f004 f8ad 	bl	2000a434 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
200062da:	68fb      	ldr	r3, [r7, #12]
200062dc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200062de:	b29b      	uxth	r3, r3
200062e0:	2b00      	cmp	r3, #0
200062e2:	d19d      	bne.n	20006220 <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
200062e4:	697a      	ldr	r2, [r7, #20]
200062e6:	6a39      	ldr	r1, [r7, #32]
200062e8:	68f8      	ldr	r0, [r7, #12]
200062ea:	f003 ff94 	bl	2000a216 <I2C_WaitOnSTOPFlagUntilTimeout>
200062ee:	4603      	mov	r3, r0
200062f0:	2b00      	cmp	r3, #0
200062f2:	d001      	beq.n	200062f8 <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
200062f4:	2301      	movs	r3, #1
200062f6:	e01a      	b.n	2000632e <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
200062f8:	68fb      	ldr	r3, [r7, #12]
200062fa:	681b      	ldr	r3, [r3, #0]
200062fc:	2220      	movs	r2, #32
200062fe:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
20006300:	68fb      	ldr	r3, [r7, #12]
20006302:	681b      	ldr	r3, [r3, #0]
20006304:	6859      	ldr	r1, [r3, #4]
20006306:	68fb      	ldr	r3, [r7, #12]
20006308:	681a      	ldr	r2, [r3, #0]
2000630a:	4b0c      	ldr	r3, [pc, #48]	; (2000633c <HAL_I2C_Master_Receive+0x1e8>)
2000630c:	400b      	ands	r3, r1
2000630e:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
20006310:	68fb      	ldr	r3, [r7, #12]
20006312:	2220      	movs	r2, #32
20006314:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
20006318:	68fb      	ldr	r3, [r7, #12]
2000631a:	2200      	movs	r2, #0
2000631c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20006320:	68fb      	ldr	r3, [r7, #12]
20006322:	2200      	movs	r2, #0
20006324:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
20006328:	2300      	movs	r3, #0
2000632a:	e000      	b.n	2000632e <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
2000632c:	2302      	movs	r3, #2
  }
}
2000632e:	4618      	mov	r0, r3
20006330:	3718      	adds	r7, #24
20006332:	46bd      	mov	sp, r7
20006334:	bd80      	pop	{r7, pc}
20006336:	bf00      	nop
20006338:	80002400 	.word	0x80002400
2000633c:	fe00e800 	.word	0xfe00e800

20006340 <HAL_I2C_Slave_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
20006340:	b580      	push	{r7, lr}
20006342:	b088      	sub	sp, #32
20006344:	af02      	add	r7, sp, #8
20006346:	60f8      	str	r0, [r7, #12]
20006348:	60b9      	str	r1, [r7, #8]
2000634a:	603b      	str	r3, [r7, #0]
2000634c:	4613      	mov	r3, r2
2000634e:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006350:	68fb      	ldr	r3, [r7, #12]
20006352:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006356:	b2db      	uxtb	r3, r3
20006358:	2b20      	cmp	r3, #32
2000635a:	f040 80f5 	bne.w	20006548 <HAL_I2C_Slave_Transmit+0x208>
  {
    if ((pData == NULL) || (Size == 0U))
2000635e:	68bb      	ldr	r3, [r7, #8]
20006360:	2b00      	cmp	r3, #0
20006362:	d002      	beq.n	2000636a <HAL_I2C_Slave_Transmit+0x2a>
20006364:	88fb      	ldrh	r3, [r7, #6]
20006366:	2b00      	cmp	r3, #0
20006368:	d105      	bne.n	20006376 <HAL_I2C_Slave_Transmit+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000636a:	68fb      	ldr	r3, [r7, #12]
2000636c:	f44f 7200 	mov.w	r2, #512	; 0x200
20006370:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
20006372:	2301      	movs	r3, #1
20006374:	e0e9      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
20006376:	68fb      	ldr	r3, [r7, #12]
20006378:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000637c:	2b01      	cmp	r3, #1
2000637e:	d101      	bne.n	20006384 <HAL_I2C_Slave_Transmit+0x44>
20006380:	2302      	movs	r3, #2
20006382:	e0e2      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
20006384:	68fb      	ldr	r3, [r7, #12]
20006386:	2201      	movs	r2, #1
20006388:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000638c:	f7fb fcf8 	bl	20001d80 <HAL_GetTick>
20006390:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
20006392:	68fb      	ldr	r3, [r7, #12]
20006394:	2221      	movs	r2, #33	; 0x21
20006396:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2000639a:	68fb      	ldr	r3, [r7, #12]
2000639c:	2220      	movs	r2, #32
2000639e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
200063a2:	68fb      	ldr	r3, [r7, #12]
200063a4:	2200      	movs	r2, #0
200063a6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
200063a8:	68fb      	ldr	r3, [r7, #12]
200063aa:	68ba      	ldr	r2, [r7, #8]
200063ac:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
200063ae:	68fb      	ldr	r3, [r7, #12]
200063b0:	88fa      	ldrh	r2, [r7, #6]
200063b2:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
200063b4:	68fb      	ldr	r3, [r7, #12]
200063b6:	2200      	movs	r2, #0
200063b8:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
200063ba:	68fb      	ldr	r3, [r7, #12]
200063bc:	681b      	ldr	r3, [r3, #0]
200063be:	685a      	ldr	r2, [r3, #4]
200063c0:	68fb      	ldr	r3, [r7, #12]
200063c2:	681b      	ldr	r3, [r3, #0]
200063c4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
200063c8:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
200063ca:	697b      	ldr	r3, [r7, #20]
200063cc:	9300      	str	r3, [sp, #0]
200063ce:	683b      	ldr	r3, [r7, #0]
200063d0:	2200      	movs	r2, #0
200063d2:	2108      	movs	r1, #8
200063d4:	68f8      	ldr	r0, [r7, #12]
200063d6:	f003 fe9e 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
200063da:	4603      	mov	r3, r0
200063dc:	2b00      	cmp	r3, #0
200063de:	d009      	beq.n	200063f4 <HAL_I2C_Slave_Transmit+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
200063e0:	68fb      	ldr	r3, [r7, #12]
200063e2:	681b      	ldr	r3, [r3, #0]
200063e4:	685a      	ldr	r2, [r3, #4]
200063e6:	68fb      	ldr	r3, [r7, #12]
200063e8:	681b      	ldr	r3, [r3, #0]
200063ea:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
200063ee:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
200063f0:	2301      	movs	r3, #1
200063f2:	e0aa      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
200063f4:	68fb      	ldr	r3, [r7, #12]
200063f6:	681b      	ldr	r3, [r3, #0]
200063f8:	2208      	movs	r2, #8
200063fa:	61da      	str	r2, [r3, #28]

    /* If 10bit addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
200063fc:	68fb      	ldr	r3, [r7, #12]
200063fe:	68db      	ldr	r3, [r3, #12]
20006400:	2b02      	cmp	r3, #2
20006402:	d118      	bne.n	20006436 <HAL_I2C_Slave_Transmit+0xf6>
    {
      /* Wait until ADDR flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
20006404:	697b      	ldr	r3, [r7, #20]
20006406:	9300      	str	r3, [sp, #0]
20006408:	683b      	ldr	r3, [r7, #0]
2000640a:	2200      	movs	r2, #0
2000640c:	2108      	movs	r1, #8
2000640e:	68f8      	ldr	r0, [r7, #12]
20006410:	f003 fe81 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20006414:	4603      	mov	r3, r0
20006416:	2b00      	cmp	r3, #0
20006418:	d009      	beq.n	2000642e <HAL_I2C_Slave_Transmit+0xee>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000641a:	68fb      	ldr	r3, [r7, #12]
2000641c:	681b      	ldr	r3, [r3, #0]
2000641e:	685a      	ldr	r2, [r3, #4]
20006420:	68fb      	ldr	r3, [r7, #12]
20006422:	681b      	ldr	r3, [r3, #0]
20006424:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006428:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2000642a:	2301      	movs	r3, #1
2000642c:	e08d      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000642e:	68fb      	ldr	r3, [r7, #12]
20006430:	681b      	ldr	r3, [r3, #0]
20006432:	2208      	movs	r2, #8
20006434:	61da      	str	r2, [r3, #28]
    }

    /* Wait until DIR flag is set Transmitter mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
20006436:	697b      	ldr	r3, [r7, #20]
20006438:	9300      	str	r3, [sp, #0]
2000643a:	683b      	ldr	r3, [r7, #0]
2000643c:	2200      	movs	r2, #0
2000643e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
20006442:	68f8      	ldr	r0, [r7, #12]
20006444:	f003 fe67 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20006448:	4603      	mov	r3, r0
2000644a:	2b00      	cmp	r3, #0
2000644c:	d02d      	beq.n	200064aa <HAL_I2C_Slave_Transmit+0x16a>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000644e:	68fb      	ldr	r3, [r7, #12]
20006450:	681b      	ldr	r3, [r3, #0]
20006452:	685a      	ldr	r2, [r3, #4]
20006454:	68fb      	ldr	r3, [r7, #12]
20006456:	681b      	ldr	r3, [r3, #0]
20006458:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000645c:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2000645e:	2301      	movs	r3, #1
20006460:	e073      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
20006462:	697a      	ldr	r2, [r7, #20]
20006464:	6839      	ldr	r1, [r7, #0]
20006466:	68f8      	ldr	r0, [r7, #12]
20006468:	f003 fe95 	bl	2000a196 <I2C_WaitOnTXISFlagUntilTimeout>
2000646c:	4603      	mov	r3, r0
2000646e:	2b00      	cmp	r3, #0
20006470:	d009      	beq.n	20006486 <HAL_I2C_Slave_Transmit+0x146>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
20006472:	68fb      	ldr	r3, [r7, #12]
20006474:	681b      	ldr	r3, [r3, #0]
20006476:	685a      	ldr	r2, [r3, #4]
20006478:	68fb      	ldr	r3, [r7, #12]
2000647a:	681b      	ldr	r3, [r3, #0]
2000647c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006480:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
20006482:	2301      	movs	r3, #1
20006484:	e061      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
20006486:	68fb      	ldr	r3, [r7, #12]
20006488:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000648a:	781a      	ldrb	r2, [r3, #0]
2000648c:	68fb      	ldr	r3, [r7, #12]
2000648e:	681b      	ldr	r3, [r3, #0]
20006490:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
20006492:	68fb      	ldr	r3, [r7, #12]
20006494:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20006496:	1c5a      	adds	r2, r3, #1
20006498:	68fb      	ldr	r3, [r7, #12]
2000649a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2000649c:	68fb      	ldr	r3, [r7, #12]
2000649e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200064a0:	b29b      	uxth	r3, r3
200064a2:	3b01      	subs	r3, #1
200064a4:	b29a      	uxth	r2, r3
200064a6:	68fb      	ldr	r3, [r7, #12]
200064a8:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
200064aa:	68fb      	ldr	r3, [r7, #12]
200064ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200064ae:	b29b      	uxth	r3, r3
200064b0:	2b00      	cmp	r3, #0
200064b2:	d1d6      	bne.n	20006462 <HAL_I2C_Slave_Transmit+0x122>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
200064b4:	697a      	ldr	r2, [r7, #20]
200064b6:	6839      	ldr	r1, [r7, #0]
200064b8:	68f8      	ldr	r0, [r7, #12]
200064ba:	f003 feac 	bl	2000a216 <I2C_WaitOnSTOPFlagUntilTimeout>
200064be:	4603      	mov	r3, r0
200064c0:	2b00      	cmp	r3, #0
200064c2:	d011      	beq.n	200064e8 <HAL_I2C_Slave_Transmit+0x1a8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
200064c4:	68fb      	ldr	r3, [r7, #12]
200064c6:	681b      	ldr	r3, [r3, #0]
200064c8:	685a      	ldr	r2, [r3, #4]
200064ca:	68fb      	ldr	r3, [r7, #12]
200064cc:	681b      	ldr	r3, [r3, #0]
200064ce:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
200064d2:	605a      	str	r2, [r3, #4]

      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
200064d4:	68fb      	ldr	r3, [r7, #12]
200064d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200064d8:	2b04      	cmp	r3, #4
200064da:	d103      	bne.n	200064e4 <HAL_I2C_Slave_Transmit+0x1a4>
      {
        /* Normal use case for Transmitter mode */
        /* A NACK is generated to confirm the end of transfer */
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
200064dc:	68fb      	ldr	r3, [r7, #12]
200064de:	2200      	movs	r2, #0
200064e0:	645a      	str	r2, [r3, #68]	; 0x44
200064e2:	e001      	b.n	200064e8 <HAL_I2C_Slave_Transmit+0x1a8>
      }
      else
      {
        return HAL_ERROR;
200064e4:	2301      	movs	r3, #1
200064e6:	e030      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
      }
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
200064e8:	68fb      	ldr	r3, [r7, #12]
200064ea:	681b      	ldr	r3, [r3, #0]
200064ec:	2220      	movs	r2, #32
200064ee:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
200064f0:	697b      	ldr	r3, [r7, #20]
200064f2:	9300      	str	r3, [sp, #0]
200064f4:	683b      	ldr	r3, [r7, #0]
200064f6:	2201      	movs	r2, #1
200064f8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
200064fc:	68f8      	ldr	r0, [r7, #12]
200064fe:	f003 fe0a 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20006502:	4603      	mov	r3, r0
20006504:	2b00      	cmp	r3, #0
20006506:	d009      	beq.n	2000651c <HAL_I2C_Slave_Transmit+0x1dc>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
20006508:	68fb      	ldr	r3, [r7, #12]
2000650a:	681b      	ldr	r3, [r3, #0]
2000650c:	685a      	ldr	r2, [r3, #4]
2000650e:	68fb      	ldr	r3, [r7, #12]
20006510:	681b      	ldr	r3, [r3, #0]
20006512:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006516:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
20006518:	2301      	movs	r3, #1
2000651a:	e016      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000651c:	68fb      	ldr	r3, [r7, #12]
2000651e:	681b      	ldr	r3, [r3, #0]
20006520:	685a      	ldr	r2, [r3, #4]
20006522:	68fb      	ldr	r3, [r7, #12]
20006524:	681b      	ldr	r3, [r3, #0]
20006526:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000652a:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000652c:	68fb      	ldr	r3, [r7, #12]
2000652e:	2220      	movs	r2, #32
20006530:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
20006534:	68fb      	ldr	r3, [r7, #12]
20006536:	2200      	movs	r2, #0
20006538:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000653c:	68fb      	ldr	r3, [r7, #12]
2000653e:	2200      	movs	r2, #0
20006540:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
20006544:	2300      	movs	r3, #0
20006546:	e000      	b.n	2000654a <HAL_I2C_Slave_Transmit+0x20a>
  }
  else
  {
    return HAL_BUSY;
20006548:	2302      	movs	r3, #2
  }
}
2000654a:	4618      	mov	r0, r3
2000654c:	3718      	adds	r7, #24
2000654e:	46bd      	mov	sp, r7
20006550:	bd80      	pop	{r7, pc}

20006552 <HAL_I2C_Slave_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
20006552:	b580      	push	{r7, lr}
20006554:	b088      	sub	sp, #32
20006556:	af02      	add	r7, sp, #8
20006558:	60f8      	str	r0, [r7, #12]
2000655a:	60b9      	str	r1, [r7, #8]
2000655c:	603b      	str	r3, [r7, #0]
2000655e:	4613      	mov	r3, r2
20006560:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006562:	68fb      	ldr	r3, [r7, #12]
20006564:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006568:	b2db      	uxtb	r3, r3
2000656a:	2b20      	cmp	r3, #32
2000656c:	f040 80eb 	bne.w	20006746 <HAL_I2C_Slave_Receive+0x1f4>
  {
    if ((pData == NULL) || (Size == 0U))
20006570:	68bb      	ldr	r3, [r7, #8]
20006572:	2b00      	cmp	r3, #0
20006574:	d002      	beq.n	2000657c <HAL_I2C_Slave_Receive+0x2a>
20006576:	88fb      	ldrh	r3, [r7, #6]
20006578:	2b00      	cmp	r3, #0
2000657a:	d105      	bne.n	20006588 <HAL_I2C_Slave_Receive+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000657c:	68fb      	ldr	r3, [r7, #12]
2000657e:	f44f 7200 	mov.w	r2, #512	; 0x200
20006582:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
20006584:	2301      	movs	r3, #1
20006586:	e0df      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
20006588:	68fb      	ldr	r3, [r7, #12]
2000658a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000658e:	2b01      	cmp	r3, #1
20006590:	d101      	bne.n	20006596 <HAL_I2C_Slave_Receive+0x44>
20006592:	2302      	movs	r3, #2
20006594:	e0d8      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
20006596:	68fb      	ldr	r3, [r7, #12]
20006598:	2201      	movs	r2, #1
2000659a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000659e:	f7fb fbef 	bl	20001d80 <HAL_GetTick>
200065a2:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
200065a4:	68fb      	ldr	r3, [r7, #12]
200065a6:	2222      	movs	r2, #34	; 0x22
200065a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
200065ac:	68fb      	ldr	r3, [r7, #12]
200065ae:	2220      	movs	r2, #32
200065b0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
200065b4:	68fb      	ldr	r3, [r7, #12]
200065b6:	2200      	movs	r2, #0
200065b8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
200065ba:	68fb      	ldr	r3, [r7, #12]
200065bc:	68ba      	ldr	r2, [r7, #8]
200065be:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
200065c0:	68fb      	ldr	r3, [r7, #12]
200065c2:	88fa      	ldrh	r2, [r7, #6]
200065c4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
200065c6:	68fb      	ldr	r3, [r7, #12]
200065c8:	2200      	movs	r2, #0
200065ca:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
200065cc:	68fb      	ldr	r3, [r7, #12]
200065ce:	681b      	ldr	r3, [r3, #0]
200065d0:	685a      	ldr	r2, [r3, #4]
200065d2:	68fb      	ldr	r3, [r7, #12]
200065d4:	681b      	ldr	r3, [r3, #0]
200065d6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
200065da:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
200065dc:	697b      	ldr	r3, [r7, #20]
200065de:	9300      	str	r3, [sp, #0]
200065e0:	683b      	ldr	r3, [r7, #0]
200065e2:	2200      	movs	r2, #0
200065e4:	2108      	movs	r1, #8
200065e6:	68f8      	ldr	r0, [r7, #12]
200065e8:	f003 fd95 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
200065ec:	4603      	mov	r3, r0
200065ee:	2b00      	cmp	r3, #0
200065f0:	d009      	beq.n	20006606 <HAL_I2C_Slave_Receive+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
200065f2:	68fb      	ldr	r3, [r7, #12]
200065f4:	681b      	ldr	r3, [r3, #0]
200065f6:	685a      	ldr	r2, [r3, #4]
200065f8:	68fb      	ldr	r3, [r7, #12]
200065fa:	681b      	ldr	r3, [r3, #0]
200065fc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006600:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
20006602:	2301      	movs	r3, #1
20006604:	e0a0      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
20006606:	68fb      	ldr	r3, [r7, #12]
20006608:	681b      	ldr	r3, [r3, #0]
2000660a:	2208      	movs	r2, #8
2000660c:	61da      	str	r2, [r3, #28]

    /* Wait until DIR flag is reset Receiver mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
2000660e:	697b      	ldr	r3, [r7, #20]
20006610:	9300      	str	r3, [sp, #0]
20006612:	683b      	ldr	r3, [r7, #0]
20006614:	2201      	movs	r2, #1
20006616:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2000661a:	68f8      	ldr	r0, [r7, #12]
2000661c:	f003 fd7b 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20006620:	4603      	mov	r3, r0
20006622:	2b00      	cmp	r3, #0
20006624:	d048      	beq.n	200066b8 <HAL_I2C_Slave_Receive+0x166>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
20006626:	68fb      	ldr	r3, [r7, #12]
20006628:	681b      	ldr	r3, [r3, #0]
2000662a:	685a      	ldr	r2, [r3, #4]
2000662c:	68fb      	ldr	r3, [r7, #12]
2000662e:	681b      	ldr	r3, [r3, #0]
20006630:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006634:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
20006636:	2301      	movs	r3, #1
20006638:	e086      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2000663a:	697a      	ldr	r2, [r7, #20]
2000663c:	6839      	ldr	r1, [r7, #0]
2000663e:	68f8      	ldr	r0, [r7, #12]
20006640:	f003 fe26 	bl	2000a290 <I2C_WaitOnRXNEFlagUntilTimeout>
20006644:	4603      	mov	r3, r0
20006646:	2b00      	cmp	r3, #0
20006648:	d023      	beq.n	20006692 <HAL_I2C_Slave_Receive+0x140>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000664a:	68fb      	ldr	r3, [r7, #12]
2000664c:	681b      	ldr	r3, [r3, #0]
2000664e:	685a      	ldr	r2, [r3, #4]
20006650:	68fb      	ldr	r3, [r7, #12]
20006652:	681b      	ldr	r3, [r3, #0]
20006654:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006658:	605a      	str	r2, [r3, #4]

        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
2000665a:	68fb      	ldr	r3, [r7, #12]
2000665c:	681b      	ldr	r3, [r3, #0]
2000665e:	699b      	ldr	r3, [r3, #24]
20006660:	f003 0304 	and.w	r3, r3, #4
20006664:	2b04      	cmp	r3, #4
20006666:	d112      	bne.n	2000668e <HAL_I2C_Slave_Receive+0x13c>
        {
          /* Read data from RXDR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20006668:	68fb      	ldr	r3, [r7, #12]
2000666a:	681b      	ldr	r3, [r3, #0]
2000666c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000666e:	68fb      	ldr	r3, [r7, #12]
20006670:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20006672:	b2d2      	uxtb	r2, r2
20006674:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
20006676:	68fb      	ldr	r3, [r7, #12]
20006678:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000667a:	1c5a      	adds	r2, r3, #1
2000667c:	68fb      	ldr	r3, [r7, #12]
2000667e:	625a      	str	r2, [r3, #36]	; 0x24

          hi2c->XferCount--;
20006680:	68fb      	ldr	r3, [r7, #12]
20006682:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006684:	b29b      	uxth	r3, r3
20006686:	3b01      	subs	r3, #1
20006688:	b29a      	uxth	r2, r3
2000668a:	68fb      	ldr	r3, [r7, #12]
2000668c:	855a      	strh	r2, [r3, #42]	; 0x2a
        }

        return HAL_ERROR;
2000668e:	2301      	movs	r3, #1
20006690:	e05a      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20006692:	68fb      	ldr	r3, [r7, #12]
20006694:	681b      	ldr	r3, [r3, #0]
20006696:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20006698:	68fb      	ldr	r3, [r7, #12]
2000669a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000669c:	b2d2      	uxtb	r2, r2
2000669e:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
200066a0:	68fb      	ldr	r3, [r7, #12]
200066a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200066a4:	1c5a      	adds	r2, r3, #1
200066a6:	68fb      	ldr	r3, [r7, #12]
200066a8:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
200066aa:	68fb      	ldr	r3, [r7, #12]
200066ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200066ae:	b29b      	uxth	r3, r3
200066b0:	3b01      	subs	r3, #1
200066b2:	b29a      	uxth	r2, r3
200066b4:	68fb      	ldr	r3, [r7, #12]
200066b6:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
200066b8:	68fb      	ldr	r3, [r7, #12]
200066ba:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200066bc:	b29b      	uxth	r3, r3
200066be:	2b00      	cmp	r3, #0
200066c0:	d1bb      	bne.n	2000663a <HAL_I2C_Slave_Receive+0xe8>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
200066c2:	697a      	ldr	r2, [r7, #20]
200066c4:	6839      	ldr	r1, [r7, #0]
200066c6:	68f8      	ldr	r0, [r7, #12]
200066c8:	f003 fda5 	bl	2000a216 <I2C_WaitOnSTOPFlagUntilTimeout>
200066cc:	4603      	mov	r3, r0
200066ce:	2b00      	cmp	r3, #0
200066d0:	d009      	beq.n	200066e6 <HAL_I2C_Slave_Receive+0x194>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
200066d2:	68fb      	ldr	r3, [r7, #12]
200066d4:	681b      	ldr	r3, [r3, #0]
200066d6:	685a      	ldr	r2, [r3, #4]
200066d8:	68fb      	ldr	r3, [r7, #12]
200066da:	681b      	ldr	r3, [r3, #0]
200066dc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
200066e0:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
200066e2:	2301      	movs	r3, #1
200066e4:	e030      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
200066e6:	68fb      	ldr	r3, [r7, #12]
200066e8:	681b      	ldr	r3, [r3, #0]
200066ea:	2220      	movs	r2, #32
200066ec:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
200066ee:	697b      	ldr	r3, [r7, #20]
200066f0:	9300      	str	r3, [sp, #0]
200066f2:	683b      	ldr	r3, [r7, #0]
200066f4:	2201      	movs	r2, #1
200066f6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
200066fa:	68f8      	ldr	r0, [r7, #12]
200066fc:	f003 fd0b 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20006700:	4603      	mov	r3, r0
20006702:	2b00      	cmp	r3, #0
20006704:	d009      	beq.n	2000671a <HAL_I2C_Slave_Receive+0x1c8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
20006706:	68fb      	ldr	r3, [r7, #12]
20006708:	681b      	ldr	r3, [r3, #0]
2000670a:	685a      	ldr	r2, [r3, #4]
2000670c:	68fb      	ldr	r3, [r7, #12]
2000670e:	681b      	ldr	r3, [r3, #0]
20006710:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006714:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
20006716:	2301      	movs	r3, #1
20006718:	e016      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000671a:	68fb      	ldr	r3, [r7, #12]
2000671c:	681b      	ldr	r3, [r3, #0]
2000671e:	685a      	ldr	r2, [r3, #4]
20006720:	68fb      	ldr	r3, [r7, #12]
20006722:	681b      	ldr	r3, [r3, #0]
20006724:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006728:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2000672a:	68fb      	ldr	r3, [r7, #12]
2000672c:	2220      	movs	r2, #32
2000672e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
20006732:	68fb      	ldr	r3, [r7, #12]
20006734:	2200      	movs	r2, #0
20006736:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000673a:	68fb      	ldr	r3, [r7, #12]
2000673c:	2200      	movs	r2, #0
2000673e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
20006742:	2300      	movs	r3, #0
20006744:	e000      	b.n	20006748 <HAL_I2C_Slave_Receive+0x1f6>
  }
  else
  {
    return HAL_BUSY;
20006746:	2302      	movs	r3, #2
  }
}
20006748:	4618      	mov	r0, r3
2000674a:	3718      	adds	r7, #24
2000674c:	46bd      	mov	sp, r7
2000674e:	bd80      	pop	{r7, pc}

20006750 <HAL_I2C_Master_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
20006750:	b580      	push	{r7, lr}
20006752:	b088      	sub	sp, #32
20006754:	af02      	add	r7, sp, #8
20006756:	60f8      	str	r0, [r7, #12]
20006758:	607a      	str	r2, [r7, #4]
2000675a:	461a      	mov	r2, r3
2000675c:	460b      	mov	r3, r1
2000675e:	817b      	strh	r3, [r7, #10]
20006760:	4613      	mov	r3, r2
20006762:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006764:	68fb      	ldr	r3, [r7, #12]
20006766:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000676a:	b2db      	uxtb	r3, r3
2000676c:	2b20      	cmp	r3, #32
2000676e:	d153      	bne.n	20006818 <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
20006770:	68fb      	ldr	r3, [r7, #12]
20006772:	681b      	ldr	r3, [r3, #0]
20006774:	699b      	ldr	r3, [r3, #24]
20006776:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000677a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000677e:	d101      	bne.n	20006784 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
20006780:	2302      	movs	r3, #2
20006782:	e04a      	b.n	2000681a <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20006784:	68fb      	ldr	r3, [r7, #12]
20006786:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000678a:	2b01      	cmp	r3, #1
2000678c:	d101      	bne.n	20006792 <HAL_I2C_Master_Transmit_IT+0x42>
2000678e:	2302      	movs	r3, #2
20006790:	e043      	b.n	2000681a <HAL_I2C_Master_Transmit_IT+0xca>
20006792:	68fb      	ldr	r3, [r7, #12]
20006794:	2201      	movs	r2, #1
20006796:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2000679a:	68fb      	ldr	r3, [r7, #12]
2000679c:	2221      	movs	r2, #33	; 0x21
2000679e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
200067a2:	68fb      	ldr	r3, [r7, #12]
200067a4:	2210      	movs	r2, #16
200067a6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
200067aa:	68fb      	ldr	r3, [r7, #12]
200067ac:	2200      	movs	r2, #0
200067ae:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
200067b0:	68fb      	ldr	r3, [r7, #12]
200067b2:	687a      	ldr	r2, [r7, #4]
200067b4:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
200067b6:	68fb      	ldr	r3, [r7, #12]
200067b8:	893a      	ldrh	r2, [r7, #8]
200067ba:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
200067bc:	68fb      	ldr	r3, [r7, #12]
200067be:	4a19      	ldr	r2, [pc, #100]	; (20006824 <HAL_I2C_Master_Transmit_IT+0xd4>)
200067c0:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
200067c2:	68fb      	ldr	r3, [r7, #12]
200067c4:	4a18      	ldr	r2, [pc, #96]	; (20006828 <HAL_I2C_Master_Transmit_IT+0xd8>)
200067c6:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200067c8:	68fb      	ldr	r3, [r7, #12]
200067ca:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200067cc:	b29b      	uxth	r3, r3
200067ce:	2bff      	cmp	r3, #255	; 0xff
200067d0:	d906      	bls.n	200067e0 <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
200067d2:	68fb      	ldr	r3, [r7, #12]
200067d4:	22ff      	movs	r2, #255	; 0xff
200067d6:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
200067d8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200067dc:	617b      	str	r3, [r7, #20]
200067de:	e007      	b.n	200067f0 <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
200067e0:	68fb      	ldr	r3, [r7, #12]
200067e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200067e4:	b29a      	uxth	r2, r3
200067e6:	68fb      	ldr	r3, [r7, #12]
200067e8:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
200067ea:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
200067ee:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
200067f0:	68fb      	ldr	r3, [r7, #12]
200067f2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200067f4:	b2da      	uxtb	r2, r3
200067f6:	8979      	ldrh	r1, [r7, #10]
200067f8:	4b0c      	ldr	r3, [pc, #48]	; (2000682c <HAL_I2C_Master_Transmit_IT+0xdc>)
200067fa:	9300      	str	r3, [sp, #0]
200067fc:	697b      	ldr	r3, [r7, #20]
200067fe:	68f8      	ldr	r0, [r7, #12]
20006800:	f003 fe18 	bl	2000a434 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20006804:	68fb      	ldr	r3, [r7, #12]
20006806:	2200      	movs	r2, #0
20006808:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000680c:	2101      	movs	r1, #1
2000680e:	68f8      	ldr	r0, [r7, #12]
20006810:	f003 fe3e 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20006814:	2300      	movs	r3, #0
20006816:	e000      	b.n	2000681a <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
20006818:	2302      	movs	r3, #2
  }
}
2000681a:	4618      	mov	r0, r3
2000681c:	3718      	adds	r7, #24
2000681e:	46bd      	mov	sp, r7
20006820:	bd80      	pop	{r7, pc}
20006822:	bf00      	nop
20006824:	ffff0000 	.word	0xffff0000
20006828:	20008e33 	.word	0x20008e33
2000682c:	80002000 	.word	0x80002000

20006830 <HAL_I2C_Master_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
20006830:	b580      	push	{r7, lr}
20006832:	b088      	sub	sp, #32
20006834:	af02      	add	r7, sp, #8
20006836:	60f8      	str	r0, [r7, #12]
20006838:	607a      	str	r2, [r7, #4]
2000683a:	461a      	mov	r2, r3
2000683c:	460b      	mov	r3, r1
2000683e:	817b      	strh	r3, [r7, #10]
20006840:	4613      	mov	r3, r2
20006842:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006844:	68fb      	ldr	r3, [r7, #12]
20006846:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000684a:	b2db      	uxtb	r3, r3
2000684c:	2b20      	cmp	r3, #32
2000684e:	d153      	bne.n	200068f8 <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
20006850:	68fb      	ldr	r3, [r7, #12]
20006852:	681b      	ldr	r3, [r3, #0]
20006854:	699b      	ldr	r3, [r3, #24]
20006856:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000685a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000685e:	d101      	bne.n	20006864 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
20006860:	2302      	movs	r3, #2
20006862:	e04a      	b.n	200068fa <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20006864:	68fb      	ldr	r3, [r7, #12]
20006866:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000686a:	2b01      	cmp	r3, #1
2000686c:	d101      	bne.n	20006872 <HAL_I2C_Master_Receive_IT+0x42>
2000686e:	2302      	movs	r3, #2
20006870:	e043      	b.n	200068fa <HAL_I2C_Master_Receive_IT+0xca>
20006872:	68fb      	ldr	r3, [r7, #12]
20006874:	2201      	movs	r2, #1
20006876:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2000687a:	68fb      	ldr	r3, [r7, #12]
2000687c:	2222      	movs	r2, #34	; 0x22
2000687e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
20006882:	68fb      	ldr	r3, [r7, #12]
20006884:	2210      	movs	r2, #16
20006886:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2000688a:	68fb      	ldr	r3, [r7, #12]
2000688c:	2200      	movs	r2, #0
2000688e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20006890:	68fb      	ldr	r3, [r7, #12]
20006892:	687a      	ldr	r2, [r7, #4]
20006894:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20006896:	68fb      	ldr	r3, [r7, #12]
20006898:	893a      	ldrh	r2, [r7, #8]
2000689a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000689c:	68fb      	ldr	r3, [r7, #12]
2000689e:	4a19      	ldr	r2, [pc, #100]	; (20006904 <HAL_I2C_Master_Receive_IT+0xd4>)
200068a0:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
200068a2:	68fb      	ldr	r3, [r7, #12]
200068a4:	4a18      	ldr	r2, [pc, #96]	; (20006908 <HAL_I2C_Master_Receive_IT+0xd8>)
200068a6:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200068a8:	68fb      	ldr	r3, [r7, #12]
200068aa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200068ac:	b29b      	uxth	r3, r3
200068ae:	2bff      	cmp	r3, #255	; 0xff
200068b0:	d906      	bls.n	200068c0 <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
200068b2:	68fb      	ldr	r3, [r7, #12]
200068b4:	22ff      	movs	r2, #255	; 0xff
200068b6:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
200068b8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200068bc:	617b      	str	r3, [r7, #20]
200068be:	e007      	b.n	200068d0 <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
200068c0:	68fb      	ldr	r3, [r7, #12]
200068c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200068c4:	b29a      	uxth	r2, r3
200068c6:	68fb      	ldr	r3, [r7, #12]
200068c8:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
200068ca:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
200068ce:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
200068d0:	68fb      	ldr	r3, [r7, #12]
200068d2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200068d4:	b2da      	uxtb	r2, r3
200068d6:	8979      	ldrh	r1, [r7, #10]
200068d8:	4b0c      	ldr	r3, [pc, #48]	; (2000690c <HAL_I2C_Master_Receive_IT+0xdc>)
200068da:	9300      	str	r3, [sp, #0]
200068dc:	697b      	ldr	r3, [r7, #20]
200068de:	68f8      	ldr	r0, [r7, #12]
200068e0:	f003 fda8 	bl	2000a434 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
200068e4:	68fb      	ldr	r3, [r7, #12]
200068e6:	2200      	movs	r2, #0
200068e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
200068ec:	2102      	movs	r1, #2
200068ee:	68f8      	ldr	r0, [r7, #12]
200068f0:	f003 fdce 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
200068f4:	2300      	movs	r3, #0
200068f6:	e000      	b.n	200068fa <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
200068f8:	2302      	movs	r3, #2
  }
}
200068fa:	4618      	mov	r0, r3
200068fc:	3718      	adds	r7, #24
200068fe:	46bd      	mov	sp, r7
20006900:	bd80      	pop	{r7, pc}
20006902:	bf00      	nop
20006904:	ffff0000 	.word	0xffff0000
20006908:	20008e33 	.word	0x20008e33
2000690c:	80002400 	.word	0x80002400

20006910 <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
20006910:	b580      	push	{r7, lr}
20006912:	b084      	sub	sp, #16
20006914:	af00      	add	r7, sp, #0
20006916:	60f8      	str	r0, [r7, #12]
20006918:	60b9      	str	r1, [r7, #8]
2000691a:	4613      	mov	r3, r2
2000691c:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2000691e:	68fb      	ldr	r3, [r7, #12]
20006920:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006924:	b2db      	uxtb	r3, r3
20006926:	2b20      	cmp	r3, #32
20006928:	d138      	bne.n	2000699c <HAL_I2C_Slave_Transmit_IT+0x8c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000692a:	68fb      	ldr	r3, [r7, #12]
2000692c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006930:	2b01      	cmp	r3, #1
20006932:	d101      	bne.n	20006938 <HAL_I2C_Slave_Transmit_IT+0x28>
20006934:	2302      	movs	r3, #2
20006936:	e032      	b.n	2000699e <HAL_I2C_Slave_Transmit_IT+0x8e>
20006938:	68fb      	ldr	r3, [r7, #12]
2000693a:	2201      	movs	r2, #1
2000693c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
20006940:	68fb      	ldr	r3, [r7, #12]
20006942:	2221      	movs	r2, #33	; 0x21
20006944:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
20006948:	68fb      	ldr	r3, [r7, #12]
2000694a:	2220      	movs	r2, #32
2000694c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
20006950:	68fb      	ldr	r3, [r7, #12]
20006952:	2200      	movs	r2, #0
20006954:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
20006956:	68fb      	ldr	r3, [r7, #12]
20006958:	681b      	ldr	r3, [r3, #0]
2000695a:	685a      	ldr	r2, [r3, #4]
2000695c:	68fb      	ldr	r3, [r7, #12]
2000695e:	681b      	ldr	r3, [r3, #0]
20006960:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20006964:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20006966:	68fb      	ldr	r3, [r7, #12]
20006968:	68ba      	ldr	r2, [r7, #8]
2000696a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000696c:	68fb      	ldr	r3, [r7, #12]
2000696e:	88fa      	ldrh	r2, [r7, #6]
20006970:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
20006972:	68fb      	ldr	r3, [r7, #12]
20006974:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006976:	b29a      	uxth	r2, r3
20006978:	68fb      	ldr	r3, [r7, #12]
2000697a:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000697c:	68fb      	ldr	r3, [r7, #12]
2000697e:	4a0a      	ldr	r2, [pc, #40]	; (200069a8 <HAL_I2C_Slave_Transmit_IT+0x98>)
20006980:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
20006982:	68fb      	ldr	r3, [r7, #12]
20006984:	4a09      	ldr	r2, [pc, #36]	; (200069ac <HAL_I2C_Slave_Transmit_IT+0x9c>)
20006986:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20006988:	68fb      	ldr	r3, [r7, #12]
2000698a:	2200      	movs	r2, #0
2000698c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
20006990:	2105      	movs	r1, #5
20006992:	68f8      	ldr	r0, [r7, #12]
20006994:	f003 fd7c 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20006998:	2300      	movs	r3, #0
2000699a:	e000      	b.n	2000699e <HAL_I2C_Slave_Transmit_IT+0x8e>
  }
  else
  {
    return HAL_BUSY;
2000699c:	2302      	movs	r3, #2
  }
}
2000699e:	4618      	mov	r0, r3
200069a0:	3710      	adds	r7, #16
200069a2:	46bd      	mov	sp, r7
200069a4:	bd80      	pop	{r7, pc}
200069a6:	bf00      	nop
200069a8:	ffff0000 	.word	0xffff0000
200069ac:	20009085 	.word	0x20009085

200069b0 <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
200069b0:	b580      	push	{r7, lr}
200069b2:	b084      	sub	sp, #16
200069b4:	af00      	add	r7, sp, #0
200069b6:	60f8      	str	r0, [r7, #12]
200069b8:	60b9      	str	r1, [r7, #8]
200069ba:	4613      	mov	r3, r2
200069bc:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
200069be:	68fb      	ldr	r3, [r7, #12]
200069c0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200069c4:	b2db      	uxtb	r3, r3
200069c6:	2b20      	cmp	r3, #32
200069c8:	d138      	bne.n	20006a3c <HAL_I2C_Slave_Receive_IT+0x8c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
200069ca:	68fb      	ldr	r3, [r7, #12]
200069cc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200069d0:	2b01      	cmp	r3, #1
200069d2:	d101      	bne.n	200069d8 <HAL_I2C_Slave_Receive_IT+0x28>
200069d4:	2302      	movs	r3, #2
200069d6:	e032      	b.n	20006a3e <HAL_I2C_Slave_Receive_IT+0x8e>
200069d8:	68fb      	ldr	r3, [r7, #12]
200069da:	2201      	movs	r2, #1
200069dc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
200069e0:	68fb      	ldr	r3, [r7, #12]
200069e2:	2222      	movs	r2, #34	; 0x22
200069e4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
200069e8:	68fb      	ldr	r3, [r7, #12]
200069ea:	2220      	movs	r2, #32
200069ec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
200069f0:	68fb      	ldr	r3, [r7, #12]
200069f2:	2200      	movs	r2, #0
200069f4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
200069f6:	68fb      	ldr	r3, [r7, #12]
200069f8:	681b      	ldr	r3, [r3, #0]
200069fa:	685a      	ldr	r2, [r3, #4]
200069fc:	68fb      	ldr	r3, [r7, #12]
200069fe:	681b      	ldr	r3, [r3, #0]
20006a00:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20006a04:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20006a06:	68fb      	ldr	r3, [r7, #12]
20006a08:	68ba      	ldr	r2, [r7, #8]
20006a0a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20006a0c:	68fb      	ldr	r3, [r7, #12]
20006a0e:	88fa      	ldrh	r2, [r7, #6]
20006a10:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
20006a12:	68fb      	ldr	r3, [r7, #12]
20006a14:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006a16:	b29a      	uxth	r2, r3
20006a18:	68fb      	ldr	r3, [r7, #12]
20006a1a:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20006a1c:	68fb      	ldr	r3, [r7, #12]
20006a1e:	4a0a      	ldr	r2, [pc, #40]	; (20006a48 <HAL_I2C_Slave_Receive_IT+0x98>)
20006a20:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
20006a22:	68fb      	ldr	r3, [r7, #12]
20006a24:	4a09      	ldr	r2, [pc, #36]	; (20006a4c <HAL_I2C_Slave_Receive_IT+0x9c>)
20006a26:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20006a28:	68fb      	ldr	r3, [r7, #12]
20006a2a:	2200      	movs	r2, #0
20006a2c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
20006a30:	2106      	movs	r1, #6
20006a32:	68f8      	ldr	r0, [r7, #12]
20006a34:	f003 fd2c 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20006a38:	2300      	movs	r3, #0
20006a3a:	e000      	b.n	20006a3e <HAL_I2C_Slave_Receive_IT+0x8e>
  }
  else
  {
    return HAL_BUSY;
20006a3c:	2302      	movs	r3, #2
  }
}
20006a3e:	4618      	mov	r0, r3
20006a40:	3710      	adds	r7, #16
20006a42:	46bd      	mov	sp, r7
20006a44:	bd80      	pop	{r7, pc}
20006a46:	bf00      	nop
20006a48:	ffff0000 	.word	0xffff0000
20006a4c:	20009085 	.word	0x20009085

20006a50 <HAL_I2C_Master_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
20006a50:	b580      	push	{r7, lr}
20006a52:	b088      	sub	sp, #32
20006a54:	af02      	add	r7, sp, #8
20006a56:	60f8      	str	r0, [r7, #12]
20006a58:	607a      	str	r2, [r7, #4]
20006a5a:	461a      	mov	r2, r3
20006a5c:	460b      	mov	r3, r1
20006a5e:	817b      	strh	r3, [r7, #10]
20006a60:	4613      	mov	r3, r2
20006a62:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006a64:	68fb      	ldr	r3, [r7, #12]
20006a66:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006a6a:	b2db      	uxtb	r3, r3
20006a6c:	2b20      	cmp	r3, #32
20006a6e:	f040 80cd 	bne.w	20006c0c <HAL_I2C_Master_Transmit_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
20006a72:	68fb      	ldr	r3, [r7, #12]
20006a74:	681b      	ldr	r3, [r3, #0]
20006a76:	699b      	ldr	r3, [r3, #24]
20006a78:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
20006a7c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20006a80:	d101      	bne.n	20006a86 <HAL_I2C_Master_Transmit_DMA+0x36>
    {
      return HAL_BUSY;
20006a82:	2302      	movs	r3, #2
20006a84:	e0c3      	b.n	20006c0e <HAL_I2C_Master_Transmit_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20006a86:	68fb      	ldr	r3, [r7, #12]
20006a88:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006a8c:	2b01      	cmp	r3, #1
20006a8e:	d101      	bne.n	20006a94 <HAL_I2C_Master_Transmit_DMA+0x44>
20006a90:	2302      	movs	r3, #2
20006a92:	e0bc      	b.n	20006c0e <HAL_I2C_Master_Transmit_DMA+0x1be>
20006a94:	68fb      	ldr	r3, [r7, #12]
20006a96:	2201      	movs	r2, #1
20006a98:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
20006a9c:	68fb      	ldr	r3, [r7, #12]
20006a9e:	2221      	movs	r2, #33	; 0x21
20006aa0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
20006aa4:	68fb      	ldr	r3, [r7, #12]
20006aa6:	2210      	movs	r2, #16
20006aa8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
20006aac:	68fb      	ldr	r3, [r7, #12]
20006aae:	2200      	movs	r2, #0
20006ab0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20006ab2:	68fb      	ldr	r3, [r7, #12]
20006ab4:	687a      	ldr	r2, [r7, #4]
20006ab6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20006ab8:	68fb      	ldr	r3, [r7, #12]
20006aba:	893a      	ldrh	r2, [r7, #8]
20006abc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20006abe:	68fb      	ldr	r3, [r7, #12]
20006ac0:	4a55      	ldr	r2, [pc, #340]	; (20006c18 <HAL_I2C_Master_Transmit_DMA+0x1c8>)
20006ac2:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
20006ac4:	68fb      	ldr	r3, [r7, #12]
20006ac6:	4a55      	ldr	r2, [pc, #340]	; (20006c1c <HAL_I2C_Master_Transmit_DMA+0x1cc>)
20006ac8:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20006aca:	68fb      	ldr	r3, [r7, #12]
20006acc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006ace:	b29b      	uxth	r3, r3
20006ad0:	2bff      	cmp	r3, #255	; 0xff
20006ad2:	d906      	bls.n	20006ae2 <HAL_I2C_Master_Transmit_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20006ad4:	68fb      	ldr	r3, [r7, #12]
20006ad6:	22ff      	movs	r2, #255	; 0xff
20006ad8:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20006ada:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20006ade:	617b      	str	r3, [r7, #20]
20006ae0:	e007      	b.n	20006af2 <HAL_I2C_Master_Transmit_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20006ae2:	68fb      	ldr	r3, [r7, #12]
20006ae4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006ae6:	b29a      	uxth	r2, r3
20006ae8:	68fb      	ldr	r3, [r7, #12]
20006aea:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
20006aec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20006af0:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
20006af2:	68fb      	ldr	r3, [r7, #12]
20006af4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006af6:	2b00      	cmp	r3, #0
20006af8:	d070      	beq.n	20006bdc <HAL_I2C_Master_Transmit_DMA+0x18c>
    {
      if (hi2c->hdmatx != NULL)
20006afa:	68fb      	ldr	r3, [r7, #12]
20006afc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006afe:	2b00      	cmp	r3, #0
20006b00:	d020      	beq.n	20006b44 <HAL_I2C_Master_Transmit_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
20006b02:	68fb      	ldr	r3, [r7, #12]
20006b04:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006b06:	4a46      	ldr	r2, [pc, #280]	; (20006c20 <HAL_I2C_Master_Transmit_DMA+0x1d0>)
20006b08:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
20006b0a:	68fb      	ldr	r3, [r7, #12]
20006b0c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006b0e:	4a45      	ldr	r2, [pc, #276]	; (20006c24 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
20006b10:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
20006b12:	68fb      	ldr	r3, [r7, #12]
20006b14:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006b16:	2200      	movs	r2, #0
20006b18:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
20006b1a:	68fb      	ldr	r3, [r7, #12]
20006b1c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006b1e:	2200      	movs	r2, #0
20006b20:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
20006b22:	68fb      	ldr	r3, [r7, #12]
20006b24:	6b98      	ldr	r0, [r3, #56]	; 0x38
20006b26:	6879      	ldr	r1, [r7, #4]
20006b28:	68fb      	ldr	r3, [r7, #12]
20006b2a:	681b      	ldr	r3, [r3, #0]
20006b2c:	3328      	adds	r3, #40	; 0x28
20006b2e:	461a      	mov	r2, r3
20006b30:	68fb      	ldr	r3, [r7, #12]
20006b32:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006b34:	f7fb ff2b 	bl	2000298e <HAL_DMA_Start_IT>
20006b38:	4603      	mov	r3, r0
20006b3a:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
20006b3c:	7cfb      	ldrb	r3, [r7, #19]
20006b3e:	2b00      	cmp	r3, #0
20006b40:	d138      	bne.n	20006bb4 <HAL_I2C_Master_Transmit_DMA+0x164>
20006b42:	e013      	b.n	20006b6c <HAL_I2C_Master_Transmit_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
20006b44:	68fb      	ldr	r3, [r7, #12]
20006b46:	2220      	movs	r2, #32
20006b48:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
20006b4c:	68fb      	ldr	r3, [r7, #12]
20006b4e:	2200      	movs	r2, #0
20006b50:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
20006b54:	68fb      	ldr	r3, [r7, #12]
20006b56:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006b58:	f043 0280 	orr.w	r2, r3, #128	; 0x80
20006b5c:	68fb      	ldr	r3, [r7, #12]
20006b5e:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
20006b60:	68fb      	ldr	r3, [r7, #12]
20006b62:	2200      	movs	r2, #0
20006b64:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
20006b68:	2301      	movs	r3, #1
20006b6a:	e050      	b.n	20006c0e <HAL_I2C_Master_Transmit_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
20006b6c:	68fb      	ldr	r3, [r7, #12]
20006b6e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006b70:	b2da      	uxtb	r2, r3
20006b72:	8979      	ldrh	r1, [r7, #10]
20006b74:	4b2c      	ldr	r3, [pc, #176]	; (20006c28 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
20006b76:	9300      	str	r3, [sp, #0]
20006b78:	697b      	ldr	r3, [r7, #20]
20006b7a:	68f8      	ldr	r0, [r7, #12]
20006b7c:	f003 fc5a 	bl	2000a434 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
20006b80:	68fb      	ldr	r3, [r7, #12]
20006b82:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006b84:	b29a      	uxth	r2, r3
20006b86:	68fb      	ldr	r3, [r7, #12]
20006b88:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006b8a:	1ad3      	subs	r3, r2, r3
20006b8c:	b29a      	uxth	r2, r3
20006b8e:	68fb      	ldr	r3, [r7, #12]
20006b90:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20006b92:	68fb      	ldr	r3, [r7, #12]
20006b94:	2200      	movs	r2, #0
20006b96:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
20006b9a:	2111      	movs	r1, #17
20006b9c:	68f8      	ldr	r0, [r7, #12]
20006b9e:	f003 fc77 	bl	2000a490 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
20006ba2:	68fb      	ldr	r3, [r7, #12]
20006ba4:	681b      	ldr	r3, [r3, #0]
20006ba6:	681a      	ldr	r2, [r3, #0]
20006ba8:	68fb      	ldr	r3, [r7, #12]
20006baa:	681b      	ldr	r3, [r3, #0]
20006bac:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20006bb0:	601a      	str	r2, [r3, #0]
20006bb2:	e029      	b.n	20006c08 <HAL_I2C_Master_Transmit_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
20006bb4:	68fb      	ldr	r3, [r7, #12]
20006bb6:	2220      	movs	r2, #32
20006bb8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
20006bbc:	68fb      	ldr	r3, [r7, #12]
20006bbe:	2200      	movs	r2, #0
20006bc0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
20006bc4:	68fb      	ldr	r3, [r7, #12]
20006bc6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006bc8:	f043 0210 	orr.w	r2, r3, #16
20006bcc:	68fb      	ldr	r3, [r7, #12]
20006bce:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20006bd0:	68fb      	ldr	r3, [r7, #12]
20006bd2:	2200      	movs	r2, #0
20006bd4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
20006bd8:	2301      	movs	r3, #1
20006bda:	e018      	b.n	20006c0e <HAL_I2C_Master_Transmit_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
20006bdc:	68fb      	ldr	r3, [r7, #12]
20006bde:	4a13      	ldr	r2, [pc, #76]	; (20006c2c <HAL_I2C_Master_Transmit_DMA+0x1dc>)
20006be0:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
20006be2:	68fb      	ldr	r3, [r7, #12]
20006be4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006be6:	b2da      	uxtb	r2, r3
20006be8:	8979      	ldrh	r1, [r7, #10]
20006bea:	4b0f      	ldr	r3, [pc, #60]	; (20006c28 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
20006bec:	9300      	str	r3, [sp, #0]
20006bee:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20006bf2:	68f8      	ldr	r0, [r7, #12]
20006bf4:	f003 fc1e 	bl	2000a434 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20006bf8:	68fb      	ldr	r3, [r7, #12]
20006bfa:	2200      	movs	r2, #0
20006bfc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
20006c00:	2101      	movs	r1, #1
20006c02:	68f8      	ldr	r0, [r7, #12]
20006c04:	f003 fc44 	bl	2000a490 <I2C_Enable_IRQ>
    }

    return HAL_OK;
20006c08:	2300      	movs	r3, #0
20006c0a:	e000      	b.n	20006c0e <HAL_I2C_Master_Transmit_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
20006c0c:	2302      	movs	r3, #2
  }
}
20006c0e:	4618      	mov	r0, r3
20006c10:	3718      	adds	r7, #24
20006c12:	46bd      	mov	sp, r7
20006c14:	bd80      	pop	{r7, pc}
20006c16:	bf00      	nop
20006c18:	ffff0000 	.word	0xffff0000
20006c1c:	20009293 	.word	0x20009293
20006c20:	20009ea9 	.word	0x20009ea9
20006c24:	2000a05b 	.word	0x2000a05b
20006c28:	80002000 	.word	0x80002000
20006c2c:	20008e33 	.word	0x20008e33

20006c30 <HAL_I2C_Master_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
20006c30:	b580      	push	{r7, lr}
20006c32:	b088      	sub	sp, #32
20006c34:	af02      	add	r7, sp, #8
20006c36:	60f8      	str	r0, [r7, #12]
20006c38:	607a      	str	r2, [r7, #4]
20006c3a:	461a      	mov	r2, r3
20006c3c:	460b      	mov	r3, r1
20006c3e:	817b      	strh	r3, [r7, #10]
20006c40:	4613      	mov	r3, r2
20006c42:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006c44:	68fb      	ldr	r3, [r7, #12]
20006c46:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006c4a:	b2db      	uxtb	r3, r3
20006c4c:	2b20      	cmp	r3, #32
20006c4e:	f040 80cd 	bne.w	20006dec <HAL_I2C_Master_Receive_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
20006c52:	68fb      	ldr	r3, [r7, #12]
20006c54:	681b      	ldr	r3, [r3, #0]
20006c56:	699b      	ldr	r3, [r3, #24]
20006c58:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
20006c5c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20006c60:	d101      	bne.n	20006c66 <HAL_I2C_Master_Receive_DMA+0x36>
    {
      return HAL_BUSY;
20006c62:	2302      	movs	r3, #2
20006c64:	e0c3      	b.n	20006dee <HAL_I2C_Master_Receive_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20006c66:	68fb      	ldr	r3, [r7, #12]
20006c68:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006c6c:	2b01      	cmp	r3, #1
20006c6e:	d101      	bne.n	20006c74 <HAL_I2C_Master_Receive_DMA+0x44>
20006c70:	2302      	movs	r3, #2
20006c72:	e0bc      	b.n	20006dee <HAL_I2C_Master_Receive_DMA+0x1be>
20006c74:	68fb      	ldr	r3, [r7, #12]
20006c76:	2201      	movs	r2, #1
20006c78:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
20006c7c:	68fb      	ldr	r3, [r7, #12]
20006c7e:	2222      	movs	r2, #34	; 0x22
20006c80:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
20006c84:	68fb      	ldr	r3, [r7, #12]
20006c86:	2210      	movs	r2, #16
20006c88:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
20006c8c:	68fb      	ldr	r3, [r7, #12]
20006c8e:	2200      	movs	r2, #0
20006c90:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20006c92:	68fb      	ldr	r3, [r7, #12]
20006c94:	687a      	ldr	r2, [r7, #4]
20006c96:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20006c98:	68fb      	ldr	r3, [r7, #12]
20006c9a:	893a      	ldrh	r2, [r7, #8]
20006c9c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20006c9e:	68fb      	ldr	r3, [r7, #12]
20006ca0:	4a55      	ldr	r2, [pc, #340]	; (20006df8 <HAL_I2C_Master_Receive_DMA+0x1c8>)
20006ca2:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
20006ca4:	68fb      	ldr	r3, [r7, #12]
20006ca6:	4a55      	ldr	r2, [pc, #340]	; (20006dfc <HAL_I2C_Master_Receive_DMA+0x1cc>)
20006ca8:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20006caa:	68fb      	ldr	r3, [r7, #12]
20006cac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006cae:	b29b      	uxth	r3, r3
20006cb0:	2bff      	cmp	r3, #255	; 0xff
20006cb2:	d906      	bls.n	20006cc2 <HAL_I2C_Master_Receive_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20006cb4:	68fb      	ldr	r3, [r7, #12]
20006cb6:	22ff      	movs	r2, #255	; 0xff
20006cb8:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20006cba:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20006cbe:	617b      	str	r3, [r7, #20]
20006cc0:	e007      	b.n	20006cd2 <HAL_I2C_Master_Receive_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20006cc2:	68fb      	ldr	r3, [r7, #12]
20006cc4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006cc6:	b29a      	uxth	r2, r3
20006cc8:	68fb      	ldr	r3, [r7, #12]
20006cca:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
20006ccc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20006cd0:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
20006cd2:	68fb      	ldr	r3, [r7, #12]
20006cd4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006cd6:	2b00      	cmp	r3, #0
20006cd8:	d070      	beq.n	20006dbc <HAL_I2C_Master_Receive_DMA+0x18c>
    {
      if (hi2c->hdmarx != NULL)
20006cda:	68fb      	ldr	r3, [r7, #12]
20006cdc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cde:	2b00      	cmp	r3, #0
20006ce0:	d020      	beq.n	20006d24 <HAL_I2C_Master_Receive_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
20006ce2:	68fb      	ldr	r3, [r7, #12]
20006ce4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006ce6:	4a46      	ldr	r2, [pc, #280]	; (20006e00 <HAL_I2C_Master_Receive_DMA+0x1d0>)
20006ce8:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
20006cea:	68fb      	ldr	r3, [r7, #12]
20006cec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cee:	4a45      	ldr	r2, [pc, #276]	; (20006e04 <HAL_I2C_Master_Receive_DMA+0x1d4>)
20006cf0:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
20006cf2:	68fb      	ldr	r3, [r7, #12]
20006cf4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cf6:	2200      	movs	r2, #0
20006cf8:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
20006cfa:	68fb      	ldr	r3, [r7, #12]
20006cfc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cfe:	2200      	movs	r2, #0
20006d00:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
20006d02:	68fb      	ldr	r3, [r7, #12]
20006d04:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
20006d06:	68fb      	ldr	r3, [r7, #12]
20006d08:	681b      	ldr	r3, [r3, #0]
20006d0a:	3324      	adds	r3, #36	; 0x24
20006d0c:	4619      	mov	r1, r3
20006d0e:	687a      	ldr	r2, [r7, #4]
20006d10:	68fb      	ldr	r3, [r7, #12]
20006d12:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006d14:	f7fb fe3b 	bl	2000298e <HAL_DMA_Start_IT>
20006d18:	4603      	mov	r3, r0
20006d1a:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
20006d1c:	7cfb      	ldrb	r3, [r7, #19]
20006d1e:	2b00      	cmp	r3, #0
20006d20:	d138      	bne.n	20006d94 <HAL_I2C_Master_Receive_DMA+0x164>
20006d22:	e013      	b.n	20006d4c <HAL_I2C_Master_Receive_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
20006d24:	68fb      	ldr	r3, [r7, #12]
20006d26:	2220      	movs	r2, #32
20006d28:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
20006d2c:	68fb      	ldr	r3, [r7, #12]
20006d2e:	2200      	movs	r2, #0
20006d30:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
20006d34:	68fb      	ldr	r3, [r7, #12]
20006d36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006d38:	f043 0280 	orr.w	r2, r3, #128	; 0x80
20006d3c:	68fb      	ldr	r3, [r7, #12]
20006d3e:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
20006d40:	68fb      	ldr	r3, [r7, #12]
20006d42:	2200      	movs	r2, #0
20006d44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
20006d48:	2301      	movs	r3, #1
20006d4a:	e050      	b.n	20006dee <HAL_I2C_Master_Receive_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
20006d4c:	68fb      	ldr	r3, [r7, #12]
20006d4e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006d50:	b2da      	uxtb	r2, r3
20006d52:	8979      	ldrh	r1, [r7, #10]
20006d54:	4b2c      	ldr	r3, [pc, #176]	; (20006e08 <HAL_I2C_Master_Receive_DMA+0x1d8>)
20006d56:	9300      	str	r3, [sp, #0]
20006d58:	697b      	ldr	r3, [r7, #20]
20006d5a:	68f8      	ldr	r0, [r7, #12]
20006d5c:	f003 fb6a 	bl	2000a434 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
20006d60:	68fb      	ldr	r3, [r7, #12]
20006d62:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006d64:	b29a      	uxth	r2, r3
20006d66:	68fb      	ldr	r3, [r7, #12]
20006d68:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006d6a:	1ad3      	subs	r3, r2, r3
20006d6c:	b29a      	uxth	r2, r3
20006d6e:	68fb      	ldr	r3, [r7, #12]
20006d70:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20006d72:	68fb      	ldr	r3, [r7, #12]
20006d74:	2200      	movs	r2, #0
20006d76:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
20006d7a:	2111      	movs	r1, #17
20006d7c:	68f8      	ldr	r0, [r7, #12]
20006d7e:	f003 fb87 	bl	2000a490 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
20006d82:	68fb      	ldr	r3, [r7, #12]
20006d84:	681b      	ldr	r3, [r3, #0]
20006d86:	681a      	ldr	r2, [r3, #0]
20006d88:	68fb      	ldr	r3, [r7, #12]
20006d8a:	681b      	ldr	r3, [r3, #0]
20006d8c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20006d90:	601a      	str	r2, [r3, #0]
20006d92:	e029      	b.n	20006de8 <HAL_I2C_Master_Receive_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
20006d94:	68fb      	ldr	r3, [r7, #12]
20006d96:	2220      	movs	r2, #32
20006d98:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
20006d9c:	68fb      	ldr	r3, [r7, #12]
20006d9e:	2200      	movs	r2, #0
20006da0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
20006da4:	68fb      	ldr	r3, [r7, #12]
20006da6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006da8:	f043 0210 	orr.w	r2, r3, #16
20006dac:	68fb      	ldr	r3, [r7, #12]
20006dae:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20006db0:	68fb      	ldr	r3, [r7, #12]
20006db2:	2200      	movs	r2, #0
20006db4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
20006db8:	2301      	movs	r3, #1
20006dba:	e018      	b.n	20006dee <HAL_I2C_Master_Receive_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
20006dbc:	68fb      	ldr	r3, [r7, #12]
20006dbe:	4a13      	ldr	r2, [pc, #76]	; (20006e0c <HAL_I2C_Master_Receive_DMA+0x1dc>)
20006dc0:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
20006dc2:	68fb      	ldr	r3, [r7, #12]
20006dc4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006dc6:	b2da      	uxtb	r2, r3
20006dc8:	8979      	ldrh	r1, [r7, #10]
20006dca:	4b0f      	ldr	r3, [pc, #60]	; (20006e08 <HAL_I2C_Master_Receive_DMA+0x1d8>)
20006dcc:	9300      	str	r3, [sp, #0]
20006dce:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20006dd2:	68f8      	ldr	r0, [r7, #12]
20006dd4:	f003 fb2e 	bl	2000a434 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20006dd8:	68fb      	ldr	r3, [r7, #12]
20006dda:	2200      	movs	r2, #0
20006ddc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
20006de0:	2101      	movs	r1, #1
20006de2:	68f8      	ldr	r0, [r7, #12]
20006de4:	f003 fb54 	bl	2000a490 <I2C_Enable_IRQ>
    }

    return HAL_OK;
20006de8:	2300      	movs	r3, #0
20006dea:	e000      	b.n	20006dee <HAL_I2C_Master_Receive_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
20006dec:	2302      	movs	r3, #2
  }
}
20006dee:	4618      	mov	r0, r3
20006df0:	3718      	adds	r7, #24
20006df2:	46bd      	mov	sp, r7
20006df4:	bd80      	pop	{r7, pc}
20006df6:	bf00      	nop
20006df8:	ffff0000 	.word	0xffff0000
20006dfc:	20009293 	.word	0x20009293
20006e00:	20009f7f 	.word	0x20009f7f
20006e04:	2000a05b 	.word	0x2000a05b
20006e08:	80002400 	.word	0x80002400
20006e0c:	20008e33 	.word	0x20008e33

20006e10 <HAL_I2C_Slave_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
20006e10:	b580      	push	{r7, lr}
20006e12:	b086      	sub	sp, #24
20006e14:	af00      	add	r7, sp, #0
20006e16:	60f8      	str	r0, [r7, #12]
20006e18:	60b9      	str	r1, [r7, #8]
20006e1a:	4613      	mov	r3, r2
20006e1c:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006e1e:	68fb      	ldr	r3, [r7, #12]
20006e20:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006e24:	b2db      	uxtb	r3, r3
20006e26:	2b20      	cmp	r3, #32
20006e28:	f040 809a 	bne.w	20006f60 <HAL_I2C_Slave_Transmit_DMA+0x150>
  {
    if ((pData == NULL) || (Size == 0U))
20006e2c:	68bb      	ldr	r3, [r7, #8]
20006e2e:	2b00      	cmp	r3, #0
20006e30:	d002      	beq.n	20006e38 <HAL_I2C_Slave_Transmit_DMA+0x28>
20006e32:	88fb      	ldrh	r3, [r7, #6]
20006e34:	2b00      	cmp	r3, #0
20006e36:	d105      	bne.n	20006e44 <HAL_I2C_Slave_Transmit_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
20006e38:	68fb      	ldr	r3, [r7, #12]
20006e3a:	f44f 7200 	mov.w	r2, #512	; 0x200
20006e3e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
20006e40:	2301      	movs	r3, #1
20006e42:	e08e      	b.n	20006f62 <HAL_I2C_Slave_Transmit_DMA+0x152>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
20006e44:	68fb      	ldr	r3, [r7, #12]
20006e46:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006e4a:	2b01      	cmp	r3, #1
20006e4c:	d101      	bne.n	20006e52 <HAL_I2C_Slave_Transmit_DMA+0x42>
20006e4e:	2302      	movs	r3, #2
20006e50:	e087      	b.n	20006f62 <HAL_I2C_Slave_Transmit_DMA+0x152>
20006e52:	68fb      	ldr	r3, [r7, #12]
20006e54:	2201      	movs	r2, #1
20006e56:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
20006e5a:	68fb      	ldr	r3, [r7, #12]
20006e5c:	2221      	movs	r2, #33	; 0x21
20006e5e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
20006e62:	68fb      	ldr	r3, [r7, #12]
20006e64:	2220      	movs	r2, #32
20006e66:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
20006e6a:	68fb      	ldr	r3, [r7, #12]
20006e6c:	2200      	movs	r2, #0
20006e6e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20006e70:	68fb      	ldr	r3, [r7, #12]
20006e72:	68ba      	ldr	r2, [r7, #8]
20006e74:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20006e76:	68fb      	ldr	r3, [r7, #12]
20006e78:	88fa      	ldrh	r2, [r7, #6]
20006e7a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
20006e7c:	68fb      	ldr	r3, [r7, #12]
20006e7e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006e80:	b29a      	uxth	r2, r3
20006e82:	68fb      	ldr	r3, [r7, #12]
20006e84:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20006e86:	68fb      	ldr	r3, [r7, #12]
20006e88:	4a38      	ldr	r2, [pc, #224]	; (20006f6c <HAL_I2C_Slave_Transmit_DMA+0x15c>)
20006e8a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
20006e8c:	68fb      	ldr	r3, [r7, #12]
20006e8e:	4a38      	ldr	r2, [pc, #224]	; (20006f70 <HAL_I2C_Slave_Transmit_DMA+0x160>)
20006e90:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
20006e92:	68fb      	ldr	r3, [r7, #12]
20006e94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006e96:	2b00      	cmp	r3, #0
20006e98:	d020      	beq.n	20006edc <HAL_I2C_Slave_Transmit_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
20006e9a:	68fb      	ldr	r3, [r7, #12]
20006e9c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006e9e:	4a35      	ldr	r2, [pc, #212]	; (20006f74 <HAL_I2C_Slave_Transmit_DMA+0x164>)
20006ea0:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
20006ea2:	68fb      	ldr	r3, [r7, #12]
20006ea4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006ea6:	4a34      	ldr	r2, [pc, #208]	; (20006f78 <HAL_I2C_Slave_Transmit_DMA+0x168>)
20006ea8:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
20006eaa:	68fb      	ldr	r3, [r7, #12]
20006eac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006eae:	2200      	movs	r2, #0
20006eb0:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
20006eb2:	68fb      	ldr	r3, [r7, #12]
20006eb4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006eb6:	2200      	movs	r2, #0
20006eb8:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
20006eba:	68fb      	ldr	r3, [r7, #12]
20006ebc:	6b98      	ldr	r0, [r3, #56]	; 0x38
20006ebe:	68b9      	ldr	r1, [r7, #8]
20006ec0:	68fb      	ldr	r3, [r7, #12]
20006ec2:	681b      	ldr	r3, [r3, #0]
20006ec4:	3328      	adds	r3, #40	; 0x28
20006ec6:	461a      	mov	r2, r3
20006ec8:	68fb      	ldr	r3, [r7, #12]
20006eca:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20006ecc:	f7fb fd5f 	bl	2000298e <HAL_DMA_Start_IT>
20006ed0:	4603      	mov	r3, r0
20006ed2:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
20006ed4:	7dfb      	ldrb	r3, [r7, #23]
20006ed6:	2b00      	cmp	r3, #0
20006ed8:	d12e      	bne.n	20006f38 <HAL_I2C_Slave_Transmit_DMA+0x128>
20006eda:	e013      	b.n	20006f04 <HAL_I2C_Slave_Transmit_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
20006edc:	68fb      	ldr	r3, [r7, #12]
20006ede:	2228      	movs	r2, #40	; 0x28
20006ee0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20006ee4:	68fb      	ldr	r3, [r7, #12]
20006ee6:	2200      	movs	r2, #0
20006ee8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
20006eec:	68fb      	ldr	r3, [r7, #12]
20006eee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006ef0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
20006ef4:	68fb      	ldr	r3, [r7, #12]
20006ef6:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20006ef8:	68fb      	ldr	r3, [r7, #12]
20006efa:	2200      	movs	r2, #0
20006efc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20006f00:	2301      	movs	r3, #1
20006f02:	e02e      	b.n	20006f62 <HAL_I2C_Slave_Transmit_DMA+0x152>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
20006f04:	68fb      	ldr	r3, [r7, #12]
20006f06:	681b      	ldr	r3, [r3, #0]
20006f08:	685a      	ldr	r2, [r3, #4]
20006f0a:	68fb      	ldr	r3, [r7, #12]
20006f0c:	681b      	ldr	r3, [r3, #0]
20006f0e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20006f12:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20006f14:	68fb      	ldr	r3, [r7, #12]
20006f16:	2200      	movs	r2, #0
20006f18:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
20006f1c:	2104      	movs	r1, #4
20006f1e:	68f8      	ldr	r0, [r7, #12]
20006f20:	f003 fab6 	bl	2000a490 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
20006f24:	68fb      	ldr	r3, [r7, #12]
20006f26:	681b      	ldr	r3, [r3, #0]
20006f28:	681a      	ldr	r2, [r3, #0]
20006f2a:	68fb      	ldr	r3, [r7, #12]
20006f2c:	681b      	ldr	r3, [r3, #0]
20006f2e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20006f32:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
20006f34:	2300      	movs	r3, #0
20006f36:	e014      	b.n	20006f62 <HAL_I2C_Slave_Transmit_DMA+0x152>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
20006f38:	68fb      	ldr	r3, [r7, #12]
20006f3a:	2228      	movs	r2, #40	; 0x28
20006f3c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20006f40:	68fb      	ldr	r3, [r7, #12]
20006f42:	2200      	movs	r2, #0
20006f44:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
20006f48:	68fb      	ldr	r3, [r7, #12]
20006f4a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006f4c:	f043 0210 	orr.w	r2, r3, #16
20006f50:	68fb      	ldr	r3, [r7, #12]
20006f52:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20006f54:	68fb      	ldr	r3, [r7, #12]
20006f56:	2200      	movs	r2, #0
20006f58:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20006f5c:	2301      	movs	r3, #1
20006f5e:	e000      	b.n	20006f62 <HAL_I2C_Slave_Transmit_DMA+0x152>
  }
  else
  {
    return HAL_BUSY;
20006f60:	2302      	movs	r3, #2
  }
}
20006f62:	4618      	mov	r0, r3
20006f64:	3718      	adds	r7, #24
20006f66:	46bd      	mov	sp, r7
20006f68:	bd80      	pop	{r7, pc}
20006f6a:	bf00      	nop
20006f6c:	ffff0000 	.word	0xffff0000
20006f70:	20009479 	.word	0x20009479
20006f74:	20009f3f 	.word	0x20009f3f
20006f78:	2000a05b 	.word	0x2000a05b

20006f7c <HAL_I2C_Slave_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
20006f7c:	b580      	push	{r7, lr}
20006f7e:	b086      	sub	sp, #24
20006f80:	af00      	add	r7, sp, #0
20006f82:	60f8      	str	r0, [r7, #12]
20006f84:	60b9      	str	r1, [r7, #8]
20006f86:	4613      	mov	r3, r2
20006f88:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
20006f8a:	68fb      	ldr	r3, [r7, #12]
20006f8c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006f90:	b2db      	uxtb	r3, r3
20006f92:	2b20      	cmp	r3, #32
20006f94:	f040 809a 	bne.w	200070cc <HAL_I2C_Slave_Receive_DMA+0x150>
  {
    if ((pData == NULL) || (Size == 0U))
20006f98:	68bb      	ldr	r3, [r7, #8]
20006f9a:	2b00      	cmp	r3, #0
20006f9c:	d002      	beq.n	20006fa4 <HAL_I2C_Slave_Receive_DMA+0x28>
20006f9e:	88fb      	ldrh	r3, [r7, #6]
20006fa0:	2b00      	cmp	r3, #0
20006fa2:	d105      	bne.n	20006fb0 <HAL_I2C_Slave_Receive_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
20006fa4:	68fb      	ldr	r3, [r7, #12]
20006fa6:	f44f 7200 	mov.w	r2, #512	; 0x200
20006faa:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
20006fac:	2301      	movs	r3, #1
20006fae:	e08e      	b.n	200070ce <HAL_I2C_Slave_Receive_DMA+0x152>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
20006fb0:	68fb      	ldr	r3, [r7, #12]
20006fb2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006fb6:	2b01      	cmp	r3, #1
20006fb8:	d101      	bne.n	20006fbe <HAL_I2C_Slave_Receive_DMA+0x42>
20006fba:	2302      	movs	r3, #2
20006fbc:	e087      	b.n	200070ce <HAL_I2C_Slave_Receive_DMA+0x152>
20006fbe:	68fb      	ldr	r3, [r7, #12]
20006fc0:	2201      	movs	r2, #1
20006fc2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
20006fc6:	68fb      	ldr	r3, [r7, #12]
20006fc8:	2222      	movs	r2, #34	; 0x22
20006fca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
20006fce:	68fb      	ldr	r3, [r7, #12]
20006fd0:	2220      	movs	r2, #32
20006fd2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
20006fd6:	68fb      	ldr	r3, [r7, #12]
20006fd8:	2200      	movs	r2, #0
20006fda:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20006fdc:	68fb      	ldr	r3, [r7, #12]
20006fde:	68ba      	ldr	r2, [r7, #8]
20006fe0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20006fe2:	68fb      	ldr	r3, [r7, #12]
20006fe4:	88fa      	ldrh	r2, [r7, #6]
20006fe6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
20006fe8:	68fb      	ldr	r3, [r7, #12]
20006fea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20006fec:	b29a      	uxth	r2, r3
20006fee:	68fb      	ldr	r3, [r7, #12]
20006ff0:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20006ff2:	68fb      	ldr	r3, [r7, #12]
20006ff4:	4a38      	ldr	r2, [pc, #224]	; (200070d8 <HAL_I2C_Slave_Receive_DMA+0x15c>)
20006ff6:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
20006ff8:	68fb      	ldr	r3, [r7, #12]
20006ffa:	4a38      	ldr	r2, [pc, #224]	; (200070dc <HAL_I2C_Slave_Receive_DMA+0x160>)
20006ffc:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
20006ffe:	68fb      	ldr	r3, [r7, #12]
20007000:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007002:	2b00      	cmp	r3, #0
20007004:	d020      	beq.n	20007048 <HAL_I2C_Slave_Receive_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
20007006:	68fb      	ldr	r3, [r7, #12]
20007008:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000700a:	4a35      	ldr	r2, [pc, #212]	; (200070e0 <HAL_I2C_Slave_Receive_DMA+0x164>)
2000700c:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2000700e:	68fb      	ldr	r3, [r7, #12]
20007010:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007012:	4a34      	ldr	r2, [pc, #208]	; (200070e4 <HAL_I2C_Slave_Receive_DMA+0x168>)
20007014:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
20007016:	68fb      	ldr	r3, [r7, #12]
20007018:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000701a:	2200      	movs	r2, #0
2000701c:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2000701e:	68fb      	ldr	r3, [r7, #12]
20007020:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007022:	2200      	movs	r2, #0
20007024:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
20007026:	68fb      	ldr	r3, [r7, #12]
20007028:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000702a:	68fb      	ldr	r3, [r7, #12]
2000702c:	681b      	ldr	r3, [r3, #0]
2000702e:	3324      	adds	r3, #36	; 0x24
20007030:	4619      	mov	r1, r3
20007032:	68ba      	ldr	r2, [r7, #8]
20007034:	68fb      	ldr	r3, [r7, #12]
20007036:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007038:	f7fb fca9 	bl	2000298e <HAL_DMA_Start_IT>
2000703c:	4603      	mov	r3, r0
2000703e:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
20007040:	7dfb      	ldrb	r3, [r7, #23]
20007042:	2b00      	cmp	r3, #0
20007044:	d12e      	bne.n	200070a4 <HAL_I2C_Slave_Receive_DMA+0x128>
20007046:	e013      	b.n	20007070 <HAL_I2C_Slave_Receive_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
20007048:	68fb      	ldr	r3, [r7, #12]
2000704a:	2228      	movs	r2, #40	; 0x28
2000704c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20007050:	68fb      	ldr	r3, [r7, #12]
20007052:	2200      	movs	r2, #0
20007054:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
20007058:	68fb      	ldr	r3, [r7, #12]
2000705a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000705c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
20007060:	68fb      	ldr	r3, [r7, #12]
20007062:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20007064:	68fb      	ldr	r3, [r7, #12]
20007066:	2200      	movs	r2, #0
20007068:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000706c:	2301      	movs	r3, #1
2000706e:	e02e      	b.n	200070ce <HAL_I2C_Slave_Receive_DMA+0x152>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
20007070:	68fb      	ldr	r3, [r7, #12]
20007072:	681b      	ldr	r3, [r3, #0]
20007074:	685a      	ldr	r2, [r3, #4]
20007076:	68fb      	ldr	r3, [r7, #12]
20007078:	681b      	ldr	r3, [r3, #0]
2000707a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000707e:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20007080:	68fb      	ldr	r3, [r7, #12]
20007082:	2200      	movs	r2, #0
20007084:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
20007088:	2104      	movs	r1, #4
2000708a:	68f8      	ldr	r0, [r7, #12]
2000708c:	f003 fa00 	bl	2000a490 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
20007090:	68fb      	ldr	r3, [r7, #12]
20007092:	681b      	ldr	r3, [r3, #0]
20007094:	681a      	ldr	r2, [r3, #0]
20007096:	68fb      	ldr	r3, [r7, #12]
20007098:	681b      	ldr	r3, [r3, #0]
2000709a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000709e:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
200070a0:	2300      	movs	r3, #0
200070a2:	e014      	b.n	200070ce <HAL_I2C_Slave_Receive_DMA+0x152>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
200070a4:	68fb      	ldr	r3, [r7, #12]
200070a6:	2228      	movs	r2, #40	; 0x28
200070a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
200070ac:	68fb      	ldr	r3, [r7, #12]
200070ae:	2200      	movs	r2, #0
200070b0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
200070b4:	68fb      	ldr	r3, [r7, #12]
200070b6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200070b8:	f043 0210 	orr.w	r2, r3, #16
200070bc:	68fb      	ldr	r3, [r7, #12]
200070be:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
200070c0:	68fb      	ldr	r3, [r7, #12]
200070c2:	2200      	movs	r2, #0
200070c4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
200070c8:	2301      	movs	r3, #1
200070ca:	e000      	b.n	200070ce <HAL_I2C_Slave_Receive_DMA+0x152>
  }
  else
  {
    return HAL_BUSY;
200070cc:	2302      	movs	r3, #2
  }
}
200070ce:	4618      	mov	r0, r3
200070d0:	3718      	adds	r7, #24
200070d2:	46bd      	mov	sp, r7
200070d4:	bd80      	pop	{r7, pc}
200070d6:	bf00      	nop
200070d8:	ffff0000 	.word	0xffff0000
200070dc:	20009479 	.word	0x20009479
200070e0:	2000a015 	.word	0x2000a015
200070e4:	2000a05b 	.word	0x2000a05b

200070e8 <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
200070e8:	b580      	push	{r7, lr}
200070ea:	b088      	sub	sp, #32
200070ec:	af02      	add	r7, sp, #8
200070ee:	60f8      	str	r0, [r7, #12]
200070f0:	4608      	mov	r0, r1
200070f2:	4611      	mov	r1, r2
200070f4:	461a      	mov	r2, r3
200070f6:	4603      	mov	r3, r0
200070f8:	817b      	strh	r3, [r7, #10]
200070fa:	460b      	mov	r3, r1
200070fc:	813b      	strh	r3, [r7, #8]
200070fe:	4613      	mov	r3, r2
20007100:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
20007102:	68fb      	ldr	r3, [r7, #12]
20007104:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007108:	b2db      	uxtb	r3, r3
2000710a:	2b20      	cmp	r3, #32
2000710c:	f040 80f9 	bne.w	20007302 <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
20007110:	6a3b      	ldr	r3, [r7, #32]
20007112:	2b00      	cmp	r3, #0
20007114:	d002      	beq.n	2000711c <HAL_I2C_Mem_Write+0x34>
20007116:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
20007118:	2b00      	cmp	r3, #0
2000711a:	d105      	bne.n	20007128 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000711c:	68fb      	ldr	r3, [r7, #12]
2000711e:	f44f 7200 	mov.w	r2, #512	; 0x200
20007122:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
20007124:	2301      	movs	r3, #1
20007126:	e0ed      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20007128:	68fb      	ldr	r3, [r7, #12]
2000712a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000712e:	2b01      	cmp	r3, #1
20007130:	d101      	bne.n	20007136 <HAL_I2C_Mem_Write+0x4e>
20007132:	2302      	movs	r3, #2
20007134:	e0e6      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
20007136:	68fb      	ldr	r3, [r7, #12]
20007138:	2201      	movs	r2, #1
2000713a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2000713e:	f7fa fe1f 	bl	20001d80 <HAL_GetTick>
20007142:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
20007144:	697b      	ldr	r3, [r7, #20]
20007146:	9300      	str	r3, [sp, #0]
20007148:	2319      	movs	r3, #25
2000714a:	2201      	movs	r2, #1
2000714c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
20007150:	68f8      	ldr	r0, [r7, #12]
20007152:	f002 ffe0 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20007156:	4603      	mov	r3, r0
20007158:	2b00      	cmp	r3, #0
2000715a:	d001      	beq.n	20007160 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
2000715c:	2301      	movs	r3, #1
2000715e:	e0d1      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
20007160:	68fb      	ldr	r3, [r7, #12]
20007162:	2221      	movs	r2, #33	; 0x21
20007164:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
20007168:	68fb      	ldr	r3, [r7, #12]
2000716a:	2240      	movs	r2, #64	; 0x40
2000716c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20007170:	68fb      	ldr	r3, [r7, #12]
20007172:	2200      	movs	r2, #0
20007174:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
20007176:	68fb      	ldr	r3, [r7, #12]
20007178:	6a3a      	ldr	r2, [r7, #32]
2000717a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2000717c:	68fb      	ldr	r3, [r7, #12]
2000717e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
20007180:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
20007182:	68fb      	ldr	r3, [r7, #12]
20007184:	2200      	movs	r2, #0
20007186:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
20007188:	88f8      	ldrh	r0, [r7, #6]
2000718a:	893a      	ldrh	r2, [r7, #8]
2000718c:	8979      	ldrh	r1, [r7, #10]
2000718e:	697b      	ldr	r3, [r7, #20]
20007190:	9301      	str	r3, [sp, #4]
20007192:	6abb      	ldr	r3, [r7, #40]	; 0x28
20007194:	9300      	str	r3, [sp, #0]
20007196:	4603      	mov	r3, r0
20007198:	68f8      	ldr	r0, [r7, #12]
2000719a:	f002 fa37 	bl	2000960c <I2C_RequestMemoryWrite>
2000719e:	4603      	mov	r3, r0
200071a0:	2b00      	cmp	r3, #0
200071a2:	d005      	beq.n	200071b0 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
200071a4:	68fb      	ldr	r3, [r7, #12]
200071a6:	2200      	movs	r2, #0
200071a8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
200071ac:	2301      	movs	r3, #1
200071ae:	e0a9      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200071b0:	68fb      	ldr	r3, [r7, #12]
200071b2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200071b4:	b29b      	uxth	r3, r3
200071b6:	2bff      	cmp	r3, #255	; 0xff
200071b8:	d90e      	bls.n	200071d8 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
200071ba:	68fb      	ldr	r3, [r7, #12]
200071bc:	22ff      	movs	r2, #255	; 0xff
200071be:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
200071c0:	68fb      	ldr	r3, [r7, #12]
200071c2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200071c4:	b2da      	uxtb	r2, r3
200071c6:	8979      	ldrh	r1, [r7, #10]
200071c8:	2300      	movs	r3, #0
200071ca:	9300      	str	r3, [sp, #0]
200071cc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200071d0:	68f8      	ldr	r0, [r7, #12]
200071d2:	f003 f92f 	bl	2000a434 <I2C_TransferConfig>
200071d6:	e00f      	b.n	200071f8 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
200071d8:	68fb      	ldr	r3, [r7, #12]
200071da:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200071dc:	b29a      	uxth	r2, r3
200071de:	68fb      	ldr	r3, [r7, #12]
200071e0:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
200071e2:	68fb      	ldr	r3, [r7, #12]
200071e4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200071e6:	b2da      	uxtb	r2, r3
200071e8:	8979      	ldrh	r1, [r7, #10]
200071ea:	2300      	movs	r3, #0
200071ec:	9300      	str	r3, [sp, #0]
200071ee:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
200071f2:	68f8      	ldr	r0, [r7, #12]
200071f4:	f003 f91e 	bl	2000a434 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
200071f8:	697a      	ldr	r2, [r7, #20]
200071fa:	6ab9      	ldr	r1, [r7, #40]	; 0x28
200071fc:	68f8      	ldr	r0, [r7, #12]
200071fe:	f002 ffca 	bl	2000a196 <I2C_WaitOnTXISFlagUntilTimeout>
20007202:	4603      	mov	r3, r0
20007204:	2b00      	cmp	r3, #0
20007206:	d001      	beq.n	2000720c <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
20007208:	2301      	movs	r3, #1
2000720a:	e07b      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2000720c:	68fb      	ldr	r3, [r7, #12]
2000720e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20007210:	781a      	ldrb	r2, [r3, #0]
20007212:	68fb      	ldr	r3, [r7, #12]
20007214:	681b      	ldr	r3, [r3, #0]
20007216:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
20007218:	68fb      	ldr	r3, [r7, #12]
2000721a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000721c:	1c5a      	adds	r2, r3, #1
2000721e:	68fb      	ldr	r3, [r7, #12]
20007220:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
20007222:	68fb      	ldr	r3, [r7, #12]
20007224:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007226:	b29b      	uxth	r3, r3
20007228:	3b01      	subs	r3, #1
2000722a:	b29a      	uxth	r2, r3
2000722c:	68fb      	ldr	r3, [r7, #12]
2000722e:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
20007230:	68fb      	ldr	r3, [r7, #12]
20007232:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007234:	3b01      	subs	r3, #1
20007236:	b29a      	uxth	r2, r3
20007238:	68fb      	ldr	r3, [r7, #12]
2000723a:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000723c:	68fb      	ldr	r3, [r7, #12]
2000723e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007240:	b29b      	uxth	r3, r3
20007242:	2b00      	cmp	r3, #0
20007244:	d034      	beq.n	200072b0 <HAL_I2C_Mem_Write+0x1c8>
20007246:	68fb      	ldr	r3, [r7, #12]
20007248:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000724a:	2b00      	cmp	r3, #0
2000724c:	d130      	bne.n	200072b0 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2000724e:	697b      	ldr	r3, [r7, #20]
20007250:	9300      	str	r3, [sp, #0]
20007252:	6abb      	ldr	r3, [r7, #40]	; 0x28
20007254:	2200      	movs	r2, #0
20007256:	2180      	movs	r1, #128	; 0x80
20007258:	68f8      	ldr	r0, [r7, #12]
2000725a:	f002 ff5c 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
2000725e:	4603      	mov	r3, r0
20007260:	2b00      	cmp	r3, #0
20007262:	d001      	beq.n	20007268 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
20007264:	2301      	movs	r3, #1
20007266:	e04d      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
20007268:	68fb      	ldr	r3, [r7, #12]
2000726a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000726c:	b29b      	uxth	r3, r3
2000726e:	2bff      	cmp	r3, #255	; 0xff
20007270:	d90e      	bls.n	20007290 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
20007272:	68fb      	ldr	r3, [r7, #12]
20007274:	22ff      	movs	r2, #255	; 0xff
20007276:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
20007278:	68fb      	ldr	r3, [r7, #12]
2000727a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000727c:	b2da      	uxtb	r2, r3
2000727e:	8979      	ldrh	r1, [r7, #10]
20007280:	2300      	movs	r3, #0
20007282:	9300      	str	r3, [sp, #0]
20007284:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20007288:	68f8      	ldr	r0, [r7, #12]
2000728a:	f003 f8d3 	bl	2000a434 <I2C_TransferConfig>
2000728e:	e00f      	b.n	200072b0 <HAL_I2C_Mem_Write+0x1c8>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
20007290:	68fb      	ldr	r3, [r7, #12]
20007292:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007294:	b29a      	uxth	r2, r3
20007296:	68fb      	ldr	r3, [r7, #12]
20007298:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2000729a:	68fb      	ldr	r3, [r7, #12]
2000729c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000729e:	b2da      	uxtb	r2, r3
200072a0:	8979      	ldrh	r1, [r7, #10]
200072a2:	2300      	movs	r3, #0
200072a4:	9300      	str	r3, [sp, #0]
200072a6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
200072aa:	68f8      	ldr	r0, [r7, #12]
200072ac:	f003 f8c2 	bl	2000a434 <I2C_TransferConfig>
        }
      }

    }
    while (hi2c->XferCount > 0U);
200072b0:	68fb      	ldr	r3, [r7, #12]
200072b2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200072b4:	b29b      	uxth	r3, r3
200072b6:	2b00      	cmp	r3, #0
200072b8:	d19e      	bne.n	200071f8 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
200072ba:	697a      	ldr	r2, [r7, #20]
200072bc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
200072be:	68f8      	ldr	r0, [r7, #12]
200072c0:	f002 ffa9 	bl	2000a216 <I2C_WaitOnSTOPFlagUntilTimeout>
200072c4:	4603      	mov	r3, r0
200072c6:	2b00      	cmp	r3, #0
200072c8:	d001      	beq.n	200072ce <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
200072ca:	2301      	movs	r3, #1
200072cc:	e01a      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
200072ce:	68fb      	ldr	r3, [r7, #12]
200072d0:	681b      	ldr	r3, [r3, #0]
200072d2:	2220      	movs	r2, #32
200072d4:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
200072d6:	68fb      	ldr	r3, [r7, #12]
200072d8:	681b      	ldr	r3, [r3, #0]
200072da:	6859      	ldr	r1, [r3, #4]
200072dc:	68fb      	ldr	r3, [r7, #12]
200072de:	681a      	ldr	r2, [r3, #0]
200072e0:	4b0a      	ldr	r3, [pc, #40]	; (2000730c <HAL_I2C_Mem_Write+0x224>)
200072e2:	400b      	ands	r3, r1
200072e4:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
200072e6:	68fb      	ldr	r3, [r7, #12]
200072e8:	2220      	movs	r2, #32
200072ea:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
200072ee:	68fb      	ldr	r3, [r7, #12]
200072f0:	2200      	movs	r2, #0
200072f2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
200072f6:	68fb      	ldr	r3, [r7, #12]
200072f8:	2200      	movs	r2, #0
200072fa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
200072fe:	2300      	movs	r3, #0
20007300:	e000      	b.n	20007304 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
20007302:	2302      	movs	r3, #2
  }
}
20007304:	4618      	mov	r0, r3
20007306:	3718      	adds	r7, #24
20007308:	46bd      	mov	sp, r7
2000730a:	bd80      	pop	{r7, pc}
2000730c:	fe00e800 	.word	0xfe00e800

20007310 <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
20007310:	b580      	push	{r7, lr}
20007312:	b088      	sub	sp, #32
20007314:	af02      	add	r7, sp, #8
20007316:	60f8      	str	r0, [r7, #12]
20007318:	4608      	mov	r0, r1
2000731a:	4611      	mov	r1, r2
2000731c:	461a      	mov	r2, r3
2000731e:	4603      	mov	r3, r0
20007320:	817b      	strh	r3, [r7, #10]
20007322:	460b      	mov	r3, r1
20007324:	813b      	strh	r3, [r7, #8]
20007326:	4613      	mov	r3, r2
20007328:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2000732a:	68fb      	ldr	r3, [r7, #12]
2000732c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007330:	b2db      	uxtb	r3, r3
20007332:	2b20      	cmp	r3, #32
20007334:	f040 80fd 	bne.w	20007532 <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
20007338:	6a3b      	ldr	r3, [r7, #32]
2000733a:	2b00      	cmp	r3, #0
2000733c:	d002      	beq.n	20007344 <HAL_I2C_Mem_Read+0x34>
2000733e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
20007340:	2b00      	cmp	r3, #0
20007342:	d105      	bne.n	20007350 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
20007344:	68fb      	ldr	r3, [r7, #12]
20007346:	f44f 7200 	mov.w	r2, #512	; 0x200
2000734a:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000734c:	2301      	movs	r3, #1
2000734e:	e0f1      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20007350:	68fb      	ldr	r3, [r7, #12]
20007352:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20007356:	2b01      	cmp	r3, #1
20007358:	d101      	bne.n	2000735e <HAL_I2C_Mem_Read+0x4e>
2000735a:	2302      	movs	r3, #2
2000735c:	e0ea      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
2000735e:	68fb      	ldr	r3, [r7, #12]
20007360:	2201      	movs	r2, #1
20007362:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
20007366:	f7fa fd0b 	bl	20001d80 <HAL_GetTick>
2000736a:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2000736c:	697b      	ldr	r3, [r7, #20]
2000736e:	9300      	str	r3, [sp, #0]
20007370:	2319      	movs	r3, #25
20007372:	2201      	movs	r2, #1
20007374:	f44f 4100 	mov.w	r1, #32768	; 0x8000
20007378:	68f8      	ldr	r0, [r7, #12]
2000737a:	f002 fecc 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
2000737e:	4603      	mov	r3, r0
20007380:	2b00      	cmp	r3, #0
20007382:	d001      	beq.n	20007388 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
20007384:	2301      	movs	r3, #1
20007386:	e0d5      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
20007388:	68fb      	ldr	r3, [r7, #12]
2000738a:	2222      	movs	r2, #34	; 0x22
2000738c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
20007390:	68fb      	ldr	r3, [r7, #12]
20007392:	2240      	movs	r2, #64	; 0x40
20007394:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20007398:	68fb      	ldr	r3, [r7, #12]
2000739a:	2200      	movs	r2, #0
2000739c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2000739e:	68fb      	ldr	r3, [r7, #12]
200073a0:	6a3a      	ldr	r2, [r7, #32]
200073a2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
200073a4:	68fb      	ldr	r3, [r7, #12]
200073a6:	8cba      	ldrh	r2, [r7, #36]	; 0x24
200073a8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
200073aa:	68fb      	ldr	r3, [r7, #12]
200073ac:	2200      	movs	r2, #0
200073ae:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
200073b0:	88f8      	ldrh	r0, [r7, #6]
200073b2:	893a      	ldrh	r2, [r7, #8]
200073b4:	8979      	ldrh	r1, [r7, #10]
200073b6:	697b      	ldr	r3, [r7, #20]
200073b8:	9301      	str	r3, [sp, #4]
200073ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
200073bc:	9300      	str	r3, [sp, #0]
200073be:	4603      	mov	r3, r0
200073c0:	68f8      	ldr	r0, [r7, #12]
200073c2:	f002 f977 	bl	200096b4 <I2C_RequestMemoryRead>
200073c6:	4603      	mov	r3, r0
200073c8:	2b00      	cmp	r3, #0
200073ca:	d005      	beq.n	200073d8 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
200073cc:	68fb      	ldr	r3, [r7, #12]
200073ce:	2200      	movs	r2, #0
200073d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
200073d4:	2301      	movs	r3, #1
200073d6:	e0ad      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200073d8:	68fb      	ldr	r3, [r7, #12]
200073da:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200073dc:	b29b      	uxth	r3, r3
200073de:	2bff      	cmp	r3, #255	; 0xff
200073e0:	d90e      	bls.n	20007400 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
200073e2:	68fb      	ldr	r3, [r7, #12]
200073e4:	22ff      	movs	r2, #255	; 0xff
200073e6:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
200073e8:	68fb      	ldr	r3, [r7, #12]
200073ea:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200073ec:	b2da      	uxtb	r2, r3
200073ee:	8979      	ldrh	r1, [r7, #10]
200073f0:	4b52      	ldr	r3, [pc, #328]	; (2000753c <HAL_I2C_Mem_Read+0x22c>)
200073f2:	9300      	str	r3, [sp, #0]
200073f4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200073f8:	68f8      	ldr	r0, [r7, #12]
200073fa:	f003 f81b 	bl	2000a434 <I2C_TransferConfig>
200073fe:	e00f      	b.n	20007420 <HAL_I2C_Mem_Read+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20007400:	68fb      	ldr	r3, [r7, #12]
20007402:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007404:	b29a      	uxth	r2, r3
20007406:	68fb      	ldr	r3, [r7, #12]
20007408:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2000740a:	68fb      	ldr	r3, [r7, #12]
2000740c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000740e:	b2da      	uxtb	r2, r3
20007410:	8979      	ldrh	r1, [r7, #10]
20007412:	4b4a      	ldr	r3, [pc, #296]	; (2000753c <HAL_I2C_Mem_Read+0x22c>)
20007414:	9300      	str	r3, [sp, #0]
20007416:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000741a:	68f8      	ldr	r0, [r7, #12]
2000741c:	f003 f80a 	bl	2000a434 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
20007420:	697b      	ldr	r3, [r7, #20]
20007422:	9300      	str	r3, [sp, #0]
20007424:	6abb      	ldr	r3, [r7, #40]	; 0x28
20007426:	2200      	movs	r2, #0
20007428:	2104      	movs	r1, #4
2000742a:	68f8      	ldr	r0, [r7, #12]
2000742c:	f002 fe73 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20007430:	4603      	mov	r3, r0
20007432:	2b00      	cmp	r3, #0
20007434:	d001      	beq.n	2000743a <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
20007436:	2301      	movs	r3, #1
20007438:	e07c      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2000743a:	68fb      	ldr	r3, [r7, #12]
2000743c:	681b      	ldr	r3, [r3, #0]
2000743e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20007440:	68fb      	ldr	r3, [r7, #12]
20007442:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20007444:	b2d2      	uxtb	r2, r2
20007446:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
20007448:	68fb      	ldr	r3, [r7, #12]
2000744a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000744c:	1c5a      	adds	r2, r3, #1
2000744e:	68fb      	ldr	r3, [r7, #12]
20007450:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
20007452:	68fb      	ldr	r3, [r7, #12]
20007454:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007456:	3b01      	subs	r3, #1
20007458:	b29a      	uxth	r2, r3
2000745a:	68fb      	ldr	r3, [r7, #12]
2000745c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2000745e:	68fb      	ldr	r3, [r7, #12]
20007460:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007462:	b29b      	uxth	r3, r3
20007464:	3b01      	subs	r3, #1
20007466:	b29a      	uxth	r2, r3
20007468:	68fb      	ldr	r3, [r7, #12]
2000746a:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2000746c:	68fb      	ldr	r3, [r7, #12]
2000746e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007470:	b29b      	uxth	r3, r3
20007472:	2b00      	cmp	r3, #0
20007474:	d034      	beq.n	200074e0 <HAL_I2C_Mem_Read+0x1d0>
20007476:	68fb      	ldr	r3, [r7, #12]
20007478:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000747a:	2b00      	cmp	r3, #0
2000747c:	d130      	bne.n	200074e0 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2000747e:	697b      	ldr	r3, [r7, #20]
20007480:	9300      	str	r3, [sp, #0]
20007482:	6abb      	ldr	r3, [r7, #40]	; 0x28
20007484:	2200      	movs	r2, #0
20007486:	2180      	movs	r1, #128	; 0x80
20007488:	68f8      	ldr	r0, [r7, #12]
2000748a:	f002 fe44 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
2000748e:	4603      	mov	r3, r0
20007490:	2b00      	cmp	r3, #0
20007492:	d001      	beq.n	20007498 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
20007494:	2301      	movs	r3, #1
20007496:	e04d      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
20007498:	68fb      	ldr	r3, [r7, #12]
2000749a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000749c:	b29b      	uxth	r3, r3
2000749e:	2bff      	cmp	r3, #255	; 0xff
200074a0:	d90e      	bls.n	200074c0 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
200074a2:	68fb      	ldr	r3, [r7, #12]
200074a4:	22ff      	movs	r2, #255	; 0xff
200074a6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
200074a8:	68fb      	ldr	r3, [r7, #12]
200074aa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200074ac:	b2da      	uxtb	r2, r3
200074ae:	8979      	ldrh	r1, [r7, #10]
200074b0:	2300      	movs	r3, #0
200074b2:	9300      	str	r3, [sp, #0]
200074b4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200074b8:	68f8      	ldr	r0, [r7, #12]
200074ba:	f002 ffbb 	bl	2000a434 <I2C_TransferConfig>
200074be:	e00f      	b.n	200074e0 <HAL_I2C_Mem_Read+0x1d0>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
200074c0:	68fb      	ldr	r3, [r7, #12]
200074c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200074c4:	b29a      	uxth	r2, r3
200074c6:	68fb      	ldr	r3, [r7, #12]
200074c8:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
200074ca:	68fb      	ldr	r3, [r7, #12]
200074cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200074ce:	b2da      	uxtb	r2, r3
200074d0:	8979      	ldrh	r1, [r7, #10]
200074d2:	2300      	movs	r3, #0
200074d4:	9300      	str	r3, [sp, #0]
200074d6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
200074da:	68f8      	ldr	r0, [r7, #12]
200074dc:	f002 ffaa 	bl	2000a434 <I2C_TransferConfig>
        }
      }
    }
    while (hi2c->XferCount > 0U);
200074e0:	68fb      	ldr	r3, [r7, #12]
200074e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200074e4:	b29b      	uxth	r3, r3
200074e6:	2b00      	cmp	r3, #0
200074e8:	d19a      	bne.n	20007420 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
200074ea:	697a      	ldr	r2, [r7, #20]
200074ec:	6ab9      	ldr	r1, [r7, #40]	; 0x28
200074ee:	68f8      	ldr	r0, [r7, #12]
200074f0:	f002 fe91 	bl	2000a216 <I2C_WaitOnSTOPFlagUntilTimeout>
200074f4:	4603      	mov	r3, r0
200074f6:	2b00      	cmp	r3, #0
200074f8:	d001      	beq.n	200074fe <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
200074fa:	2301      	movs	r3, #1
200074fc:	e01a      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
200074fe:	68fb      	ldr	r3, [r7, #12]
20007500:	681b      	ldr	r3, [r3, #0]
20007502:	2220      	movs	r2, #32
20007504:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
20007506:	68fb      	ldr	r3, [r7, #12]
20007508:	681b      	ldr	r3, [r3, #0]
2000750a:	6859      	ldr	r1, [r3, #4]
2000750c:	68fb      	ldr	r3, [r7, #12]
2000750e:	681a      	ldr	r2, [r3, #0]
20007510:	4b0b      	ldr	r3, [pc, #44]	; (20007540 <HAL_I2C_Mem_Read+0x230>)
20007512:	400b      	ands	r3, r1
20007514:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
20007516:	68fb      	ldr	r3, [r7, #12]
20007518:	2220      	movs	r2, #32
2000751a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2000751e:	68fb      	ldr	r3, [r7, #12]
20007520:	2200      	movs	r2, #0
20007522:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20007526:	68fb      	ldr	r3, [r7, #12]
20007528:	2200      	movs	r2, #0
2000752a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000752e:	2300      	movs	r3, #0
20007530:	e000      	b.n	20007534 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
20007532:	2302      	movs	r3, #2
  }
}
20007534:	4618      	mov	r0, r3
20007536:	3718      	adds	r7, #24
20007538:	46bd      	mov	sp, r7
2000753a:	bd80      	pop	{r7, pc}
2000753c:	80002400 	.word	0x80002400
20007540:	fe00e800 	.word	0xfe00e800

20007544 <HAL_I2C_Mem_Write_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
20007544:	b580      	push	{r7, lr}
20007546:	b088      	sub	sp, #32
20007548:	af02      	add	r7, sp, #8
2000754a:	60f8      	str	r0, [r7, #12]
2000754c:	4608      	mov	r0, r1
2000754e:	4611      	mov	r1, r2
20007550:	461a      	mov	r2, r3
20007552:	4603      	mov	r3, r0
20007554:	817b      	strh	r3, [r7, #10]
20007556:	460b      	mov	r3, r1
20007558:	813b      	strh	r3, [r7, #8]
2000755a:	4613      	mov	r3, r2
2000755c:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2000755e:	68fb      	ldr	r3, [r7, #12]
20007560:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007564:	b2db      	uxtb	r3, r3
20007566:	2b20      	cmp	r3, #32
20007568:	d176      	bne.n	20007658 <HAL_I2C_Mem_Write_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
2000756a:	6a3b      	ldr	r3, [r7, #32]
2000756c:	2b00      	cmp	r3, #0
2000756e:	d002      	beq.n	20007576 <HAL_I2C_Mem_Write_IT+0x32>
20007570:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
20007572:	2b00      	cmp	r3, #0
20007574:	d105      	bne.n	20007582 <HAL_I2C_Mem_Write_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
20007576:	68fb      	ldr	r3, [r7, #12]
20007578:	f44f 7200 	mov.w	r2, #512	; 0x200
2000757c:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000757e:	2301      	movs	r3, #1
20007580:	e06b      	b.n	2000765a <HAL_I2C_Mem_Write_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
20007582:	68fb      	ldr	r3, [r7, #12]
20007584:	681b      	ldr	r3, [r3, #0]
20007586:	699b      	ldr	r3, [r3, #24]
20007588:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000758c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20007590:	d101      	bne.n	20007596 <HAL_I2C_Mem_Write_IT+0x52>
    {
      return HAL_BUSY;
20007592:	2302      	movs	r3, #2
20007594:	e061      	b.n	2000765a <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20007596:	68fb      	ldr	r3, [r7, #12]
20007598:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000759c:	2b01      	cmp	r3, #1
2000759e:	d101      	bne.n	200075a4 <HAL_I2C_Mem_Write_IT+0x60>
200075a0:	2302      	movs	r3, #2
200075a2:	e05a      	b.n	2000765a <HAL_I2C_Mem_Write_IT+0x116>
200075a4:	68fb      	ldr	r3, [r7, #12]
200075a6:	2201      	movs	r2, #1
200075a8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
200075ac:	f7fa fbe8 	bl	20001d80 <HAL_GetTick>
200075b0:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
200075b2:	68fb      	ldr	r3, [r7, #12]
200075b4:	2221      	movs	r2, #33	; 0x21
200075b6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
200075ba:	68fb      	ldr	r3, [r7, #12]
200075bc:	2240      	movs	r2, #64	; 0x40
200075be:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
200075c2:	68fb      	ldr	r3, [r7, #12]
200075c4:	2200      	movs	r2, #0
200075c6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
200075c8:	68fb      	ldr	r3, [r7, #12]
200075ca:	6a3a      	ldr	r2, [r7, #32]
200075cc:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
200075ce:	68fb      	ldr	r3, [r7, #12]
200075d0:	8cba      	ldrh	r2, [r7, #36]	; 0x24
200075d2:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
200075d4:	68fb      	ldr	r3, [r7, #12]
200075d6:	4a23      	ldr	r2, [pc, #140]	; (20007664 <HAL_I2C_Mem_Write_IT+0x120>)
200075d8:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
200075da:	68fb      	ldr	r3, [r7, #12]
200075dc:	4a22      	ldr	r2, [pc, #136]	; (20007668 <HAL_I2C_Mem_Write_IT+0x124>)
200075de:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200075e0:	68fb      	ldr	r3, [r7, #12]
200075e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200075e4:	b29b      	uxth	r3, r3
200075e6:	2bff      	cmp	r3, #255	; 0xff
200075e8:	d906      	bls.n	200075f8 <HAL_I2C_Mem_Write_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
200075ea:	68fb      	ldr	r3, [r7, #12]
200075ec:	22ff      	movs	r2, #255	; 0xff
200075ee:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
200075f0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
200075f4:	617b      	str	r3, [r7, #20]
200075f6:	e007      	b.n	20007608 <HAL_I2C_Mem_Write_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
200075f8:	68fb      	ldr	r3, [r7, #12]
200075fa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200075fc:	b29a      	uxth	r2, r3
200075fe:	68fb      	ldr	r3, [r7, #12]
20007600:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
20007602:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20007606:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
20007608:	88f8      	ldrh	r0, [r7, #6]
2000760a:	893a      	ldrh	r2, [r7, #8]
2000760c:	8979      	ldrh	r1, [r7, #10]
2000760e:	693b      	ldr	r3, [r7, #16]
20007610:	9301      	str	r3, [sp, #4]
20007612:	2319      	movs	r3, #25
20007614:	9300      	str	r3, [sp, #0]
20007616:	4603      	mov	r3, r0
20007618:	68f8      	ldr	r0, [r7, #12]
2000761a:	f001 fff7 	bl	2000960c <I2C_RequestMemoryWrite>
2000761e:	4603      	mov	r3, r0
20007620:	2b00      	cmp	r3, #0
20007622:	d005      	beq.n	20007630 <HAL_I2C_Mem_Write_IT+0xec>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20007624:	68fb      	ldr	r3, [r7, #12]
20007626:	2200      	movs	r2, #0
20007628:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000762c:	2301      	movs	r3, #1
2000762e:	e014      	b.n	2000765a <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
20007630:	68fb      	ldr	r3, [r7, #12]
20007632:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007634:	b2da      	uxtb	r2, r3
20007636:	8979      	ldrh	r1, [r7, #10]
20007638:	2300      	movs	r3, #0
2000763a:	9300      	str	r3, [sp, #0]
2000763c:	697b      	ldr	r3, [r7, #20]
2000763e:	68f8      	ldr	r0, [r7, #12]
20007640:	f002 fef8 	bl	2000a434 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20007644:	68fb      	ldr	r3, [r7, #12]
20007646:	2200      	movs	r2, #0
20007648:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2000764c:	2101      	movs	r1, #1
2000764e:	68f8      	ldr	r0, [r7, #12]
20007650:	f002 ff1e 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20007654:	2300      	movs	r3, #0
20007656:	e000      	b.n	2000765a <HAL_I2C_Mem_Write_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
20007658:	2302      	movs	r3, #2
  }
}
2000765a:	4618      	mov	r0, r3
2000765c:	3718      	adds	r7, #24
2000765e:	46bd      	mov	sp, r7
20007660:	bd80      	pop	{r7, pc}
20007662:	bf00      	nop
20007664:	ffff0000 	.word	0xffff0000
20007668:	20008e33 	.word	0x20008e33

2000766c <HAL_I2C_Mem_Read_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2000766c:	b580      	push	{r7, lr}
2000766e:	b088      	sub	sp, #32
20007670:	af02      	add	r7, sp, #8
20007672:	60f8      	str	r0, [r7, #12]
20007674:	4608      	mov	r0, r1
20007676:	4611      	mov	r1, r2
20007678:	461a      	mov	r2, r3
2000767a:	4603      	mov	r3, r0
2000767c:	817b      	strh	r3, [r7, #10]
2000767e:	460b      	mov	r3, r1
20007680:	813b      	strh	r3, [r7, #8]
20007682:	4613      	mov	r3, r2
20007684:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
20007686:	68fb      	ldr	r3, [r7, #12]
20007688:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000768c:	b2db      	uxtb	r3, r3
2000768e:	2b20      	cmp	r3, #32
20007690:	d176      	bne.n	20007780 <HAL_I2C_Mem_Read_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
20007692:	6a3b      	ldr	r3, [r7, #32]
20007694:	2b00      	cmp	r3, #0
20007696:	d002      	beq.n	2000769e <HAL_I2C_Mem_Read_IT+0x32>
20007698:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2000769a:	2b00      	cmp	r3, #0
2000769c:	d105      	bne.n	200076aa <HAL_I2C_Mem_Read_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2000769e:	68fb      	ldr	r3, [r7, #12]
200076a0:	f44f 7200 	mov.w	r2, #512	; 0x200
200076a4:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
200076a6:	2301      	movs	r3, #1
200076a8:	e06b      	b.n	20007782 <HAL_I2C_Mem_Read_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
200076aa:	68fb      	ldr	r3, [r7, #12]
200076ac:	681b      	ldr	r3, [r3, #0]
200076ae:	699b      	ldr	r3, [r3, #24]
200076b0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
200076b4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200076b8:	d101      	bne.n	200076be <HAL_I2C_Mem_Read_IT+0x52>
    {
      return HAL_BUSY;
200076ba:	2302      	movs	r3, #2
200076bc:	e061      	b.n	20007782 <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
200076be:	68fb      	ldr	r3, [r7, #12]
200076c0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200076c4:	2b01      	cmp	r3, #1
200076c6:	d101      	bne.n	200076cc <HAL_I2C_Mem_Read_IT+0x60>
200076c8:	2302      	movs	r3, #2
200076ca:	e05a      	b.n	20007782 <HAL_I2C_Mem_Read_IT+0x116>
200076cc:	68fb      	ldr	r3, [r7, #12]
200076ce:	2201      	movs	r2, #1
200076d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
200076d4:	f7fa fb54 	bl	20001d80 <HAL_GetTick>
200076d8:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
200076da:	68fb      	ldr	r3, [r7, #12]
200076dc:	2222      	movs	r2, #34	; 0x22
200076de:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
200076e2:	68fb      	ldr	r3, [r7, #12]
200076e4:	2240      	movs	r2, #64	; 0x40
200076e6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
200076ea:	68fb      	ldr	r3, [r7, #12]
200076ec:	2200      	movs	r2, #0
200076ee:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
200076f0:	68fb      	ldr	r3, [r7, #12]
200076f2:	6a3a      	ldr	r2, [r7, #32]
200076f4:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
200076f6:	68fb      	ldr	r3, [r7, #12]
200076f8:	8cba      	ldrh	r2, [r7, #36]	; 0x24
200076fa:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
200076fc:	68fb      	ldr	r3, [r7, #12]
200076fe:	4a23      	ldr	r2, [pc, #140]	; (2000778c <HAL_I2C_Mem_Read_IT+0x120>)
20007700:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
20007702:	68fb      	ldr	r3, [r7, #12]
20007704:	4a22      	ldr	r2, [pc, #136]	; (20007790 <HAL_I2C_Mem_Read_IT+0x124>)
20007706:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20007708:	68fb      	ldr	r3, [r7, #12]
2000770a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000770c:	b29b      	uxth	r3, r3
2000770e:	2bff      	cmp	r3, #255	; 0xff
20007710:	d906      	bls.n	20007720 <HAL_I2C_Mem_Read_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20007712:	68fb      	ldr	r3, [r7, #12]
20007714:	22ff      	movs	r2, #255	; 0xff
20007716:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20007718:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000771c:	617b      	str	r3, [r7, #20]
2000771e:	e007      	b.n	20007730 <HAL_I2C_Mem_Read_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20007720:	68fb      	ldr	r3, [r7, #12]
20007722:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007724:	b29a      	uxth	r2, r3
20007726:	68fb      	ldr	r3, [r7, #12]
20007728:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2000772a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000772e:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
20007730:	88f8      	ldrh	r0, [r7, #6]
20007732:	893a      	ldrh	r2, [r7, #8]
20007734:	8979      	ldrh	r1, [r7, #10]
20007736:	693b      	ldr	r3, [r7, #16]
20007738:	9301      	str	r3, [sp, #4]
2000773a:	2319      	movs	r3, #25
2000773c:	9300      	str	r3, [sp, #0]
2000773e:	4603      	mov	r3, r0
20007740:	68f8      	ldr	r0, [r7, #12]
20007742:	f001 ffb7 	bl	200096b4 <I2C_RequestMemoryRead>
20007746:	4603      	mov	r3, r0
20007748:	2b00      	cmp	r3, #0
2000774a:	d005      	beq.n	20007758 <HAL_I2C_Mem_Read_IT+0xec>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000774c:	68fb      	ldr	r3, [r7, #12]
2000774e:	2200      	movs	r2, #0
20007750:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20007754:	2301      	movs	r3, #1
20007756:	e014      	b.n	20007782 <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
20007758:	68fb      	ldr	r3, [r7, #12]
2000775a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000775c:	b2da      	uxtb	r2, r3
2000775e:	8979      	ldrh	r1, [r7, #10]
20007760:	4b0c      	ldr	r3, [pc, #48]	; (20007794 <HAL_I2C_Mem_Read_IT+0x128>)
20007762:	9300      	str	r3, [sp, #0]
20007764:	697b      	ldr	r3, [r7, #20]
20007766:	68f8      	ldr	r0, [r7, #12]
20007768:	f002 fe64 	bl	2000a434 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000776c:	68fb      	ldr	r3, [r7, #12]
2000776e:	2200      	movs	r2, #0
20007770:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
20007774:	2102      	movs	r1, #2
20007776:	68f8      	ldr	r0, [r7, #12]
20007778:	f002 fe8a 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
2000777c:	2300      	movs	r3, #0
2000777e:	e000      	b.n	20007782 <HAL_I2C_Mem_Read_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
20007780:	2302      	movs	r3, #2
  }
}
20007782:	4618      	mov	r0, r3
20007784:	3718      	adds	r7, #24
20007786:	46bd      	mov	sp, r7
20007788:	bd80      	pop	{r7, pc}
2000778a:	bf00      	nop
2000778c:	ffff0000 	.word	0xffff0000
20007790:	20008e33 	.word	0x20008e33
20007794:	80002400 	.word	0x80002400

20007798 <HAL_I2C_Mem_Write_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
20007798:	b580      	push	{r7, lr}
2000779a:	b08a      	sub	sp, #40	; 0x28
2000779c:	af02      	add	r7, sp, #8
2000779e:	60f8      	str	r0, [r7, #12]
200077a0:	4608      	mov	r0, r1
200077a2:	4611      	mov	r1, r2
200077a4:	461a      	mov	r2, r3
200077a6:	4603      	mov	r3, r0
200077a8:	817b      	strh	r3, [r7, #10]
200077aa:	460b      	mov	r3, r1
200077ac:	813b      	strh	r3, [r7, #8]
200077ae:	4613      	mov	r3, r2
200077b0:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
200077b2:	68fb      	ldr	r3, [r7, #12]
200077b4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200077b8:	b2db      	uxtb	r3, r3
200077ba:	2b20      	cmp	r3, #32
200077bc:	f040 80d5 	bne.w	2000796a <HAL_I2C_Mem_Write_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
200077c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
200077c2:	2b00      	cmp	r3, #0
200077c4:	d002      	beq.n	200077cc <HAL_I2C_Mem_Write_DMA+0x34>
200077c6:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
200077c8:	2b00      	cmp	r3, #0
200077ca:	d105      	bne.n	200077d8 <HAL_I2C_Mem_Write_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
200077cc:	68fb      	ldr	r3, [r7, #12]
200077ce:	f44f 7200 	mov.w	r2, #512	; 0x200
200077d2:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
200077d4:	2301      	movs	r3, #1
200077d6:	e0c9      	b.n	2000796c <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
200077d8:	68fb      	ldr	r3, [r7, #12]
200077da:	681b      	ldr	r3, [r3, #0]
200077dc:	699b      	ldr	r3, [r3, #24]
200077de:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
200077e2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200077e6:	d101      	bne.n	200077ec <HAL_I2C_Mem_Write_DMA+0x54>
    {
      return HAL_BUSY;
200077e8:	2302      	movs	r3, #2
200077ea:	e0bf      	b.n	2000796c <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
200077ec:	68fb      	ldr	r3, [r7, #12]
200077ee:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200077f2:	2b01      	cmp	r3, #1
200077f4:	d101      	bne.n	200077fa <HAL_I2C_Mem_Write_DMA+0x62>
200077f6:	2302      	movs	r3, #2
200077f8:	e0b8      	b.n	2000796c <HAL_I2C_Mem_Write_DMA+0x1d4>
200077fa:	68fb      	ldr	r3, [r7, #12]
200077fc:	2201      	movs	r2, #1
200077fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
20007802:	f7fa fabd 	bl	20001d80 <HAL_GetTick>
20007806:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
20007808:	68fb      	ldr	r3, [r7, #12]
2000780a:	2221      	movs	r2, #33	; 0x21
2000780c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
20007810:	68fb      	ldr	r3, [r7, #12]
20007812:	2240      	movs	r2, #64	; 0x40
20007814:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
20007818:	68fb      	ldr	r3, [r7, #12]
2000781a:	2200      	movs	r2, #0
2000781c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2000781e:	68fb      	ldr	r3, [r7, #12]
20007820:	6aba      	ldr	r2, [r7, #40]	; 0x28
20007822:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20007824:	68fb      	ldr	r3, [r7, #12]
20007826:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
20007828:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2000782a:	68fb      	ldr	r3, [r7, #12]
2000782c:	4a51      	ldr	r2, [pc, #324]	; (20007974 <HAL_I2C_Mem_Write_DMA+0x1dc>)
2000782e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
20007830:	68fb      	ldr	r3, [r7, #12]
20007832:	4a51      	ldr	r2, [pc, #324]	; (20007978 <HAL_I2C_Mem_Write_DMA+0x1e0>)
20007834:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20007836:	68fb      	ldr	r3, [r7, #12]
20007838:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000783a:	b29b      	uxth	r3, r3
2000783c:	2bff      	cmp	r3, #255	; 0xff
2000783e:	d906      	bls.n	2000784e <HAL_I2C_Mem_Write_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20007840:	68fb      	ldr	r3, [r7, #12]
20007842:	22ff      	movs	r2, #255	; 0xff
20007844:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20007846:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000784a:	61fb      	str	r3, [r7, #28]
2000784c:	e007      	b.n	2000785e <HAL_I2C_Mem_Write_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000784e:	68fb      	ldr	r3, [r7, #12]
20007850:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007852:	b29a      	uxth	r2, r3
20007854:	68fb      	ldr	r3, [r7, #12]
20007856:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
20007858:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000785c:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2000785e:	88f8      	ldrh	r0, [r7, #6]
20007860:	893a      	ldrh	r2, [r7, #8]
20007862:	8979      	ldrh	r1, [r7, #10]
20007864:	69bb      	ldr	r3, [r7, #24]
20007866:	9301      	str	r3, [sp, #4]
20007868:	2319      	movs	r3, #25
2000786a:	9300      	str	r3, [sp, #0]
2000786c:	4603      	mov	r3, r0
2000786e:	68f8      	ldr	r0, [r7, #12]
20007870:	f001 fecc 	bl	2000960c <I2C_RequestMemoryWrite>
20007874:	4603      	mov	r3, r0
20007876:	2b00      	cmp	r3, #0
20007878:	d005      	beq.n	20007886 <HAL_I2C_Mem_Write_DMA+0xee>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000787a:	68fb      	ldr	r3, [r7, #12]
2000787c:	2200      	movs	r2, #0
2000787e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20007882:	2301      	movs	r3, #1
20007884:	e072      	b.n	2000796c <HAL_I2C_Mem_Write_DMA+0x1d4>
    }


    if (hi2c->hdmatx != NULL)
20007886:	68fb      	ldr	r3, [r7, #12]
20007888:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000788a:	2b00      	cmp	r3, #0
2000788c:	d020      	beq.n	200078d0 <HAL_I2C_Mem_Write_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2000788e:	68fb      	ldr	r3, [r7, #12]
20007890:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20007892:	4a3a      	ldr	r2, [pc, #232]	; (2000797c <HAL_I2C_Mem_Write_DMA+0x1e4>)
20007894:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
20007896:	68fb      	ldr	r3, [r7, #12]
20007898:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000789a:	4a39      	ldr	r2, [pc, #228]	; (20007980 <HAL_I2C_Mem_Write_DMA+0x1e8>)
2000789c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2000789e:	68fb      	ldr	r3, [r7, #12]
200078a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200078a2:	2200      	movs	r2, #0
200078a4:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
200078a6:	68fb      	ldr	r3, [r7, #12]
200078a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200078aa:	2200      	movs	r2, #0
200078ac:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
200078ae:	68fb      	ldr	r3, [r7, #12]
200078b0:	6b98      	ldr	r0, [r3, #56]	; 0x38
200078b2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
200078b4:	68fb      	ldr	r3, [r7, #12]
200078b6:	681b      	ldr	r3, [r3, #0]
200078b8:	3328      	adds	r3, #40	; 0x28
200078ba:	461a      	mov	r2, r3
200078bc:	68fb      	ldr	r3, [r7, #12]
200078be:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200078c0:	f7fb f865 	bl	2000298e <HAL_DMA_Start_IT>
200078c4:	4603      	mov	r3, r0
200078c6:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
200078c8:	7dfb      	ldrb	r3, [r7, #23]
200078ca:	2b00      	cmp	r3, #0
200078cc:	d139      	bne.n	20007942 <HAL_I2C_Mem_Write_DMA+0x1aa>
200078ce:	e013      	b.n	200078f8 <HAL_I2C_Mem_Write_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
200078d0:	68fb      	ldr	r3, [r7, #12]
200078d2:	2220      	movs	r2, #32
200078d4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
200078d8:	68fb      	ldr	r3, [r7, #12]
200078da:	2200      	movs	r2, #0
200078dc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
200078e0:	68fb      	ldr	r3, [r7, #12]
200078e2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200078e4:	f043 0280 	orr.w	r2, r3, #128	; 0x80
200078e8:	68fb      	ldr	r3, [r7, #12]
200078ea:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
200078ec:	68fb      	ldr	r3, [r7, #12]
200078ee:	2200      	movs	r2, #0
200078f0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
200078f4:	2301      	movs	r3, #1
200078f6:	e039      	b.n	2000796c <HAL_I2C_Mem_Write_DMA+0x1d4>
    {
      /* Send Slave Address */
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
200078f8:	68fb      	ldr	r3, [r7, #12]
200078fa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200078fc:	b2da      	uxtb	r2, r3
200078fe:	8979      	ldrh	r1, [r7, #10]
20007900:	2300      	movs	r3, #0
20007902:	9300      	str	r3, [sp, #0]
20007904:	69fb      	ldr	r3, [r7, #28]
20007906:	68f8      	ldr	r0, [r7, #12]
20007908:	f002 fd94 	bl	2000a434 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2000790c:	68fb      	ldr	r3, [r7, #12]
2000790e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007910:	b29a      	uxth	r2, r3
20007912:	68fb      	ldr	r3, [r7, #12]
20007914:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007916:	1ad3      	subs	r3, r2, r3
20007918:	b29a      	uxth	r2, r3
2000791a:	68fb      	ldr	r3, [r7, #12]
2000791c:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000791e:	68fb      	ldr	r3, [r7, #12]
20007920:	2200      	movs	r2, #0
20007922:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
20007926:	2111      	movs	r1, #17
20007928:	68f8      	ldr	r0, [r7, #12]
2000792a:	f002 fdb1 	bl	2000a490 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2000792e:	68fb      	ldr	r3, [r7, #12]
20007930:	681b      	ldr	r3, [r3, #0]
20007932:	681a      	ldr	r2, [r3, #0]
20007934:	68fb      	ldr	r3, [r7, #12]
20007936:	681b      	ldr	r3, [r3, #0]
20007938:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000793c:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2000793e:	2300      	movs	r3, #0
20007940:	e014      	b.n	2000796c <HAL_I2C_Mem_Write_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
20007942:	68fb      	ldr	r3, [r7, #12]
20007944:	2220      	movs	r2, #32
20007946:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2000794a:	68fb      	ldr	r3, [r7, #12]
2000794c:	2200      	movs	r2, #0
2000794e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
20007952:	68fb      	ldr	r3, [r7, #12]
20007954:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20007956:	f043 0210 	orr.w	r2, r3, #16
2000795a:	68fb      	ldr	r3, [r7, #12]
2000795c:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2000795e:	68fb      	ldr	r3, [r7, #12]
20007960:	2200      	movs	r2, #0
20007962:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20007966:	2301      	movs	r3, #1
20007968:	e000      	b.n	2000796c <HAL_I2C_Mem_Write_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
2000796a:	2302      	movs	r3, #2
  }
}
2000796c:	4618      	mov	r0, r3
2000796e:	3720      	adds	r7, #32
20007970:	46bd      	mov	sp, r7
20007972:	bd80      	pop	{r7, pc}
20007974:	ffff0000 	.word	0xffff0000
20007978:	20009293 	.word	0x20009293
2000797c:	20009ea9 	.word	0x20009ea9
20007980:	2000a05b 	.word	0x2000a05b

20007984 <HAL_I2C_Mem_Read_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
20007984:	b580      	push	{r7, lr}
20007986:	b08a      	sub	sp, #40	; 0x28
20007988:	af02      	add	r7, sp, #8
2000798a:	60f8      	str	r0, [r7, #12]
2000798c:	4608      	mov	r0, r1
2000798e:	4611      	mov	r1, r2
20007990:	461a      	mov	r2, r3
20007992:	4603      	mov	r3, r0
20007994:	817b      	strh	r3, [r7, #10]
20007996:	460b      	mov	r3, r1
20007998:	813b      	strh	r3, [r7, #8]
2000799a:	4613      	mov	r3, r2
2000799c:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2000799e:	68fb      	ldr	r3, [r7, #12]
200079a0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200079a4:	b2db      	uxtb	r3, r3
200079a6:	2b20      	cmp	r3, #32
200079a8:	f040 80d5 	bne.w	20007b56 <HAL_I2C_Mem_Read_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
200079ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
200079ae:	2b00      	cmp	r3, #0
200079b0:	d002      	beq.n	200079b8 <HAL_I2C_Mem_Read_DMA+0x34>
200079b2:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
200079b4:	2b00      	cmp	r3, #0
200079b6:	d105      	bne.n	200079c4 <HAL_I2C_Mem_Read_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
200079b8:	68fb      	ldr	r3, [r7, #12]
200079ba:	f44f 7200 	mov.w	r2, #512	; 0x200
200079be:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
200079c0:	2301      	movs	r3, #1
200079c2:	e0c9      	b.n	20007b58 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
200079c4:	68fb      	ldr	r3, [r7, #12]
200079c6:	681b      	ldr	r3, [r3, #0]
200079c8:	699b      	ldr	r3, [r3, #24]
200079ca:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
200079ce:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200079d2:	d101      	bne.n	200079d8 <HAL_I2C_Mem_Read_DMA+0x54>
    {
      return HAL_BUSY;
200079d4:	2302      	movs	r3, #2
200079d6:	e0bf      	b.n	20007b58 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
200079d8:	68fb      	ldr	r3, [r7, #12]
200079da:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200079de:	2b01      	cmp	r3, #1
200079e0:	d101      	bne.n	200079e6 <HAL_I2C_Mem_Read_DMA+0x62>
200079e2:	2302      	movs	r3, #2
200079e4:	e0b8      	b.n	20007b58 <HAL_I2C_Mem_Read_DMA+0x1d4>
200079e6:	68fb      	ldr	r3, [r7, #12]
200079e8:	2201      	movs	r2, #1
200079ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
200079ee:	f7fa f9c7 	bl	20001d80 <HAL_GetTick>
200079f2:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
200079f4:	68fb      	ldr	r3, [r7, #12]
200079f6:	2222      	movs	r2, #34	; 0x22
200079f8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
200079fc:	68fb      	ldr	r3, [r7, #12]
200079fe:	2240      	movs	r2, #64	; 0x40
20007a00:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
20007a04:	68fb      	ldr	r3, [r7, #12]
20007a06:	2200      	movs	r2, #0
20007a08:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20007a0a:	68fb      	ldr	r3, [r7, #12]
20007a0c:	6aba      	ldr	r2, [r7, #40]	; 0x28
20007a0e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20007a10:	68fb      	ldr	r3, [r7, #12]
20007a12:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
20007a14:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20007a16:	68fb      	ldr	r3, [r7, #12]
20007a18:	4a51      	ldr	r2, [pc, #324]	; (20007b60 <HAL_I2C_Mem_Read_DMA+0x1dc>)
20007a1a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
20007a1c:	68fb      	ldr	r3, [r7, #12]
20007a1e:	4a51      	ldr	r2, [pc, #324]	; (20007b64 <HAL_I2C_Mem_Read_DMA+0x1e0>)
20007a20:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20007a22:	68fb      	ldr	r3, [r7, #12]
20007a24:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007a26:	b29b      	uxth	r3, r3
20007a28:	2bff      	cmp	r3, #255	; 0xff
20007a2a:	d906      	bls.n	20007a3a <HAL_I2C_Mem_Read_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20007a2c:	68fb      	ldr	r3, [r7, #12]
20007a2e:	22ff      	movs	r2, #255	; 0xff
20007a30:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20007a32:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20007a36:	61fb      	str	r3, [r7, #28]
20007a38:	e007      	b.n	20007a4a <HAL_I2C_Mem_Read_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20007a3a:	68fb      	ldr	r3, [r7, #12]
20007a3c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007a3e:	b29a      	uxth	r2, r3
20007a40:	68fb      	ldr	r3, [r7, #12]
20007a42:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
20007a44:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20007a48:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
20007a4a:	88f8      	ldrh	r0, [r7, #6]
20007a4c:	893a      	ldrh	r2, [r7, #8]
20007a4e:	8979      	ldrh	r1, [r7, #10]
20007a50:	69bb      	ldr	r3, [r7, #24]
20007a52:	9301      	str	r3, [sp, #4]
20007a54:	2319      	movs	r3, #25
20007a56:	9300      	str	r3, [sp, #0]
20007a58:	4603      	mov	r3, r0
20007a5a:	68f8      	ldr	r0, [r7, #12]
20007a5c:	f001 fe2a 	bl	200096b4 <I2C_RequestMemoryRead>
20007a60:	4603      	mov	r3, r0
20007a62:	2b00      	cmp	r3, #0
20007a64:	d005      	beq.n	20007a72 <HAL_I2C_Mem_Read_DMA+0xee>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20007a66:	68fb      	ldr	r3, [r7, #12]
20007a68:	2200      	movs	r2, #0
20007a6a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20007a6e:	2301      	movs	r3, #1
20007a70:	e072      	b.n	20007b58 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (hi2c->hdmarx != NULL)
20007a72:	68fb      	ldr	r3, [r7, #12]
20007a74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007a76:	2b00      	cmp	r3, #0
20007a78:	d020      	beq.n	20007abc <HAL_I2C_Mem_Read_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
20007a7a:	68fb      	ldr	r3, [r7, #12]
20007a7c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007a7e:	4a3a      	ldr	r2, [pc, #232]	; (20007b68 <HAL_I2C_Mem_Read_DMA+0x1e4>)
20007a80:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
20007a82:	68fb      	ldr	r3, [r7, #12]
20007a84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007a86:	4a39      	ldr	r2, [pc, #228]	; (20007b6c <HAL_I2C_Mem_Read_DMA+0x1e8>)
20007a88:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
20007a8a:	68fb      	ldr	r3, [r7, #12]
20007a8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007a8e:	2200      	movs	r2, #0
20007a90:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
20007a92:	68fb      	ldr	r3, [r7, #12]
20007a94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007a96:	2200      	movs	r2, #0
20007a98:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
20007a9a:	68fb      	ldr	r3, [r7, #12]
20007a9c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
20007a9e:	68fb      	ldr	r3, [r7, #12]
20007aa0:	681b      	ldr	r3, [r3, #0]
20007aa2:	3324      	adds	r3, #36	; 0x24
20007aa4:	4619      	mov	r1, r3
20007aa6:	6aba      	ldr	r2, [r7, #40]	; 0x28
20007aa8:	68fb      	ldr	r3, [r7, #12]
20007aaa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007aac:	f7fa ff6f 	bl	2000298e <HAL_DMA_Start_IT>
20007ab0:	4603      	mov	r3, r0
20007ab2:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
20007ab4:	7dfb      	ldrb	r3, [r7, #23]
20007ab6:	2b00      	cmp	r3, #0
20007ab8:	d139      	bne.n	20007b2e <HAL_I2C_Mem_Read_DMA+0x1aa>
20007aba:	e013      	b.n	20007ae4 <HAL_I2C_Mem_Read_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
20007abc:	68fb      	ldr	r3, [r7, #12]
20007abe:	2220      	movs	r2, #32
20007ac0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20007ac4:	68fb      	ldr	r3, [r7, #12]
20007ac6:	2200      	movs	r2, #0
20007ac8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
20007acc:	68fb      	ldr	r3, [r7, #12]
20007ace:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20007ad0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
20007ad4:	68fb      	ldr	r3, [r7, #12]
20007ad6:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20007ad8:	68fb      	ldr	r3, [r7, #12]
20007ada:	2200      	movs	r2, #0
20007adc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20007ae0:	2301      	movs	r3, #1
20007ae2:	e039      	b.n	20007b58 <HAL_I2C_Mem_Read_DMA+0x1d4>
    {
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
20007ae4:	68fb      	ldr	r3, [r7, #12]
20007ae6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007ae8:	b2da      	uxtb	r2, r3
20007aea:	8979      	ldrh	r1, [r7, #10]
20007aec:	4b20      	ldr	r3, [pc, #128]	; (20007b70 <HAL_I2C_Mem_Read_DMA+0x1ec>)
20007aee:	9300      	str	r3, [sp, #0]
20007af0:	69fb      	ldr	r3, [r7, #28]
20007af2:	68f8      	ldr	r0, [r7, #12]
20007af4:	f002 fc9e 	bl	2000a434 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
20007af8:	68fb      	ldr	r3, [r7, #12]
20007afa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007afc:	b29a      	uxth	r2, r3
20007afe:	68fb      	ldr	r3, [r7, #12]
20007b00:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007b02:	1ad3      	subs	r3, r2, r3
20007b04:	b29a      	uxth	r2, r3
20007b06:	68fb      	ldr	r3, [r7, #12]
20007b08:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20007b0a:	68fb      	ldr	r3, [r7, #12]
20007b0c:	2200      	movs	r2, #0
20007b0e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
20007b12:	2111      	movs	r1, #17
20007b14:	68f8      	ldr	r0, [r7, #12]
20007b16:	f002 fcbb 	bl	2000a490 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
20007b1a:	68fb      	ldr	r3, [r7, #12]
20007b1c:	681b      	ldr	r3, [r3, #0]
20007b1e:	681a      	ldr	r2, [r3, #0]
20007b20:	68fb      	ldr	r3, [r7, #12]
20007b22:	681b      	ldr	r3, [r3, #0]
20007b24:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20007b28:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
20007b2a:	2300      	movs	r3, #0
20007b2c:	e014      	b.n	20007b58 <HAL_I2C_Mem_Read_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
20007b2e:	68fb      	ldr	r3, [r7, #12]
20007b30:	2220      	movs	r2, #32
20007b32:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20007b36:	68fb      	ldr	r3, [r7, #12]
20007b38:	2200      	movs	r2, #0
20007b3a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
20007b3e:	68fb      	ldr	r3, [r7, #12]
20007b40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20007b42:	f043 0210 	orr.w	r2, r3, #16
20007b46:	68fb      	ldr	r3, [r7, #12]
20007b48:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20007b4a:	68fb      	ldr	r3, [r7, #12]
20007b4c:	2200      	movs	r2, #0
20007b4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20007b52:	2301      	movs	r3, #1
20007b54:	e000      	b.n	20007b58 <HAL_I2C_Mem_Read_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
20007b56:	2302      	movs	r3, #2
  }
}
20007b58:	4618      	mov	r0, r3
20007b5a:	3720      	adds	r7, #32
20007b5c:	46bd      	mov	sp, r7
20007b5e:	bd80      	pop	{r7, pc}
20007b60:	ffff0000 	.word	0xffff0000
20007b64:	20009293 	.word	0x20009293
20007b68:	20009f7f 	.word	0x20009f7f
20007b6c:	2000a05b 	.word	0x2000a05b
20007b70:	80002400 	.word	0x80002400

20007b74 <HAL_I2C_IsDeviceReady>:
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
{
20007b74:	b580      	push	{r7, lr}
20007b76:	b08a      	sub	sp, #40	; 0x28
20007b78:	af02      	add	r7, sp, #8
20007b7a:	60f8      	str	r0, [r7, #12]
20007b7c:	607a      	str	r2, [r7, #4]
20007b7e:	603b      	str	r3, [r7, #0]
20007b80:	460b      	mov	r3, r1
20007b82:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart;

  __IO uint32_t I2C_Trials = 0UL;
20007b84:	2300      	movs	r3, #0
20007b86:	617b      	str	r3, [r7, #20]

  FlagStatus tmp1;
  FlagStatus tmp2;

  if (hi2c->State == HAL_I2C_STATE_READY)
20007b88:	68fb      	ldr	r3, [r7, #12]
20007b8a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007b8e:	b2db      	uxtb	r3, r3
20007b90:	2b20      	cmp	r3, #32
20007b92:	f040 80ef 	bne.w	20007d74 <HAL_I2C_IsDeviceReady+0x200>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
20007b96:	68fb      	ldr	r3, [r7, #12]
20007b98:	681b      	ldr	r3, [r3, #0]
20007b9a:	699b      	ldr	r3, [r3, #24]
20007b9c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
20007ba0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20007ba4:	d101      	bne.n	20007baa <HAL_I2C_IsDeviceReady+0x36>
    {
      return HAL_BUSY;
20007ba6:	2302      	movs	r3, #2
20007ba8:	e0e5      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20007baa:	68fb      	ldr	r3, [r7, #12]
20007bac:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20007bb0:	2b01      	cmp	r3, #1
20007bb2:	d101      	bne.n	20007bb8 <HAL_I2C_IsDeviceReady+0x44>
20007bb4:	2302      	movs	r3, #2
20007bb6:	e0de      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
20007bb8:	68fb      	ldr	r3, [r7, #12]
20007bba:	2201      	movs	r2, #1
20007bbc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
20007bc0:	68fb      	ldr	r3, [r7, #12]
20007bc2:	2224      	movs	r2, #36	; 0x24
20007bc4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20007bc8:	68fb      	ldr	r3, [r7, #12]
20007bca:	2200      	movs	r2, #0
20007bcc:	645a      	str	r2, [r3, #68]	; 0x44

    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
20007bce:	68fb      	ldr	r3, [r7, #12]
20007bd0:	68db      	ldr	r3, [r3, #12]
20007bd2:	2b01      	cmp	r3, #1
20007bd4:	d105      	bne.n	20007be2 <HAL_I2C_IsDeviceReady+0x6e>
20007bd6:	897b      	ldrh	r3, [r7, #10]
20007bd8:	f3c3 0209 	ubfx	r2, r3, #0, #10
20007bdc:	4b68      	ldr	r3, [pc, #416]	; (20007d80 <HAL_I2C_IsDeviceReady+0x20c>)
20007bde:	4313      	orrs	r3, r2
20007be0:	e004      	b.n	20007bec <HAL_I2C_IsDeviceReady+0x78>
20007be2:	897b      	ldrh	r3, [r7, #10]
20007be4:	f3c3 0309 	ubfx	r3, r3, #0, #10
20007be8:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
20007bec:	68fa      	ldr	r2, [r7, #12]
20007bee:	6812      	ldr	r2, [r2, #0]
20007bf0:	6053      	str	r3, [r2, #4]

      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
20007bf2:	f7fa f8c5 	bl	20001d80 <HAL_GetTick>
20007bf6:	61b8      	str	r0, [r7, #24]

      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
20007bf8:	68fb      	ldr	r3, [r7, #12]
20007bfa:	681b      	ldr	r3, [r3, #0]
20007bfc:	699b      	ldr	r3, [r3, #24]
20007bfe:	f003 0320 	and.w	r3, r3, #32
20007c02:	2b20      	cmp	r3, #32
20007c04:	bf0c      	ite	eq
20007c06:	2301      	moveq	r3, #1
20007c08:	2300      	movne	r3, #0
20007c0a:	b2db      	uxtb	r3, r3
20007c0c:	77fb      	strb	r3, [r7, #31]
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
20007c0e:	68fb      	ldr	r3, [r7, #12]
20007c10:	681b      	ldr	r3, [r3, #0]
20007c12:	699b      	ldr	r3, [r3, #24]
20007c14:	f003 0310 	and.w	r3, r3, #16
20007c18:	2b10      	cmp	r3, #16
20007c1a:	bf0c      	ite	eq
20007c1c:	2301      	moveq	r3, #1
20007c1e:	2300      	movne	r3, #0
20007c20:	b2db      	uxtb	r3, r3
20007c22:	77bb      	strb	r3, [r7, #30]

      while ((tmp1 == RESET) && (tmp2 == RESET))
20007c24:	e034      	b.n	20007c90 <HAL_I2C_IsDeviceReady+0x11c>
      {
        if (Timeout != HAL_MAX_DELAY)
20007c26:	683b      	ldr	r3, [r7, #0]
20007c28:	f1b3 3fff 	cmp.w	r3, #4294967295
20007c2c:	d01a      	beq.n	20007c64 <HAL_I2C_IsDeviceReady+0xf0>
        {
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
20007c2e:	f7fa f8a7 	bl	20001d80 <HAL_GetTick>
20007c32:	4602      	mov	r2, r0
20007c34:	69bb      	ldr	r3, [r7, #24]
20007c36:	1ad3      	subs	r3, r2, r3
20007c38:	683a      	ldr	r2, [r7, #0]
20007c3a:	429a      	cmp	r2, r3
20007c3c:	d302      	bcc.n	20007c44 <HAL_I2C_IsDeviceReady+0xd0>
20007c3e:	683b      	ldr	r3, [r7, #0]
20007c40:	2b00      	cmp	r3, #0
20007c42:	d10f      	bne.n	20007c64 <HAL_I2C_IsDeviceReady+0xf0>
          {
            /* Update I2C state */
            hi2c->State = HAL_I2C_STATE_READY;
20007c44:	68fb      	ldr	r3, [r7, #12]
20007c46:	2220      	movs	r2, #32
20007c48:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

            /* Update I2C error code */
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
20007c4c:	68fb      	ldr	r3, [r7, #12]
20007c4e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20007c50:	f043 0220 	orr.w	r2, r3, #32
20007c54:	68fb      	ldr	r3, [r7, #12]
20007c56:	645a      	str	r2, [r3, #68]	; 0x44

            /* Process Unlocked */
            __HAL_UNLOCK(hi2c);
20007c58:	68fb      	ldr	r3, [r7, #12]
20007c5a:	2200      	movs	r2, #0
20007c5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

            return HAL_ERROR;
20007c60:	2301      	movs	r3, #1
20007c62:	e088      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
          }
        }

        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
20007c64:	68fb      	ldr	r3, [r7, #12]
20007c66:	681b      	ldr	r3, [r3, #0]
20007c68:	699b      	ldr	r3, [r3, #24]
20007c6a:	f003 0320 	and.w	r3, r3, #32
20007c6e:	2b20      	cmp	r3, #32
20007c70:	bf0c      	ite	eq
20007c72:	2301      	moveq	r3, #1
20007c74:	2300      	movne	r3, #0
20007c76:	b2db      	uxtb	r3, r3
20007c78:	77fb      	strb	r3, [r7, #31]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
20007c7a:	68fb      	ldr	r3, [r7, #12]
20007c7c:	681b      	ldr	r3, [r3, #0]
20007c7e:	699b      	ldr	r3, [r3, #24]
20007c80:	f003 0310 	and.w	r3, r3, #16
20007c84:	2b10      	cmp	r3, #16
20007c86:	bf0c      	ite	eq
20007c88:	2301      	moveq	r3, #1
20007c8a:	2300      	movne	r3, #0
20007c8c:	b2db      	uxtb	r3, r3
20007c8e:	77bb      	strb	r3, [r7, #30]
      while ((tmp1 == RESET) && (tmp2 == RESET))
20007c90:	7ffb      	ldrb	r3, [r7, #31]
20007c92:	2b00      	cmp	r3, #0
20007c94:	d102      	bne.n	20007c9c <HAL_I2C_IsDeviceReady+0x128>
20007c96:	7fbb      	ldrb	r3, [r7, #30]
20007c98:	2b00      	cmp	r3, #0
20007c9a:	d0c4      	beq.n	20007c26 <HAL_I2C_IsDeviceReady+0xb2>
      }

      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
20007c9c:	68fb      	ldr	r3, [r7, #12]
20007c9e:	681b      	ldr	r3, [r3, #0]
20007ca0:	699b      	ldr	r3, [r3, #24]
20007ca2:	f003 0310 	and.w	r3, r3, #16
20007ca6:	2b10      	cmp	r3, #16
20007ca8:	d01a      	beq.n	20007ce0 <HAL_I2C_IsDeviceReady+0x16c>
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
20007caa:	69bb      	ldr	r3, [r7, #24]
20007cac:	9300      	str	r3, [sp, #0]
20007cae:	683b      	ldr	r3, [r7, #0]
20007cb0:	2200      	movs	r2, #0
20007cb2:	2120      	movs	r1, #32
20007cb4:	68f8      	ldr	r0, [r7, #12]
20007cb6:	f002 fa2e 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20007cba:	4603      	mov	r3, r0
20007cbc:	2b00      	cmp	r3, #0
20007cbe:	d001      	beq.n	20007cc4 <HAL_I2C_IsDeviceReady+0x150>
        {
          return HAL_ERROR;
20007cc0:	2301      	movs	r3, #1
20007cc2:	e058      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20007cc4:	68fb      	ldr	r3, [r7, #12]
20007cc6:	681b      	ldr	r3, [r3, #0]
20007cc8:	2220      	movs	r2, #32
20007cca:	61da      	str	r2, [r3, #28]

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
20007ccc:	68fb      	ldr	r3, [r7, #12]
20007cce:	2220      	movs	r2, #32
20007cd0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20007cd4:	68fb      	ldr	r3, [r7, #12]
20007cd6:	2200      	movs	r2, #0
20007cd8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_OK;
20007cdc:	2300      	movs	r3, #0
20007cde:	e04a      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
      }
      else
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
20007ce0:	69bb      	ldr	r3, [r7, #24]
20007ce2:	9300      	str	r3, [sp, #0]
20007ce4:	683b      	ldr	r3, [r7, #0]
20007ce6:	2200      	movs	r2, #0
20007ce8:	2120      	movs	r1, #32
20007cea:	68f8      	ldr	r0, [r7, #12]
20007cec:	f002 fa13 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20007cf0:	4603      	mov	r3, r0
20007cf2:	2b00      	cmp	r3, #0
20007cf4:	d001      	beq.n	20007cfa <HAL_I2C_IsDeviceReady+0x186>
        {
          return HAL_ERROR;
20007cf6:	2301      	movs	r3, #1
20007cf8:	e03d      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20007cfa:	68fb      	ldr	r3, [r7, #12]
20007cfc:	681b      	ldr	r3, [r3, #0]
20007cfe:	2210      	movs	r2, #16
20007d00:	61da      	str	r2, [r3, #28]

        /* Clear STOP Flag, auto generated with autoend*/
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20007d02:	68fb      	ldr	r3, [r7, #12]
20007d04:	681b      	ldr	r3, [r3, #0]
20007d06:	2220      	movs	r2, #32
20007d08:	61da      	str	r2, [r3, #28]
      }

      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials == Trials)
20007d0a:	697b      	ldr	r3, [r7, #20]
20007d0c:	687a      	ldr	r2, [r7, #4]
20007d0e:	429a      	cmp	r2, r3
20007d10:	d118      	bne.n	20007d44 <HAL_I2C_IsDeviceReady+0x1d0>
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
20007d12:	68fb      	ldr	r3, [r7, #12]
20007d14:	681b      	ldr	r3, [r3, #0]
20007d16:	685a      	ldr	r2, [r3, #4]
20007d18:	68fb      	ldr	r3, [r7, #12]
20007d1a:	681b      	ldr	r3, [r3, #0]
20007d1c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20007d20:	605a      	str	r2, [r3, #4]

        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
20007d22:	69bb      	ldr	r3, [r7, #24]
20007d24:	9300      	str	r3, [sp, #0]
20007d26:	683b      	ldr	r3, [r7, #0]
20007d28:	2200      	movs	r2, #0
20007d2a:	2120      	movs	r1, #32
20007d2c:	68f8      	ldr	r0, [r7, #12]
20007d2e:	f002 f9f2 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20007d32:	4603      	mov	r3, r0
20007d34:	2b00      	cmp	r3, #0
20007d36:	d001      	beq.n	20007d3c <HAL_I2C_IsDeviceReady+0x1c8>
        {
          return HAL_ERROR;
20007d38:	2301      	movs	r3, #1
20007d3a:	e01c      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20007d3c:	68fb      	ldr	r3, [r7, #12]
20007d3e:	681b      	ldr	r3, [r3, #0]
20007d40:	2220      	movs	r2, #32
20007d42:	61da      	str	r2, [r3, #28]
      }

      /* Increment Trials */
      I2C_Trials++;
20007d44:	697b      	ldr	r3, [r7, #20]
20007d46:	3301      	adds	r3, #1
20007d48:	617b      	str	r3, [r7, #20]
    }
    while (I2C_Trials < Trials);
20007d4a:	697b      	ldr	r3, [r7, #20]
20007d4c:	687a      	ldr	r2, [r7, #4]
20007d4e:	429a      	cmp	r2, r3
20007d50:	f63f af3d 	bhi.w	20007bce <HAL_I2C_IsDeviceReady+0x5a>

    /* Update I2C state */
    hi2c->State = HAL_I2C_STATE_READY;
20007d54:	68fb      	ldr	r3, [r7, #12]
20007d56:	2220      	movs	r2, #32
20007d58:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Update I2C error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
20007d5c:	68fb      	ldr	r3, [r7, #12]
20007d5e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20007d60:	f043 0220 	orr.w	r2, r3, #32
20007d64:	68fb      	ldr	r3, [r7, #12]
20007d66:	645a      	str	r2, [r3, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20007d68:	68fb      	ldr	r3, [r7, #12]
20007d6a:	2200      	movs	r2, #0
20007d6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
20007d70:	2301      	movs	r3, #1
20007d72:	e000      	b.n	20007d76 <HAL_I2C_IsDeviceReady+0x202>
  }
  else
  {
    return HAL_BUSY;
20007d74:	2302      	movs	r3, #2
  }
}
20007d76:	4618      	mov	r0, r3
20007d78:	3720      	adds	r7, #32
20007d7a:	46bd      	mov	sp, r7
20007d7c:	bd80      	pop	{r7, pc}
20007d7e:	bf00      	nop
20007d80:	02002000 	.word	0x02002000

20007d84 <HAL_I2C_Master_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
20007d84:	b580      	push	{r7, lr}
20007d86:	b088      	sub	sp, #32
20007d88:	af02      	add	r7, sp, #8
20007d8a:	60f8      	str	r0, [r7, #12]
20007d8c:	607a      	str	r2, [r7, #4]
20007d8e:	461a      	mov	r2, r3
20007d90:	460b      	mov	r3, r1
20007d92:	817b      	strh	r3, [r7, #10]
20007d94:	4613      	mov	r3, r2
20007d96:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
20007d98:	4b3a      	ldr	r3, [pc, #232]	; (20007e84 <HAL_I2C_Master_Seq_Transmit_IT+0x100>)
20007d9a:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
20007d9c:	68fb      	ldr	r3, [r7, #12]
20007d9e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007da2:	b2db      	uxtb	r3, r3
20007da4:	2b20      	cmp	r3, #32
20007da6:	d167      	bne.n	20007e78 <HAL_I2C_Master_Seq_Transmit_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20007da8:	68fb      	ldr	r3, [r7, #12]
20007daa:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20007dae:	2b01      	cmp	r3, #1
20007db0:	d101      	bne.n	20007db6 <HAL_I2C_Master_Seq_Transmit_IT+0x32>
20007db2:	2302      	movs	r3, #2
20007db4:	e061      	b.n	20007e7a <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
20007db6:	68fb      	ldr	r3, [r7, #12]
20007db8:	2201      	movs	r2, #1
20007dba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
20007dbe:	68fb      	ldr	r3, [r7, #12]
20007dc0:	2221      	movs	r2, #33	; 0x21
20007dc2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
20007dc6:	68fb      	ldr	r3, [r7, #12]
20007dc8:	2210      	movs	r2, #16
20007dca:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20007dce:	68fb      	ldr	r3, [r7, #12]
20007dd0:	2200      	movs	r2, #0
20007dd2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20007dd4:	68fb      	ldr	r3, [r7, #12]
20007dd6:	687a      	ldr	r2, [r7, #4]
20007dd8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20007dda:	68fb      	ldr	r3, [r7, #12]
20007ddc:	893a      	ldrh	r2, [r7, #8]
20007dde:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
20007de0:	68fb      	ldr	r3, [r7, #12]
20007de2:	6a3a      	ldr	r2, [r7, #32]
20007de4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
20007de6:	68fb      	ldr	r3, [r7, #12]
20007de8:	4a27      	ldr	r2, [pc, #156]	; (20007e88 <HAL_I2C_Master_Seq_Transmit_IT+0x104>)
20007dea:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20007dec:	68fb      	ldr	r3, [r7, #12]
20007dee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007df0:	b29b      	uxth	r3, r3
20007df2:	2bff      	cmp	r3, #255	; 0xff
20007df4:	d906      	bls.n	20007e04 <HAL_I2C_Master_Seq_Transmit_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20007df6:	68fb      	ldr	r3, [r7, #12]
20007df8:	22ff      	movs	r2, #255	; 0xff
20007dfa:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20007dfc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20007e00:	617b      	str	r3, [r7, #20]
20007e02:	e007      	b.n	20007e14 <HAL_I2C_Master_Seq_Transmit_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20007e04:	68fb      	ldr	r3, [r7, #12]
20007e06:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007e08:	b29a      	uxth	r2, r3
20007e0a:	68fb      	ldr	r3, [r7, #12]
20007e0c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
20007e0e:	68fb      	ldr	r3, [r7, #12]
20007e10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20007e12:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
20007e14:	68fb      	ldr	r3, [r7, #12]
20007e16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20007e18:	2b11      	cmp	r3, #17
20007e1a:	d10e      	bne.n	20007e3a <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
20007e1c:	6a3b      	ldr	r3, [r7, #32]
20007e1e:	2baa      	cmp	r3, #170	; 0xaa
20007e20:	d003      	beq.n	20007e2a <HAL_I2C_Master_Seq_Transmit_IT+0xa6>
20007e22:	6a3b      	ldr	r3, [r7, #32]
20007e24:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
20007e28:	d101      	bne.n	20007e2e <HAL_I2C_Master_Seq_Transmit_IT+0xaa>
20007e2a:	2301      	movs	r3, #1
20007e2c:	e000      	b.n	20007e30 <HAL_I2C_Master_Seq_Transmit_IT+0xac>
20007e2e:	2300      	movs	r3, #0
20007e30:	2b00      	cmp	r3, #0
20007e32:	d102      	bne.n	20007e3a <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
20007e34:	2300      	movs	r3, #0
20007e36:	613b      	str	r3, [r7, #16]
20007e38:	e00a      	b.n	20007e50 <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
20007e3a:	68f8      	ldr	r0, [r7, #12]
20007e3c:	f002 fbfb 	bl	2000a636 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
20007e40:	68fb      	ldr	r3, [r7, #12]
20007e42:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007e44:	b29b      	uxth	r3, r3
20007e46:	2bfe      	cmp	r3, #254	; 0xfe
20007e48:	d802      	bhi.n	20007e50 <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
20007e4a:	68fb      	ldr	r3, [r7, #12]
20007e4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20007e4e:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to write */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
20007e50:	68fb      	ldr	r3, [r7, #12]
20007e52:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007e54:	b2da      	uxtb	r2, r3
20007e56:	8979      	ldrh	r1, [r7, #10]
20007e58:	693b      	ldr	r3, [r7, #16]
20007e5a:	9300      	str	r3, [sp, #0]
20007e5c:	697b      	ldr	r3, [r7, #20]
20007e5e:	68f8      	ldr	r0, [r7, #12]
20007e60:	f002 fae8 	bl	2000a434 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20007e64:	68fb      	ldr	r3, [r7, #12]
20007e66:	2200      	movs	r2, #0
20007e68:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
20007e6c:	2101      	movs	r1, #1
20007e6e:	68f8      	ldr	r0, [r7, #12]
20007e70:	f002 fb0e 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20007e74:	2300      	movs	r3, #0
20007e76:	e000      	b.n	20007e7a <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
20007e78:	2302      	movs	r3, #2
  }
}
20007e7a:	4618      	mov	r0, r3
20007e7c:	3718      	adds	r7, #24
20007e7e:	46bd      	mov	sp, r7
20007e80:	bd80      	pop	{r7, pc}
20007e82:	bf00      	nop
20007e84:	80002000 	.word	0x80002000
20007e88:	20008e33 	.word	0x20008e33

20007e8c <HAL_I2C_Master_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
20007e8c:	b580      	push	{r7, lr}
20007e8e:	b08a      	sub	sp, #40	; 0x28
20007e90:	af02      	add	r7, sp, #8
20007e92:	60f8      	str	r0, [r7, #12]
20007e94:	607a      	str	r2, [r7, #4]
20007e96:	461a      	mov	r2, r3
20007e98:	460b      	mov	r3, r1
20007e9a:	817b      	strh	r3, [r7, #10]
20007e9c:	4613      	mov	r3, r2
20007e9e:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
20007ea0:	4b77      	ldr	r3, [pc, #476]	; (20008080 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
20007ea2:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
20007ea4:	68fb      	ldr	r3, [r7, #12]
20007ea6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007eaa:	b2db      	uxtb	r3, r3
20007eac:	2b20      	cmp	r3, #32
20007eae:	f040 80e1 	bne.w	20008074 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20007eb2:	68fb      	ldr	r3, [r7, #12]
20007eb4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20007eb8:	2b01      	cmp	r3, #1
20007eba:	d101      	bne.n	20007ec0 <HAL_I2C_Master_Seq_Transmit_DMA+0x34>
20007ebc:	2302      	movs	r3, #2
20007ebe:	e0da      	b.n	20008076 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
20007ec0:	68fb      	ldr	r3, [r7, #12]
20007ec2:	2201      	movs	r2, #1
20007ec4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
20007ec8:	68fb      	ldr	r3, [r7, #12]
20007eca:	2221      	movs	r2, #33	; 0x21
20007ecc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
20007ed0:	68fb      	ldr	r3, [r7, #12]
20007ed2:	2210      	movs	r2, #16
20007ed4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
20007ed8:	68fb      	ldr	r3, [r7, #12]
20007eda:	2200      	movs	r2, #0
20007edc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20007ede:	68fb      	ldr	r3, [r7, #12]
20007ee0:	687a      	ldr	r2, [r7, #4]
20007ee2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
20007ee4:	68fb      	ldr	r3, [r7, #12]
20007ee6:	893a      	ldrh	r2, [r7, #8]
20007ee8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
20007eea:	68fb      	ldr	r3, [r7, #12]
20007eec:	6aba      	ldr	r2, [r7, #40]	; 0x28
20007eee:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
20007ef0:	68fb      	ldr	r3, [r7, #12]
20007ef2:	4a64      	ldr	r2, [pc, #400]	; (20008084 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f8>)
20007ef4:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20007ef6:	68fb      	ldr	r3, [r7, #12]
20007ef8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007efa:	b29b      	uxth	r3, r3
20007efc:	2bff      	cmp	r3, #255	; 0xff
20007efe:	d906      	bls.n	20007f0e <HAL_I2C_Master_Seq_Transmit_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20007f00:	68fb      	ldr	r3, [r7, #12]
20007f02:	22ff      	movs	r2, #255	; 0xff
20007f04:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20007f06:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20007f0a:	61fb      	str	r3, [r7, #28]
20007f0c:	e007      	b.n	20007f1e <HAL_I2C_Master_Seq_Transmit_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20007f0e:	68fb      	ldr	r3, [r7, #12]
20007f10:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007f12:	b29a      	uxth	r2, r3
20007f14:	68fb      	ldr	r3, [r7, #12]
20007f16:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
20007f18:	68fb      	ldr	r3, [r7, #12]
20007f1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20007f1c:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
20007f1e:	68fb      	ldr	r3, [r7, #12]
20007f20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20007f22:	2b11      	cmp	r3, #17
20007f24:	d10e      	bne.n	20007f44 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
20007f26:	6abb      	ldr	r3, [r7, #40]	; 0x28
20007f28:	2baa      	cmp	r3, #170	; 0xaa
20007f2a:	d003      	beq.n	20007f34 <HAL_I2C_Master_Seq_Transmit_DMA+0xa8>
20007f2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
20007f2e:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
20007f32:	d101      	bne.n	20007f38 <HAL_I2C_Master_Seq_Transmit_DMA+0xac>
20007f34:	2301      	movs	r3, #1
20007f36:	e000      	b.n	20007f3a <HAL_I2C_Master_Seq_Transmit_DMA+0xae>
20007f38:	2300      	movs	r3, #0
20007f3a:	2b00      	cmp	r3, #0
20007f3c:	d102      	bne.n	20007f44 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
20007f3e:	2300      	movs	r3, #0
20007f40:	61bb      	str	r3, [r7, #24]
20007f42:	e00a      	b.n	20007f5a <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
20007f44:	68f8      	ldr	r0, [r7, #12]
20007f46:	f002 fb76 	bl	2000a636 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
20007f4a:	68fb      	ldr	r3, [r7, #12]
20007f4c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007f4e:	b29b      	uxth	r3, r3
20007f50:	2bfe      	cmp	r3, #254	; 0xfe
20007f52:	d802      	bhi.n	20007f5a <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
20007f54:	68fb      	ldr	r3, [r7, #12]
20007f56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20007f58:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
20007f5a:	68fb      	ldr	r3, [r7, #12]
20007f5c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007f5e:	2b00      	cmp	r3, #0
20007f60:	d070      	beq.n	20008044 <HAL_I2C_Master_Seq_Transmit_DMA+0x1b8>
    {
      if (hi2c->hdmatx != NULL)
20007f62:	68fb      	ldr	r3, [r7, #12]
20007f64:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20007f66:	2b00      	cmp	r3, #0
20007f68:	d020      	beq.n	20007fac <HAL_I2C_Master_Seq_Transmit_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
20007f6a:	68fb      	ldr	r3, [r7, #12]
20007f6c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20007f6e:	4a46      	ldr	r2, [pc, #280]	; (20008088 <HAL_I2C_Master_Seq_Transmit_DMA+0x1fc>)
20007f70:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
20007f72:	68fb      	ldr	r3, [r7, #12]
20007f74:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20007f76:	4a45      	ldr	r2, [pc, #276]	; (2000808c <HAL_I2C_Master_Seq_Transmit_DMA+0x200>)
20007f78:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
20007f7a:	68fb      	ldr	r3, [r7, #12]
20007f7c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20007f7e:	2200      	movs	r2, #0
20007f80:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
20007f82:	68fb      	ldr	r3, [r7, #12]
20007f84:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20007f86:	2200      	movs	r2, #0
20007f88:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
20007f8a:	68fb      	ldr	r3, [r7, #12]
20007f8c:	6b98      	ldr	r0, [r3, #56]	; 0x38
20007f8e:	6879      	ldr	r1, [r7, #4]
20007f90:	68fb      	ldr	r3, [r7, #12]
20007f92:	681b      	ldr	r3, [r3, #0]
20007f94:	3328      	adds	r3, #40	; 0x28
20007f96:	461a      	mov	r2, r3
20007f98:	68fb      	ldr	r3, [r7, #12]
20007f9a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007f9c:	f7fa fcf7 	bl	2000298e <HAL_DMA_Start_IT>
20007fa0:	4603      	mov	r3, r0
20007fa2:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
20007fa4:	7dfb      	ldrb	r3, [r7, #23]
20007fa6:	2b00      	cmp	r3, #0
20007fa8:	d138      	bne.n	2000801c <HAL_I2C_Master_Seq_Transmit_DMA+0x190>
20007faa:	e013      	b.n	20007fd4 <HAL_I2C_Master_Seq_Transmit_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
20007fac:	68fb      	ldr	r3, [r7, #12]
20007fae:	2220      	movs	r2, #32
20007fb0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
20007fb4:	68fb      	ldr	r3, [r7, #12]
20007fb6:	2200      	movs	r2, #0
20007fb8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
20007fbc:	68fb      	ldr	r3, [r7, #12]
20007fbe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20007fc0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
20007fc4:	68fb      	ldr	r3, [r7, #12]
20007fc6:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
20007fc8:	68fb      	ldr	r3, [r7, #12]
20007fca:	2200      	movs	r2, #0
20007fcc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
20007fd0:	2301      	movs	r3, #1
20007fd2:	e050      	b.n	20008076 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to write */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
20007fd4:	68fb      	ldr	r3, [r7, #12]
20007fd6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007fd8:	b2da      	uxtb	r2, r3
20007fda:	8979      	ldrh	r1, [r7, #10]
20007fdc:	69bb      	ldr	r3, [r7, #24]
20007fde:	9300      	str	r3, [sp, #0]
20007fe0:	69fb      	ldr	r3, [r7, #28]
20007fe2:	68f8      	ldr	r0, [r7, #12]
20007fe4:	f002 fa26 	bl	2000a434 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
20007fe8:	68fb      	ldr	r3, [r7, #12]
20007fea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20007fec:	b29a      	uxth	r2, r3
20007fee:	68fb      	ldr	r3, [r7, #12]
20007ff0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20007ff2:	1ad3      	subs	r3, r2, r3
20007ff4:	b29a      	uxth	r2, r3
20007ff6:	68fb      	ldr	r3, [r7, #12]
20007ff8:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20007ffa:	68fb      	ldr	r3, [r7, #12]
20007ffc:	2200      	movs	r2, #0
20007ffe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
20008002:	2111      	movs	r1, #17
20008004:	68f8      	ldr	r0, [r7, #12]
20008006:	f002 fa43 	bl	2000a490 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2000800a:	68fb      	ldr	r3, [r7, #12]
2000800c:	681b      	ldr	r3, [r3, #0]
2000800e:	681a      	ldr	r2, [r3, #0]
20008010:	68fb      	ldr	r3, [r7, #12]
20008012:	681b      	ldr	r3, [r3, #0]
20008014:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20008018:	601a      	str	r2, [r3, #0]
2000801a:	e029      	b.n	20008070 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2000801c:	68fb      	ldr	r3, [r7, #12]
2000801e:	2220      	movs	r2, #32
20008020:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
20008024:	68fb      	ldr	r3, [r7, #12]
20008026:	2200      	movs	r2, #0
20008028:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000802c:	68fb      	ldr	r3, [r7, #12]
2000802e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008030:	f043 0210 	orr.w	r2, r3, #16
20008034:	68fb      	ldr	r3, [r7, #12]
20008036:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20008038:	68fb      	ldr	r3, [r7, #12]
2000803a:	2200      	movs	r2, #0
2000803c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
20008040:	2301      	movs	r3, #1
20008042:	e018      	b.n	20008076 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
20008044:	68fb      	ldr	r3, [r7, #12]
20008046:	4a12      	ldr	r2, [pc, #72]	; (20008090 <HAL_I2C_Master_Seq_Transmit_DMA+0x204>)
20008048:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
2000804a:	68fb      	ldr	r3, [r7, #12]
2000804c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000804e:	b2da      	uxtb	r2, r3
20008050:	8979      	ldrh	r1, [r7, #10]
20008052:	4b0b      	ldr	r3, [pc, #44]	; (20008080 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
20008054:	9300      	str	r3, [sp, #0]
20008056:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000805a:	68f8      	ldr	r0, [r7, #12]
2000805c:	f002 f9ea 	bl	2000a434 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20008060:	68fb      	ldr	r3, [r7, #12]
20008062:	2200      	movs	r2, #0
20008064:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
20008068:	2101      	movs	r1, #1
2000806a:	68f8      	ldr	r0, [r7, #12]
2000806c:	f002 fa10 	bl	2000a490 <I2C_Enable_IRQ>
    }

    return HAL_OK;
20008070:	2300      	movs	r3, #0
20008072:	e000      	b.n	20008076 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
20008074:	2302      	movs	r3, #2
  }
}
20008076:	4618      	mov	r0, r3
20008078:	3720      	adds	r7, #32
2000807a:	46bd      	mov	sp, r7
2000807c:	bd80      	pop	{r7, pc}
2000807e:	bf00      	nop
20008080:	80002000 	.word	0x80002000
20008084:	20009293 	.word	0x20009293
20008088:	20009ea9 	.word	0x20009ea9
2000808c:	2000a05b 	.word	0x2000a05b
20008090:	20008e33 	.word	0x20008e33

20008094 <HAL_I2C_Master_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
20008094:	b580      	push	{r7, lr}
20008096:	b088      	sub	sp, #32
20008098:	af02      	add	r7, sp, #8
2000809a:	60f8      	str	r0, [r7, #12]
2000809c:	607a      	str	r2, [r7, #4]
2000809e:	461a      	mov	r2, r3
200080a0:	460b      	mov	r3, r1
200080a2:	817b      	strh	r3, [r7, #10]
200080a4:	4613      	mov	r3, r2
200080a6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
200080a8:	4b3a      	ldr	r3, [pc, #232]	; (20008194 <HAL_I2C_Master_Seq_Receive_IT+0x100>)
200080aa:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
200080ac:	68fb      	ldr	r3, [r7, #12]
200080ae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200080b2:	b2db      	uxtb	r3, r3
200080b4:	2b20      	cmp	r3, #32
200080b6:	d167      	bne.n	20008188 <HAL_I2C_Master_Seq_Receive_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
200080b8:	68fb      	ldr	r3, [r7, #12]
200080ba:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200080be:	2b01      	cmp	r3, #1
200080c0:	d101      	bne.n	200080c6 <HAL_I2C_Master_Seq_Receive_IT+0x32>
200080c2:	2302      	movs	r3, #2
200080c4:	e061      	b.n	2000818a <HAL_I2C_Master_Seq_Receive_IT+0xf6>
200080c6:	68fb      	ldr	r3, [r7, #12]
200080c8:	2201      	movs	r2, #1
200080ca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
200080ce:	68fb      	ldr	r3, [r7, #12]
200080d0:	2222      	movs	r2, #34	; 0x22
200080d2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
200080d6:	68fb      	ldr	r3, [r7, #12]
200080d8:	2210      	movs	r2, #16
200080da:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
200080de:	68fb      	ldr	r3, [r7, #12]
200080e0:	2200      	movs	r2, #0
200080e2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
200080e4:	68fb      	ldr	r3, [r7, #12]
200080e6:	687a      	ldr	r2, [r7, #4]
200080e8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
200080ea:	68fb      	ldr	r3, [r7, #12]
200080ec:	893a      	ldrh	r2, [r7, #8]
200080ee:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
200080f0:	68fb      	ldr	r3, [r7, #12]
200080f2:	6a3a      	ldr	r2, [r7, #32]
200080f4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
200080f6:	68fb      	ldr	r3, [r7, #12]
200080f8:	4a27      	ldr	r2, [pc, #156]	; (20008198 <HAL_I2C_Master_Seq_Receive_IT+0x104>)
200080fa:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
200080fc:	68fb      	ldr	r3, [r7, #12]
200080fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008100:	b29b      	uxth	r3, r3
20008102:	2bff      	cmp	r3, #255	; 0xff
20008104:	d906      	bls.n	20008114 <HAL_I2C_Master_Seq_Receive_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20008106:	68fb      	ldr	r3, [r7, #12]
20008108:	22ff      	movs	r2, #255	; 0xff
2000810a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2000810c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20008110:	617b      	str	r3, [r7, #20]
20008112:	e007      	b.n	20008124 <HAL_I2C_Master_Seq_Receive_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
20008114:	68fb      	ldr	r3, [r7, #12]
20008116:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008118:	b29a      	uxth	r2, r3
2000811a:	68fb      	ldr	r3, [r7, #12]
2000811c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2000811e:	68fb      	ldr	r3, [r7, #12]
20008120:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20008122:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
20008124:	68fb      	ldr	r3, [r7, #12]
20008126:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20008128:	2b12      	cmp	r3, #18
2000812a:	d10e      	bne.n	2000814a <HAL_I2C_Master_Seq_Receive_IT+0xb6>
2000812c:	6a3b      	ldr	r3, [r7, #32]
2000812e:	2baa      	cmp	r3, #170	; 0xaa
20008130:	d003      	beq.n	2000813a <HAL_I2C_Master_Seq_Receive_IT+0xa6>
20008132:	6a3b      	ldr	r3, [r7, #32]
20008134:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
20008138:	d101      	bne.n	2000813e <HAL_I2C_Master_Seq_Receive_IT+0xaa>
2000813a:	2301      	movs	r3, #1
2000813c:	e000      	b.n	20008140 <HAL_I2C_Master_Seq_Receive_IT+0xac>
2000813e:	2300      	movs	r3, #0
20008140:	2b00      	cmp	r3, #0
20008142:	d102      	bne.n	2000814a <HAL_I2C_Master_Seq_Receive_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
20008144:	2300      	movs	r3, #0
20008146:	613b      	str	r3, [r7, #16]
20008148:	e00a      	b.n	20008160 <HAL_I2C_Master_Seq_Receive_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2000814a:	68f8      	ldr	r0, [r7, #12]
2000814c:	f002 fa73 	bl	2000a636 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
20008150:	68fb      	ldr	r3, [r7, #12]
20008152:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008154:	b29b      	uxth	r3, r3
20008156:	2bfe      	cmp	r3, #254	; 0xfe
20008158:	d802      	bhi.n	20008160 <HAL_I2C_Master_Seq_Receive_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2000815a:	68fb      	ldr	r3, [r7, #12]
2000815c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000815e:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to read */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
20008160:	68fb      	ldr	r3, [r7, #12]
20008162:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008164:	b2da      	uxtb	r2, r3
20008166:	8979      	ldrh	r1, [r7, #10]
20008168:	693b      	ldr	r3, [r7, #16]
2000816a:	9300      	str	r3, [sp, #0]
2000816c:	697b      	ldr	r3, [r7, #20]
2000816e:	68f8      	ldr	r0, [r7, #12]
20008170:	f002 f960 	bl	2000a434 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20008174:	68fb      	ldr	r3, [r7, #12]
20008176:	2200      	movs	r2, #0
20008178:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2000817c:	2102      	movs	r1, #2
2000817e:	68f8      	ldr	r0, [r7, #12]
20008180:	f002 f986 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20008184:	2300      	movs	r3, #0
20008186:	e000      	b.n	2000818a <HAL_I2C_Master_Seq_Receive_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
20008188:	2302      	movs	r3, #2
  }
}
2000818a:	4618      	mov	r0, r3
2000818c:	3718      	adds	r7, #24
2000818e:	46bd      	mov	sp, r7
20008190:	bd80      	pop	{r7, pc}
20008192:	bf00      	nop
20008194:	80002400 	.word	0x80002400
20008198:	20008e33 	.word	0x20008e33

2000819c <HAL_I2C_Master_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2000819c:	b580      	push	{r7, lr}
2000819e:	b08a      	sub	sp, #40	; 0x28
200081a0:	af02      	add	r7, sp, #8
200081a2:	60f8      	str	r0, [r7, #12]
200081a4:	607a      	str	r2, [r7, #4]
200081a6:	461a      	mov	r2, r3
200081a8:	460b      	mov	r3, r1
200081aa:	817b      	strh	r3, [r7, #10]
200081ac:	4613      	mov	r3, r2
200081ae:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
200081b0:	4b77      	ldr	r3, [pc, #476]	; (20008390 <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
200081b2:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
200081b4:	68fb      	ldr	r3, [r7, #12]
200081b6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200081ba:	b2db      	uxtb	r3, r3
200081bc:	2b20      	cmp	r3, #32
200081be:	f040 80e1 	bne.w	20008384 <HAL_I2C_Master_Seq_Receive_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
200081c2:	68fb      	ldr	r3, [r7, #12]
200081c4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200081c8:	2b01      	cmp	r3, #1
200081ca:	d101      	bne.n	200081d0 <HAL_I2C_Master_Seq_Receive_DMA+0x34>
200081cc:	2302      	movs	r3, #2
200081ce:	e0da      	b.n	20008386 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
200081d0:	68fb      	ldr	r3, [r7, #12]
200081d2:	2201      	movs	r2, #1
200081d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
200081d8:	68fb      	ldr	r3, [r7, #12]
200081da:	2222      	movs	r2, #34	; 0x22
200081dc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
200081e0:	68fb      	ldr	r3, [r7, #12]
200081e2:	2210      	movs	r2, #16
200081e4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
200081e8:	68fb      	ldr	r3, [r7, #12]
200081ea:	2200      	movs	r2, #0
200081ec:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
200081ee:	68fb      	ldr	r3, [r7, #12]
200081f0:	687a      	ldr	r2, [r7, #4]
200081f2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
200081f4:	68fb      	ldr	r3, [r7, #12]
200081f6:	893a      	ldrh	r2, [r7, #8]
200081f8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
200081fa:	68fb      	ldr	r3, [r7, #12]
200081fc:	6aba      	ldr	r2, [r7, #40]	; 0x28
200081fe:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
20008200:	68fb      	ldr	r3, [r7, #12]
20008202:	4a64      	ldr	r2, [pc, #400]	; (20008394 <HAL_I2C_Master_Seq_Receive_DMA+0x1f8>)
20008204:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20008206:	68fb      	ldr	r3, [r7, #12]
20008208:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000820a:	b29b      	uxth	r3, r3
2000820c:	2bff      	cmp	r3, #255	; 0xff
2000820e:	d906      	bls.n	2000821e <HAL_I2C_Master_Seq_Receive_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
20008210:	68fb      	ldr	r3, [r7, #12]
20008212:	22ff      	movs	r2, #255	; 0xff
20008214:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
20008216:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2000821a:	61fb      	str	r3, [r7, #28]
2000821c:	e007      	b.n	2000822e <HAL_I2C_Master_Seq_Receive_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2000821e:	68fb      	ldr	r3, [r7, #12]
20008220:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008222:	b29a      	uxth	r2, r3
20008224:	68fb      	ldr	r3, [r7, #12]
20008226:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
20008228:	68fb      	ldr	r3, [r7, #12]
2000822a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000822c:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2000822e:	68fb      	ldr	r3, [r7, #12]
20008230:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20008232:	2b12      	cmp	r3, #18
20008234:	d10e      	bne.n	20008254 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
20008236:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008238:	2baa      	cmp	r3, #170	; 0xaa
2000823a:	d003      	beq.n	20008244 <HAL_I2C_Master_Seq_Receive_DMA+0xa8>
2000823c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000823e:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
20008242:	d101      	bne.n	20008248 <HAL_I2C_Master_Seq_Receive_DMA+0xac>
20008244:	2301      	movs	r3, #1
20008246:	e000      	b.n	2000824a <HAL_I2C_Master_Seq_Receive_DMA+0xae>
20008248:	2300      	movs	r3, #0
2000824a:	2b00      	cmp	r3, #0
2000824c:	d102      	bne.n	20008254 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2000824e:	2300      	movs	r3, #0
20008250:	61bb      	str	r3, [r7, #24]
20008252:	e00a      	b.n	2000826a <HAL_I2C_Master_Seq_Receive_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
20008254:	68f8      	ldr	r0, [r7, #12]
20008256:	f002 f9ee 	bl	2000a636 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2000825a:	68fb      	ldr	r3, [r7, #12]
2000825c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000825e:	b29b      	uxth	r3, r3
20008260:	2bfe      	cmp	r3, #254	; 0xfe
20008262:	d802      	bhi.n	2000826a <HAL_I2C_Master_Seq_Receive_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
20008264:	68fb      	ldr	r3, [r7, #12]
20008266:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20008268:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2000826a:	68fb      	ldr	r3, [r7, #12]
2000826c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000826e:	2b00      	cmp	r3, #0
20008270:	d070      	beq.n	20008354 <HAL_I2C_Master_Seq_Receive_DMA+0x1b8>
    {
      if (hi2c->hdmarx != NULL)
20008272:	68fb      	ldr	r3, [r7, #12]
20008274:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008276:	2b00      	cmp	r3, #0
20008278:	d020      	beq.n	200082bc <HAL_I2C_Master_Seq_Receive_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2000827a:	68fb      	ldr	r3, [r7, #12]
2000827c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000827e:	4a46      	ldr	r2, [pc, #280]	; (20008398 <HAL_I2C_Master_Seq_Receive_DMA+0x1fc>)
20008280:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
20008282:	68fb      	ldr	r3, [r7, #12]
20008284:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008286:	4a45      	ldr	r2, [pc, #276]	; (2000839c <HAL_I2C_Master_Seq_Receive_DMA+0x200>)
20008288:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2000828a:	68fb      	ldr	r3, [r7, #12]
2000828c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000828e:	2200      	movs	r2, #0
20008290:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
20008292:	68fb      	ldr	r3, [r7, #12]
20008294:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008296:	2200      	movs	r2, #0
20008298:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2000829a:	68fb      	ldr	r3, [r7, #12]
2000829c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000829e:	68fb      	ldr	r3, [r7, #12]
200082a0:	681b      	ldr	r3, [r3, #0]
200082a2:	3324      	adds	r3, #36	; 0x24
200082a4:	4619      	mov	r1, r3
200082a6:	687a      	ldr	r2, [r7, #4]
200082a8:	68fb      	ldr	r3, [r7, #12]
200082aa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200082ac:	f7fa fb6f 	bl	2000298e <HAL_DMA_Start_IT>
200082b0:	4603      	mov	r3, r0
200082b2:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
200082b4:	7dfb      	ldrb	r3, [r7, #23]
200082b6:	2b00      	cmp	r3, #0
200082b8:	d138      	bne.n	2000832c <HAL_I2C_Master_Seq_Receive_DMA+0x190>
200082ba:	e013      	b.n	200082e4 <HAL_I2C_Master_Seq_Receive_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
200082bc:	68fb      	ldr	r3, [r7, #12]
200082be:	2220      	movs	r2, #32
200082c0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
200082c4:	68fb      	ldr	r3, [r7, #12]
200082c6:	2200      	movs	r2, #0
200082c8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
200082cc:	68fb      	ldr	r3, [r7, #12]
200082ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200082d0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
200082d4:	68fb      	ldr	r3, [r7, #12]
200082d6:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
200082d8:	68fb      	ldr	r3, [r7, #12]
200082da:	2200      	movs	r2, #0
200082dc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
200082e0:	2301      	movs	r3, #1
200082e2:	e050      	b.n	20008386 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to read */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
200082e4:	68fb      	ldr	r3, [r7, #12]
200082e6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200082e8:	b2da      	uxtb	r2, r3
200082ea:	8979      	ldrh	r1, [r7, #10]
200082ec:	69bb      	ldr	r3, [r7, #24]
200082ee:	9300      	str	r3, [sp, #0]
200082f0:	69fb      	ldr	r3, [r7, #28]
200082f2:	68f8      	ldr	r0, [r7, #12]
200082f4:	f002 f89e 	bl	2000a434 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
200082f8:	68fb      	ldr	r3, [r7, #12]
200082fa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200082fc:	b29a      	uxth	r2, r3
200082fe:	68fb      	ldr	r3, [r7, #12]
20008300:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008302:	1ad3      	subs	r3, r2, r3
20008304:	b29a      	uxth	r2, r3
20008306:	68fb      	ldr	r3, [r7, #12]
20008308:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000830a:	68fb      	ldr	r3, [r7, #12]
2000830c:	2200      	movs	r2, #0
2000830e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
20008312:	2111      	movs	r1, #17
20008314:	68f8      	ldr	r0, [r7, #12]
20008316:	f002 f8bb 	bl	2000a490 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2000831a:	68fb      	ldr	r3, [r7, #12]
2000831c:	681b      	ldr	r3, [r3, #0]
2000831e:	681a      	ldr	r2, [r3, #0]
20008320:	68fb      	ldr	r3, [r7, #12]
20008322:	681b      	ldr	r3, [r3, #0]
20008324:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20008328:	601a      	str	r2, [r3, #0]
2000832a:	e029      	b.n	20008380 <HAL_I2C_Master_Seq_Receive_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2000832c:	68fb      	ldr	r3, [r7, #12]
2000832e:	2220      	movs	r2, #32
20008330:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
20008334:	68fb      	ldr	r3, [r7, #12]
20008336:	2200      	movs	r2, #0
20008338:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2000833c:	68fb      	ldr	r3, [r7, #12]
2000833e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008340:	f043 0210 	orr.w	r2, r3, #16
20008344:	68fb      	ldr	r3, [r7, #12]
20008346:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
20008348:	68fb      	ldr	r3, [r7, #12]
2000834a:	2200      	movs	r2, #0
2000834c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
20008350:	2301      	movs	r3, #1
20008352:	e018      	b.n	20008386 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
20008354:	68fb      	ldr	r3, [r7, #12]
20008356:	4a12      	ldr	r2, [pc, #72]	; (200083a0 <HAL_I2C_Master_Seq_Receive_DMA+0x204>)
20008358:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2000835a:	68fb      	ldr	r3, [r7, #12]
2000835c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000835e:	b2da      	uxtb	r2, r3
20008360:	8979      	ldrh	r1, [r7, #10]
20008362:	4b0b      	ldr	r3, [pc, #44]	; (20008390 <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
20008364:	9300      	str	r3, [sp, #0]
20008366:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2000836a:	68f8      	ldr	r0, [r7, #12]
2000836c:	f002 f862 	bl	2000a434 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20008370:	68fb      	ldr	r3, [r7, #12]
20008372:	2200      	movs	r2, #0
20008374:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
20008378:	2101      	movs	r1, #1
2000837a:	68f8      	ldr	r0, [r7, #12]
2000837c:	f002 f888 	bl	2000a490 <I2C_Enable_IRQ>
    }

    return HAL_OK;
20008380:	2300      	movs	r3, #0
20008382:	e000      	b.n	20008386 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
20008384:	2302      	movs	r3, #2
  }
}
20008386:	4618      	mov	r0, r3
20008388:	3720      	adds	r7, #32
2000838a:	46bd      	mov	sp, r7
2000838c:	bd80      	pop	{r7, pc}
2000838e:	bf00      	nop
20008390:	80002400 	.word	0x80002400
20008394:	20009293 	.word	0x20009293
20008398:	20009f7f 	.word	0x20009f7f
2000839c:	2000a05b 	.word	0x2000a05b
200083a0:	20008e33 	.word	0x20008e33

200083a4 <HAL_I2C_Slave_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
200083a4:	b580      	push	{r7, lr}
200083a6:	b084      	sub	sp, #16
200083a8:	af00      	add	r7, sp, #0
200083aa:	60f8      	str	r0, [r7, #12]
200083ac:	60b9      	str	r1, [r7, #8]
200083ae:	603b      	str	r3, [r7, #0]
200083b0:	4613      	mov	r3, r2
200083b2:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
200083b4:	68fb      	ldr	r3, [r7, #12]
200083b6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200083ba:	b2db      	uxtb	r3, r3
200083bc:	f003 0328 	and.w	r3, r3, #40	; 0x28
200083c0:	2b28      	cmp	r3, #40	; 0x28
200083c2:	f040 8088 	bne.w	200084d6 <HAL_I2C_Slave_Seq_Transmit_IT+0x132>
  {
    if ((pData == NULL) || (Size == 0U))
200083c6:	68bb      	ldr	r3, [r7, #8]
200083c8:	2b00      	cmp	r3, #0
200083ca:	d002      	beq.n	200083d2 <HAL_I2C_Slave_Seq_Transmit_IT+0x2e>
200083cc:	88fb      	ldrh	r3, [r7, #6]
200083ce:	2b00      	cmp	r3, #0
200083d0:	d105      	bne.n	200083de <HAL_I2C_Slave_Seq_Transmit_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
200083d2:	68fb      	ldr	r3, [r7, #12]
200083d4:	f44f 7200 	mov.w	r2, #512	; 0x200
200083d8:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
200083da:	2301      	movs	r3, #1
200083dc:	e07c      	b.n	200084d8 <HAL_I2C_Slave_Seq_Transmit_IT+0x134>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
200083de:	2105      	movs	r1, #5
200083e0:	68f8      	ldr	r0, [r7, #12]
200083e2:	f002 f8c3 	bl	2000a56c <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
200083e6:	68fb      	ldr	r3, [r7, #12]
200083e8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200083ec:	2b01      	cmp	r3, #1
200083ee:	d101      	bne.n	200083f4 <HAL_I2C_Slave_Seq_Transmit_IT+0x50>
200083f0:	2302      	movs	r3, #2
200083f2:	e071      	b.n	200084d8 <HAL_I2C_Slave_Seq_Transmit_IT+0x134>
200083f4:	68fb      	ldr	r3, [r7, #12]
200083f6:	2201      	movs	r2, #1
200083f8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
200083fc:	68fb      	ldr	r3, [r7, #12]
200083fe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20008402:	b2db      	uxtb	r3, r3
20008404:	2b2a      	cmp	r3, #42	; 0x2a
20008406:	d12a      	bne.n	2000845e <HAL_I2C_Slave_Seq_Transmit_IT+0xba>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
20008408:	2102      	movs	r1, #2
2000840a:	68f8      	ldr	r0, [r7, #12]
2000840c:	f002 f8ae 	bl	2000a56c <I2C_Disable_IRQ>

      /* Abort DMA Xfer if any */
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
20008410:	68fb      	ldr	r3, [r7, #12]
20008412:	681b      	ldr	r3, [r3, #0]
20008414:	681b      	ldr	r3, [r3, #0]
20008416:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000841a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000841e:	d11e      	bne.n	2000845e <HAL_I2C_Slave_Seq_Transmit_IT+0xba>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
20008420:	68fb      	ldr	r3, [r7, #12]
20008422:	681b      	ldr	r3, [r3, #0]
20008424:	681a      	ldr	r2, [r3, #0]
20008426:	68fb      	ldr	r3, [r7, #12]
20008428:	681b      	ldr	r3, [r3, #0]
2000842a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000842e:	601a      	str	r2, [r3, #0]

        if (hi2c->hdmarx != NULL)
20008430:	68fb      	ldr	r3, [r7, #12]
20008432:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008434:	2b00      	cmp	r3, #0
20008436:	d012      	beq.n	2000845e <HAL_I2C_Slave_Seq_Transmit_IT+0xba>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
20008438:	68fb      	ldr	r3, [r7, #12]
2000843a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000843c:	4a28      	ldr	r2, [pc, #160]	; (200084e0 <HAL_I2C_Slave_Seq_Transmit_IT+0x13c>)
2000843e:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
20008440:	68fb      	ldr	r3, [r7, #12]
20008442:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008444:	4618      	mov	r0, r3
20008446:	f7fa fb72 	bl	20002b2e <HAL_DMA_Abort_IT>
2000844a:	4603      	mov	r3, r0
2000844c:	2b00      	cmp	r3, #0
2000844e:	d006      	beq.n	2000845e <HAL_I2C_Slave_Seq_Transmit_IT+0xba>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
20008450:	68fb      	ldr	r3, [r7, #12]
20008452:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008454:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20008456:	68fa      	ldr	r2, [r7, #12]
20008458:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2000845a:	4610      	mov	r0, r2
2000845c:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2000845e:	68fb      	ldr	r3, [r7, #12]
20008460:	2229      	movs	r2, #41	; 0x29
20008462:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
20008466:	68fb      	ldr	r3, [r7, #12]
20008468:	2220      	movs	r2, #32
2000846a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000846e:	68fb      	ldr	r3, [r7, #12]
20008470:	2200      	movs	r2, #0
20008472:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
20008474:	68fb      	ldr	r3, [r7, #12]
20008476:	681b      	ldr	r3, [r3, #0]
20008478:	685a      	ldr	r2, [r3, #4]
2000847a:	68fb      	ldr	r3, [r7, #12]
2000847c:	681b      	ldr	r3, [r3, #0]
2000847e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20008482:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20008484:	68fb      	ldr	r3, [r7, #12]
20008486:	68ba      	ldr	r2, [r7, #8]
20008488:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000848a:	68fb      	ldr	r3, [r7, #12]
2000848c:	88fa      	ldrh	r2, [r7, #6]
2000848e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
20008490:	68fb      	ldr	r3, [r7, #12]
20008492:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008494:	b29a      	uxth	r2, r3
20008496:	68fb      	ldr	r3, [r7, #12]
20008498:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2000849a:	68fb      	ldr	r3, [r7, #12]
2000849c:	683a      	ldr	r2, [r7, #0]
2000849e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
200084a0:	68fb      	ldr	r3, [r7, #12]
200084a2:	4a10      	ldr	r2, [pc, #64]	; (200084e4 <HAL_I2C_Slave_Seq_Transmit_IT+0x140>)
200084a4:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
200084a6:	68fb      	ldr	r3, [r7, #12]
200084a8:	681b      	ldr	r3, [r3, #0]
200084aa:	699b      	ldr	r3, [r3, #24]
200084ac:	0c1b      	lsrs	r3, r3, #16
200084ae:	b2db      	uxtb	r3, r3
200084b0:	f003 0301 	and.w	r3, r3, #1
200084b4:	b2db      	uxtb	r3, r3
200084b6:	2b01      	cmp	r3, #1
200084b8:	d103      	bne.n	200084c2 <HAL_I2C_Slave_Seq_Transmit_IT+0x11e>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
200084ba:	68fb      	ldr	r3, [r7, #12]
200084bc:	681b      	ldr	r3, [r3, #0]
200084be:	2208      	movs	r2, #8
200084c0:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
200084c2:	68fb      	ldr	r3, [r7, #12]
200084c4:	2200      	movs	r2, #0
200084c6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
200084ca:	2105      	movs	r1, #5
200084cc:	68f8      	ldr	r0, [r7, #12]
200084ce:	f001 ffdf 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
200084d2:	2300      	movs	r3, #0
200084d4:	e000      	b.n	200084d8 <HAL_I2C_Slave_Seq_Transmit_IT+0x134>
  }
  else
  {
    return HAL_ERROR;
200084d6:	2301      	movs	r3, #1
  }
}
200084d8:	4618      	mov	r0, r3
200084da:	3710      	adds	r7, #16
200084dc:	46bd      	mov	sp, r7
200084de:	bd80      	pop	{r7, pc}
200084e0:	2000a0cf 	.word	0x2000a0cf
200084e4:	20009085 	.word	0x20009085

200084e8 <HAL_I2C_Slave_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
200084e8:	b580      	push	{r7, lr}
200084ea:	b086      	sub	sp, #24
200084ec:	af00      	add	r7, sp, #0
200084ee:	60f8      	str	r0, [r7, #12]
200084f0:	60b9      	str	r1, [r7, #8]
200084f2:	603b      	str	r3, [r7, #0]
200084f4:	4613      	mov	r3, r2
200084f6:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
200084f8:	68fb      	ldr	r3, [r7, #12]
200084fa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200084fe:	b2db      	uxtb	r3, r3
20008500:	f003 0328 	and.w	r3, r3, #40	; 0x28
20008504:	2b28      	cmp	r3, #40	; 0x28
20008506:	f040 8118 	bne.w	2000873a <HAL_I2C_Slave_Seq_Transmit_DMA+0x252>
  {
    if ((pData == NULL) || (Size == 0U))
2000850a:	68bb      	ldr	r3, [r7, #8]
2000850c:	2b00      	cmp	r3, #0
2000850e:	d002      	beq.n	20008516 <HAL_I2C_Slave_Seq_Transmit_DMA+0x2e>
20008510:	88fb      	ldrh	r3, [r7, #6]
20008512:	2b00      	cmp	r3, #0
20008514:	d105      	bne.n	20008522 <HAL_I2C_Slave_Seq_Transmit_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
20008516:	68fb      	ldr	r3, [r7, #12]
20008518:	f44f 7200 	mov.w	r2, #512	; 0x200
2000851c:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000851e:	2301      	movs	r3, #1
20008520:	e10c      	b.n	2000873c <HAL_I2C_Slave_Seq_Transmit_DMA+0x254>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
20008522:	68fb      	ldr	r3, [r7, #12]
20008524:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20008528:	2b01      	cmp	r3, #1
2000852a:	d101      	bne.n	20008530 <HAL_I2C_Slave_Seq_Transmit_DMA+0x48>
2000852c:	2302      	movs	r3, #2
2000852e:	e105      	b.n	2000873c <HAL_I2C_Slave_Seq_Transmit_DMA+0x254>
20008530:	68fb      	ldr	r3, [r7, #12]
20008532:	2201      	movs	r2, #1
20008534:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
20008538:	2105      	movs	r1, #5
2000853a:	68f8      	ldr	r0, [r7, #12]
2000853c:	f002 f816 	bl	2000a56c <I2C_Disable_IRQ>

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
20008540:	68fb      	ldr	r3, [r7, #12]
20008542:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20008546:	b2db      	uxtb	r3, r3
20008548:	2b2a      	cmp	r3, #42	; 0x2a
2000854a:	d12b      	bne.n	200085a4 <HAL_I2C_Slave_Seq_Transmit_DMA+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2000854c:	2102      	movs	r1, #2
2000854e:	68f8      	ldr	r0, [r7, #12]
20008550:	f002 f80c 	bl	2000a56c <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
20008554:	68fb      	ldr	r3, [r7, #12]
20008556:	681b      	ldr	r3, [r3, #0]
20008558:	681b      	ldr	r3, [r3, #0]
2000855a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000855e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20008562:	d14c      	bne.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
20008564:	68fb      	ldr	r3, [r7, #12]
20008566:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008568:	2b00      	cmp	r3, #0
2000856a:	d048      	beq.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2000856c:	68fb      	ldr	r3, [r7, #12]
2000856e:	681b      	ldr	r3, [r3, #0]
20008570:	681a      	ldr	r2, [r3, #0]
20008572:	68fb      	ldr	r3, [r7, #12]
20008574:	681b      	ldr	r3, [r3, #0]
20008576:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000857a:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2000857c:	68fb      	ldr	r3, [r7, #12]
2000857e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008580:	4a70      	ldr	r2, [pc, #448]	; (20008744 <HAL_I2C_Slave_Seq_Transmit_DMA+0x25c>)
20008582:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
20008584:	68fb      	ldr	r3, [r7, #12]
20008586:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008588:	4618      	mov	r0, r3
2000858a:	f7fa fad0 	bl	20002b2e <HAL_DMA_Abort_IT>
2000858e:	4603      	mov	r3, r0
20008590:	2b00      	cmp	r3, #0
20008592:	d034      	beq.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
20008594:	68fb      	ldr	r3, [r7, #12]
20008596:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008598:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000859a:	68fa      	ldr	r2, [r7, #12]
2000859c:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2000859e:	4610      	mov	r0, r2
200085a0:	4798      	blx	r3
200085a2:	e02c      	b.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
200085a4:	68fb      	ldr	r3, [r7, #12]
200085a6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200085aa:	b2db      	uxtb	r3, r3
200085ac:	2b29      	cmp	r3, #41	; 0x29
200085ae:	d126      	bne.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
200085b0:	68fb      	ldr	r3, [r7, #12]
200085b2:	681b      	ldr	r3, [r3, #0]
200085b4:	681b      	ldr	r3, [r3, #0]
200085b6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
200085ba:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200085be:	d11e      	bne.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
200085c0:	68fb      	ldr	r3, [r7, #12]
200085c2:	681b      	ldr	r3, [r3, #0]
200085c4:	681a      	ldr	r2, [r3, #0]
200085c6:	68fb      	ldr	r3, [r7, #12]
200085c8:	681b      	ldr	r3, [r3, #0]
200085ca:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
200085ce:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
200085d0:	68fb      	ldr	r3, [r7, #12]
200085d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200085d4:	2b00      	cmp	r3, #0
200085d6:	d012      	beq.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
200085d8:	68fb      	ldr	r3, [r7, #12]
200085da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200085dc:	4a59      	ldr	r2, [pc, #356]	; (20008744 <HAL_I2C_Slave_Seq_Transmit_DMA+0x25c>)
200085de:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
200085e0:	68fb      	ldr	r3, [r7, #12]
200085e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200085e4:	4618      	mov	r0, r3
200085e6:	f7fa faa2 	bl	20002b2e <HAL_DMA_Abort_IT>
200085ea:	4603      	mov	r3, r0
200085ec:	2b00      	cmp	r3, #0
200085ee:	d006      	beq.n	200085fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x116>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
200085f0:	68fb      	ldr	r3, [r7, #12]
200085f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200085f4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200085f6:	68fa      	ldr	r2, [r7, #12]
200085f8:	6b92      	ldr	r2, [r2, #56]	; 0x38
200085fa:	4610      	mov	r0, r2
200085fc:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
200085fe:	68fb      	ldr	r3, [r7, #12]
20008600:	2229      	movs	r2, #41	; 0x29
20008602:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
20008606:	68fb      	ldr	r3, [r7, #12]
20008608:	2220      	movs	r2, #32
2000860a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000860e:	68fb      	ldr	r3, [r7, #12]
20008610:	2200      	movs	r2, #0
20008612:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
20008614:	68fb      	ldr	r3, [r7, #12]
20008616:	681b      	ldr	r3, [r3, #0]
20008618:	685a      	ldr	r2, [r3, #4]
2000861a:	68fb      	ldr	r3, [r7, #12]
2000861c:	681b      	ldr	r3, [r3, #0]
2000861e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20008622:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20008624:	68fb      	ldr	r3, [r7, #12]
20008626:	68ba      	ldr	r2, [r7, #8]
20008628:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000862a:	68fb      	ldr	r3, [r7, #12]
2000862c:	88fa      	ldrh	r2, [r7, #6]
2000862e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
20008630:	68fb      	ldr	r3, [r7, #12]
20008632:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008634:	b29a      	uxth	r2, r3
20008636:	68fb      	ldr	r3, [r7, #12]
20008638:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2000863a:	68fb      	ldr	r3, [r7, #12]
2000863c:	683a      	ldr	r2, [r7, #0]
2000863e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
20008640:	68fb      	ldr	r3, [r7, #12]
20008642:	4a41      	ldr	r2, [pc, #260]	; (20008748 <HAL_I2C_Slave_Seq_Transmit_DMA+0x260>)
20008644:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
20008646:	68fb      	ldr	r3, [r7, #12]
20008648:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000864a:	2b00      	cmp	r3, #0
2000864c:	d020      	beq.n	20008690 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1a8>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2000864e:	68fb      	ldr	r3, [r7, #12]
20008650:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008652:	4a3e      	ldr	r2, [pc, #248]	; (2000874c <HAL_I2C_Slave_Seq_Transmit_DMA+0x264>)
20008654:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
20008656:	68fb      	ldr	r3, [r7, #12]
20008658:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000865a:	4a3d      	ldr	r2, [pc, #244]	; (20008750 <HAL_I2C_Slave_Seq_Transmit_DMA+0x268>)
2000865c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2000865e:	68fb      	ldr	r3, [r7, #12]
20008660:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008662:	2200      	movs	r2, #0
20008664:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
20008666:	68fb      	ldr	r3, [r7, #12]
20008668:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000866a:	2200      	movs	r2, #0
2000866c:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2000866e:	68fb      	ldr	r3, [r7, #12]
20008670:	6b98      	ldr	r0, [r3, #56]	; 0x38
20008672:	68b9      	ldr	r1, [r7, #8]
20008674:	68fb      	ldr	r3, [r7, #12]
20008676:	681b      	ldr	r3, [r3, #0]
20008678:	3328      	adds	r3, #40	; 0x28
2000867a:	461a      	mov	r2, r3
2000867c:	68fb      	ldr	r3, [r7, #12]
2000867e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008680:	f7fa f985 	bl	2000298e <HAL_DMA_Start_IT>
20008684:	4603      	mov	r3, r0
20008686:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
20008688:	7dfb      	ldrb	r3, [r7, #23]
2000868a:	2b00      	cmp	r3, #0
2000868c:	d12b      	bne.n	200086e6 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1fe>
2000868e:	e013      	b.n	200086b8 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1d0>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
20008690:	68fb      	ldr	r3, [r7, #12]
20008692:	2228      	movs	r2, #40	; 0x28
20008694:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20008698:	68fb      	ldr	r3, [r7, #12]
2000869a:	2200      	movs	r2, #0
2000869c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
200086a0:	68fb      	ldr	r3, [r7, #12]
200086a2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200086a4:	f043 0280 	orr.w	r2, r3, #128	; 0x80
200086a8:	68fb      	ldr	r3, [r7, #12]
200086aa:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
200086ac:	68fb      	ldr	r3, [r7, #12]
200086ae:	2200      	movs	r2, #0
200086b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
200086b4:	2301      	movs	r3, #1
200086b6:	e041      	b.n	2000873c <HAL_I2C_Slave_Seq_Transmit_DMA+0x254>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
200086b8:	68fb      	ldr	r3, [r7, #12]
200086ba:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200086bc:	b29a      	uxth	r2, r3
200086be:	68fb      	ldr	r3, [r7, #12]
200086c0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200086c2:	1ad3      	subs	r3, r2, r3
200086c4:	b29a      	uxth	r2, r3
200086c6:	68fb      	ldr	r3, [r7, #12]
200086c8:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
200086ca:	68fb      	ldr	r3, [r7, #12]
200086cc:	2200      	movs	r2, #0
200086ce:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
200086d0:	68fb      	ldr	r3, [r7, #12]
200086d2:	681b      	ldr	r3, [r3, #0]
200086d4:	699b      	ldr	r3, [r3, #24]
200086d6:	0c1b      	lsrs	r3, r3, #16
200086d8:	b2db      	uxtb	r3, r3
200086da:	f003 0301 	and.w	r3, r3, #1
200086de:	b2db      	uxtb	r3, r3
200086e0:	2b01      	cmp	r3, #1
200086e2:	d118      	bne.n	20008716 <HAL_I2C_Slave_Seq_Transmit_DMA+0x22e>
200086e4:	e013      	b.n	2000870e <HAL_I2C_Slave_Seq_Transmit_DMA+0x226>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
200086e6:	68fb      	ldr	r3, [r7, #12]
200086e8:	2228      	movs	r2, #40	; 0x28
200086ea:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
200086ee:	68fb      	ldr	r3, [r7, #12]
200086f0:	2200      	movs	r2, #0
200086f2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
200086f6:	68fb      	ldr	r3, [r7, #12]
200086f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200086fa:	f043 0210 	orr.w	r2, r3, #16
200086fe:	68fb      	ldr	r3, [r7, #12]
20008700:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20008702:	68fb      	ldr	r3, [r7, #12]
20008704:	2200      	movs	r2, #0
20008706:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2000870a:	2301      	movs	r3, #1
2000870c:	e016      	b.n	2000873c <HAL_I2C_Slave_Seq_Transmit_DMA+0x254>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000870e:	68fb      	ldr	r3, [r7, #12]
20008710:	681b      	ldr	r3, [r3, #0]
20008712:	2208      	movs	r2, #8
20008714:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20008716:	68fb      	ldr	r3, [r7, #12]
20008718:	2200      	movs	r2, #0
2000871a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* Enable ERR, STOP, NACK, ADDR interrupts */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000871e:	2104      	movs	r1, #4
20008720:	68f8      	ldr	r0, [r7, #12]
20008722:	f001 feb5 	bl	2000a490 <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
20008726:	68fb      	ldr	r3, [r7, #12]
20008728:	681b      	ldr	r3, [r3, #0]
2000872a:	681a      	ldr	r2, [r3, #0]
2000872c:	68fb      	ldr	r3, [r7, #12]
2000872e:	681b      	ldr	r3, [r3, #0]
20008730:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20008734:	601a      	str	r2, [r3, #0]

    return HAL_OK;
20008736:	2300      	movs	r3, #0
20008738:	e000      	b.n	2000873c <HAL_I2C_Slave_Seq_Transmit_DMA+0x254>
  }
  else
  {
    return HAL_ERROR;
2000873a:	2301      	movs	r3, #1
  }
}
2000873c:	4618      	mov	r0, r3
2000873e:	3718      	adds	r7, #24
20008740:	46bd      	mov	sp, r7
20008742:	bd80      	pop	{r7, pc}
20008744:	2000a0cf 	.word	0x2000a0cf
20008748:	20009479 	.word	0x20009479
2000874c:	20009f3f 	.word	0x20009f3f
20008750:	2000a05b 	.word	0x2000a05b

20008754 <HAL_I2C_Slave_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
20008754:	b580      	push	{r7, lr}
20008756:	b084      	sub	sp, #16
20008758:	af00      	add	r7, sp, #0
2000875a:	60f8      	str	r0, [r7, #12]
2000875c:	60b9      	str	r1, [r7, #8]
2000875e:	603b      	str	r3, [r7, #0]
20008760:	4613      	mov	r3, r2
20008762:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
20008764:	68fb      	ldr	r3, [r7, #12]
20008766:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000876a:	b2db      	uxtb	r3, r3
2000876c:	f003 0328 	and.w	r3, r3, #40	; 0x28
20008770:	2b28      	cmp	r3, #40	; 0x28
20008772:	f040 8088 	bne.w	20008886 <HAL_I2C_Slave_Seq_Receive_IT+0x132>
  {
    if ((pData == NULL) || (Size == 0U))
20008776:	68bb      	ldr	r3, [r7, #8]
20008778:	2b00      	cmp	r3, #0
2000877a:	d002      	beq.n	20008782 <HAL_I2C_Slave_Seq_Receive_IT+0x2e>
2000877c:	88fb      	ldrh	r3, [r7, #6]
2000877e:	2b00      	cmp	r3, #0
20008780:	d105      	bne.n	2000878e <HAL_I2C_Slave_Seq_Receive_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
20008782:	68fb      	ldr	r3, [r7, #12]
20008784:	f44f 7200 	mov.w	r2, #512	; 0x200
20008788:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2000878a:	2301      	movs	r3, #1
2000878c:	e07c      	b.n	20008888 <HAL_I2C_Slave_Seq_Receive_IT+0x134>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2000878e:	2106      	movs	r1, #6
20008790:	68f8      	ldr	r0, [r7, #12]
20008792:	f001 feeb 	bl	2000a56c <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
20008796:	68fb      	ldr	r3, [r7, #12]
20008798:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000879c:	2b01      	cmp	r3, #1
2000879e:	d101      	bne.n	200087a4 <HAL_I2C_Slave_Seq_Receive_IT+0x50>
200087a0:	2302      	movs	r3, #2
200087a2:	e071      	b.n	20008888 <HAL_I2C_Slave_Seq_Receive_IT+0x134>
200087a4:	68fb      	ldr	r3, [r7, #12]
200087a6:	2201      	movs	r2, #1
200087a8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
200087ac:	68fb      	ldr	r3, [r7, #12]
200087ae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200087b2:	b2db      	uxtb	r3, r3
200087b4:	2b29      	cmp	r3, #41	; 0x29
200087b6:	d12a      	bne.n	2000880e <HAL_I2C_Slave_Seq_Receive_IT+0xba>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
200087b8:	2101      	movs	r1, #1
200087ba:	68f8      	ldr	r0, [r7, #12]
200087bc:	f001 fed6 	bl	2000a56c <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
200087c0:	68fb      	ldr	r3, [r7, #12]
200087c2:	681b      	ldr	r3, [r3, #0]
200087c4:	681b      	ldr	r3, [r3, #0]
200087c6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
200087ca:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200087ce:	d11e      	bne.n	2000880e <HAL_I2C_Slave_Seq_Receive_IT+0xba>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
200087d0:	68fb      	ldr	r3, [r7, #12]
200087d2:	681b      	ldr	r3, [r3, #0]
200087d4:	681a      	ldr	r2, [r3, #0]
200087d6:	68fb      	ldr	r3, [r7, #12]
200087d8:	681b      	ldr	r3, [r3, #0]
200087da:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
200087de:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
200087e0:	68fb      	ldr	r3, [r7, #12]
200087e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200087e4:	2b00      	cmp	r3, #0
200087e6:	d012      	beq.n	2000880e <HAL_I2C_Slave_Seq_Receive_IT+0xba>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
200087e8:	68fb      	ldr	r3, [r7, #12]
200087ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200087ec:	4a28      	ldr	r2, [pc, #160]	; (20008890 <HAL_I2C_Slave_Seq_Receive_IT+0x13c>)
200087ee:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
200087f0:	68fb      	ldr	r3, [r7, #12]
200087f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200087f4:	4618      	mov	r0, r3
200087f6:	f7fa f99a 	bl	20002b2e <HAL_DMA_Abort_IT>
200087fa:	4603      	mov	r3, r0
200087fc:	2b00      	cmp	r3, #0
200087fe:	d006      	beq.n	2000880e <HAL_I2C_Slave_Seq_Receive_IT+0xba>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
20008800:	68fb      	ldr	r3, [r7, #12]
20008802:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008804:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20008806:	68fa      	ldr	r2, [r7, #12]
20008808:	6b92      	ldr	r2, [r2, #56]	; 0x38
2000880a:	4610      	mov	r0, r2
2000880c:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2000880e:	68fb      	ldr	r3, [r7, #12]
20008810:	222a      	movs	r2, #42	; 0x2a
20008812:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
20008816:	68fb      	ldr	r3, [r7, #12]
20008818:	2220      	movs	r2, #32
2000881a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000881e:	68fb      	ldr	r3, [r7, #12]
20008820:	2200      	movs	r2, #0
20008822:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
20008824:	68fb      	ldr	r3, [r7, #12]
20008826:	681b      	ldr	r3, [r3, #0]
20008828:	685a      	ldr	r2, [r3, #4]
2000882a:	68fb      	ldr	r3, [r7, #12]
2000882c:	681b      	ldr	r3, [r3, #0]
2000882e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20008832:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
20008834:	68fb      	ldr	r3, [r7, #12]
20008836:	68ba      	ldr	r2, [r7, #8]
20008838:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2000883a:	68fb      	ldr	r3, [r7, #12]
2000883c:	88fa      	ldrh	r2, [r7, #6]
2000883e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
20008840:	68fb      	ldr	r3, [r7, #12]
20008842:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008844:	b29a      	uxth	r2, r3
20008846:	68fb      	ldr	r3, [r7, #12]
20008848:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2000884a:	68fb      	ldr	r3, [r7, #12]
2000884c:	683a      	ldr	r2, [r7, #0]
2000884e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
20008850:	68fb      	ldr	r3, [r7, #12]
20008852:	4a10      	ldr	r2, [pc, #64]	; (20008894 <HAL_I2C_Slave_Seq_Receive_IT+0x140>)
20008854:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
20008856:	68fb      	ldr	r3, [r7, #12]
20008858:	681b      	ldr	r3, [r3, #0]
2000885a:	699b      	ldr	r3, [r3, #24]
2000885c:	0c1b      	lsrs	r3, r3, #16
2000885e:	b2db      	uxtb	r3, r3
20008860:	f003 0301 	and.w	r3, r3, #1
20008864:	b2db      	uxtb	r3, r3
20008866:	2b00      	cmp	r3, #0
20008868:	d103      	bne.n	20008872 <HAL_I2C_Slave_Seq_Receive_IT+0x11e>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2000886a:	68fb      	ldr	r3, [r7, #12]
2000886c:	681b      	ldr	r3, [r3, #0]
2000886e:	2208      	movs	r2, #8
20008870:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20008872:	68fb      	ldr	r3, [r7, #12]
20008874:	2200      	movs	r2, #0
20008876:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2000887a:	2106      	movs	r1, #6
2000887c:	68f8      	ldr	r0, [r7, #12]
2000887e:	f001 fe07 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20008882:	2300      	movs	r3, #0
20008884:	e000      	b.n	20008888 <HAL_I2C_Slave_Seq_Receive_IT+0x134>
  }
  else
  {
    return HAL_ERROR;
20008886:	2301      	movs	r3, #1
  }
}
20008888:	4618      	mov	r0, r3
2000888a:	3710      	adds	r7, #16
2000888c:	46bd      	mov	sp, r7
2000888e:	bd80      	pop	{r7, pc}
20008890:	2000a0cf 	.word	0x2000a0cf
20008894:	20009085 	.word	0x20009085

20008898 <HAL_I2C_Slave_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
20008898:	b580      	push	{r7, lr}
2000889a:	b086      	sub	sp, #24
2000889c:	af00      	add	r7, sp, #0
2000889e:	60f8      	str	r0, [r7, #12]
200088a0:	60b9      	str	r1, [r7, #8]
200088a2:	603b      	str	r3, [r7, #0]
200088a4:	4613      	mov	r3, r2
200088a6:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
200088a8:	68fb      	ldr	r3, [r7, #12]
200088aa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200088ae:	b2db      	uxtb	r3, r3
200088b0:	f003 0328 	and.w	r3, r3, #40	; 0x28
200088b4:	2b28      	cmp	r3, #40	; 0x28
200088b6:	f040 8118 	bne.w	20008aea <HAL_I2C_Slave_Seq_Receive_DMA+0x252>
  {
    if ((pData == NULL) || (Size == 0U))
200088ba:	68bb      	ldr	r3, [r7, #8]
200088bc:	2b00      	cmp	r3, #0
200088be:	d002      	beq.n	200088c6 <HAL_I2C_Slave_Seq_Receive_DMA+0x2e>
200088c0:	88fb      	ldrh	r3, [r7, #6]
200088c2:	2b00      	cmp	r3, #0
200088c4:	d105      	bne.n	200088d2 <HAL_I2C_Slave_Seq_Receive_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
200088c6:	68fb      	ldr	r3, [r7, #12]
200088c8:	f44f 7200 	mov.w	r2, #512	; 0x200
200088cc:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
200088ce:	2301      	movs	r3, #1
200088d0:	e10c      	b.n	20008aec <HAL_I2C_Slave_Seq_Receive_DMA+0x254>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
200088d2:	2106      	movs	r1, #6
200088d4:	68f8      	ldr	r0, [r7, #12]
200088d6:	f001 fe49 	bl	2000a56c <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
200088da:	68fb      	ldr	r3, [r7, #12]
200088dc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200088e0:	2b01      	cmp	r3, #1
200088e2:	d101      	bne.n	200088e8 <HAL_I2C_Slave_Seq_Receive_DMA+0x50>
200088e4:	2302      	movs	r3, #2
200088e6:	e101      	b.n	20008aec <HAL_I2C_Slave_Seq_Receive_DMA+0x254>
200088e8:	68fb      	ldr	r3, [r7, #12]
200088ea:	2201      	movs	r2, #1
200088ec:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
200088f0:	68fb      	ldr	r3, [r7, #12]
200088f2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200088f6:	b2db      	uxtb	r3, r3
200088f8:	2b29      	cmp	r3, #41	; 0x29
200088fa:	d12b      	bne.n	20008954 <HAL_I2C_Slave_Seq_Receive_DMA+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
200088fc:	2101      	movs	r1, #1
200088fe:	68f8      	ldr	r0, [r7, #12]
20008900:	f001 fe34 	bl	2000a56c <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
20008904:	68fb      	ldr	r3, [r7, #12]
20008906:	681b      	ldr	r3, [r3, #0]
20008908:	681b      	ldr	r3, [r3, #0]
2000890a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000890e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20008912:	d14c      	bne.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
20008914:	68fb      	ldr	r3, [r7, #12]
20008916:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008918:	2b00      	cmp	r3, #0
2000891a:	d048      	beq.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2000891c:	68fb      	ldr	r3, [r7, #12]
2000891e:	681b      	ldr	r3, [r3, #0]
20008920:	681a      	ldr	r2, [r3, #0]
20008922:	68fb      	ldr	r3, [r7, #12]
20008924:	681b      	ldr	r3, [r3, #0]
20008926:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2000892a:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2000892c:	68fb      	ldr	r3, [r7, #12]
2000892e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008930:	4a70      	ldr	r2, [pc, #448]	; (20008af4 <HAL_I2C_Slave_Seq_Receive_DMA+0x25c>)
20008932:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
20008934:	68fb      	ldr	r3, [r7, #12]
20008936:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008938:	4618      	mov	r0, r3
2000893a:	f7fa f8f8 	bl	20002b2e <HAL_DMA_Abort_IT>
2000893e:	4603      	mov	r3, r0
20008940:	2b00      	cmp	r3, #0
20008942:	d034      	beq.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
20008944:	68fb      	ldr	r3, [r7, #12]
20008946:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008948:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000894a:	68fa      	ldr	r2, [r7, #12]
2000894c:	6b92      	ldr	r2, [r2, #56]	; 0x38
2000894e:	4610      	mov	r0, r2
20008950:	4798      	blx	r3
20008952:	e02c      	b.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
20008954:	68fb      	ldr	r3, [r7, #12]
20008956:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000895a:	b2db      	uxtb	r3, r3
2000895c:	2b2a      	cmp	r3, #42	; 0x2a
2000895e:	d126      	bne.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
20008960:	68fb      	ldr	r3, [r7, #12]
20008962:	681b      	ldr	r3, [r3, #0]
20008964:	681b      	ldr	r3, [r3, #0]
20008966:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000896a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000896e:	d11e      	bne.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
20008970:	68fb      	ldr	r3, [r7, #12]
20008972:	681b      	ldr	r3, [r3, #0]
20008974:	681a      	ldr	r2, [r3, #0]
20008976:	68fb      	ldr	r3, [r7, #12]
20008978:	681b      	ldr	r3, [r3, #0]
2000897a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000897e:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
20008980:	68fb      	ldr	r3, [r7, #12]
20008982:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008984:	2b00      	cmp	r3, #0
20008986:	d012      	beq.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
20008988:	68fb      	ldr	r3, [r7, #12]
2000898a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000898c:	4a59      	ldr	r2, [pc, #356]	; (20008af4 <HAL_I2C_Slave_Seq_Receive_DMA+0x25c>)
2000898e:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
20008990:	68fb      	ldr	r3, [r7, #12]
20008992:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008994:	4618      	mov	r0, r3
20008996:	f7fa f8ca 	bl	20002b2e <HAL_DMA_Abort_IT>
2000899a:	4603      	mov	r3, r0
2000899c:	2b00      	cmp	r3, #0
2000899e:	d006      	beq.n	200089ae <HAL_I2C_Slave_Seq_Receive_DMA+0x116>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
200089a0:	68fb      	ldr	r3, [r7, #12]
200089a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200089a4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200089a6:	68fa      	ldr	r2, [r7, #12]
200089a8:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
200089aa:	4610      	mov	r0, r2
200089ac:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
200089ae:	68fb      	ldr	r3, [r7, #12]
200089b0:	222a      	movs	r2, #42	; 0x2a
200089b2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
200089b6:	68fb      	ldr	r3, [r7, #12]
200089b8:	2220      	movs	r2, #32
200089ba:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
200089be:	68fb      	ldr	r3, [r7, #12]
200089c0:	2200      	movs	r2, #0
200089c2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
200089c4:	68fb      	ldr	r3, [r7, #12]
200089c6:	681b      	ldr	r3, [r3, #0]
200089c8:	685a      	ldr	r2, [r3, #4]
200089ca:	68fb      	ldr	r3, [r7, #12]
200089cc:	681b      	ldr	r3, [r3, #0]
200089ce:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
200089d2:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
200089d4:	68fb      	ldr	r3, [r7, #12]
200089d6:	68ba      	ldr	r2, [r7, #8]
200089d8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
200089da:	68fb      	ldr	r3, [r7, #12]
200089dc:	88fa      	ldrh	r2, [r7, #6]
200089de:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
200089e0:	68fb      	ldr	r3, [r7, #12]
200089e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200089e4:	b29a      	uxth	r2, r3
200089e6:	68fb      	ldr	r3, [r7, #12]
200089e8:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
200089ea:	68fb      	ldr	r3, [r7, #12]
200089ec:	683a      	ldr	r2, [r7, #0]
200089ee:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
200089f0:	68fb      	ldr	r3, [r7, #12]
200089f2:	4a41      	ldr	r2, [pc, #260]	; (20008af8 <HAL_I2C_Slave_Seq_Receive_DMA+0x260>)
200089f4:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
200089f6:	68fb      	ldr	r3, [r7, #12]
200089f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200089fa:	2b00      	cmp	r3, #0
200089fc:	d020      	beq.n	20008a40 <HAL_I2C_Slave_Seq_Receive_DMA+0x1a8>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
200089fe:	68fb      	ldr	r3, [r7, #12]
20008a00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008a02:	4a3e      	ldr	r2, [pc, #248]	; (20008afc <HAL_I2C_Slave_Seq_Receive_DMA+0x264>)
20008a04:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
20008a06:	68fb      	ldr	r3, [r7, #12]
20008a08:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008a0a:	4a3d      	ldr	r2, [pc, #244]	; (20008b00 <HAL_I2C_Slave_Seq_Receive_DMA+0x268>)
20008a0c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
20008a0e:	68fb      	ldr	r3, [r7, #12]
20008a10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008a12:	2200      	movs	r2, #0
20008a14:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
20008a16:	68fb      	ldr	r3, [r7, #12]
20008a18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008a1a:	2200      	movs	r2, #0
20008a1c:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
20008a1e:	68fb      	ldr	r3, [r7, #12]
20008a20:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
20008a22:	68fb      	ldr	r3, [r7, #12]
20008a24:	681b      	ldr	r3, [r3, #0]
20008a26:	3324      	adds	r3, #36	; 0x24
20008a28:	4619      	mov	r1, r3
20008a2a:	68ba      	ldr	r2, [r7, #8]
20008a2c:	68fb      	ldr	r3, [r7, #12]
20008a2e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008a30:	f7f9 ffad 	bl	2000298e <HAL_DMA_Start_IT>
20008a34:	4603      	mov	r3, r0
20008a36:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
20008a38:	7dfb      	ldrb	r3, [r7, #23]
20008a3a:	2b00      	cmp	r3, #0
20008a3c:	d12b      	bne.n	20008a96 <HAL_I2C_Slave_Seq_Receive_DMA+0x1fe>
20008a3e:	e013      	b.n	20008a68 <HAL_I2C_Slave_Seq_Receive_DMA+0x1d0>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
20008a40:	68fb      	ldr	r3, [r7, #12]
20008a42:	2228      	movs	r2, #40	; 0x28
20008a44:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20008a48:	68fb      	ldr	r3, [r7, #12]
20008a4a:	2200      	movs	r2, #0
20008a4c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
20008a50:	68fb      	ldr	r3, [r7, #12]
20008a52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008a54:	f043 0280 	orr.w	r2, r3, #128	; 0x80
20008a58:	68fb      	ldr	r3, [r7, #12]
20008a5a:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20008a5c:	68fb      	ldr	r3, [r7, #12]
20008a5e:	2200      	movs	r2, #0
20008a60:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20008a64:	2301      	movs	r3, #1
20008a66:	e041      	b.n	20008aec <HAL_I2C_Slave_Seq_Receive_DMA+0x254>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
20008a68:	68fb      	ldr	r3, [r7, #12]
20008a6a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008a6c:	b29a      	uxth	r2, r3
20008a6e:	68fb      	ldr	r3, [r7, #12]
20008a70:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008a72:	1ad3      	subs	r3, r2, r3
20008a74:	b29a      	uxth	r2, r3
20008a76:	68fb      	ldr	r3, [r7, #12]
20008a78:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
20008a7a:	68fb      	ldr	r3, [r7, #12]
20008a7c:	2200      	movs	r2, #0
20008a7e:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
20008a80:	68fb      	ldr	r3, [r7, #12]
20008a82:	681b      	ldr	r3, [r3, #0]
20008a84:	699b      	ldr	r3, [r3, #24]
20008a86:	0c1b      	lsrs	r3, r3, #16
20008a88:	b2db      	uxtb	r3, r3
20008a8a:	f003 0301 	and.w	r3, r3, #1
20008a8e:	b2db      	uxtb	r3, r3
20008a90:	2b00      	cmp	r3, #0
20008a92:	d118      	bne.n	20008ac6 <HAL_I2C_Slave_Seq_Receive_DMA+0x22e>
20008a94:	e013      	b.n	20008abe <HAL_I2C_Slave_Seq_Receive_DMA+0x226>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
20008a96:	68fb      	ldr	r3, [r7, #12]
20008a98:	2228      	movs	r2, #40	; 0x28
20008a9a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
20008a9e:	68fb      	ldr	r3, [r7, #12]
20008aa0:	2200      	movs	r2, #0
20008aa2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
20008aa6:	68fb      	ldr	r3, [r7, #12]
20008aa8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008aaa:	f043 0210 	orr.w	r2, r3, #16
20008aae:	68fb      	ldr	r3, [r7, #12]
20008ab0:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
20008ab2:	68fb      	ldr	r3, [r7, #12]
20008ab4:	2200      	movs	r2, #0
20008ab6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
20008aba:	2301      	movs	r3, #1
20008abc:	e016      	b.n	20008aec <HAL_I2C_Slave_Seq_Receive_DMA+0x254>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
20008abe:	68fb      	ldr	r3, [r7, #12]
20008ac0:	681b      	ldr	r3, [r3, #0]
20008ac2:	2208      	movs	r2, #8
20008ac4:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20008ac6:	68fb      	ldr	r3, [r7, #12]
20008ac8:	2200      	movs	r2, #0
20008aca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
20008ace:	2106      	movs	r1, #6
20008ad0:	68f8      	ldr	r0, [r7, #12]
20008ad2:	f001 fcdd 	bl	2000a490 <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
20008ad6:	68fb      	ldr	r3, [r7, #12]
20008ad8:	681b      	ldr	r3, [r3, #0]
20008ada:	681a      	ldr	r2, [r3, #0]
20008adc:	68fb      	ldr	r3, [r7, #12]
20008ade:	681b      	ldr	r3, [r3, #0]
20008ae0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20008ae4:	601a      	str	r2, [r3, #0]

    return HAL_OK;
20008ae6:	2300      	movs	r3, #0
20008ae8:	e000      	b.n	20008aec <HAL_I2C_Slave_Seq_Receive_DMA+0x254>
  }
  else
  {
    return HAL_ERROR;
20008aea:	2301      	movs	r3, #1
  }
}
20008aec:	4618      	mov	r0, r3
20008aee:	3718      	adds	r7, #24
20008af0:	46bd      	mov	sp, r7
20008af2:	bd80      	pop	{r7, pc}
20008af4:	2000a0cf 	.word	0x2000a0cf
20008af8:	20009479 	.word	0x20009479
20008afc:	2000a015 	.word	0x2000a015
20008b00:	2000a05b 	.word	0x2000a05b

20008b04 <HAL_I2C_EnableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
{
20008b04:	b580      	push	{r7, lr}
20008b06:	b082      	sub	sp, #8
20008b08:	af00      	add	r7, sp, #0
20008b0a:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_READY)
20008b0c:	687b      	ldr	r3, [r7, #4]
20008b0e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20008b12:	b2db      	uxtb	r3, r3
20008b14:	2b20      	cmp	r3, #32
20008b16:	d10c      	bne.n	20008b32 <HAL_I2C_EnableListen_IT+0x2e>
  {
    hi2c->State = HAL_I2C_STATE_LISTEN;
20008b18:	687b      	ldr	r3, [r7, #4]
20008b1a:	2228      	movs	r2, #40	; 0x28
20008b1c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR = I2C_Slave_ISR_IT;
20008b20:	687b      	ldr	r3, [r7, #4]
20008b22:	4a06      	ldr	r2, [pc, #24]	; (20008b3c <HAL_I2C_EnableListen_IT+0x38>)
20008b24:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the Address Match interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
20008b26:	2104      	movs	r1, #4
20008b28:	6878      	ldr	r0, [r7, #4]
20008b2a:	f001 fcb1 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20008b2e:	2300      	movs	r3, #0
20008b30:	e000      	b.n	20008b34 <HAL_I2C_EnableListen_IT+0x30>
  }
  else
  {
    return HAL_BUSY;
20008b32:	2302      	movs	r3, #2
  }
}
20008b34:	4618      	mov	r0, r3
20008b36:	3708      	adds	r7, #8
20008b38:	46bd      	mov	sp, r7
20008b3a:	bd80      	pop	{r7, pc}
20008b3c:	20009085 	.word	0x20009085

20008b40 <HAL_I2C_DisableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
{
20008b40:	b580      	push	{r7, lr}
20008b42:	b084      	sub	sp, #16
20008b44:	af00      	add	r7, sp, #0
20008b46:	6078      	str	r0, [r7, #4]
  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp;

  /* Disable Address listen mode only if a transfer is not ongoing */
  if (hi2c->State == HAL_I2C_STATE_LISTEN)
20008b48:	687b      	ldr	r3, [r7, #4]
20008b4a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20008b4e:	b2db      	uxtb	r3, r3
20008b50:	2b28      	cmp	r3, #40	; 0x28
20008b52:	d120      	bne.n	20008b96 <HAL_I2C_DisableListen_IT+0x56>
  {
    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
20008b54:	687b      	ldr	r3, [r7, #4]
20008b56:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20008b5a:	b2db      	uxtb	r3, r3
20008b5c:	f003 0303 	and.w	r3, r3, #3
20008b60:	60fb      	str	r3, [r7, #12]
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
20008b62:	687b      	ldr	r3, [r7, #4]
20008b64:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
20008b68:	b2db      	uxtb	r3, r3
20008b6a:	461a      	mov	r2, r3
20008b6c:	68fb      	ldr	r3, [r7, #12]
20008b6e:	431a      	orrs	r2, r3
20008b70:	687b      	ldr	r3, [r7, #4]
20008b72:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
20008b74:	687b      	ldr	r3, [r7, #4]
20008b76:	2220      	movs	r2, #32
20008b78:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
20008b7c:	687b      	ldr	r3, [r7, #4]
20008b7e:	2200      	movs	r2, #0
20008b80:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->XferISR = NULL;
20008b84:	687b      	ldr	r3, [r7, #4]
20008b86:	2200      	movs	r2, #0
20008b88:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable the Address Match interrupt */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
20008b8a:	2104      	movs	r1, #4
20008b8c:	6878      	ldr	r0, [r7, #4]
20008b8e:	f001 fced 	bl	2000a56c <I2C_Disable_IRQ>

    return HAL_OK;
20008b92:	2300      	movs	r3, #0
20008b94:	e000      	b.n	20008b98 <HAL_I2C_DisableListen_IT+0x58>
  }
  else
  {
    return HAL_BUSY;
20008b96:	2302      	movs	r3, #2
  }
}
20008b98:	4618      	mov	r0, r3
20008b9a:	3710      	adds	r7, #16
20008b9c:	46bd      	mov	sp, r7
20008b9e:	bd80      	pop	{r7, pc}

20008ba0 <HAL_I2C_Master_Abort_IT>:
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
{
20008ba0:	b580      	push	{r7, lr}
20008ba2:	b084      	sub	sp, #16
20008ba4:	af02      	add	r7, sp, #8
20008ba6:	6078      	str	r0, [r7, #4]
20008ba8:	460b      	mov	r3, r1
20008baa:	807b      	strh	r3, [r7, #2]
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
20008bac:	687b      	ldr	r3, [r7, #4]
20008bae:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
20008bb2:	b2db      	uxtb	r3, r3
20008bb4:	2b10      	cmp	r3, #16
20008bb6:	d129      	bne.n	20008c0c <HAL_I2C_Master_Abort_IT+0x6c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
20008bb8:	687b      	ldr	r3, [r7, #4]
20008bba:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20008bbe:	2b01      	cmp	r3, #1
20008bc0:	d101      	bne.n	20008bc6 <HAL_I2C_Master_Abort_IT+0x26>
20008bc2:	2302      	movs	r3, #2
20008bc4:	e023      	b.n	20008c0e <HAL_I2C_Master_Abort_IT+0x6e>
20008bc6:	687b      	ldr	r3, [r7, #4]
20008bc8:	2201      	movs	r2, #1
20008bca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
20008bce:	2102      	movs	r1, #2
20008bd0:	6878      	ldr	r0, [r7, #4]
20008bd2:	f001 fccb 	bl	2000a56c <I2C_Disable_IRQ>
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
20008bd6:	2101      	movs	r1, #1
20008bd8:	6878      	ldr	r0, [r7, #4]
20008bda:	f001 fcc7 	bl	2000a56c <I2C_Disable_IRQ>

    /* Set State at HAL_I2C_STATE_ABORT */
    hi2c->State = HAL_I2C_STATE_ABORT;
20008bde:	687b      	ldr	r3, [r7, #4]
20008be0:	2260      	movs	r2, #96	; 0x60
20008be2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
20008be6:	8879      	ldrh	r1, [r7, #2]
20008be8:	4b0b      	ldr	r3, [pc, #44]	; (20008c18 <HAL_I2C_Master_Abort_IT+0x78>)
20008bea:	9300      	str	r3, [sp, #0]
20008bec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20008bf0:	2201      	movs	r2, #1
20008bf2:	6878      	ldr	r0, [r7, #4]
20008bf4:	f001 fc1e 	bl	2000a434 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20008bf8:	687b      	ldr	r3, [r7, #4]
20008bfa:	2200      	movs	r2, #0
20008bfc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
20008c00:	2112      	movs	r1, #18
20008c02:	6878      	ldr	r0, [r7, #4]
20008c04:	f001 fc44 	bl	2000a490 <I2C_Enable_IRQ>

    return HAL_OK;
20008c08:	2300      	movs	r3, #0
20008c0a:	e000      	b.n	20008c0e <HAL_I2C_Master_Abort_IT+0x6e>
  }
  else
  {
    /* Wrong usage of abort function */
    /* This function should be used only in case of abort monitored by master device */
    return HAL_ERROR;
20008c0c:	2301      	movs	r3, #1
  }
}
20008c0e:	4618      	mov	r0, r3
20008c10:	3708      	adds	r7, #8
20008c12:	46bd      	mov	sp, r7
20008c14:	bd80      	pop	{r7, pc}
20008c16:	bf00      	nop
20008c18:	80004000 	.word	0x80004000

20008c1c <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
20008c1c:	b580      	push	{r7, lr}
20008c1e:	b084      	sub	sp, #16
20008c20:	af00      	add	r7, sp, #0
20008c22:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
20008c24:	687b      	ldr	r3, [r7, #4]
20008c26:	681b      	ldr	r3, [r3, #0]
20008c28:	699b      	ldr	r3, [r3, #24]
20008c2a:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
20008c2c:	687b      	ldr	r3, [r7, #4]
20008c2e:	681b      	ldr	r3, [r3, #0]
20008c30:	681b      	ldr	r3, [r3, #0]
20008c32:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
20008c34:	687b      	ldr	r3, [r7, #4]
20008c36:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20008c38:	2b00      	cmp	r3, #0
20008c3a:	d005      	beq.n	20008c48 <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
20008c3c:	687b      	ldr	r3, [r7, #4]
20008c3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20008c40:	68ba      	ldr	r2, [r7, #8]
20008c42:	68f9      	ldr	r1, [r7, #12]
20008c44:	6878      	ldr	r0, [r7, #4]
20008c46:	4798      	blx	r3
  }
}
20008c48:	bf00      	nop
20008c4a:	3710      	adds	r7, #16
20008c4c:	46bd      	mov	sp, r7
20008c4e:	bd80      	pop	{r7, pc}

20008c50 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
20008c50:	b580      	push	{r7, lr}
20008c52:	b086      	sub	sp, #24
20008c54:	af00      	add	r7, sp, #0
20008c56:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
20008c58:	687b      	ldr	r3, [r7, #4]
20008c5a:	681b      	ldr	r3, [r3, #0]
20008c5c:	699b      	ldr	r3, [r3, #24]
20008c5e:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
20008c60:	687b      	ldr	r3, [r7, #4]
20008c62:	681b      	ldr	r3, [r3, #0]
20008c64:	681b      	ldr	r3, [r3, #0]
20008c66:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
20008c68:	697b      	ldr	r3, [r7, #20]
20008c6a:	0a1b      	lsrs	r3, r3, #8
20008c6c:	f003 0301 	and.w	r3, r3, #1
20008c70:	2b00      	cmp	r3, #0
20008c72:	d010      	beq.n	20008c96 <HAL_I2C_ER_IRQHandler+0x46>
20008c74:	693b      	ldr	r3, [r7, #16]
20008c76:	09db      	lsrs	r3, r3, #7
20008c78:	f003 0301 	and.w	r3, r3, #1
20008c7c:	2b00      	cmp	r3, #0
20008c7e:	d00a      	beq.n	20008c96 <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
20008c80:	687b      	ldr	r3, [r7, #4]
20008c82:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008c84:	f043 0201 	orr.w	r2, r3, #1
20008c88:	687b      	ldr	r3, [r7, #4]
20008c8a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
20008c8c:	687b      	ldr	r3, [r7, #4]
20008c8e:	681b      	ldr	r3, [r3, #0]
20008c90:	f44f 7280 	mov.w	r2, #256	; 0x100
20008c94:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
20008c96:	697b      	ldr	r3, [r7, #20]
20008c98:	0a9b      	lsrs	r3, r3, #10
20008c9a:	f003 0301 	and.w	r3, r3, #1
20008c9e:	2b00      	cmp	r3, #0
20008ca0:	d010      	beq.n	20008cc4 <HAL_I2C_ER_IRQHandler+0x74>
20008ca2:	693b      	ldr	r3, [r7, #16]
20008ca4:	09db      	lsrs	r3, r3, #7
20008ca6:	f003 0301 	and.w	r3, r3, #1
20008caa:	2b00      	cmp	r3, #0
20008cac:	d00a      	beq.n	20008cc4 <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
20008cae:	687b      	ldr	r3, [r7, #4]
20008cb0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008cb2:	f043 0208 	orr.w	r2, r3, #8
20008cb6:	687b      	ldr	r3, [r7, #4]
20008cb8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
20008cba:	687b      	ldr	r3, [r7, #4]
20008cbc:	681b      	ldr	r3, [r3, #0]
20008cbe:	f44f 6280 	mov.w	r2, #1024	; 0x400
20008cc2:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
20008cc4:	697b      	ldr	r3, [r7, #20]
20008cc6:	0a5b      	lsrs	r3, r3, #9
20008cc8:	f003 0301 	and.w	r3, r3, #1
20008ccc:	2b00      	cmp	r3, #0
20008cce:	d010      	beq.n	20008cf2 <HAL_I2C_ER_IRQHandler+0xa2>
20008cd0:	693b      	ldr	r3, [r7, #16]
20008cd2:	09db      	lsrs	r3, r3, #7
20008cd4:	f003 0301 	and.w	r3, r3, #1
20008cd8:	2b00      	cmp	r3, #0
20008cda:	d00a      	beq.n	20008cf2 <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
20008cdc:	687b      	ldr	r3, [r7, #4]
20008cde:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008ce0:	f043 0202 	orr.w	r2, r3, #2
20008ce4:	687b      	ldr	r3, [r7, #4]
20008ce6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
20008ce8:	687b      	ldr	r3, [r7, #4]
20008cea:	681b      	ldr	r3, [r3, #0]
20008cec:	f44f 7200 	mov.w	r2, #512	; 0x200
20008cf0:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
20008cf2:	687b      	ldr	r3, [r7, #4]
20008cf4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008cf6:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
20008cf8:	68fb      	ldr	r3, [r7, #12]
20008cfa:	f003 030b 	and.w	r3, r3, #11
20008cfe:	2b00      	cmp	r3, #0
20008d00:	d003      	beq.n	20008d0a <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
20008d02:	68f9      	ldr	r1, [r7, #12]
20008d04:	6878      	ldr	r0, [r7, #4]
20008d06:	f000 ffeb 	bl	20009ce0 <I2C_ITError>
  }
}
20008d0a:	bf00      	nop
20008d0c:	3718      	adds	r7, #24
20008d0e:	46bd      	mov	sp, r7
20008d10:	bd80      	pop	{r7, pc}

20008d12 <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008d12:	b480      	push	{r7}
20008d14:	b083      	sub	sp, #12
20008d16:	af00      	add	r7, sp, #0
20008d18:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
20008d1a:	bf00      	nop
20008d1c:	370c      	adds	r7, #12
20008d1e:	46bd      	mov	sp, r7
20008d20:	f85d 7b04 	ldr.w	r7, [sp], #4
20008d24:	4770      	bx	lr

20008d26 <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008d26:	b480      	push	{r7}
20008d28:	b083      	sub	sp, #12
20008d2a:	af00      	add	r7, sp, #0
20008d2c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
20008d2e:	bf00      	nop
20008d30:	370c      	adds	r7, #12
20008d32:	46bd      	mov	sp, r7
20008d34:	f85d 7b04 	ldr.w	r7, [sp], #4
20008d38:	4770      	bx	lr

20008d3a <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008d3a:	b480      	push	{r7}
20008d3c:	b083      	sub	sp, #12
20008d3e:	af00      	add	r7, sp, #0
20008d40:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
20008d42:	bf00      	nop
20008d44:	370c      	adds	r7, #12
20008d46:	46bd      	mov	sp, r7
20008d48:	f85d 7b04 	ldr.w	r7, [sp], #4
20008d4c:	4770      	bx	lr

20008d4e <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008d4e:	b480      	push	{r7}
20008d50:	b083      	sub	sp, #12
20008d52:	af00      	add	r7, sp, #0
20008d54:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
20008d56:	bf00      	nop
20008d58:	370c      	adds	r7, #12
20008d5a:	46bd      	mov	sp, r7
20008d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
20008d60:	4770      	bx	lr

20008d62 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
20008d62:	b480      	push	{r7}
20008d64:	b083      	sub	sp, #12
20008d66:	af00      	add	r7, sp, #0
20008d68:	6078      	str	r0, [r7, #4]
20008d6a:	460b      	mov	r3, r1
20008d6c:	70fb      	strb	r3, [r7, #3]
20008d6e:	4613      	mov	r3, r2
20008d70:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
20008d72:	bf00      	nop
20008d74:	370c      	adds	r7, #12
20008d76:	46bd      	mov	sp, r7
20008d78:	f85d 7b04 	ldr.w	r7, [sp], #4
20008d7c:	4770      	bx	lr

20008d7e <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008d7e:	b480      	push	{r7}
20008d80:	b083      	sub	sp, #12
20008d82:	af00      	add	r7, sp, #0
20008d84:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
20008d86:	bf00      	nop
20008d88:	370c      	adds	r7, #12
20008d8a:	46bd      	mov	sp, r7
20008d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
20008d90:	4770      	bx	lr

20008d92 <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008d92:	b480      	push	{r7}
20008d94:	b083      	sub	sp, #12
20008d96:	af00      	add	r7, sp, #0
20008d98:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
20008d9a:	bf00      	nop
20008d9c:	370c      	adds	r7, #12
20008d9e:	46bd      	mov	sp, r7
20008da0:	f85d 7b04 	ldr.w	r7, [sp], #4
20008da4:	4770      	bx	lr

20008da6 <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008da6:	b480      	push	{r7}
20008da8:	b083      	sub	sp, #12
20008daa:	af00      	add	r7, sp, #0
20008dac:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
20008dae:	bf00      	nop
20008db0:	370c      	adds	r7, #12
20008db2:	46bd      	mov	sp, r7
20008db4:	f85d 7b04 	ldr.w	r7, [sp], #4
20008db8:	4770      	bx	lr

20008dba <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
20008dba:	b480      	push	{r7}
20008dbc:	b083      	sub	sp, #12
20008dbe:	af00      	add	r7, sp, #0
20008dc0:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
20008dc2:	bf00      	nop
20008dc4:	370c      	adds	r7, #12
20008dc6:	46bd      	mov	sp, r7
20008dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
20008dcc:	4770      	bx	lr

20008dce <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
20008dce:	b480      	push	{r7}
20008dd0:	b083      	sub	sp, #12
20008dd2:	af00      	add	r7, sp, #0
20008dd4:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
20008dd6:	bf00      	nop
20008dd8:	370c      	adds	r7, #12
20008dda:	46bd      	mov	sp, r7
20008ddc:	f85d 7b04 	ldr.w	r7, [sp], #4
20008de0:	4770      	bx	lr

20008de2 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
20008de2:	b480      	push	{r7}
20008de4:	b083      	sub	sp, #12
20008de6:	af00      	add	r7, sp, #0
20008de8:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
20008dea:	687b      	ldr	r3, [r7, #4]
20008dec:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20008df0:	b2db      	uxtb	r3, r3
}
20008df2:	4618      	mov	r0, r3
20008df4:	370c      	adds	r7, #12
20008df6:	46bd      	mov	sp, r7
20008df8:	f85d 7b04 	ldr.w	r7, [sp], #4
20008dfc:	4770      	bx	lr

20008dfe <HAL_I2C_GetMode>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  */
HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
{
20008dfe:	b480      	push	{r7}
20008e00:	b083      	sub	sp, #12
20008e02:	af00      	add	r7, sp, #0
20008e04:	6078      	str	r0, [r7, #4]
  return hi2c->Mode;
20008e06:	687b      	ldr	r3, [r7, #4]
20008e08:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
20008e0c:	b2db      	uxtb	r3, r3
}
20008e0e:	4618      	mov	r0, r3
20008e10:	370c      	adds	r7, #12
20008e12:	46bd      	mov	sp, r7
20008e14:	f85d 7b04 	ldr.w	r7, [sp], #4
20008e18:	4770      	bx	lr

20008e1a <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
* @retval I2C Error Code
*/
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
20008e1a:	b480      	push	{r7}
20008e1c:	b083      	sub	sp, #12
20008e1e:	af00      	add	r7, sp, #0
20008e20:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
20008e22:	687b      	ldr	r3, [r7, #4]
20008e24:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
20008e26:	4618      	mov	r0, r3
20008e28:	370c      	adds	r7, #12
20008e2a:	46bd      	mov	sp, r7
20008e2c:	f85d 7b04 	ldr.w	r7, [sp], #4
20008e30:	4770      	bx	lr

20008e32 <I2C_Master_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
20008e32:	b580      	push	{r7, lr}
20008e34:	b088      	sub	sp, #32
20008e36:	af02      	add	r7, sp, #8
20008e38:	60f8      	str	r0, [r7, #12]
20008e3a:	60b9      	str	r1, [r7, #8]
20008e3c:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
20008e3e:	68bb      	ldr	r3, [r7, #8]
20008e40:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
20008e42:	68fb      	ldr	r3, [r7, #12]
20008e44:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20008e48:	2b01      	cmp	r3, #1
20008e4a:	d101      	bne.n	20008e50 <I2C_Master_ISR_IT+0x1e>
20008e4c:	2302      	movs	r3, #2
20008e4e:	e115      	b.n	2000907c <I2C_Master_ISR_IT+0x24a>
20008e50:	68fb      	ldr	r3, [r7, #12]
20008e52:	2201      	movs	r2, #1
20008e54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
20008e58:	697b      	ldr	r3, [r7, #20]
20008e5a:	091b      	lsrs	r3, r3, #4
20008e5c:	f003 0301 	and.w	r3, r3, #1
20008e60:	2b00      	cmp	r3, #0
20008e62:	d013      	beq.n	20008e8c <I2C_Master_ISR_IT+0x5a>
20008e64:	687b      	ldr	r3, [r7, #4]
20008e66:	091b      	lsrs	r3, r3, #4
20008e68:	f003 0301 	and.w	r3, r3, #1
20008e6c:	2b00      	cmp	r3, #0
20008e6e:	d00d      	beq.n	20008e8c <I2C_Master_ISR_IT+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20008e70:	68fb      	ldr	r3, [r7, #12]
20008e72:	681b      	ldr	r3, [r3, #0]
20008e74:	2210      	movs	r2, #16
20008e76:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20008e78:	68fb      	ldr	r3, [r7, #12]
20008e7a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008e7c:	f043 0204 	orr.w	r2, r3, #4
20008e80:	68fb      	ldr	r3, [r7, #12]
20008e82:	645a      	str	r2, [r3, #68]	; 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
20008e84:	68f8      	ldr	r0, [r7, #12]
20008e86:	f000 ffeb 	bl	20009e60 <I2C_Flush_TXDR>
20008e8a:	e0e2      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
20008e8c:	697b      	ldr	r3, [r7, #20]
20008e8e:	089b      	lsrs	r3, r3, #2
20008e90:	f003 0301 	and.w	r3, r3, #1
20008e94:	2b00      	cmp	r3, #0
20008e96:	d023      	beq.n	20008ee0 <I2C_Master_ISR_IT+0xae>
20008e98:	687b      	ldr	r3, [r7, #4]
20008e9a:	089b      	lsrs	r3, r3, #2
20008e9c:	f003 0301 	and.w	r3, r3, #1
20008ea0:	2b00      	cmp	r3, #0
20008ea2:	d01d      	beq.n	20008ee0 <I2C_Master_ISR_IT+0xae>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
20008ea4:	697b      	ldr	r3, [r7, #20]
20008ea6:	f023 0304 	bic.w	r3, r3, #4
20008eaa:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20008eac:	68fb      	ldr	r3, [r7, #12]
20008eae:	681b      	ldr	r3, [r3, #0]
20008eb0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20008eb2:	68fb      	ldr	r3, [r7, #12]
20008eb4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20008eb6:	b2d2      	uxtb	r2, r2
20008eb8:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
20008eba:	68fb      	ldr	r3, [r7, #12]
20008ebc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20008ebe:	1c5a      	adds	r2, r3, #1
20008ec0:	68fb      	ldr	r3, [r7, #12]
20008ec2:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
20008ec4:	68fb      	ldr	r3, [r7, #12]
20008ec6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008ec8:	3b01      	subs	r3, #1
20008eca:	b29a      	uxth	r2, r3
20008ecc:	68fb      	ldr	r3, [r7, #12]
20008ece:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
20008ed0:	68fb      	ldr	r3, [r7, #12]
20008ed2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008ed4:	b29b      	uxth	r3, r3
20008ed6:	3b01      	subs	r3, #1
20008ed8:	b29a      	uxth	r2, r3
20008eda:	68fb      	ldr	r3, [r7, #12]
20008edc:	855a      	strh	r2, [r3, #42]	; 0x2a
20008ede:	e0b8      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
20008ee0:	697b      	ldr	r3, [r7, #20]
20008ee2:	085b      	lsrs	r3, r3, #1
20008ee4:	f003 0301 	and.w	r3, r3, #1
20008ee8:	2b00      	cmp	r3, #0
20008eea:	d01e      	beq.n	20008f2a <I2C_Master_ISR_IT+0xf8>
20008eec:	687b      	ldr	r3, [r7, #4]
20008eee:	085b      	lsrs	r3, r3, #1
20008ef0:	f003 0301 	and.w	r3, r3, #1
20008ef4:	2b00      	cmp	r3, #0
20008ef6:	d018      	beq.n	20008f2a <I2C_Master_ISR_IT+0xf8>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
20008ef8:	68fb      	ldr	r3, [r7, #12]
20008efa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20008efc:	781a      	ldrb	r2, [r3, #0]
20008efe:	68fb      	ldr	r3, [r7, #12]
20008f00:	681b      	ldr	r3, [r3, #0]
20008f02:	629a      	str	r2, [r3, #40]	; 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
20008f04:	68fb      	ldr	r3, [r7, #12]
20008f06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20008f08:	1c5a      	adds	r2, r3, #1
20008f0a:	68fb      	ldr	r3, [r7, #12]
20008f0c:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
20008f0e:	68fb      	ldr	r3, [r7, #12]
20008f10:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008f12:	3b01      	subs	r3, #1
20008f14:	b29a      	uxth	r2, r3
20008f16:	68fb      	ldr	r3, [r7, #12]
20008f18:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
20008f1a:	68fb      	ldr	r3, [r7, #12]
20008f1c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008f1e:	b29b      	uxth	r3, r3
20008f20:	3b01      	subs	r3, #1
20008f22:	b29a      	uxth	r2, r3
20008f24:	68fb      	ldr	r3, [r7, #12]
20008f26:	855a      	strh	r2, [r3, #42]	; 0x2a
20008f28:	e093      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
20008f2a:	697b      	ldr	r3, [r7, #20]
20008f2c:	09db      	lsrs	r3, r3, #7
20008f2e:	f003 0301 	and.w	r3, r3, #1
20008f32:	2b00      	cmp	r3, #0
20008f34:	d05e      	beq.n	20008ff4 <I2C_Master_ISR_IT+0x1c2>
20008f36:	687b      	ldr	r3, [r7, #4]
20008f38:	099b      	lsrs	r3, r3, #6
20008f3a:	f003 0301 	and.w	r3, r3, #1
20008f3e:	2b00      	cmp	r3, #0
20008f40:	d058      	beq.n	20008ff4 <I2C_Master_ISR_IT+0x1c2>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
20008f42:	68fb      	ldr	r3, [r7, #12]
20008f44:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008f46:	b29b      	uxth	r3, r3
20008f48:	2b00      	cmp	r3, #0
20008f4a:	d041      	beq.n	20008fd0 <I2C_Master_ISR_IT+0x19e>
20008f4c:	68fb      	ldr	r3, [r7, #12]
20008f4e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008f50:	2b00      	cmp	r3, #0
20008f52:	d13d      	bne.n	20008fd0 <I2C_Master_ISR_IT+0x19e>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
20008f54:	68fb      	ldr	r3, [r7, #12]
20008f56:	681b      	ldr	r3, [r3, #0]
20008f58:	685b      	ldr	r3, [r3, #4]
20008f5a:	b29b      	uxth	r3, r3
20008f5c:	f3c3 0309 	ubfx	r3, r3, #0, #10
20008f60:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
20008f62:	68fb      	ldr	r3, [r7, #12]
20008f64:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008f66:	b29b      	uxth	r3, r3
20008f68:	2bff      	cmp	r3, #255	; 0xff
20008f6a:	d90e      	bls.n	20008f8a <I2C_Master_ISR_IT+0x158>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
20008f6c:	68fb      	ldr	r3, [r7, #12]
20008f6e:	22ff      	movs	r2, #255	; 0xff
20008f70:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
20008f72:	68fb      	ldr	r3, [r7, #12]
20008f74:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008f76:	b2da      	uxtb	r2, r3
20008f78:	8a79      	ldrh	r1, [r7, #18]
20008f7a:	2300      	movs	r3, #0
20008f7c:	9300      	str	r3, [sp, #0]
20008f7e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20008f82:	68f8      	ldr	r0, [r7, #12]
20008f84:	f001 fa56 	bl	2000a434 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
20008f88:	e033      	b.n	20008ff2 <I2C_Master_ISR_IT+0x1c0>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
20008f8a:	68fb      	ldr	r3, [r7, #12]
20008f8c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20008f8e:	b29a      	uxth	r2, r3
20008f90:	68fb      	ldr	r3, [r7, #12]
20008f92:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
20008f94:	68fb      	ldr	r3, [r7, #12]
20008f96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20008f98:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20008f9c:	d00c      	beq.n	20008fb8 <I2C_Master_ISR_IT+0x186>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
20008f9e:	68fb      	ldr	r3, [r7, #12]
20008fa0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008fa2:	b2da      	uxtb	r2, r3
20008fa4:	68fb      	ldr	r3, [r7, #12]
20008fa6:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
20008fa8:	8a79      	ldrh	r1, [r7, #18]
20008faa:	2300      	movs	r3, #0
20008fac:	9300      	str	r3, [sp, #0]
20008fae:	4603      	mov	r3, r0
20008fb0:	68f8      	ldr	r0, [r7, #12]
20008fb2:	f001 fa3f 	bl	2000a434 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
20008fb6:	e01c      	b.n	20008ff2 <I2C_Master_ISR_IT+0x1c0>
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
20008fb8:	68fb      	ldr	r3, [r7, #12]
20008fba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20008fbc:	b2da      	uxtb	r2, r3
20008fbe:	8a79      	ldrh	r1, [r7, #18]
20008fc0:	2300      	movs	r3, #0
20008fc2:	9300      	str	r3, [sp, #0]
20008fc4:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20008fc8:	68f8      	ldr	r0, [r7, #12]
20008fca:	f001 fa33 	bl	2000a434 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
20008fce:	e010      	b.n	20008ff2 <I2C_Master_ISR_IT+0x1c0>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
20008fd0:	68fb      	ldr	r3, [r7, #12]
20008fd2:	681b      	ldr	r3, [r3, #0]
20008fd4:	685b      	ldr	r3, [r3, #4]
20008fd6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20008fda:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20008fde:	d003      	beq.n	20008fe8 <I2C_Master_ISR_IT+0x1b6>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
20008fe0:	68f8      	ldr	r0, [r7, #12]
20008fe2:	f000 fc3d 	bl	20009860 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
20008fe6:	e034      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
20008fe8:	2140      	movs	r1, #64	; 0x40
20008fea:	68f8      	ldr	r0, [r7, #12]
20008fec:	f000 fe78 	bl	20009ce0 <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
20008ff0:	e02f      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
20008ff2:	e02e      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
20008ff4:	697b      	ldr	r3, [r7, #20]
20008ff6:	099b      	lsrs	r3, r3, #6
20008ff8:	f003 0301 	and.w	r3, r3, #1
20008ffc:	2b00      	cmp	r3, #0
20008ffe:	d028      	beq.n	20009052 <I2C_Master_ISR_IT+0x220>
20009000:	687b      	ldr	r3, [r7, #4]
20009002:	099b      	lsrs	r3, r3, #6
20009004:	f003 0301 	and.w	r3, r3, #1
20009008:	2b00      	cmp	r3, #0
2000900a:	d022      	beq.n	20009052 <I2C_Master_ISR_IT+0x220>
  {
    if (hi2c->XferCount == 0U)
2000900c:	68fb      	ldr	r3, [r7, #12]
2000900e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009010:	b29b      	uxth	r3, r3
20009012:	2b00      	cmp	r3, #0
20009014:	d119      	bne.n	2000904a <I2C_Master_ISR_IT+0x218>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
20009016:	68fb      	ldr	r3, [r7, #12]
20009018:	681b      	ldr	r3, [r3, #0]
2000901a:	685b      	ldr	r3, [r3, #4]
2000901c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20009020:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20009024:	d015      	beq.n	20009052 <I2C_Master_ISR_IT+0x220>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
20009026:	68fb      	ldr	r3, [r7, #12]
20009028:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000902a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2000902e:	d108      	bne.n	20009042 <I2C_Master_ISR_IT+0x210>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
20009030:	68fb      	ldr	r3, [r7, #12]
20009032:	681b      	ldr	r3, [r3, #0]
20009034:	685a      	ldr	r2, [r3, #4]
20009036:	68fb      	ldr	r3, [r7, #12]
20009038:	681b      	ldr	r3, [r3, #0]
2000903a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000903e:	605a      	str	r2, [r3, #4]
20009040:	e007      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
20009042:	68f8      	ldr	r0, [r7, #12]
20009044:	f000 fc0c 	bl	20009860 <I2C_ITMasterSeqCplt>
20009048:	e003      	b.n	20009052 <I2C_Master_ISR_IT+0x220>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2000904a:	2140      	movs	r1, #64	; 0x40
2000904c:	68f8      	ldr	r0, [r7, #12]
2000904e:	f000 fe47 	bl	20009ce0 <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
20009052:	697b      	ldr	r3, [r7, #20]
20009054:	095b      	lsrs	r3, r3, #5
20009056:	f003 0301 	and.w	r3, r3, #1
2000905a:	2b00      	cmp	r3, #0
2000905c:	d009      	beq.n	20009072 <I2C_Master_ISR_IT+0x240>
2000905e:	687b      	ldr	r3, [r7, #4]
20009060:	095b      	lsrs	r3, r3, #5
20009062:	f003 0301 	and.w	r3, r3, #1
20009066:	2b00      	cmp	r3, #0
20009068:	d003      	beq.n	20009072 <I2C_Master_ISR_IT+0x240>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
2000906a:	6979      	ldr	r1, [r7, #20]
2000906c:	68f8      	ldr	r0, [r7, #12]
2000906e:	f000 fc71 	bl	20009954 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
20009072:	68fb      	ldr	r3, [r7, #12]
20009074:	2200      	movs	r2, #0
20009076:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2000907a:	2300      	movs	r3, #0
}
2000907c:	4618      	mov	r0, r3
2000907e:	3718      	adds	r7, #24
20009080:	46bd      	mov	sp, r7
20009082:	bd80      	pop	{r7, pc}

20009084 <I2C_Slave_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
20009084:	b580      	push	{r7, lr}
20009086:	b086      	sub	sp, #24
20009088:	af00      	add	r7, sp, #0
2000908a:	60f8      	str	r0, [r7, #12]
2000908c:	60b9      	str	r1, [r7, #8]
2000908e:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
20009090:	68fb      	ldr	r3, [r7, #12]
20009092:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009094:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
20009096:	68bb      	ldr	r3, [r7, #8]
20009098:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hi2c);
2000909a:	68fb      	ldr	r3, [r7, #12]
2000909c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200090a0:	2b01      	cmp	r3, #1
200090a2:	d101      	bne.n	200090a8 <I2C_Slave_ISR_IT+0x24>
200090a4:	2302      	movs	r3, #2
200090a6:	e0f0      	b.n	2000928a <I2C_Slave_ISR_IT+0x206>
200090a8:	68fb      	ldr	r3, [r7, #12]
200090aa:	2201      	movs	r2, #1
200090ac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
200090b0:	697b      	ldr	r3, [r7, #20]
200090b2:	091b      	lsrs	r3, r3, #4
200090b4:	f003 0301 	and.w	r3, r3, #1
200090b8:	2b00      	cmp	r3, #0
200090ba:	d04d      	beq.n	20009158 <I2C_Slave_ISR_IT+0xd4>
200090bc:	687b      	ldr	r3, [r7, #4]
200090be:	091b      	lsrs	r3, r3, #4
200090c0:	f003 0301 	and.w	r3, r3, #1
200090c4:	2b00      	cmp	r3, #0
200090c6:	d047      	beq.n	20009158 <I2C_Slave_ISR_IT+0xd4>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
200090c8:	68fb      	ldr	r3, [r7, #12]
200090ca:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200090cc:	b29b      	uxth	r3, r3
200090ce:	2b00      	cmp	r3, #0
200090d0:	d128      	bne.n	20009124 <I2C_Slave_ISR_IT+0xa0>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
200090d2:	68fb      	ldr	r3, [r7, #12]
200090d4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200090d8:	b2db      	uxtb	r3, r3
200090da:	2b28      	cmp	r3, #40	; 0x28
200090dc:	d108      	bne.n	200090f0 <I2C_Slave_ISR_IT+0x6c>
200090de:	693b      	ldr	r3, [r7, #16]
200090e0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200090e4:	d104      	bne.n	200090f0 <I2C_Slave_ISR_IT+0x6c>
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
200090e6:	6979      	ldr	r1, [r7, #20]
200090e8:	68f8      	ldr	r0, [r7, #12]
200090ea:	f000 fda5 	bl	20009c38 <I2C_ITListenCplt>
200090ee:	e032      	b.n	20009156 <I2C_Slave_ISR_IT+0xd2>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
200090f0:	68fb      	ldr	r3, [r7, #12]
200090f2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200090f6:	b2db      	uxtb	r3, r3
200090f8:	2b29      	cmp	r3, #41	; 0x29
200090fa:	d10e      	bne.n	2000911a <I2C_Slave_ISR_IT+0x96>
200090fc:	693b      	ldr	r3, [r7, #16]
200090fe:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20009102:	d00a      	beq.n	2000911a <I2C_Slave_ISR_IT+0x96>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20009104:	68fb      	ldr	r3, [r7, #12]
20009106:	681b      	ldr	r3, [r3, #0]
20009108:	2210      	movs	r2, #16
2000910a:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
2000910c:	68f8      	ldr	r0, [r7, #12]
2000910e:	f000 fea7 	bl	20009e60 <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
20009112:	68f8      	ldr	r0, [r7, #12]
20009114:	f000 fbe1 	bl	200098da <I2C_ITSlaveSeqCplt>
20009118:	e01d      	b.n	20009156 <I2C_Slave_ISR_IT+0xd2>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2000911a:	68fb      	ldr	r3, [r7, #12]
2000911c:	681b      	ldr	r3, [r3, #0]
2000911e:	2210      	movs	r2, #16
20009120:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
20009122:	e09a      	b.n	2000925a <I2C_Slave_ISR_IT+0x1d6>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20009124:	68fb      	ldr	r3, [r7, #12]
20009126:	681b      	ldr	r3, [r3, #0]
20009128:	2210      	movs	r2, #16
2000912a:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2000912c:	68fb      	ldr	r3, [r7, #12]
2000912e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20009130:	f043 0204 	orr.w	r2, r3, #4
20009134:	68fb      	ldr	r3, [r7, #12]
20009136:	645a      	str	r2, [r3, #68]	; 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
20009138:	693b      	ldr	r3, [r7, #16]
2000913a:	2b00      	cmp	r3, #0
2000913c:	d004      	beq.n	20009148 <I2C_Slave_ISR_IT+0xc4>
2000913e:	693b      	ldr	r3, [r7, #16]
20009140:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009144:	f040 8089 	bne.w	2000925a <I2C_Slave_ISR_IT+0x1d6>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
20009148:	68fb      	ldr	r3, [r7, #12]
2000914a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000914c:	4619      	mov	r1, r3
2000914e:	68f8      	ldr	r0, [r7, #12]
20009150:	f000 fdc6 	bl	20009ce0 <I2C_ITError>
    if (hi2c->XferCount == 0U)
20009154:	e081      	b.n	2000925a <I2C_Slave_ISR_IT+0x1d6>
20009156:	e080      	b.n	2000925a <I2C_Slave_ISR_IT+0x1d6>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
20009158:	697b      	ldr	r3, [r7, #20]
2000915a:	089b      	lsrs	r3, r3, #2
2000915c:	f003 0301 	and.w	r3, r3, #1
20009160:	2b00      	cmp	r3, #0
20009162:	d034      	beq.n	200091ce <I2C_Slave_ISR_IT+0x14a>
20009164:	687b      	ldr	r3, [r7, #4]
20009166:	089b      	lsrs	r3, r3, #2
20009168:	f003 0301 	and.w	r3, r3, #1
2000916c:	2b00      	cmp	r3, #0
2000916e:	d02e      	beq.n	200091ce <I2C_Slave_ISR_IT+0x14a>
  {
    if (hi2c->XferCount > 0U)
20009170:	68fb      	ldr	r3, [r7, #12]
20009172:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009174:	b29b      	uxth	r3, r3
20009176:	2b00      	cmp	r3, #0
20009178:	d01c      	beq.n	200091b4 <I2C_Slave_ISR_IT+0x130>
    {
      /* Remove RXNE flag on temporary variable as read done */
      tmpITFlags &= ~I2C_FLAG_RXNE;
2000917a:	697b      	ldr	r3, [r7, #20]
2000917c:	f023 0304 	bic.w	r3, r3, #4
20009180:	617b      	str	r3, [r7, #20]

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20009182:	68fb      	ldr	r3, [r7, #12]
20009184:	681b      	ldr	r3, [r3, #0]
20009186:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20009188:	68fb      	ldr	r3, [r7, #12]
2000918a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000918c:	b2d2      	uxtb	r2, r2
2000918e:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
20009190:	68fb      	ldr	r3, [r7, #12]
20009192:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009194:	1c5a      	adds	r2, r3, #1
20009196:	68fb      	ldr	r3, [r7, #12]
20009198:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2000919a:	68fb      	ldr	r3, [r7, #12]
2000919c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000919e:	3b01      	subs	r3, #1
200091a0:	b29a      	uxth	r2, r3
200091a2:	68fb      	ldr	r3, [r7, #12]
200091a4:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
200091a6:	68fb      	ldr	r3, [r7, #12]
200091a8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200091aa:	b29b      	uxth	r3, r3
200091ac:	3b01      	subs	r3, #1
200091ae:	b29a      	uxth	r2, r3
200091b0:	68fb      	ldr	r3, [r7, #12]
200091b2:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
200091b4:	68fb      	ldr	r3, [r7, #12]
200091b6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200091b8:	b29b      	uxth	r3, r3
200091ba:	2b00      	cmp	r3, #0
200091bc:	d14f      	bne.n	2000925e <I2C_Slave_ISR_IT+0x1da>
200091be:	693b      	ldr	r3, [r7, #16]
200091c0:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
200091c4:	d04b      	beq.n	2000925e <I2C_Slave_ISR_IT+0x1da>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
200091c6:	68f8      	ldr	r0, [r7, #12]
200091c8:	f000 fb87 	bl	200098da <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
200091cc:	e047      	b.n	2000925e <I2C_Slave_ISR_IT+0x1da>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
200091ce:	697b      	ldr	r3, [r7, #20]
200091d0:	08db      	lsrs	r3, r3, #3
200091d2:	f003 0301 	and.w	r3, r3, #1
200091d6:	2b00      	cmp	r3, #0
200091d8:	d00a      	beq.n	200091f0 <I2C_Slave_ISR_IT+0x16c>
200091da:	687b      	ldr	r3, [r7, #4]
200091dc:	08db      	lsrs	r3, r3, #3
200091de:	f003 0301 	and.w	r3, r3, #1
200091e2:	2b00      	cmp	r3, #0
200091e4:	d004      	beq.n	200091f0 <I2C_Slave_ISR_IT+0x16c>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
200091e6:	6979      	ldr	r1, [r7, #20]
200091e8:	68f8      	ldr	r0, [r7, #12]
200091ea:	f000 fab7 	bl	2000975c <I2C_ITAddrCplt>
200091ee:	e037      	b.n	20009260 <I2C_Slave_ISR_IT+0x1dc>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
200091f0:	697b      	ldr	r3, [r7, #20]
200091f2:	085b      	lsrs	r3, r3, #1
200091f4:	f003 0301 	and.w	r3, r3, #1
200091f8:	2b00      	cmp	r3, #0
200091fa:	d031      	beq.n	20009260 <I2C_Slave_ISR_IT+0x1dc>
200091fc:	687b      	ldr	r3, [r7, #4]
200091fe:	085b      	lsrs	r3, r3, #1
20009200:	f003 0301 	and.w	r3, r3, #1
20009204:	2b00      	cmp	r3, #0
20009206:	d02b      	beq.n	20009260 <I2C_Slave_ISR_IT+0x1dc>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Datas have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
20009208:	68fb      	ldr	r3, [r7, #12]
2000920a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000920c:	b29b      	uxth	r3, r3
2000920e:	2b00      	cmp	r3, #0
20009210:	d018      	beq.n	20009244 <I2C_Slave_ISR_IT+0x1c0>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
20009212:	68fb      	ldr	r3, [r7, #12]
20009214:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009216:	781a      	ldrb	r2, [r3, #0]
20009218:	68fb      	ldr	r3, [r7, #12]
2000921a:	681b      	ldr	r3, [r3, #0]
2000921c:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2000921e:	68fb      	ldr	r3, [r7, #12]
20009220:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009222:	1c5a      	adds	r2, r3, #1
20009224:	68fb      	ldr	r3, [r7, #12]
20009226:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
20009228:	68fb      	ldr	r3, [r7, #12]
2000922a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000922c:	b29b      	uxth	r3, r3
2000922e:	3b01      	subs	r3, #1
20009230:	b29a      	uxth	r2, r3
20009232:	68fb      	ldr	r3, [r7, #12]
20009234:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
20009236:	68fb      	ldr	r3, [r7, #12]
20009238:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000923a:	3b01      	subs	r3, #1
2000923c:	b29a      	uxth	r2, r3
2000923e:	68fb      	ldr	r3, [r7, #12]
20009240:	851a      	strh	r2, [r3, #40]	; 0x28
20009242:	e00d      	b.n	20009260 <I2C_Slave_ISR_IT+0x1dc>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
20009244:	693b      	ldr	r3, [r7, #16]
20009246:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000924a:	d002      	beq.n	20009252 <I2C_Slave_ISR_IT+0x1ce>
2000924c:	693b      	ldr	r3, [r7, #16]
2000924e:	2b00      	cmp	r3, #0
20009250:	d106      	bne.n	20009260 <I2C_Slave_ISR_IT+0x1dc>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
20009252:	68f8      	ldr	r0, [r7, #12]
20009254:	f000 fb41 	bl	200098da <I2C_ITSlaveSeqCplt>
20009258:	e002      	b.n	20009260 <I2C_Slave_ISR_IT+0x1dc>
    if (hi2c->XferCount == 0U)
2000925a:	bf00      	nop
2000925c:	e000      	b.n	20009260 <I2C_Slave_ISR_IT+0x1dc>
    if ((hi2c->XferCount == 0U) && \
2000925e:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
20009260:	697b      	ldr	r3, [r7, #20]
20009262:	095b      	lsrs	r3, r3, #5
20009264:	f003 0301 	and.w	r3, r3, #1
20009268:	2b00      	cmp	r3, #0
2000926a:	d009      	beq.n	20009280 <I2C_Slave_ISR_IT+0x1fc>
2000926c:	687b      	ldr	r3, [r7, #4]
2000926e:	095b      	lsrs	r3, r3, #5
20009270:	f003 0301 	and.w	r3, r3, #1
20009274:	2b00      	cmp	r3, #0
20009276:	d003      	beq.n	20009280 <I2C_Slave_ISR_IT+0x1fc>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
20009278:	6979      	ldr	r1, [r7, #20]
2000927a:	68f8      	ldr	r0, [r7, #12]
2000927c:	f000 fc06 	bl	20009a8c <I2C_ITSlaveCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
20009280:	68fb      	ldr	r3, [r7, #12]
20009282:	2200      	movs	r2, #0
20009284:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
20009288:	2300      	movs	r3, #0
}
2000928a:	4618      	mov	r0, r3
2000928c:	3718      	adds	r7, #24
2000928e:	46bd      	mov	sp, r7
20009290:	bd80      	pop	{r7, pc}

20009292 <I2C_Master_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
20009292:	b580      	push	{r7, lr}
20009294:	b088      	sub	sp, #32
20009296:	af02      	add	r7, sp, #8
20009298:	60f8      	str	r0, [r7, #12]
2000929a:	60b9      	str	r1, [r7, #8]
2000929c:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
2000929e:	68fb      	ldr	r3, [r7, #12]
200092a0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200092a4:	2b01      	cmp	r3, #1
200092a6:	d101      	bne.n	200092ac <I2C_Master_ISR_DMA+0x1a>
200092a8:	2302      	movs	r3, #2
200092aa:	e0e1      	b.n	20009470 <I2C_Master_ISR_DMA+0x1de>
200092ac:	68fb      	ldr	r3, [r7, #12]
200092ae:	2201      	movs	r2, #1
200092b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
200092b4:	68bb      	ldr	r3, [r7, #8]
200092b6:	091b      	lsrs	r3, r3, #4
200092b8:	f003 0301 	and.w	r3, r3, #1
200092bc:	2b00      	cmp	r3, #0
200092be:	d017      	beq.n	200092f0 <I2C_Master_ISR_DMA+0x5e>
200092c0:	687b      	ldr	r3, [r7, #4]
200092c2:	091b      	lsrs	r3, r3, #4
200092c4:	f003 0301 	and.w	r3, r3, #1
200092c8:	2b00      	cmp	r3, #0
200092ca:	d011      	beq.n	200092f0 <I2C_Master_ISR_DMA+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
200092cc:	68fb      	ldr	r3, [r7, #12]
200092ce:	681b      	ldr	r3, [r3, #0]
200092d0:	2210      	movs	r2, #16
200092d2:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
200092d4:	68fb      	ldr	r3, [r7, #12]
200092d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200092d8:	f043 0204 	orr.w	r2, r3, #4
200092dc:	68fb      	ldr	r3, [r7, #12]
200092de:	645a      	str	r2, [r3, #68]	; 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
200092e0:	2112      	movs	r1, #18
200092e2:	68f8      	ldr	r0, [r7, #12]
200092e4:	f001 f8d4 	bl	2000a490 <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
200092e8:	68f8      	ldr	r0, [r7, #12]
200092ea:	f000 fdb9 	bl	20009e60 <I2C_Flush_TXDR>
200092ee:	e0ba      	b.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
200092f0:	68bb      	ldr	r3, [r7, #8]
200092f2:	09db      	lsrs	r3, r3, #7
200092f4:	f003 0301 	and.w	r3, r3, #1
200092f8:	2b00      	cmp	r3, #0
200092fa:	d072      	beq.n	200093e2 <I2C_Master_ISR_DMA+0x150>
200092fc:	687b      	ldr	r3, [r7, #4]
200092fe:	099b      	lsrs	r3, r3, #6
20009300:	f003 0301 	and.w	r3, r3, #1
20009304:	2b00      	cmp	r3, #0
20009306:	d06c      	beq.n	200093e2 <I2C_Master_ISR_DMA+0x150>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
20009308:	68fb      	ldr	r3, [r7, #12]
2000930a:	681b      	ldr	r3, [r3, #0]
2000930c:	681a      	ldr	r2, [r3, #0]
2000930e:	68fb      	ldr	r3, [r7, #12]
20009310:	681b      	ldr	r3, [r3, #0]
20009312:	f022 0240 	bic.w	r2, r2, #64	; 0x40
20009316:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
20009318:	68fb      	ldr	r3, [r7, #12]
2000931a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000931c:	b29b      	uxth	r3, r3
2000931e:	2b00      	cmp	r3, #0
20009320:	d04e      	beq.n	200093c0 <I2C_Master_ISR_DMA+0x12e>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
20009322:	68fb      	ldr	r3, [r7, #12]
20009324:	681b      	ldr	r3, [r3, #0]
20009326:	685b      	ldr	r3, [r3, #4]
20009328:	b29b      	uxth	r3, r3
2000932a:	f3c3 0309 	ubfx	r3, r3, #0, #10
2000932e:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
20009330:	68fb      	ldr	r3, [r7, #12]
20009332:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009334:	b29b      	uxth	r3, r3
20009336:	2bff      	cmp	r3, #255	; 0xff
20009338:	d906      	bls.n	20009348 <I2C_Master_ISR_DMA+0xb6>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2000933a:	68fb      	ldr	r3, [r7, #12]
2000933c:	22ff      	movs	r2, #255	; 0xff
2000933e:	851a      	strh	r2, [r3, #40]	; 0x28
        xfermode = I2C_RELOAD_MODE;
20009340:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20009344:	617b      	str	r3, [r7, #20]
20009346:	e010      	b.n	2000936a <I2C_Master_ISR_DMA+0xd8>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
20009348:	68fb      	ldr	r3, [r7, #12]
2000934a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2000934c:	b29a      	uxth	r2, r3
2000934e:	68fb      	ldr	r3, [r7, #12]
20009350:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
20009352:	68fb      	ldr	r3, [r7, #12]
20009354:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009356:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2000935a:	d003      	beq.n	20009364 <I2C_Master_ISR_DMA+0xd2>
        {
          xfermode = hi2c->XferOptions;
2000935c:	68fb      	ldr	r3, [r7, #12]
2000935e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009360:	617b      	str	r3, [r7, #20]
20009362:	e002      	b.n	2000936a <I2C_Master_ISR_DMA+0xd8>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
20009364:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
20009368:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2000936a:	68fb      	ldr	r3, [r7, #12]
2000936c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000936e:	b2da      	uxtb	r2, r3
20009370:	8a79      	ldrh	r1, [r7, #18]
20009372:	2300      	movs	r3, #0
20009374:	9300      	str	r3, [sp, #0]
20009376:	697b      	ldr	r3, [r7, #20]
20009378:	68f8      	ldr	r0, [r7, #12]
2000937a:	f001 f85b 	bl	2000a434 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2000937e:	68fb      	ldr	r3, [r7, #12]
20009380:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009382:	b29a      	uxth	r2, r3
20009384:	68fb      	ldr	r3, [r7, #12]
20009386:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20009388:	1ad3      	subs	r3, r2, r3
2000938a:	b29a      	uxth	r2, r3
2000938c:	68fb      	ldr	r3, [r7, #12]
2000938e:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
20009390:	68fb      	ldr	r3, [r7, #12]
20009392:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009396:	b2db      	uxtb	r3, r3
20009398:	2b22      	cmp	r3, #34	; 0x22
2000939a:	d108      	bne.n	200093ae <I2C_Master_ISR_DMA+0x11c>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2000939c:	68fb      	ldr	r3, [r7, #12]
2000939e:	681b      	ldr	r3, [r3, #0]
200093a0:	681a      	ldr	r2, [r3, #0]
200093a2:	68fb      	ldr	r3, [r7, #12]
200093a4:	681b      	ldr	r3, [r3, #0]
200093a6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
200093aa:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
200093ac:	e05b      	b.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
200093ae:	68fb      	ldr	r3, [r7, #12]
200093b0:	681b      	ldr	r3, [r3, #0]
200093b2:	681a      	ldr	r2, [r3, #0]
200093b4:	68fb      	ldr	r3, [r7, #12]
200093b6:	681b      	ldr	r3, [r3, #0]
200093b8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
200093bc:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
200093be:	e052      	b.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
200093c0:	68fb      	ldr	r3, [r7, #12]
200093c2:	681b      	ldr	r3, [r3, #0]
200093c4:	685b      	ldr	r3, [r3, #4]
200093c6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200093ca:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
200093ce:	d003      	beq.n	200093d8 <I2C_Master_ISR_DMA+0x146>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
200093d0:	68f8      	ldr	r0, [r7, #12]
200093d2:	f000 fa45 	bl	20009860 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
200093d6:	e046      	b.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
200093d8:	2140      	movs	r1, #64	; 0x40
200093da:	68f8      	ldr	r0, [r7, #12]
200093dc:	f000 fc80 	bl	20009ce0 <I2C_ITError>
    if (hi2c->XferCount != 0U)
200093e0:	e041      	b.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
200093e2:	68bb      	ldr	r3, [r7, #8]
200093e4:	099b      	lsrs	r3, r3, #6
200093e6:	f003 0301 	and.w	r3, r3, #1
200093ea:	2b00      	cmp	r3, #0
200093ec:	d029      	beq.n	20009442 <I2C_Master_ISR_DMA+0x1b0>
200093ee:	687b      	ldr	r3, [r7, #4]
200093f0:	099b      	lsrs	r3, r3, #6
200093f2:	f003 0301 	and.w	r3, r3, #1
200093f6:	2b00      	cmp	r3, #0
200093f8:	d023      	beq.n	20009442 <I2C_Master_ISR_DMA+0x1b0>
  {
    if (hi2c->XferCount == 0U)
200093fa:	68fb      	ldr	r3, [r7, #12]
200093fc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
200093fe:	b29b      	uxth	r3, r3
20009400:	2b00      	cmp	r3, #0
20009402:	d119      	bne.n	20009438 <I2C_Master_ISR_DMA+0x1a6>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
20009404:	68fb      	ldr	r3, [r7, #12]
20009406:	681b      	ldr	r3, [r3, #0]
20009408:	685b      	ldr	r3, [r3, #4]
2000940a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000940e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20009412:	d027      	beq.n	20009464 <I2C_Master_ISR_DMA+0x1d2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
20009414:	68fb      	ldr	r3, [r7, #12]
20009416:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009418:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2000941c:	d108      	bne.n	20009430 <I2C_Master_ISR_DMA+0x19e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2000941e:	68fb      	ldr	r3, [r7, #12]
20009420:	681b      	ldr	r3, [r3, #0]
20009422:	685a      	ldr	r2, [r3, #4]
20009424:	68fb      	ldr	r3, [r7, #12]
20009426:	681b      	ldr	r3, [r3, #0]
20009428:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2000942c:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
2000942e:	e019      	b.n	20009464 <I2C_Master_ISR_DMA+0x1d2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
20009430:	68f8      	ldr	r0, [r7, #12]
20009432:	f000 fa15 	bl	20009860 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
20009436:	e015      	b.n	20009464 <I2C_Master_ISR_DMA+0x1d2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
20009438:	2140      	movs	r1, #64	; 0x40
2000943a:	68f8      	ldr	r0, [r7, #12]
2000943c:	f000 fc50 	bl	20009ce0 <I2C_ITError>
    if (hi2c->XferCount == 0U)
20009440:	e010      	b.n	20009464 <I2C_Master_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
20009442:	68bb      	ldr	r3, [r7, #8]
20009444:	095b      	lsrs	r3, r3, #5
20009446:	f003 0301 	and.w	r3, r3, #1
2000944a:	2b00      	cmp	r3, #0
2000944c:	d00b      	beq.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
2000944e:	687b      	ldr	r3, [r7, #4]
20009450:	095b      	lsrs	r3, r3, #5
20009452:	f003 0301 	and.w	r3, r3, #1
20009456:	2b00      	cmp	r3, #0
20009458:	d005      	beq.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
2000945a:	68b9      	ldr	r1, [r7, #8]
2000945c:	68f8      	ldr	r0, [r7, #12]
2000945e:	f000 fa79 	bl	20009954 <I2C_ITMasterCplt>
20009462:	e000      	b.n	20009466 <I2C_Master_ISR_DMA+0x1d4>
    if (hi2c->XferCount == 0U)
20009464:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
20009466:	68fb      	ldr	r3, [r7, #12]
20009468:	2200      	movs	r2, #0
2000946a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2000946e:	2300      	movs	r3, #0
}
20009470:	4618      	mov	r0, r3
20009472:	3718      	adds	r7, #24
20009474:	46bd      	mov	sp, r7
20009476:	bd80      	pop	{r7, pc}

20009478 <I2C_Slave_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
20009478:	b580      	push	{r7, lr}
2000947a:	b086      	sub	sp, #24
2000947c:	af00      	add	r7, sp, #0
2000947e:	60f8      	str	r0, [r7, #12]
20009480:	60b9      	str	r1, [r7, #8]
20009482:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
20009484:	68fb      	ldr	r3, [r7, #12]
20009486:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009488:	613b      	str	r3, [r7, #16]
  uint32_t treatdmanack = 0U;
2000948a:	2300      	movs	r3, #0
2000948c:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hi2c);
2000948e:	68fb      	ldr	r3, [r7, #12]
20009490:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20009494:	2b01      	cmp	r3, #1
20009496:	d101      	bne.n	2000949c <I2C_Slave_ISR_DMA+0x24>
20009498:	2302      	movs	r3, #2
2000949a:	e0b2      	b.n	20009602 <I2C_Slave_ISR_DMA+0x18a>
2000949c:	68fb      	ldr	r3, [r7, #12]
2000949e:	2201      	movs	r2, #1
200094a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
200094a4:	68bb      	ldr	r3, [r7, #8]
200094a6:	091b      	lsrs	r3, r3, #4
200094a8:	f003 0301 	and.w	r3, r3, #1
200094ac:	2b00      	cmp	r3, #0
200094ae:	f000 8082 	beq.w	200095b6 <I2C_Slave_ISR_DMA+0x13e>
200094b2:	687b      	ldr	r3, [r7, #4]
200094b4:	091b      	lsrs	r3, r3, #4
200094b6:	f003 0301 	and.w	r3, r3, #1
200094ba:	2b00      	cmp	r3, #0
200094bc:	d07b      	beq.n	200095b6 <I2C_Slave_ISR_DMA+0x13e>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
200094be:	687b      	ldr	r3, [r7, #4]
200094c0:	0b9b      	lsrs	r3, r3, #14
200094c2:	f003 0301 	and.w	r3, r3, #1
200094c6:	2b00      	cmp	r3, #0
200094c8:	d105      	bne.n	200094d6 <I2C_Slave_ISR_DMA+0x5e>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
200094ca:	687b      	ldr	r3, [r7, #4]
200094cc:	0bdb      	lsrs	r3, r3, #15
200094ce:	f003 0301 	and.w	r3, r3, #1
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
200094d2:	2b00      	cmp	r3, #0
200094d4:	d068      	beq.n	200095a8 <I2C_Slave_ISR_DMA+0x130>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
200094d6:	68fb      	ldr	r3, [r7, #12]
200094d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200094da:	2b00      	cmp	r3, #0
200094dc:	d00d      	beq.n	200094fa <I2C_Slave_ISR_DMA+0x82>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
200094de:	687b      	ldr	r3, [r7, #4]
200094e0:	0bdb      	lsrs	r3, r3, #15
200094e2:	f003 0301 	and.w	r3, r3, #1
200094e6:	2b00      	cmp	r3, #0
200094e8:	d007      	beq.n	200094fa <I2C_Slave_ISR_DMA+0x82>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
200094ea:	68fb      	ldr	r3, [r7, #12]
200094ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200094ee:	681b      	ldr	r3, [r3, #0]
200094f0:	685b      	ldr	r3, [r3, #4]
200094f2:	2b00      	cmp	r3, #0
200094f4:	d101      	bne.n	200094fa <I2C_Slave_ISR_DMA+0x82>
          {
            treatdmanack = 1U;
200094f6:	2301      	movs	r3, #1
200094f8:	617b      	str	r3, [r7, #20]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
200094fa:	68fb      	ldr	r3, [r7, #12]
200094fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200094fe:	2b00      	cmp	r3, #0
20009500:	d00d      	beq.n	2000951e <I2C_Slave_ISR_DMA+0xa6>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
20009502:	687b      	ldr	r3, [r7, #4]
20009504:	0b9b      	lsrs	r3, r3, #14
20009506:	f003 0301 	and.w	r3, r3, #1
2000950a:	2b00      	cmp	r3, #0
2000950c:	d007      	beq.n	2000951e <I2C_Slave_ISR_DMA+0xa6>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
2000950e:	68fb      	ldr	r3, [r7, #12]
20009510:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009512:	681b      	ldr	r3, [r3, #0]
20009514:	685b      	ldr	r3, [r3, #4]
20009516:	2b00      	cmp	r3, #0
20009518:	d101      	bne.n	2000951e <I2C_Slave_ISR_DMA+0xa6>
          {
            treatdmanack = 1U;
2000951a:	2301      	movs	r3, #1
2000951c:	617b      	str	r3, [r7, #20]
          }
        }
      }

      if (treatdmanack == 1U)
2000951e:	697b      	ldr	r3, [r7, #20]
20009520:	2b01      	cmp	r3, #1
20009522:	d128      	bne.n	20009576 <I2C_Slave_ISR_DMA+0xfe>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
20009524:	68fb      	ldr	r3, [r7, #12]
20009526:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000952a:	b2db      	uxtb	r3, r3
2000952c:	2b28      	cmp	r3, #40	; 0x28
2000952e:	d108      	bne.n	20009542 <I2C_Slave_ISR_DMA+0xca>
20009530:	693b      	ldr	r3, [r7, #16]
20009532:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20009536:	d104      	bne.n	20009542 <I2C_Slave_ISR_DMA+0xca>
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
20009538:	68b9      	ldr	r1, [r7, #8]
2000953a:	68f8      	ldr	r0, [r7, #12]
2000953c:	f000 fb7c 	bl	20009c38 <I2C_ITListenCplt>
20009540:	e031      	b.n	200095a6 <I2C_Slave_ISR_DMA+0x12e>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
20009542:	68fb      	ldr	r3, [r7, #12]
20009544:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009548:	b2db      	uxtb	r3, r3
2000954a:	2b29      	cmp	r3, #41	; 0x29
2000954c:	d10e      	bne.n	2000956c <I2C_Slave_ISR_DMA+0xf4>
2000954e:	693b      	ldr	r3, [r7, #16]
20009550:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20009554:	d00a      	beq.n	2000956c <I2C_Slave_ISR_DMA+0xf4>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20009556:	68fb      	ldr	r3, [r7, #12]
20009558:	681b      	ldr	r3, [r3, #0]
2000955a:	2210      	movs	r2, #16
2000955c:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
2000955e:	68f8      	ldr	r0, [r7, #12]
20009560:	f000 fc7e 	bl	20009e60 <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
20009564:	68f8      	ldr	r0, [r7, #12]
20009566:	f000 f9b8 	bl	200098da <I2C_ITSlaveSeqCplt>
2000956a:	e01c      	b.n	200095a6 <I2C_Slave_ISR_DMA+0x12e>
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2000956c:	68fb      	ldr	r3, [r7, #12]
2000956e:	681b      	ldr	r3, [r3, #0]
20009570:	2210      	movs	r2, #16
20009572:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
20009574:	e01d      	b.n	200095b2 <I2C_Slave_ISR_DMA+0x13a>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20009576:	68fb      	ldr	r3, [r7, #12]
20009578:	681b      	ldr	r3, [r3, #0]
2000957a:	2210      	movs	r2, #16
2000957c:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2000957e:	68fb      	ldr	r3, [r7, #12]
20009580:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20009582:	f043 0204 	orr.w	r2, r3, #4
20009586:	68fb      	ldr	r3, [r7, #12]
20009588:	645a      	str	r2, [r3, #68]	; 0x44

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2000958a:	693b      	ldr	r3, [r7, #16]
2000958c:	2b00      	cmp	r3, #0
2000958e:	d003      	beq.n	20009598 <I2C_Slave_ISR_DMA+0x120>
20009590:	693b      	ldr	r3, [r7, #16]
20009592:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009596:	d10c      	bne.n	200095b2 <I2C_Slave_ISR_DMA+0x13a>
        {
          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
20009598:	68fb      	ldr	r3, [r7, #12]
2000959a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000959c:	4619      	mov	r1, r3
2000959e:	68f8      	ldr	r0, [r7, #12]
200095a0:	f000 fb9e 	bl	20009ce0 <I2C_ITError>
      if (treatdmanack == 1U)
200095a4:	e005      	b.n	200095b2 <I2C_Slave_ISR_DMA+0x13a>
200095a6:	e004      	b.n	200095b2 <I2C_Slave_ISR_DMA+0x13a>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
200095a8:	68fb      	ldr	r3, [r7, #12]
200095aa:	681b      	ldr	r3, [r3, #0]
200095ac:	2210      	movs	r2, #16
200095ae:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
200095b0:	e022      	b.n	200095f8 <I2C_Slave_ISR_DMA+0x180>
      if (treatdmanack == 1U)
200095b2:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
200095b4:	e020      	b.n	200095f8 <I2C_Slave_ISR_DMA+0x180>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
200095b6:	68bb      	ldr	r3, [r7, #8]
200095b8:	08db      	lsrs	r3, r3, #3
200095ba:	f003 0301 	and.w	r3, r3, #1
200095be:	2b00      	cmp	r3, #0
200095c0:	d00a      	beq.n	200095d8 <I2C_Slave_ISR_DMA+0x160>
200095c2:	687b      	ldr	r3, [r7, #4]
200095c4:	08db      	lsrs	r3, r3, #3
200095c6:	f003 0301 	and.w	r3, r3, #1
200095ca:	2b00      	cmp	r3, #0
200095cc:	d004      	beq.n	200095d8 <I2C_Slave_ISR_DMA+0x160>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
200095ce:	68b9      	ldr	r1, [r7, #8]
200095d0:	68f8      	ldr	r0, [r7, #12]
200095d2:	f000 f8c3 	bl	2000975c <I2C_ITAddrCplt>
200095d6:	e00f      	b.n	200095f8 <I2C_Slave_ISR_DMA+0x180>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
200095d8:	68bb      	ldr	r3, [r7, #8]
200095da:	095b      	lsrs	r3, r3, #5
200095dc:	f003 0301 	and.w	r3, r3, #1
200095e0:	2b00      	cmp	r3, #0
200095e2:	d009      	beq.n	200095f8 <I2C_Slave_ISR_DMA+0x180>
200095e4:	687b      	ldr	r3, [r7, #4]
200095e6:	095b      	lsrs	r3, r3, #5
200095e8:	f003 0301 	and.w	r3, r3, #1
200095ec:	2b00      	cmp	r3, #0
200095ee:	d003      	beq.n	200095f8 <I2C_Slave_ISR_DMA+0x180>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
200095f0:	68b9      	ldr	r1, [r7, #8]
200095f2:	68f8      	ldr	r0, [r7, #12]
200095f4:	f000 fa4a 	bl	20009a8c <I2C_ITSlaveCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
200095f8:	68fb      	ldr	r3, [r7, #12]
200095fa:	2200      	movs	r2, #0
200095fc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
20009600:	2300      	movs	r3, #0
}
20009602:	4618      	mov	r0, r3
20009604:	3718      	adds	r7, #24
20009606:	46bd      	mov	sp, r7
20009608:	bd80      	pop	{r7, pc}
	...

2000960c <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
2000960c:	b580      	push	{r7, lr}
2000960e:	b086      	sub	sp, #24
20009610:	af02      	add	r7, sp, #8
20009612:	60f8      	str	r0, [r7, #12]
20009614:	4608      	mov	r0, r1
20009616:	4611      	mov	r1, r2
20009618:	461a      	mov	r2, r3
2000961a:	4603      	mov	r3, r0
2000961c:	817b      	strh	r3, [r7, #10]
2000961e:	460b      	mov	r3, r1
20009620:	813b      	strh	r3, [r7, #8]
20009622:	4613      	mov	r3, r2
20009624:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
20009626:	88fb      	ldrh	r3, [r7, #6]
20009628:	b2da      	uxtb	r2, r3
2000962a:	8979      	ldrh	r1, [r7, #10]
2000962c:	4b20      	ldr	r3, [pc, #128]	; (200096b0 <I2C_RequestMemoryWrite+0xa4>)
2000962e:	9300      	str	r3, [sp, #0]
20009630:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20009634:	68f8      	ldr	r0, [r7, #12]
20009636:	f000 fefd 	bl	2000a434 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2000963a:	69fa      	ldr	r2, [r7, #28]
2000963c:	69b9      	ldr	r1, [r7, #24]
2000963e:	68f8      	ldr	r0, [r7, #12]
20009640:	f000 fda9 	bl	2000a196 <I2C_WaitOnTXISFlagUntilTimeout>
20009644:	4603      	mov	r3, r0
20009646:	2b00      	cmp	r3, #0
20009648:	d001      	beq.n	2000964e <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
2000964a:	2301      	movs	r3, #1
2000964c:	e02c      	b.n	200096a8 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2000964e:	88fb      	ldrh	r3, [r7, #6]
20009650:	2b01      	cmp	r3, #1
20009652:	d105      	bne.n	20009660 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
20009654:	893b      	ldrh	r3, [r7, #8]
20009656:	b2da      	uxtb	r2, r3
20009658:	68fb      	ldr	r3, [r7, #12]
2000965a:	681b      	ldr	r3, [r3, #0]
2000965c:	629a      	str	r2, [r3, #40]	; 0x28
2000965e:	e015      	b.n	2000968c <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
20009660:	893b      	ldrh	r3, [r7, #8]
20009662:	0a1b      	lsrs	r3, r3, #8
20009664:	b29b      	uxth	r3, r3
20009666:	b2da      	uxtb	r2, r3
20009668:	68fb      	ldr	r3, [r7, #12]
2000966a:	681b      	ldr	r3, [r3, #0]
2000966c:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2000966e:	69fa      	ldr	r2, [r7, #28]
20009670:	69b9      	ldr	r1, [r7, #24]
20009672:	68f8      	ldr	r0, [r7, #12]
20009674:	f000 fd8f 	bl	2000a196 <I2C_WaitOnTXISFlagUntilTimeout>
20009678:	4603      	mov	r3, r0
2000967a:	2b00      	cmp	r3, #0
2000967c:	d001      	beq.n	20009682 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
2000967e:	2301      	movs	r3, #1
20009680:	e012      	b.n	200096a8 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
20009682:	893b      	ldrh	r3, [r7, #8]
20009684:	b2da      	uxtb	r2, r3
20009686:	68fb      	ldr	r3, [r7, #12]
20009688:	681b      	ldr	r3, [r3, #0]
2000968a:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
2000968c:	69fb      	ldr	r3, [r7, #28]
2000968e:	9300      	str	r3, [sp, #0]
20009690:	69bb      	ldr	r3, [r7, #24]
20009692:	2200      	movs	r2, #0
20009694:	2180      	movs	r1, #128	; 0x80
20009696:	68f8      	ldr	r0, [r7, #12]
20009698:	f000 fd3d 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
2000969c:	4603      	mov	r3, r0
2000969e:	2b00      	cmp	r3, #0
200096a0:	d001      	beq.n	200096a6 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
200096a2:	2301      	movs	r3, #1
200096a4:	e000      	b.n	200096a8 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
200096a6:	2300      	movs	r3, #0
}
200096a8:	4618      	mov	r0, r3
200096aa:	3710      	adds	r7, #16
200096ac:	46bd      	mov	sp, r7
200096ae:	bd80      	pop	{r7, pc}
200096b0:	80002000 	.word	0x80002000

200096b4 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
200096b4:	b580      	push	{r7, lr}
200096b6:	b086      	sub	sp, #24
200096b8:	af02      	add	r7, sp, #8
200096ba:	60f8      	str	r0, [r7, #12]
200096bc:	4608      	mov	r0, r1
200096be:	4611      	mov	r1, r2
200096c0:	461a      	mov	r2, r3
200096c2:	4603      	mov	r3, r0
200096c4:	817b      	strh	r3, [r7, #10]
200096c6:	460b      	mov	r3, r1
200096c8:	813b      	strh	r3, [r7, #8]
200096ca:	4613      	mov	r3, r2
200096cc:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
200096ce:	88fb      	ldrh	r3, [r7, #6]
200096d0:	b2da      	uxtb	r2, r3
200096d2:	8979      	ldrh	r1, [r7, #10]
200096d4:	4b20      	ldr	r3, [pc, #128]	; (20009758 <I2C_RequestMemoryRead+0xa4>)
200096d6:	9300      	str	r3, [sp, #0]
200096d8:	2300      	movs	r3, #0
200096da:	68f8      	ldr	r0, [r7, #12]
200096dc:	f000 feaa 	bl	2000a434 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
200096e0:	69fa      	ldr	r2, [r7, #28]
200096e2:	69b9      	ldr	r1, [r7, #24]
200096e4:	68f8      	ldr	r0, [r7, #12]
200096e6:	f000 fd56 	bl	2000a196 <I2C_WaitOnTXISFlagUntilTimeout>
200096ea:	4603      	mov	r3, r0
200096ec:	2b00      	cmp	r3, #0
200096ee:	d001      	beq.n	200096f4 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
200096f0:	2301      	movs	r3, #1
200096f2:	e02c      	b.n	2000974e <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
200096f4:	88fb      	ldrh	r3, [r7, #6]
200096f6:	2b01      	cmp	r3, #1
200096f8:	d105      	bne.n	20009706 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
200096fa:	893b      	ldrh	r3, [r7, #8]
200096fc:	b2da      	uxtb	r2, r3
200096fe:	68fb      	ldr	r3, [r7, #12]
20009700:	681b      	ldr	r3, [r3, #0]
20009702:	629a      	str	r2, [r3, #40]	; 0x28
20009704:	e015      	b.n	20009732 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
20009706:	893b      	ldrh	r3, [r7, #8]
20009708:	0a1b      	lsrs	r3, r3, #8
2000970a:	b29b      	uxth	r3, r3
2000970c:	b2da      	uxtb	r2, r3
2000970e:	68fb      	ldr	r3, [r7, #12]
20009710:	681b      	ldr	r3, [r3, #0]
20009712:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
20009714:	69fa      	ldr	r2, [r7, #28]
20009716:	69b9      	ldr	r1, [r7, #24]
20009718:	68f8      	ldr	r0, [r7, #12]
2000971a:	f000 fd3c 	bl	2000a196 <I2C_WaitOnTXISFlagUntilTimeout>
2000971e:	4603      	mov	r3, r0
20009720:	2b00      	cmp	r3, #0
20009722:	d001      	beq.n	20009728 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
20009724:	2301      	movs	r3, #1
20009726:	e012      	b.n	2000974e <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
20009728:	893b      	ldrh	r3, [r7, #8]
2000972a:	b2da      	uxtb	r2, r3
2000972c:	68fb      	ldr	r3, [r7, #12]
2000972e:	681b      	ldr	r3, [r3, #0]
20009730:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
20009732:	69fb      	ldr	r3, [r7, #28]
20009734:	9300      	str	r3, [sp, #0]
20009736:	69bb      	ldr	r3, [r7, #24]
20009738:	2200      	movs	r2, #0
2000973a:	2140      	movs	r1, #64	; 0x40
2000973c:	68f8      	ldr	r0, [r7, #12]
2000973e:	f000 fcea 	bl	2000a116 <I2C_WaitOnFlagUntilTimeout>
20009742:	4603      	mov	r3, r0
20009744:	2b00      	cmp	r3, #0
20009746:	d001      	beq.n	2000974c <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
20009748:	2301      	movs	r3, #1
2000974a:	e000      	b.n	2000974e <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
2000974c:	2300      	movs	r3, #0
}
2000974e:	4618      	mov	r0, r3
20009750:	3710      	adds	r7, #16
20009752:	46bd      	mov	sp, r7
20009754:	bd80      	pop	{r7, pc}
20009756:	bf00      	nop
20009758:	80002000 	.word	0x80002000

2000975c <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2000975c:	b580      	push	{r7, lr}
2000975e:	b084      	sub	sp, #16
20009760:	af00      	add	r7, sp, #0
20009762:	6078      	str	r0, [r7, #4]
20009764:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
20009766:	687b      	ldr	r3, [r7, #4]
20009768:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000976c:	b2db      	uxtb	r3, r3
2000976e:	f003 0328 	and.w	r3, r3, #40	; 0x28
20009772:	2b28      	cmp	r3, #40	; 0x28
20009774:	d168      	bne.n	20009848 <I2C_ITAddrCplt+0xec>
  {
    transferdirection = I2C_GET_DIR(hi2c);
20009776:	687b      	ldr	r3, [r7, #4]
20009778:	681b      	ldr	r3, [r3, #0]
2000977a:	699b      	ldr	r3, [r3, #24]
2000977c:	0c1b      	lsrs	r3, r3, #16
2000977e:	b2db      	uxtb	r3, r3
20009780:	f003 0301 	and.w	r3, r3, #1
20009784:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
20009786:	687b      	ldr	r3, [r7, #4]
20009788:	681b      	ldr	r3, [r3, #0]
2000978a:	699b      	ldr	r3, [r3, #24]
2000978c:	0c1b      	lsrs	r3, r3, #16
2000978e:	b29b      	uxth	r3, r3
20009790:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
20009794:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
20009796:	687b      	ldr	r3, [r7, #4]
20009798:	681b      	ldr	r3, [r3, #0]
2000979a:	689b      	ldr	r3, [r3, #8]
2000979c:	b29b      	uxth	r3, r3
2000979e:	f3c3 0309 	ubfx	r3, r3, #0, #10
200097a2:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
200097a4:	687b      	ldr	r3, [r7, #4]
200097a6:	681b      	ldr	r3, [r3, #0]
200097a8:	68db      	ldr	r3, [r3, #12]
200097aa:	b29b      	uxth	r3, r3
200097ac:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
200097b0:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
200097b2:	687b      	ldr	r3, [r7, #4]
200097b4:	68db      	ldr	r3, [r3, #12]
200097b6:	2b02      	cmp	r3, #2
200097b8:	d137      	bne.n	2000982a <I2C_ITAddrCplt+0xce>
    {
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
200097ba:	897b      	ldrh	r3, [r7, #10]
200097bc:	09db      	lsrs	r3, r3, #7
200097be:	b29a      	uxth	r2, r3
200097c0:	89bb      	ldrh	r3, [r7, #12]
200097c2:	4053      	eors	r3, r2
200097c4:	b29b      	uxth	r3, r3
200097c6:	f003 0306 	and.w	r3, r3, #6
200097ca:	2b00      	cmp	r3, #0
200097cc:	d11c      	bne.n	20009808 <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
200097ce:	897b      	ldrh	r3, [r7, #10]
200097d0:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
200097d2:	687b      	ldr	r3, [r7, #4]
200097d4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200097d6:	1c5a      	adds	r2, r3, #1
200097d8:	687b      	ldr	r3, [r7, #4]
200097da:	649a      	str	r2, [r3, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
200097dc:	687b      	ldr	r3, [r7, #4]
200097de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200097e0:	2b02      	cmp	r3, #2
200097e2:	d139      	bne.n	20009858 <I2C_ITAddrCplt+0xfc>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
200097e4:	687b      	ldr	r3, [r7, #4]
200097e6:	2200      	movs	r2, #0
200097e8:	649a      	str	r2, [r3, #72]	; 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
200097ea:	687b      	ldr	r3, [r7, #4]
200097ec:	681b      	ldr	r3, [r3, #0]
200097ee:	2208      	movs	r2, #8
200097f0:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
200097f2:	687b      	ldr	r3, [r7, #4]
200097f4:	2200      	movs	r2, #0
200097f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
200097fa:	89ba      	ldrh	r2, [r7, #12]
200097fc:	7bfb      	ldrb	r3, [r7, #15]
200097fe:	4619      	mov	r1, r3
20009800:	6878      	ldr	r0, [r7, #4]
20009802:	f7ff faae 	bl	20008d62 <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
20009806:	e027      	b.n	20009858 <I2C_ITAddrCplt+0xfc>
        slaveaddrcode = ownadd2code;
20009808:	893b      	ldrh	r3, [r7, #8]
2000980a:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000980c:	2104      	movs	r1, #4
2000980e:	6878      	ldr	r0, [r7, #4]
20009810:	f000 feac 	bl	2000a56c <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
20009814:	687b      	ldr	r3, [r7, #4]
20009816:	2200      	movs	r2, #0
20009818:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2000981c:	89ba      	ldrh	r2, [r7, #12]
2000981e:	7bfb      	ldrb	r3, [r7, #15]
20009820:	4619      	mov	r1, r3
20009822:	6878      	ldr	r0, [r7, #4]
20009824:	f7ff fa9d 	bl	20008d62 <HAL_I2C_AddrCallback>
}
20009828:	e016      	b.n	20009858 <I2C_ITAddrCplt+0xfc>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2000982a:	2104      	movs	r1, #4
2000982c:	6878      	ldr	r0, [r7, #4]
2000982e:	f000 fe9d 	bl	2000a56c <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
20009832:	687b      	ldr	r3, [r7, #4]
20009834:	2200      	movs	r2, #0
20009836:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2000983a:	89ba      	ldrh	r2, [r7, #12]
2000983c:	7bfb      	ldrb	r3, [r7, #15]
2000983e:	4619      	mov	r1, r3
20009840:	6878      	ldr	r0, [r7, #4]
20009842:	f7ff fa8e 	bl	20008d62 <HAL_I2C_AddrCallback>
}
20009846:	e007      	b.n	20009858 <I2C_ITAddrCplt+0xfc>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
20009848:	687b      	ldr	r3, [r7, #4]
2000984a:	681b      	ldr	r3, [r3, #0]
2000984c:	2208      	movs	r2, #8
2000984e:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
20009850:	687b      	ldr	r3, [r7, #4]
20009852:	2200      	movs	r2, #0
20009854:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
20009858:	bf00      	nop
2000985a:	3710      	adds	r7, #16
2000985c:	46bd      	mov	sp, r7
2000985e:	bd80      	pop	{r7, pc}

20009860 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
20009860:	b580      	push	{r7, lr}
20009862:	b082      	sub	sp, #8
20009864:	af00      	add	r7, sp, #0
20009866:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
20009868:	687b      	ldr	r3, [r7, #4]
2000986a:	2200      	movs	r2, #0
2000986c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
20009870:	687b      	ldr	r3, [r7, #4]
20009872:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009876:	b2db      	uxtb	r3, r3
20009878:	2b21      	cmp	r3, #33	; 0x21
2000987a:	d115      	bne.n	200098a8 <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
2000987c:	687b      	ldr	r3, [r7, #4]
2000987e:	2220      	movs	r2, #32
20009880:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
20009884:	687b      	ldr	r3, [r7, #4]
20009886:	2211      	movs	r2, #17
20009888:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2000988a:	687b      	ldr	r3, [r7, #4]
2000988c:	2200      	movs	r2, #0
2000988e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
20009890:	2101      	movs	r1, #1
20009892:	6878      	ldr	r0, [r7, #4]
20009894:	f000 fe6a 	bl	2000a56c <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
20009898:	687b      	ldr	r3, [r7, #4]
2000989a:	2200      	movs	r2, #0
2000989c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
200098a0:	6878      	ldr	r0, [r7, #4]
200098a2:	f7ff fa36 	bl	20008d12 <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
200098a6:	e014      	b.n	200098d2 <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
200098a8:	687b      	ldr	r3, [r7, #4]
200098aa:	2220      	movs	r2, #32
200098ac:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
200098b0:	687b      	ldr	r3, [r7, #4]
200098b2:	2212      	movs	r2, #18
200098b4:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
200098b6:	687b      	ldr	r3, [r7, #4]
200098b8:	2200      	movs	r2, #0
200098ba:	635a      	str	r2, [r3, #52]	; 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
200098bc:	2102      	movs	r1, #2
200098be:	6878      	ldr	r0, [r7, #4]
200098c0:	f000 fe54 	bl	2000a56c <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
200098c4:	687b      	ldr	r3, [r7, #4]
200098c6:	2200      	movs	r2, #0
200098c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
200098cc:	6878      	ldr	r0, [r7, #4]
200098ce:	f7ff fa2a 	bl	20008d26 <HAL_I2C_MasterRxCpltCallback>
}
200098d2:	bf00      	nop
200098d4:	3708      	adds	r7, #8
200098d6:	46bd      	mov	sp, r7
200098d8:	bd80      	pop	{r7, pc}

200098da <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
200098da:	b580      	push	{r7, lr}
200098dc:	b082      	sub	sp, #8
200098de:	af00      	add	r7, sp, #0
200098e0:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
200098e2:	687b      	ldr	r3, [r7, #4]
200098e4:	2200      	movs	r2, #0
200098e6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
200098ea:	687b      	ldr	r3, [r7, #4]
200098ec:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200098f0:	b2db      	uxtb	r3, r3
200098f2:	2b29      	cmp	r3, #41	; 0x29
200098f4:	d112      	bne.n	2000991c <I2C_ITSlaveSeqCplt+0x42>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
200098f6:	687b      	ldr	r3, [r7, #4]
200098f8:	2228      	movs	r2, #40	; 0x28
200098fa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
200098fe:	687b      	ldr	r3, [r7, #4]
20009900:	2221      	movs	r2, #33	; 0x21
20009902:	631a      	str	r2, [r3, #48]	; 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
20009904:	2101      	movs	r1, #1
20009906:	6878      	ldr	r0, [r7, #4]
20009908:	f000 fe30 	bl	2000a56c <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000990c:	687b      	ldr	r3, [r7, #4]
2000990e:	2200      	movs	r2, #0
20009910:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
20009914:	6878      	ldr	r0, [r7, #4]
20009916:	f7ff fa10 	bl	20008d3a <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
2000991a:	e017      	b.n	2000994c <I2C_ITSlaveSeqCplt+0x72>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2000991c:	687b      	ldr	r3, [r7, #4]
2000991e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009922:	b2db      	uxtb	r3, r3
20009924:	2b2a      	cmp	r3, #42	; 0x2a
20009926:	d111      	bne.n	2000994c <I2C_ITSlaveSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
20009928:	687b      	ldr	r3, [r7, #4]
2000992a:	2228      	movs	r2, #40	; 0x28
2000992c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
20009930:	687b      	ldr	r3, [r7, #4]
20009932:	2222      	movs	r2, #34	; 0x22
20009934:	631a      	str	r2, [r3, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
20009936:	2102      	movs	r1, #2
20009938:	6878      	ldr	r0, [r7, #4]
2000993a:	f000 fe17 	bl	2000a56c <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2000993e:	687b      	ldr	r3, [r7, #4]
20009940:	2200      	movs	r2, #0
20009942:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
20009946:	6878      	ldr	r0, [r7, #4]
20009948:	f7ff fa01 	bl	20008d4e <HAL_I2C_SlaveRxCpltCallback>
}
2000994c:	bf00      	nop
2000994e:	3708      	adds	r7, #8
20009950:	46bd      	mov	sp, r7
20009952:	bd80      	pop	{r7, pc}

20009954 <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
20009954:	b580      	push	{r7, lr}
20009956:	b084      	sub	sp, #16
20009958:	af00      	add	r7, sp, #0
2000995a:	6078      	str	r0, [r7, #4]
2000995c:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000995e:	687b      	ldr	r3, [r7, #4]
20009960:	681b      	ldr	r3, [r3, #0]
20009962:	2220      	movs	r2, #32
20009964:	61da      	str	r2, [r3, #28]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
20009966:	687b      	ldr	r3, [r7, #4]
20009968:	681b      	ldr	r3, [r3, #0]
2000996a:	6859      	ldr	r1, [r3, #4]
2000996c:	687b      	ldr	r3, [r7, #4]
2000996e:	681a      	ldr	r2, [r3, #0]
20009970:	4b44      	ldr	r3, [pc, #272]	; (20009a84 <I2C_ITMasterCplt+0x130>)
20009972:	400b      	ands	r3, r1
20009974:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->PreviousState = I2C_STATE_NONE;
20009976:	687b      	ldr	r3, [r7, #4]
20009978:	2200      	movs	r2, #0
2000997a:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->XferISR       = NULL;
2000997c:	687b      	ldr	r3, [r7, #4]
2000997e:	2200      	movs	r2, #0
20009980:	635a      	str	r2, [r3, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
20009982:	687b      	ldr	r3, [r7, #4]
20009984:	4a40      	ldr	r2, [pc, #256]	; (20009a88 <I2C_ITMasterCplt+0x134>)
20009986:	62da      	str	r2, [r3, #44]	; 0x2c

  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET)
20009988:	683b      	ldr	r3, [r7, #0]
2000998a:	091b      	lsrs	r3, r3, #4
2000998c:	f003 0301 	and.w	r3, r3, #1
20009990:	2b00      	cmp	r3, #0
20009992:	d009      	beq.n	200099a8 <I2C_ITMasterCplt+0x54>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20009994:	687b      	ldr	r3, [r7, #4]
20009996:	681b      	ldr	r3, [r3, #0]
20009998:	2210      	movs	r2, #16
2000999a:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2000999c:	687b      	ldr	r3, [r7, #4]
2000999e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200099a0:	f043 0204 	orr.w	r2, r3, #4
200099a4:	687b      	ldr	r3, [r7, #4]
200099a6:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
200099a8:	6878      	ldr	r0, [r7, #4]
200099aa:	f000 fa59 	bl	20009e60 <I2C_Flush_TXDR>

  /* Disable Interrupts */
  I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_RX_IT);
200099ae:	2103      	movs	r1, #3
200099b0:	6878      	ldr	r0, [r7, #4]
200099b2:	f000 fddb 	bl	2000a56c <I2C_Disable_IRQ>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
200099b6:	687b      	ldr	r3, [r7, #4]
200099b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200099ba:	60fb      	str	r3, [r7, #12]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
200099bc:	687b      	ldr	r3, [r7, #4]
200099be:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200099c2:	b2db      	uxtb	r3, r3
200099c4:	2b60      	cmp	r3, #96	; 0x60
200099c6:	d002      	beq.n	200099ce <I2C_ITMasterCplt+0x7a>
200099c8:	68fb      	ldr	r3, [r7, #12]
200099ca:	2b00      	cmp	r3, #0
200099cc:	d006      	beq.n	200099dc <I2C_ITMasterCplt+0x88>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
200099ce:	687b      	ldr	r3, [r7, #4]
200099d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200099d2:	4619      	mov	r1, r3
200099d4:	6878      	ldr	r0, [r7, #4]
200099d6:	f000 f983 	bl	20009ce0 <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
200099da:	e04e      	b.n	20009a7a <I2C_ITMasterCplt+0x126>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
200099dc:	687b      	ldr	r3, [r7, #4]
200099de:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200099e2:	b2db      	uxtb	r3, r3
200099e4:	2b21      	cmp	r3, #33	; 0x21
200099e6:	d121      	bne.n	20009a2c <I2C_ITMasterCplt+0xd8>
    hi2c->State = HAL_I2C_STATE_READY;
200099e8:	687b      	ldr	r3, [r7, #4]
200099ea:	2220      	movs	r2, #32
200099ec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
200099f0:	687b      	ldr	r3, [r7, #4]
200099f2:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
200099f6:	b2db      	uxtb	r3, r3
200099f8:	2b40      	cmp	r3, #64	; 0x40
200099fa:	d10b      	bne.n	20009a14 <I2C_ITMasterCplt+0xc0>
      hi2c->Mode = HAL_I2C_MODE_NONE;
200099fc:	687b      	ldr	r3, [r7, #4]
200099fe:	2200      	movs	r2, #0
20009a00:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20009a04:	687b      	ldr	r3, [r7, #4]
20009a06:	2200      	movs	r2, #0
20009a08:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
20009a0c:	6878      	ldr	r0, [r7, #4]
20009a0e:	f7ff f9c0 	bl	20008d92 <HAL_I2C_MemTxCpltCallback>
}
20009a12:	e032      	b.n	20009a7a <I2C_ITMasterCplt+0x126>
      hi2c->Mode = HAL_I2C_MODE_NONE;
20009a14:	687b      	ldr	r3, [r7, #4]
20009a16:	2200      	movs	r2, #0
20009a18:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20009a1c:	687b      	ldr	r3, [r7, #4]
20009a1e:	2200      	movs	r2, #0
20009a20:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
20009a24:	6878      	ldr	r0, [r7, #4]
20009a26:	f7ff f974 	bl	20008d12 <HAL_I2C_MasterTxCpltCallback>
}
20009a2a:	e026      	b.n	20009a7a <I2C_ITMasterCplt+0x126>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
20009a2c:	687b      	ldr	r3, [r7, #4]
20009a2e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009a32:	b2db      	uxtb	r3, r3
20009a34:	2b22      	cmp	r3, #34	; 0x22
20009a36:	d120      	bne.n	20009a7a <I2C_ITMasterCplt+0x126>
    hi2c->State = HAL_I2C_STATE_READY;
20009a38:	687b      	ldr	r3, [r7, #4]
20009a3a:	2220      	movs	r2, #32
20009a3c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
20009a40:	687b      	ldr	r3, [r7, #4]
20009a42:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
20009a46:	b2db      	uxtb	r3, r3
20009a48:	2b40      	cmp	r3, #64	; 0x40
20009a4a:	d10b      	bne.n	20009a64 <I2C_ITMasterCplt+0x110>
      hi2c->Mode = HAL_I2C_MODE_NONE;
20009a4c:	687b      	ldr	r3, [r7, #4]
20009a4e:	2200      	movs	r2, #0
20009a50:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20009a54:	687b      	ldr	r3, [r7, #4]
20009a56:	2200      	movs	r2, #0
20009a58:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
20009a5c:	6878      	ldr	r0, [r7, #4]
20009a5e:	f7ff f9a2 	bl	20008da6 <HAL_I2C_MemRxCpltCallback>
}
20009a62:	e00a      	b.n	20009a7a <I2C_ITMasterCplt+0x126>
      hi2c->Mode = HAL_I2C_MODE_NONE;
20009a64:	687b      	ldr	r3, [r7, #4]
20009a66:	2200      	movs	r2, #0
20009a68:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
20009a6c:	687b      	ldr	r3, [r7, #4]
20009a6e:	2200      	movs	r2, #0
20009a70:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
20009a74:	6878      	ldr	r0, [r7, #4]
20009a76:	f7ff f956 	bl	20008d26 <HAL_I2C_MasterRxCpltCallback>
}
20009a7a:	bf00      	nop
20009a7c:	3710      	adds	r7, #16
20009a7e:	46bd      	mov	sp, r7
20009a80:	bd80      	pop	{r7, pc}
20009a82:	bf00      	nop
20009a84:	fe00e800 	.word	0xfe00e800
20009a88:	ffff0000 	.word	0xffff0000

20009a8c <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
20009a8c:	b580      	push	{r7, lr}
20009a8e:	b084      	sub	sp, #16
20009a90:	af00      	add	r7, sp, #0
20009a92:	6078      	str	r0, [r7, #4]
20009a94:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
20009a96:	687b      	ldr	r3, [r7, #4]
20009a98:	681b      	ldr	r3, [r3, #0]
20009a9a:	681b      	ldr	r3, [r3, #0]
20009a9c:	60bb      	str	r3, [r7, #8]
  uint32_t tmpITFlags = ITFlags;
20009a9e:	683b      	ldr	r3, [r7, #0]
20009aa0:	60fb      	str	r3, [r7, #12]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
20009aa2:	687b      	ldr	r3, [r7, #4]
20009aa4:	681b      	ldr	r3, [r3, #0]
20009aa6:	2220      	movs	r2, #32
20009aa8:	61da      	str	r2, [r3, #28]

  /* Disable all interrupts */
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
20009aaa:	2107      	movs	r1, #7
20009aac:	6878      	ldr	r0, [r7, #4]
20009aae:	f000 fd5d 	bl	2000a56c <I2C_Disable_IRQ>

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
20009ab2:	687b      	ldr	r3, [r7, #4]
20009ab4:	681b      	ldr	r3, [r3, #0]
20009ab6:	685a      	ldr	r2, [r3, #4]
20009ab8:	687b      	ldr	r3, [r7, #4]
20009aba:	681b      	ldr	r3, [r3, #0]
20009abc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
20009ac0:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
20009ac2:	687b      	ldr	r3, [r7, #4]
20009ac4:	681b      	ldr	r3, [r3, #0]
20009ac6:	6859      	ldr	r1, [r3, #4]
20009ac8:	687b      	ldr	r3, [r7, #4]
20009aca:	681a      	ldr	r2, [r3, #0]
20009acc:	4b58      	ldr	r3, [pc, #352]	; (20009c30 <I2C_ITSlaveCplt+0x1a4>)
20009ace:	400b      	ands	r3, r1
20009ad0:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
20009ad2:	6878      	ldr	r0, [r7, #4]
20009ad4:	f000 f9c4 	bl	20009e60 <I2C_Flush_TXDR>

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
20009ad8:	68bb      	ldr	r3, [r7, #8]
20009ada:	0b9b      	lsrs	r3, r3, #14
20009adc:	f003 0301 	and.w	r3, r3, #1
20009ae0:	2b00      	cmp	r3, #0
20009ae2:	d00b      	beq.n	20009afc <I2C_ITSlaveCplt+0x70>
  {
    if (hi2c->hdmatx != NULL)
20009ae4:	687b      	ldr	r3, [r7, #4]
20009ae6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009ae8:	2b00      	cmp	r3, #0
20009aea:	d018      	beq.n	20009b1e <I2C_ITSlaveCplt+0x92>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmatx);
20009aec:	687b      	ldr	r3, [r7, #4]
20009aee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009af0:	681b      	ldr	r3, [r3, #0]
20009af2:	685b      	ldr	r3, [r3, #4]
20009af4:	b29a      	uxth	r2, r3
20009af6:	687b      	ldr	r3, [r7, #4]
20009af8:	855a      	strh	r2, [r3, #42]	; 0x2a
20009afa:	e010      	b.n	20009b1e <I2C_ITSlaveCplt+0x92>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
20009afc:	68bb      	ldr	r3, [r7, #8]
20009afe:	0bdb      	lsrs	r3, r3, #15
20009b00:	f003 0301 	and.w	r3, r3, #1
20009b04:	2b00      	cmp	r3, #0
20009b06:	d00a      	beq.n	20009b1e <I2C_ITSlaveCplt+0x92>
  {
    if (hi2c->hdmarx != NULL)
20009b08:	687b      	ldr	r3, [r7, #4]
20009b0a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20009b0c:	2b00      	cmp	r3, #0
20009b0e:	d006      	beq.n	20009b1e <I2C_ITSlaveCplt+0x92>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
20009b10:	687b      	ldr	r3, [r7, #4]
20009b12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20009b14:	681b      	ldr	r3, [r3, #0]
20009b16:	685b      	ldr	r3, [r3, #4]
20009b18:	b29a      	uxth	r2, r3
20009b1a:	687b      	ldr	r3, [r7, #4]
20009b1c:	855a      	strh	r2, [r3, #42]	; 0x2a
  {
    /* Do nothing */
  }

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
20009b1e:	68fb      	ldr	r3, [r7, #12]
20009b20:	089b      	lsrs	r3, r3, #2
20009b22:	f003 0301 	and.w	r3, r3, #1
20009b26:	2b00      	cmp	r3, #0
20009b28:	d020      	beq.n	20009b6c <I2C_ITSlaveCplt+0xe0>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
20009b2a:	68fb      	ldr	r3, [r7, #12]
20009b2c:	f023 0304 	bic.w	r3, r3, #4
20009b30:	60fb      	str	r3, [r7, #12]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20009b32:	687b      	ldr	r3, [r7, #4]
20009b34:	681b      	ldr	r3, [r3, #0]
20009b36:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20009b38:	687b      	ldr	r3, [r7, #4]
20009b3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009b3c:	b2d2      	uxtb	r2, r2
20009b3e:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
20009b40:	687b      	ldr	r3, [r7, #4]
20009b42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009b44:	1c5a      	adds	r2, r3, #1
20009b46:	687b      	ldr	r3, [r7, #4]
20009b48:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
20009b4a:	687b      	ldr	r3, [r7, #4]
20009b4c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20009b4e:	2b00      	cmp	r3, #0
20009b50:	d00c      	beq.n	20009b6c <I2C_ITSlaveCplt+0xe0>
    {
      hi2c->XferSize--;
20009b52:	687b      	ldr	r3, [r7, #4]
20009b54:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20009b56:	3b01      	subs	r3, #1
20009b58:	b29a      	uxth	r2, r3
20009b5a:	687b      	ldr	r3, [r7, #4]
20009b5c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
20009b5e:	687b      	ldr	r3, [r7, #4]
20009b60:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009b62:	b29b      	uxth	r3, r3
20009b64:	3b01      	subs	r3, #1
20009b66:	b29a      	uxth	r2, r3
20009b68:	687b      	ldr	r3, [r7, #4]
20009b6a:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
20009b6c:	687b      	ldr	r3, [r7, #4]
20009b6e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009b70:	b29b      	uxth	r3, r3
20009b72:	2b00      	cmp	r3, #0
20009b74:	d005      	beq.n	20009b82 <I2C_ITSlaveCplt+0xf6>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20009b76:	687b      	ldr	r3, [r7, #4]
20009b78:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20009b7a:	f043 0204 	orr.w	r2, r3, #4
20009b7e:	687b      	ldr	r3, [r7, #4]
20009b80:	645a      	str	r2, [r3, #68]	; 0x44
  }

  hi2c->PreviousState = I2C_STATE_NONE;
20009b82:	687b      	ldr	r3, [r7, #4]
20009b84:	2200      	movs	r2, #0
20009b86:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
20009b88:	687b      	ldr	r3, [r7, #4]
20009b8a:	2200      	movs	r2, #0
20009b8c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
20009b90:	687b      	ldr	r3, [r7, #4]
20009b92:	2200      	movs	r2, #0
20009b94:	635a      	str	r2, [r3, #52]	; 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
20009b96:	687b      	ldr	r3, [r7, #4]
20009b98:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20009b9a:	2b00      	cmp	r3, #0
20009b9c:	d010      	beq.n	20009bc0 <I2C_ITSlaveCplt+0x134>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
20009b9e:	687b      	ldr	r3, [r7, #4]
20009ba0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20009ba2:	4619      	mov	r1, r3
20009ba4:	6878      	ldr	r0, [r7, #4]
20009ba6:	f000 f89b 	bl	20009ce0 <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
20009baa:	687b      	ldr	r3, [r7, #4]
20009bac:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009bb0:	b2db      	uxtb	r3, r3
20009bb2:	2b28      	cmp	r3, #40	; 0x28
20009bb4:	d138      	bne.n	20009c28 <I2C_ITSlaveCplt+0x19c>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
20009bb6:	68f9      	ldr	r1, [r7, #12]
20009bb8:	6878      	ldr	r0, [r7, #4]
20009bba:	f000 f83d 	bl	20009c38 <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
20009bbe:	e033      	b.n	20009c28 <I2C_ITSlaveCplt+0x19c>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
20009bc0:	687b      	ldr	r3, [r7, #4]
20009bc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009bc4:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
20009bc8:	d011      	beq.n	20009bee <I2C_ITSlaveCplt+0x162>
    I2C_ITSlaveSeqCplt(hi2c);
20009bca:	6878      	ldr	r0, [r7, #4]
20009bcc:	f7ff fe85 	bl	200098da <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20009bd0:	687b      	ldr	r3, [r7, #4]
20009bd2:	4a18      	ldr	r2, [pc, #96]	; (20009c34 <I2C_ITSlaveCplt+0x1a8>)
20009bd4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
20009bd6:	687b      	ldr	r3, [r7, #4]
20009bd8:	2220      	movs	r2, #32
20009bda:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
20009bde:	687b      	ldr	r3, [r7, #4]
20009be0:	2200      	movs	r2, #0
20009be2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
20009be6:	6878      	ldr	r0, [r7, #4]
20009be8:	f7ff f8c9 	bl	20008d7e <HAL_I2C_ListenCpltCallback>
}
20009bec:	e01c      	b.n	20009c28 <I2C_ITSlaveCplt+0x19c>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
20009bee:	687b      	ldr	r3, [r7, #4]
20009bf0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009bf4:	b2db      	uxtb	r3, r3
20009bf6:	2b22      	cmp	r3, #34	; 0x22
20009bf8:	d10b      	bne.n	20009c12 <I2C_ITSlaveCplt+0x186>
    hi2c->State = HAL_I2C_STATE_READY;
20009bfa:	687b      	ldr	r3, [r7, #4]
20009bfc:	2220      	movs	r2, #32
20009bfe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
20009c02:	687b      	ldr	r3, [r7, #4]
20009c04:	2200      	movs	r2, #0
20009c06:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
20009c0a:	6878      	ldr	r0, [r7, #4]
20009c0c:	f7ff f89f 	bl	20008d4e <HAL_I2C_SlaveRxCpltCallback>
}
20009c10:	e00a      	b.n	20009c28 <I2C_ITSlaveCplt+0x19c>
    hi2c->State = HAL_I2C_STATE_READY;
20009c12:	687b      	ldr	r3, [r7, #4]
20009c14:	2220      	movs	r2, #32
20009c16:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
20009c1a:	687b      	ldr	r3, [r7, #4]
20009c1c:	2200      	movs	r2, #0
20009c1e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
20009c22:	6878      	ldr	r0, [r7, #4]
20009c24:	f7ff f889 	bl	20008d3a <HAL_I2C_SlaveTxCpltCallback>
}
20009c28:	bf00      	nop
20009c2a:	3710      	adds	r7, #16
20009c2c:	46bd      	mov	sp, r7
20009c2e:	bd80      	pop	{r7, pc}
20009c30:	fe00e800 	.word	0xfe00e800
20009c34:	ffff0000 	.word	0xffff0000

20009c38 <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
20009c38:	b580      	push	{r7, lr}
20009c3a:	b082      	sub	sp, #8
20009c3c:	af00      	add	r7, sp, #0
20009c3e:	6078      	str	r0, [r7, #4]
20009c40:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
20009c42:	687b      	ldr	r3, [r7, #4]
20009c44:	4a25      	ldr	r2, [pc, #148]	; (20009cdc <I2C_ITListenCplt+0xa4>)
20009c46:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
20009c48:	687b      	ldr	r3, [r7, #4]
20009c4a:	2200      	movs	r2, #0
20009c4c:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
20009c4e:	687b      	ldr	r3, [r7, #4]
20009c50:	2220      	movs	r2, #32
20009c52:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
20009c56:	687b      	ldr	r3, [r7, #4]
20009c58:	2200      	movs	r2, #0
20009c5a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
20009c5e:	687b      	ldr	r3, [r7, #4]
20009c60:	2200      	movs	r2, #0
20009c62:	635a      	str	r2, [r3, #52]	; 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
20009c64:	683b      	ldr	r3, [r7, #0]
20009c66:	089b      	lsrs	r3, r3, #2
20009c68:	f003 0301 	and.w	r3, r3, #1
20009c6c:	2b00      	cmp	r3, #0
20009c6e:	d022      	beq.n	20009cb6 <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
20009c70:	687b      	ldr	r3, [r7, #4]
20009c72:	681b      	ldr	r3, [r3, #0]
20009c74:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20009c76:	687b      	ldr	r3, [r7, #4]
20009c78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009c7a:	b2d2      	uxtb	r2, r2
20009c7c:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
20009c7e:	687b      	ldr	r3, [r7, #4]
20009c80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009c82:	1c5a      	adds	r2, r3, #1
20009c84:	687b      	ldr	r3, [r7, #4]
20009c86:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
20009c88:	687b      	ldr	r3, [r7, #4]
20009c8a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20009c8c:	2b00      	cmp	r3, #0
20009c8e:	d012      	beq.n	20009cb6 <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
20009c90:	687b      	ldr	r3, [r7, #4]
20009c92:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20009c94:	3b01      	subs	r3, #1
20009c96:	b29a      	uxth	r2, r3
20009c98:	687b      	ldr	r3, [r7, #4]
20009c9a:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
20009c9c:	687b      	ldr	r3, [r7, #4]
20009c9e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009ca0:	b29b      	uxth	r3, r3
20009ca2:	3b01      	subs	r3, #1
20009ca4:	b29a      	uxth	r2, r3
20009ca6:	687b      	ldr	r3, [r7, #4]
20009ca8:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
20009caa:	687b      	ldr	r3, [r7, #4]
20009cac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20009cae:	f043 0204 	orr.w	r2, r3, #4
20009cb2:	687b      	ldr	r3, [r7, #4]
20009cb4:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
20009cb6:	2107      	movs	r1, #7
20009cb8:	6878      	ldr	r0, [r7, #4]
20009cba:	f000 fc57 	bl	2000a56c <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
20009cbe:	687b      	ldr	r3, [r7, #4]
20009cc0:	681b      	ldr	r3, [r3, #0]
20009cc2:	2210      	movs	r2, #16
20009cc4:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
20009cc6:	687b      	ldr	r3, [r7, #4]
20009cc8:	2200      	movs	r2, #0
20009cca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
20009cce:	6878      	ldr	r0, [r7, #4]
20009cd0:	f7ff f855 	bl	20008d7e <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
20009cd4:	bf00      	nop
20009cd6:	3708      	adds	r7, #8
20009cd8:	46bd      	mov	sp, r7
20009cda:	bd80      	pop	{r7, pc}
20009cdc:	ffff0000 	.word	0xffff0000

20009ce0 <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
20009ce0:	b580      	push	{r7, lr}
20009ce2:	b084      	sub	sp, #16
20009ce4:	af00      	add	r7, sp, #0
20009ce6:	6078      	str	r0, [r7, #4]
20009ce8:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
20009cea:	687b      	ldr	r3, [r7, #4]
20009cec:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009cf0:	73fb      	strb	r3, [r7, #15]

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
20009cf2:	687b      	ldr	r3, [r7, #4]
20009cf4:	2200      	movs	r2, #0
20009cf6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
20009cfa:	687b      	ldr	r3, [r7, #4]
20009cfc:	4a55      	ldr	r2, [pc, #340]	; (20009e54 <I2C_ITError+0x174>)
20009cfe:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->XferCount     = 0U;
20009d00:	687b      	ldr	r3, [r7, #4]
20009d02:	2200      	movs	r2, #0
20009d04:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
20009d06:	687b      	ldr	r3, [r7, #4]
20009d08:	6c5a      	ldr	r2, [r3, #68]	; 0x44
20009d0a:	683b      	ldr	r3, [r7, #0]
20009d0c:	431a      	orrs	r2, r3
20009d0e:	687b      	ldr	r3, [r7, #4]
20009d10:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
20009d12:	7bfb      	ldrb	r3, [r7, #15]
20009d14:	2b28      	cmp	r3, #40	; 0x28
20009d16:	d005      	beq.n	20009d24 <I2C_ITError+0x44>
20009d18:	7bfb      	ldrb	r3, [r7, #15]
20009d1a:	2b29      	cmp	r3, #41	; 0x29
20009d1c:	d002      	beq.n	20009d24 <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
20009d1e:	7bfb      	ldrb	r3, [r7, #15]
20009d20:	2b2a      	cmp	r3, #42	; 0x2a
20009d22:	d10e      	bne.n	20009d42 <I2C_ITError+0x62>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
20009d24:	2103      	movs	r1, #3
20009d26:	6878      	ldr	r0, [r7, #4]
20009d28:	f000 fc20 	bl	2000a56c <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
20009d2c:	687b      	ldr	r3, [r7, #4]
20009d2e:	2228      	movs	r2, #40	; 0x28
20009d30:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
20009d34:	687b      	ldr	r3, [r7, #4]
20009d36:	2200      	movs	r2, #0
20009d38:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = I2C_Slave_ISR_IT;
20009d3a:	687b      	ldr	r3, [r7, #4]
20009d3c:	4a46      	ldr	r2, [pc, #280]	; (20009e58 <I2C_ITError+0x178>)
20009d3e:	635a      	str	r2, [r3, #52]	; 0x34
20009d40:	e013      	b.n	20009d6a <I2C_ITError+0x8a>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
20009d42:	2107      	movs	r1, #7
20009d44:	6878      	ldr	r0, [r7, #4]
20009d46:	f000 fc11 	bl	2000a56c <I2C_Disable_IRQ>

    /* If state is an abort treatment on goind, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
20009d4a:	687b      	ldr	r3, [r7, #4]
20009d4c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009d50:	b2db      	uxtb	r3, r3
20009d52:	2b60      	cmp	r3, #96	; 0x60
20009d54:	d003      	beq.n	20009d5e <I2C_ITError+0x7e>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
20009d56:	687b      	ldr	r3, [r7, #4]
20009d58:	2220      	movs	r2, #32
20009d5a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
    hi2c->PreviousState = I2C_STATE_NONE;
20009d5e:	687b      	ldr	r3, [r7, #4]
20009d60:	2200      	movs	r2, #0
20009d62:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
20009d64:	687b      	ldr	r3, [r7, #4]
20009d66:	2200      	movs	r2, #0
20009d68:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Abort DMA TX transfer if any */
  if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
20009d6a:	687b      	ldr	r3, [r7, #4]
20009d6c:	681b      	ldr	r3, [r3, #0]
20009d6e:	681b      	ldr	r3, [r3, #0]
20009d70:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
20009d74:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20009d78:	d123      	bne.n	20009dc2 <I2C_ITError+0xe2>
  {
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
20009d7a:	687b      	ldr	r3, [r7, #4]
20009d7c:	681b      	ldr	r3, [r3, #0]
20009d7e:	681a      	ldr	r2, [r3, #0]
20009d80:	687b      	ldr	r3, [r7, #4]
20009d82:	681b      	ldr	r3, [r3, #0]
20009d84:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
20009d88:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
20009d8a:	687b      	ldr	r3, [r7, #4]
20009d8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009d8e:	2b00      	cmp	r3, #0
20009d90:	d05c      	beq.n	20009e4c <I2C_ITError+0x16c>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
20009d92:	687b      	ldr	r3, [r7, #4]
20009d94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009d96:	4a31      	ldr	r2, [pc, #196]	; (20009e5c <I2C_ITError+0x17c>)
20009d98:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
20009d9a:	687b      	ldr	r3, [r7, #4]
20009d9c:	2200      	movs	r2, #0
20009d9e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
20009da2:	687b      	ldr	r3, [r7, #4]
20009da4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009da6:	4618      	mov	r0, r3
20009da8:	f7f8 fec1 	bl	20002b2e <HAL_DMA_Abort_IT>
20009dac:	4603      	mov	r3, r0
20009dae:	2b00      	cmp	r3, #0
20009db0:	d04c      	beq.n	20009e4c <I2C_ITError+0x16c>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
20009db2:	687b      	ldr	r3, [r7, #4]
20009db4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009db6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20009db8:	687a      	ldr	r2, [r7, #4]
20009dba:	6b92      	ldr	r2, [r2, #56]	; 0x38
20009dbc:	4610      	mov	r0, r2
20009dbe:	4798      	blx	r3
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
20009dc0:	e044      	b.n	20009e4c <I2C_ITError+0x16c>
  else if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
20009dc2:	687b      	ldr	r3, [r7, #4]
20009dc4:	681b      	ldr	r3, [r3, #0]
20009dc6:	681b      	ldr	r3, [r3, #0]
20009dc8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
20009dcc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20009dd0:	d123      	bne.n	20009e1a <I2C_ITError+0x13a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
20009dd2:	687b      	ldr	r3, [r7, #4]
20009dd4:	681b      	ldr	r3, [r3, #0]
20009dd6:	681a      	ldr	r2, [r3, #0]
20009dd8:	687b      	ldr	r3, [r7, #4]
20009dda:	681b      	ldr	r3, [r3, #0]
20009ddc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20009de0:	601a      	str	r2, [r3, #0]
    if (hi2c->hdmarx != NULL)
20009de2:	687b      	ldr	r3, [r7, #4]
20009de4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20009de6:	2b00      	cmp	r3, #0
20009de8:	d030      	beq.n	20009e4c <I2C_ITError+0x16c>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
20009dea:	687b      	ldr	r3, [r7, #4]
20009dec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20009dee:	4a1b      	ldr	r2, [pc, #108]	; (20009e5c <I2C_ITError+0x17c>)
20009df0:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
20009df2:	687b      	ldr	r3, [r7, #4]
20009df4:	2200      	movs	r2, #0
20009df6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
20009dfa:	687b      	ldr	r3, [r7, #4]
20009dfc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20009dfe:	4618      	mov	r0, r3
20009e00:	f7f8 fe95 	bl	20002b2e <HAL_DMA_Abort_IT>
20009e04:	4603      	mov	r3, r0
20009e06:	2b00      	cmp	r3, #0
20009e08:	d020      	beq.n	20009e4c <I2C_ITError+0x16c>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
20009e0a:	687b      	ldr	r3, [r7, #4]
20009e0c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20009e0e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20009e10:	687a      	ldr	r2, [r7, #4]
20009e12:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
20009e14:	4610      	mov	r0, r2
20009e16:	4798      	blx	r3
}
20009e18:	e018      	b.n	20009e4c <I2C_ITError+0x16c>
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
20009e1a:	687b      	ldr	r3, [r7, #4]
20009e1c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20009e20:	b2db      	uxtb	r3, r3
20009e22:	2b60      	cmp	r3, #96	; 0x60
20009e24:	d10b      	bne.n	20009e3e <I2C_ITError+0x15e>
    hi2c->State = HAL_I2C_STATE_READY;
20009e26:	687b      	ldr	r3, [r7, #4]
20009e28:	2220      	movs	r2, #32
20009e2a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
20009e2e:	687b      	ldr	r3, [r7, #4]
20009e30:	2200      	movs	r2, #0
20009e32:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_AbortCpltCallback(hi2c);
20009e36:	6878      	ldr	r0, [r7, #4]
20009e38:	f7fe ffc9 	bl	20008dce <HAL_I2C_AbortCpltCallback>
}
20009e3c:	e006      	b.n	20009e4c <I2C_ITError+0x16c>
    __HAL_UNLOCK(hi2c);
20009e3e:	687b      	ldr	r3, [r7, #4]
20009e40:	2200      	movs	r2, #0
20009e42:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
20009e46:	6878      	ldr	r0, [r7, #4]
20009e48:	f7fe ffb7 	bl	20008dba <HAL_I2C_ErrorCallback>
}
20009e4c:	bf00      	nop
20009e4e:	3710      	adds	r7, #16
20009e50:	46bd      	mov	sp, r7
20009e52:	bd80      	pop	{r7, pc}
20009e54:	ffff0000 	.word	0xffff0000
20009e58:	20009085 	.word	0x20009085
20009e5c:	2000a0cf 	.word	0x2000a0cf

20009e60 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
20009e60:	b480      	push	{r7}
20009e62:	b083      	sub	sp, #12
20009e64:	af00      	add	r7, sp, #0
20009e66:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
20009e68:	687b      	ldr	r3, [r7, #4]
20009e6a:	681b      	ldr	r3, [r3, #0]
20009e6c:	699b      	ldr	r3, [r3, #24]
20009e6e:	f003 0302 	and.w	r3, r3, #2
20009e72:	2b02      	cmp	r3, #2
20009e74:	d103      	bne.n	20009e7e <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
20009e76:	687b      	ldr	r3, [r7, #4]
20009e78:	681b      	ldr	r3, [r3, #0]
20009e7a:	2200      	movs	r2, #0
20009e7c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
20009e7e:	687b      	ldr	r3, [r7, #4]
20009e80:	681b      	ldr	r3, [r3, #0]
20009e82:	699b      	ldr	r3, [r3, #24]
20009e84:	f003 0301 	and.w	r3, r3, #1
20009e88:	2b01      	cmp	r3, #1
20009e8a:	d007      	beq.n	20009e9c <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
20009e8c:	687b      	ldr	r3, [r7, #4]
20009e8e:	681b      	ldr	r3, [r3, #0]
20009e90:	699a      	ldr	r2, [r3, #24]
20009e92:	687b      	ldr	r3, [r7, #4]
20009e94:	681b      	ldr	r3, [r3, #0]
20009e96:	f042 0201 	orr.w	r2, r2, #1
20009e9a:	619a      	str	r2, [r3, #24]
  }
}
20009e9c:	bf00      	nop
20009e9e:	370c      	adds	r7, #12
20009ea0:	46bd      	mov	sp, r7
20009ea2:	f85d 7b04 	ldr.w	r7, [sp], #4
20009ea6:	4770      	bx	lr

20009ea8 <I2C_DMAMasterTransmitCplt>:
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
{
20009ea8:	b580      	push	{r7, lr}
20009eaa:	b084      	sub	sp, #16
20009eac:	af00      	add	r7, sp, #0
20009eae:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
20009eb0:	687b      	ldr	r3, [r7, #4]
20009eb2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009eb4:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
20009eb6:	68fb      	ldr	r3, [r7, #12]
20009eb8:	681b      	ldr	r3, [r3, #0]
20009eba:	681a      	ldr	r2, [r3, #0]
20009ebc:	68fb      	ldr	r3, [r7, #12]
20009ebe:	681b      	ldr	r3, [r3, #0]
20009ec0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
20009ec4:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
20009ec6:	68fb      	ldr	r3, [r7, #12]
20009ec8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009eca:	b29b      	uxth	r3, r3
20009ecc:	2b00      	cmp	r3, #0
20009ece:	d104      	bne.n	20009eda <I2C_DMAMasterTransmitCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
20009ed0:	2112      	movs	r1, #18
20009ed2:	68f8      	ldr	r0, [r7, #12]
20009ed4:	f000 fadc 	bl	2000a490 <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
20009ed8:	e02d      	b.n	20009f36 <I2C_DMAMasterTransmitCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
20009eda:	68fb      	ldr	r3, [r7, #12]
20009edc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009ede:	68fa      	ldr	r2, [r7, #12]
20009ee0:	8d12      	ldrh	r2, [r2, #40]	; 0x28
20009ee2:	441a      	add	r2, r3
20009ee4:	68fb      	ldr	r3, [r7, #12]
20009ee6:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20009ee8:	68fb      	ldr	r3, [r7, #12]
20009eea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009eec:	b29b      	uxth	r3, r3
20009eee:	2bff      	cmp	r3, #255	; 0xff
20009ef0:	d903      	bls.n	20009efa <I2C_DMAMasterTransmitCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
20009ef2:	68fb      	ldr	r3, [r7, #12]
20009ef4:	22ff      	movs	r2, #255	; 0xff
20009ef6:	851a      	strh	r2, [r3, #40]	; 0x28
20009ef8:	e004      	b.n	20009f04 <I2C_DMAMasterTransmitCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
20009efa:	68fb      	ldr	r3, [r7, #12]
20009efc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009efe:	b29a      	uxth	r2, r3
20009f00:	68fb      	ldr	r3, [r7, #12]
20009f02:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
20009f04:	68fb      	ldr	r3, [r7, #12]
20009f06:	6b98      	ldr	r0, [r3, #56]	; 0x38
20009f08:	68fb      	ldr	r3, [r7, #12]
20009f0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009f0c:	4619      	mov	r1, r3
20009f0e:	68fb      	ldr	r3, [r7, #12]
20009f10:	681b      	ldr	r3, [r3, #0]
20009f12:	3328      	adds	r3, #40	; 0x28
20009f14:	461a      	mov	r2, r3
20009f16:	68fb      	ldr	r3, [r7, #12]
20009f18:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20009f1a:	f7f8 fd38 	bl	2000298e <HAL_DMA_Start_IT>
20009f1e:	4603      	mov	r3, r0
20009f20:	2b00      	cmp	r3, #0
20009f22:	d004      	beq.n	20009f2e <I2C_DMAMasterTransmitCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
20009f24:	2110      	movs	r1, #16
20009f26:	68f8      	ldr	r0, [r7, #12]
20009f28:	f7ff feda 	bl	20009ce0 <I2C_ITError>
}
20009f2c:	e003      	b.n	20009f36 <I2C_DMAMasterTransmitCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
20009f2e:	2112      	movs	r1, #18
20009f30:	68f8      	ldr	r0, [r7, #12]
20009f32:	f000 faad 	bl	2000a490 <I2C_Enable_IRQ>
}
20009f36:	bf00      	nop
20009f38:	3710      	adds	r7, #16
20009f3a:	46bd      	mov	sp, r7
20009f3c:	bd80      	pop	{r7, pc}

20009f3e <I2C_DMASlaveTransmitCplt>:
  * @brief  DMA I2C slave transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
{
20009f3e:	b580      	push	{r7, lr}
20009f40:	b084      	sub	sp, #16
20009f42:	af00      	add	r7, sp, #0
20009f44:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
20009f46:	687b      	ldr	r3, [r7, #4]
20009f48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009f4a:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
20009f4c:	68fb      	ldr	r3, [r7, #12]
20009f4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009f50:	60bb      	str	r3, [r7, #8]

  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
20009f52:	68bb      	ldr	r3, [r7, #8]
20009f54:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009f58:	d002      	beq.n	20009f60 <I2C_DMASlaveTransmitCplt+0x22>
20009f5a:	68bb      	ldr	r3, [r7, #8]
20009f5c:	2b00      	cmp	r3, #0
20009f5e:	d10a      	bne.n	20009f76 <I2C_DMASlaveTransmitCplt+0x38>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
20009f60:	68fb      	ldr	r3, [r7, #12]
20009f62:	681b      	ldr	r3, [r3, #0]
20009f64:	681a      	ldr	r2, [r3, #0]
20009f66:	68fb      	ldr	r3, [r7, #12]
20009f68:	681b      	ldr	r3, [r3, #0]
20009f6a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
20009f6e:	601a      	str	r2, [r3, #0]

    /* Last Byte is Transmitted */
    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
20009f70:	68f8      	ldr	r0, [r7, #12]
20009f72:	f7ff fcb2 	bl	200098da <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
20009f76:	bf00      	nop
20009f78:	3710      	adds	r7, #16
20009f7a:	46bd      	mov	sp, r7
20009f7c:	bd80      	pop	{r7, pc}

20009f7e <I2C_DMAMasterReceiveCplt>:
  * @brief DMA I2C master receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
{
20009f7e:	b580      	push	{r7, lr}
20009f80:	b084      	sub	sp, #16
20009f82:	af00      	add	r7, sp, #0
20009f84:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
20009f86:	687b      	ldr	r3, [r7, #4]
20009f88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009f8a:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
20009f8c:	68fb      	ldr	r3, [r7, #12]
20009f8e:	681b      	ldr	r3, [r3, #0]
20009f90:	681a      	ldr	r2, [r3, #0]
20009f92:	68fb      	ldr	r3, [r7, #12]
20009f94:	681b      	ldr	r3, [r3, #0]
20009f96:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
20009f9a:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
20009f9c:	68fb      	ldr	r3, [r7, #12]
20009f9e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009fa0:	b29b      	uxth	r3, r3
20009fa2:	2b00      	cmp	r3, #0
20009fa4:	d104      	bne.n	20009fb0 <I2C_DMAMasterReceiveCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
20009fa6:	2112      	movs	r1, #18
20009fa8:	68f8      	ldr	r0, [r7, #12]
20009faa:	f000 fa71 	bl	2000a490 <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
20009fae:	e02d      	b.n	2000a00c <I2C_DMAMasterReceiveCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
20009fb0:	68fb      	ldr	r3, [r7, #12]
20009fb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009fb4:	68fa      	ldr	r2, [r7, #12]
20009fb6:	8d12      	ldrh	r2, [r2, #40]	; 0x28
20009fb8:	441a      	add	r2, r3
20009fba:	68fb      	ldr	r3, [r7, #12]
20009fbc:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
20009fbe:	68fb      	ldr	r3, [r7, #12]
20009fc0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009fc2:	b29b      	uxth	r3, r3
20009fc4:	2bff      	cmp	r3, #255	; 0xff
20009fc6:	d903      	bls.n	20009fd0 <I2C_DMAMasterReceiveCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
20009fc8:	68fb      	ldr	r3, [r7, #12]
20009fca:	22ff      	movs	r2, #255	; 0xff
20009fcc:	851a      	strh	r2, [r3, #40]	; 0x28
20009fce:	e004      	b.n	20009fda <I2C_DMAMasterReceiveCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
20009fd0:	68fb      	ldr	r3, [r7, #12]
20009fd2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
20009fd4:	b29a      	uxth	r2, r3
20009fd6:	68fb      	ldr	r3, [r7, #12]
20009fd8:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
20009fda:	68fb      	ldr	r3, [r7, #12]
20009fdc:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
20009fde:	68fb      	ldr	r3, [r7, #12]
20009fe0:	681b      	ldr	r3, [r3, #0]
20009fe2:	3324      	adds	r3, #36	; 0x24
20009fe4:	4619      	mov	r1, r3
20009fe6:	68fb      	ldr	r3, [r7, #12]
20009fe8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009fea:	461a      	mov	r2, r3
20009fec:	68fb      	ldr	r3, [r7, #12]
20009fee:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
20009ff0:	f7f8 fccd 	bl	2000298e <HAL_DMA_Start_IT>
20009ff4:	4603      	mov	r3, r0
20009ff6:	2b00      	cmp	r3, #0
20009ff8:	d004      	beq.n	2000a004 <I2C_DMAMasterReceiveCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
20009ffa:	2110      	movs	r1, #16
20009ffc:	68f8      	ldr	r0, [r7, #12]
20009ffe:	f7ff fe6f 	bl	20009ce0 <I2C_ITError>
}
2000a002:	e003      	b.n	2000a00c <I2C_DMAMasterReceiveCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2000a004:	2112      	movs	r1, #18
2000a006:	68f8      	ldr	r0, [r7, #12]
2000a008:	f000 fa42 	bl	2000a490 <I2C_Enable_IRQ>
}
2000a00c:	bf00      	nop
2000a00e:	3710      	adds	r7, #16
2000a010:	46bd      	mov	sp, r7
2000a012:	bd80      	pop	{r7, pc}

2000a014 <I2C_DMASlaveReceiveCplt>:
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
{
2000a014:	b580      	push	{r7, lr}
2000a016:	b084      	sub	sp, #16
2000a018:	af00      	add	r7, sp, #0
2000a01a:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2000a01c:	687b      	ldr	r3, [r7, #4]
2000a01e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000a020:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2000a022:	68fb      	ldr	r3, [r7, #12]
2000a024:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000a026:	60bb      	str	r3, [r7, #8]

  if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
2000a028:	68fb      	ldr	r3, [r7, #12]
2000a02a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000a02c:	681b      	ldr	r3, [r3, #0]
2000a02e:	685b      	ldr	r3, [r3, #4]
2000a030:	2b00      	cmp	r3, #0
2000a032:	d10e      	bne.n	2000a052 <I2C_DMASlaveReceiveCplt+0x3e>
2000a034:	68bb      	ldr	r3, [r7, #8]
2000a036:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2000a03a:	d00a      	beq.n	2000a052 <I2C_DMASlaveReceiveCplt+0x3e>
      (tmpoptions != I2C_NO_OPTION_FRAME))
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2000a03c:	68fb      	ldr	r3, [r7, #12]
2000a03e:	681b      	ldr	r3, [r3, #0]
2000a040:	681a      	ldr	r2, [r3, #0]
2000a042:	68fb      	ldr	r3, [r7, #12]
2000a044:	681b      	ldr	r3, [r3, #0]
2000a046:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2000a04a:	601a      	str	r2, [r3, #0]

    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2000a04c:	68f8      	ldr	r0, [r7, #12]
2000a04e:	f7ff fc44 	bl	200098da <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2000a052:	bf00      	nop
2000a054:	3710      	adds	r7, #16
2000a056:	46bd      	mov	sp, r7
2000a058:	bd80      	pop	{r7, pc}

2000a05a <I2C_DMAError>:
  * @brief  DMA I2C communication error callback.
  * @param hdma DMA handle
  * @retval None
  */
static void I2C_DMAError(DMA_HandleTypeDef *hdma)
{
2000a05a:	b580      	push	{r7, lr}
2000a05c:	b084      	sub	sp, #16
2000a05e:	af00      	add	r7, sp, #0
2000a060:	6078      	str	r0, [r7, #4]
  uint32_t treatdmaerror = 0U;
2000a062:	2300      	movs	r3, #0
2000a064:	60fb      	str	r3, [r7, #12]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2000a066:	687b      	ldr	r3, [r7, #4]
2000a068:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000a06a:	60bb      	str	r3, [r7, #8]

  if (hi2c->hdmatx != NULL)
2000a06c:	68bb      	ldr	r3, [r7, #8]
2000a06e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000a070:	2b00      	cmp	r3, #0
2000a072:	d007      	beq.n	2000a084 <I2C_DMAError+0x2a>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
2000a074:	68bb      	ldr	r3, [r7, #8]
2000a076:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000a078:	681b      	ldr	r3, [r3, #0]
2000a07a:	685b      	ldr	r3, [r3, #4]
2000a07c:	2b00      	cmp	r3, #0
2000a07e:	d101      	bne.n	2000a084 <I2C_DMAError+0x2a>
    {
      treatdmaerror = 1U;
2000a080:	2301      	movs	r3, #1
2000a082:	60fb      	str	r3, [r7, #12]
    }
  }

  if (hi2c->hdmarx != NULL)
2000a084:	68bb      	ldr	r3, [r7, #8]
2000a086:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000a088:	2b00      	cmp	r3, #0
2000a08a:	d007      	beq.n	2000a09c <I2C_DMAError+0x42>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
2000a08c:	68bb      	ldr	r3, [r7, #8]
2000a08e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000a090:	681b      	ldr	r3, [r3, #0]
2000a092:	685b      	ldr	r3, [r3, #4]
2000a094:	2b00      	cmp	r3, #0
2000a096:	d101      	bne.n	2000a09c <I2C_DMAError+0x42>
    {
      treatdmaerror = 1U;
2000a098:	2301      	movs	r3, #1
2000a09a:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
2000a09c:	6878      	ldr	r0, [r7, #4]
2000a09e:	f7f9 f89d 	bl	200031dc <HAL_DMA_GetError>
2000a0a2:	4603      	mov	r3, r0
2000a0a4:	2b02      	cmp	r3, #2
2000a0a6:	d00e      	beq.n	2000a0c6 <I2C_DMAError+0x6c>
2000a0a8:	68fb      	ldr	r3, [r7, #12]
2000a0aa:	2b00      	cmp	r3, #0
2000a0ac:	d00b      	beq.n	2000a0c6 <I2C_DMAError+0x6c>
  {
    /* Disable Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2000a0ae:	68bb      	ldr	r3, [r7, #8]
2000a0b0:	681b      	ldr	r3, [r3, #0]
2000a0b2:	685a      	ldr	r2, [r3, #4]
2000a0b4:	68bb      	ldr	r3, [r7, #8]
2000a0b6:	681b      	ldr	r3, [r3, #0]
2000a0b8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2000a0bc:	605a      	str	r2, [r3, #4]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2000a0be:	2110      	movs	r1, #16
2000a0c0:	68b8      	ldr	r0, [r7, #8]
2000a0c2:	f7ff fe0d 	bl	20009ce0 <I2C_ITError>
  }
}
2000a0c6:	bf00      	nop
2000a0c8:	3710      	adds	r7, #16
2000a0ca:	46bd      	mov	sp, r7
2000a0cc:	bd80      	pop	{r7, pc}

2000a0ce <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
2000a0ce:	b580      	push	{r7, lr}
2000a0d0:	b084      	sub	sp, #16
2000a0d2:	af00      	add	r7, sp, #0
2000a0d4:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2000a0d6:	687b      	ldr	r3, [r7, #4]
2000a0d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000a0da:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  hi2c->hdmatx->XferAbortCallback = NULL;
2000a0dc:	68fb      	ldr	r3, [r7, #12]
2000a0de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000a0e0:	2200      	movs	r2, #0
2000a0e2:	651a      	str	r2, [r3, #80]	; 0x50
  hi2c->hdmarx->XferAbortCallback = NULL;
2000a0e4:	68fb      	ldr	r3, [r7, #12]
2000a0e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000a0e8:	2200      	movs	r2, #0
2000a0ea:	651a      	str	r2, [r3, #80]	; 0x50

  /* Check if come from abort from user */
  if (hi2c->State == HAL_I2C_STATE_ABORT)
2000a0ec:	68fb      	ldr	r3, [r7, #12]
2000a0ee:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000a0f2:	b2db      	uxtb	r3, r3
2000a0f4:	2b60      	cmp	r3, #96	; 0x60
2000a0f6:	d107      	bne.n	2000a108 <I2C_DMAAbort+0x3a>
  {
    hi2c->State = HAL_I2C_STATE_READY;
2000a0f8:	68fb      	ldr	r3, [r7, #12]
2000a0fa:	2220      	movs	r2, #32
2000a0fc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
2000a100:	68f8      	ldr	r0, [r7, #12]
2000a102:	f7fe fe64 	bl	20008dce <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2000a106:	e002      	b.n	2000a10e <I2C_DMAAbort+0x40>
    HAL_I2C_ErrorCallback(hi2c);
2000a108:	68f8      	ldr	r0, [r7, #12]
2000a10a:	f7fe fe56 	bl	20008dba <HAL_I2C_ErrorCallback>
}
2000a10e:	bf00      	nop
2000a110:	3710      	adds	r7, #16
2000a112:	46bd      	mov	sp, r7
2000a114:	bd80      	pop	{r7, pc}

2000a116 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
2000a116:	b580      	push	{r7, lr}
2000a118:	b084      	sub	sp, #16
2000a11a:	af00      	add	r7, sp, #0
2000a11c:	60f8      	str	r0, [r7, #12]
2000a11e:	60b9      	str	r1, [r7, #8]
2000a120:	603b      	str	r3, [r7, #0]
2000a122:	4613      	mov	r3, r2
2000a124:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2000a126:	e022      	b.n	2000a16e <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2000a128:	683b      	ldr	r3, [r7, #0]
2000a12a:	f1b3 3fff 	cmp.w	r3, #4294967295
2000a12e:	d01e      	beq.n	2000a16e <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2000a130:	f7f7 fe26 	bl	20001d80 <HAL_GetTick>
2000a134:	4602      	mov	r2, r0
2000a136:	69bb      	ldr	r3, [r7, #24]
2000a138:	1ad3      	subs	r3, r2, r3
2000a13a:	683a      	ldr	r2, [r7, #0]
2000a13c:	429a      	cmp	r2, r3
2000a13e:	d302      	bcc.n	2000a146 <I2C_WaitOnFlagUntilTimeout+0x30>
2000a140:	683b      	ldr	r3, [r7, #0]
2000a142:	2b00      	cmp	r3, #0
2000a144:	d113      	bne.n	2000a16e <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2000a146:	68fb      	ldr	r3, [r7, #12]
2000a148:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a14a:	f043 0220 	orr.w	r2, r3, #32
2000a14e:	68fb      	ldr	r3, [r7, #12]
2000a150:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2000a152:	68fb      	ldr	r3, [r7, #12]
2000a154:	2220      	movs	r2, #32
2000a156:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2000a15a:	68fb      	ldr	r3, [r7, #12]
2000a15c:	2200      	movs	r2, #0
2000a15e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000a162:	68fb      	ldr	r3, [r7, #12]
2000a164:	2200      	movs	r2, #0
2000a166:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2000a16a:	2301      	movs	r3, #1
2000a16c:	e00f      	b.n	2000a18e <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2000a16e:	68fb      	ldr	r3, [r7, #12]
2000a170:	681b      	ldr	r3, [r3, #0]
2000a172:	699a      	ldr	r2, [r3, #24]
2000a174:	68bb      	ldr	r3, [r7, #8]
2000a176:	4013      	ands	r3, r2
2000a178:	68ba      	ldr	r2, [r7, #8]
2000a17a:	429a      	cmp	r2, r3
2000a17c:	bf0c      	ite	eq
2000a17e:	2301      	moveq	r3, #1
2000a180:	2300      	movne	r3, #0
2000a182:	b2db      	uxtb	r3, r3
2000a184:	461a      	mov	r2, r3
2000a186:	79fb      	ldrb	r3, [r7, #7]
2000a188:	429a      	cmp	r2, r3
2000a18a:	d0cd      	beq.n	2000a128 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2000a18c:	2300      	movs	r3, #0
}
2000a18e:	4618      	mov	r0, r3
2000a190:	3710      	adds	r7, #16
2000a192:	46bd      	mov	sp, r7
2000a194:	bd80      	pop	{r7, pc}

2000a196 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2000a196:	b580      	push	{r7, lr}
2000a198:	b084      	sub	sp, #16
2000a19a:	af00      	add	r7, sp, #0
2000a19c:	60f8      	str	r0, [r7, #12]
2000a19e:	60b9      	str	r1, [r7, #8]
2000a1a0:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2000a1a2:	e02c      	b.n	2000a1fe <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2000a1a4:	687a      	ldr	r2, [r7, #4]
2000a1a6:	68b9      	ldr	r1, [r7, #8]
2000a1a8:	68f8      	ldr	r0, [r7, #12]
2000a1aa:	f000 f8dd 	bl	2000a368 <I2C_IsAcknowledgeFailed>
2000a1ae:	4603      	mov	r3, r0
2000a1b0:	2b00      	cmp	r3, #0
2000a1b2:	d001      	beq.n	2000a1b8 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2000a1b4:	2301      	movs	r3, #1
2000a1b6:	e02a      	b.n	2000a20e <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2000a1b8:	68bb      	ldr	r3, [r7, #8]
2000a1ba:	f1b3 3fff 	cmp.w	r3, #4294967295
2000a1be:	d01e      	beq.n	2000a1fe <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2000a1c0:	f7f7 fdde 	bl	20001d80 <HAL_GetTick>
2000a1c4:	4602      	mov	r2, r0
2000a1c6:	687b      	ldr	r3, [r7, #4]
2000a1c8:	1ad3      	subs	r3, r2, r3
2000a1ca:	68ba      	ldr	r2, [r7, #8]
2000a1cc:	429a      	cmp	r2, r3
2000a1ce:	d302      	bcc.n	2000a1d6 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
2000a1d0:	68bb      	ldr	r3, [r7, #8]
2000a1d2:	2b00      	cmp	r3, #0
2000a1d4:	d113      	bne.n	2000a1fe <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2000a1d6:	68fb      	ldr	r3, [r7, #12]
2000a1d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a1da:	f043 0220 	orr.w	r2, r3, #32
2000a1de:	68fb      	ldr	r3, [r7, #12]
2000a1e0:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2000a1e2:	68fb      	ldr	r3, [r7, #12]
2000a1e4:	2220      	movs	r2, #32
2000a1e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2000a1ea:	68fb      	ldr	r3, [r7, #12]
2000a1ec:	2200      	movs	r2, #0
2000a1ee:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000a1f2:	68fb      	ldr	r3, [r7, #12]
2000a1f4:	2200      	movs	r2, #0
2000a1f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2000a1fa:	2301      	movs	r3, #1
2000a1fc:	e007      	b.n	2000a20e <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2000a1fe:	68fb      	ldr	r3, [r7, #12]
2000a200:	681b      	ldr	r3, [r3, #0]
2000a202:	699b      	ldr	r3, [r3, #24]
2000a204:	f003 0302 	and.w	r3, r3, #2
2000a208:	2b02      	cmp	r3, #2
2000a20a:	d1cb      	bne.n	2000a1a4 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
2000a20c:	2300      	movs	r3, #0
}
2000a20e:	4618      	mov	r0, r3
2000a210:	3710      	adds	r7, #16
2000a212:	46bd      	mov	sp, r7
2000a214:	bd80      	pop	{r7, pc}

2000a216 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2000a216:	b580      	push	{r7, lr}
2000a218:	b084      	sub	sp, #16
2000a21a:	af00      	add	r7, sp, #0
2000a21c:	60f8      	str	r0, [r7, #12]
2000a21e:	60b9      	str	r1, [r7, #8]
2000a220:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2000a222:	e028      	b.n	2000a276 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2000a224:	687a      	ldr	r2, [r7, #4]
2000a226:	68b9      	ldr	r1, [r7, #8]
2000a228:	68f8      	ldr	r0, [r7, #12]
2000a22a:	f000 f89d 	bl	2000a368 <I2C_IsAcknowledgeFailed>
2000a22e:	4603      	mov	r3, r0
2000a230:	2b00      	cmp	r3, #0
2000a232:	d001      	beq.n	2000a238 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2000a234:	2301      	movs	r3, #1
2000a236:	e026      	b.n	2000a286 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2000a238:	f7f7 fda2 	bl	20001d80 <HAL_GetTick>
2000a23c:	4602      	mov	r2, r0
2000a23e:	687b      	ldr	r3, [r7, #4]
2000a240:	1ad3      	subs	r3, r2, r3
2000a242:	68ba      	ldr	r2, [r7, #8]
2000a244:	429a      	cmp	r2, r3
2000a246:	d302      	bcc.n	2000a24e <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
2000a248:	68bb      	ldr	r3, [r7, #8]
2000a24a:	2b00      	cmp	r3, #0
2000a24c:	d113      	bne.n	2000a276 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2000a24e:	68fb      	ldr	r3, [r7, #12]
2000a250:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a252:	f043 0220 	orr.w	r2, r3, #32
2000a256:	68fb      	ldr	r3, [r7, #12]
2000a258:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2000a25a:	68fb      	ldr	r3, [r7, #12]
2000a25c:	2220      	movs	r2, #32
2000a25e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
2000a262:	68fb      	ldr	r3, [r7, #12]
2000a264:	2200      	movs	r2, #0
2000a266:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000a26a:	68fb      	ldr	r3, [r7, #12]
2000a26c:	2200      	movs	r2, #0
2000a26e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2000a272:	2301      	movs	r3, #1
2000a274:	e007      	b.n	2000a286 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2000a276:	68fb      	ldr	r3, [r7, #12]
2000a278:	681b      	ldr	r3, [r3, #0]
2000a27a:	699b      	ldr	r3, [r3, #24]
2000a27c:	f003 0320 	and.w	r3, r3, #32
2000a280:	2b20      	cmp	r3, #32
2000a282:	d1cf      	bne.n	2000a224 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2000a284:	2300      	movs	r3, #0
}
2000a286:	4618      	mov	r0, r3
2000a288:	3710      	adds	r7, #16
2000a28a:	46bd      	mov	sp, r7
2000a28c:	bd80      	pop	{r7, pc}
	...

2000a290 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2000a290:	b580      	push	{r7, lr}
2000a292:	b084      	sub	sp, #16
2000a294:	af00      	add	r7, sp, #0
2000a296:	60f8      	str	r0, [r7, #12]
2000a298:	60b9      	str	r1, [r7, #8]
2000a29a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2000a29c:	e055      	b.n	2000a34a <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2000a29e:	687a      	ldr	r2, [r7, #4]
2000a2a0:	68b9      	ldr	r1, [r7, #8]
2000a2a2:	68f8      	ldr	r0, [r7, #12]
2000a2a4:	f000 f860 	bl	2000a368 <I2C_IsAcknowledgeFailed>
2000a2a8:	4603      	mov	r3, r0
2000a2aa:	2b00      	cmp	r3, #0
2000a2ac:	d001      	beq.n	2000a2b2 <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2000a2ae:	2301      	movs	r3, #1
2000a2b0:	e053      	b.n	2000a35a <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
2000a2b2:	68fb      	ldr	r3, [r7, #12]
2000a2b4:	681b      	ldr	r3, [r3, #0]
2000a2b6:	699b      	ldr	r3, [r3, #24]
2000a2b8:	f003 0320 	and.w	r3, r3, #32
2000a2bc:	2b20      	cmp	r3, #32
2000a2be:	d129      	bne.n	2000a314 <I2C_WaitOnRXNEFlagUntilTimeout+0x84>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
2000a2c0:	68fb      	ldr	r3, [r7, #12]
2000a2c2:	681b      	ldr	r3, [r3, #0]
2000a2c4:	699b      	ldr	r3, [r3, #24]
2000a2c6:	f003 0304 	and.w	r3, r3, #4
2000a2ca:	2b04      	cmp	r3, #4
2000a2cc:	d105      	bne.n	2000a2da <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
2000a2ce:	68fb      	ldr	r3, [r7, #12]
2000a2d0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2000a2d2:	2b00      	cmp	r3, #0
2000a2d4:	d001      	beq.n	2000a2da <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
2000a2d6:	2300      	movs	r3, #0
2000a2d8:	e03f      	b.n	2000a35a <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000a2da:	68fb      	ldr	r3, [r7, #12]
2000a2dc:	681b      	ldr	r3, [r3, #0]
2000a2de:	2220      	movs	r2, #32
2000a2e0:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
2000a2e2:	68fb      	ldr	r3, [r7, #12]
2000a2e4:	681b      	ldr	r3, [r3, #0]
2000a2e6:	6859      	ldr	r1, [r3, #4]
2000a2e8:	68fb      	ldr	r3, [r7, #12]
2000a2ea:	681a      	ldr	r2, [r3, #0]
2000a2ec:	4b1d      	ldr	r3, [pc, #116]	; (2000a364 <I2C_WaitOnRXNEFlagUntilTimeout+0xd4>)
2000a2ee:	400b      	ands	r3, r1
2000a2f0:	6053      	str	r3, [r2, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2000a2f2:	68fb      	ldr	r3, [r7, #12]
2000a2f4:	2200      	movs	r2, #0
2000a2f6:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2000a2f8:	68fb      	ldr	r3, [r7, #12]
2000a2fa:	2220      	movs	r2, #32
2000a2fc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2000a300:	68fb      	ldr	r3, [r7, #12]
2000a302:	2200      	movs	r2, #0
2000a304:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2000a308:	68fb      	ldr	r3, [r7, #12]
2000a30a:	2200      	movs	r2, #0
2000a30c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2000a310:	2301      	movs	r3, #1
2000a312:	e022      	b.n	2000a35a <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2000a314:	f7f7 fd34 	bl	20001d80 <HAL_GetTick>
2000a318:	4602      	mov	r2, r0
2000a31a:	687b      	ldr	r3, [r7, #4]
2000a31c:	1ad3      	subs	r3, r2, r3
2000a31e:	68ba      	ldr	r2, [r7, #8]
2000a320:	429a      	cmp	r2, r3
2000a322:	d302      	bcc.n	2000a32a <I2C_WaitOnRXNEFlagUntilTimeout+0x9a>
2000a324:	68bb      	ldr	r3, [r7, #8]
2000a326:	2b00      	cmp	r3, #0
2000a328:	d10f      	bne.n	2000a34a <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2000a32a:	68fb      	ldr	r3, [r7, #12]
2000a32c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a32e:	f043 0220 	orr.w	r2, r3, #32
2000a332:	68fb      	ldr	r3, [r7, #12]
2000a334:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2000a336:	68fb      	ldr	r3, [r7, #12]
2000a338:	2220      	movs	r2, #32
2000a33a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2000a33e:	68fb      	ldr	r3, [r7, #12]
2000a340:	2200      	movs	r2, #0
2000a342:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2000a346:	2301      	movs	r3, #1
2000a348:	e007      	b.n	2000a35a <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2000a34a:	68fb      	ldr	r3, [r7, #12]
2000a34c:	681b      	ldr	r3, [r3, #0]
2000a34e:	699b      	ldr	r3, [r3, #24]
2000a350:	f003 0304 	and.w	r3, r3, #4
2000a354:	2b04      	cmp	r3, #4
2000a356:	d1a2      	bne.n	2000a29e <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2000a358:	2300      	movs	r3, #0
}
2000a35a:	4618      	mov	r0, r3
2000a35c:	3710      	adds	r7, #16
2000a35e:	46bd      	mov	sp, r7
2000a360:	bd80      	pop	{r7, pc}
2000a362:	bf00      	nop
2000a364:	fe00e800 	.word	0xfe00e800

2000a368 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2000a368:	b580      	push	{r7, lr}
2000a36a:	b084      	sub	sp, #16
2000a36c:	af00      	add	r7, sp, #0
2000a36e:	60f8      	str	r0, [r7, #12]
2000a370:	60b9      	str	r1, [r7, #8]
2000a372:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
2000a374:	68fb      	ldr	r3, [r7, #12]
2000a376:	681b      	ldr	r3, [r3, #0]
2000a378:	699b      	ldr	r3, [r3, #24]
2000a37a:	f003 0310 	and.w	r3, r3, #16
2000a37e:	2b10      	cmp	r3, #16
2000a380:	d151      	bne.n	2000a426 <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2000a382:	e022      	b.n	2000a3ca <I2C_IsAcknowledgeFailed+0x62>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
2000a384:	68bb      	ldr	r3, [r7, #8]
2000a386:	f1b3 3fff 	cmp.w	r3, #4294967295
2000a38a:	d01e      	beq.n	2000a3ca <I2C_IsAcknowledgeFailed+0x62>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2000a38c:	f7f7 fcf8 	bl	20001d80 <HAL_GetTick>
2000a390:	4602      	mov	r2, r0
2000a392:	687b      	ldr	r3, [r7, #4]
2000a394:	1ad3      	subs	r3, r2, r3
2000a396:	68ba      	ldr	r2, [r7, #8]
2000a398:	429a      	cmp	r2, r3
2000a39a:	d302      	bcc.n	2000a3a2 <I2C_IsAcknowledgeFailed+0x3a>
2000a39c:	68bb      	ldr	r3, [r7, #8]
2000a39e:	2b00      	cmp	r3, #0
2000a3a0:	d113      	bne.n	2000a3ca <I2C_IsAcknowledgeFailed+0x62>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2000a3a2:	68fb      	ldr	r3, [r7, #12]
2000a3a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a3a6:	f043 0220 	orr.w	r2, r3, #32
2000a3aa:	68fb      	ldr	r3, [r7, #12]
2000a3ac:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
2000a3ae:	68fb      	ldr	r3, [r7, #12]
2000a3b0:	2220      	movs	r2, #32
2000a3b2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
2000a3b6:	68fb      	ldr	r3, [r7, #12]
2000a3b8:	2200      	movs	r2, #0
2000a3ba:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2000a3be:	68fb      	ldr	r3, [r7, #12]
2000a3c0:	2200      	movs	r2, #0
2000a3c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
2000a3c6:	2301      	movs	r3, #1
2000a3c8:	e02e      	b.n	2000a428 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2000a3ca:	68fb      	ldr	r3, [r7, #12]
2000a3cc:	681b      	ldr	r3, [r3, #0]
2000a3ce:	699b      	ldr	r3, [r3, #24]
2000a3d0:	f003 0320 	and.w	r3, r3, #32
2000a3d4:	2b20      	cmp	r3, #32
2000a3d6:	d1d5      	bne.n	2000a384 <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2000a3d8:	68fb      	ldr	r3, [r7, #12]
2000a3da:	681b      	ldr	r3, [r3, #0]
2000a3dc:	2210      	movs	r2, #16
2000a3de:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2000a3e0:	68fb      	ldr	r3, [r7, #12]
2000a3e2:	681b      	ldr	r3, [r3, #0]
2000a3e4:	2220      	movs	r2, #32
2000a3e6:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2000a3e8:	68f8      	ldr	r0, [r7, #12]
2000a3ea:	f7ff fd39 	bl	20009e60 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2000a3ee:	68fb      	ldr	r3, [r7, #12]
2000a3f0:	681b      	ldr	r3, [r3, #0]
2000a3f2:	6859      	ldr	r1, [r3, #4]
2000a3f4:	68fb      	ldr	r3, [r7, #12]
2000a3f6:	681a      	ldr	r2, [r3, #0]
2000a3f8:	4b0d      	ldr	r3, [pc, #52]	; (2000a430 <I2C_IsAcknowledgeFailed+0xc8>)
2000a3fa:	400b      	ands	r3, r1
2000a3fc:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2000a3fe:	68fb      	ldr	r3, [r7, #12]
2000a400:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a402:	f043 0204 	orr.w	r2, r3, #4
2000a406:	68fb      	ldr	r3, [r7, #12]
2000a408:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
2000a40a:	68fb      	ldr	r3, [r7, #12]
2000a40c:	2220      	movs	r2, #32
2000a40e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2000a412:	68fb      	ldr	r3, [r7, #12]
2000a414:	2200      	movs	r2, #0
2000a416:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000a41a:	68fb      	ldr	r3, [r7, #12]
2000a41c:	2200      	movs	r2, #0
2000a41e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2000a422:	2301      	movs	r3, #1
2000a424:	e000      	b.n	2000a428 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
2000a426:	2300      	movs	r3, #0
}
2000a428:	4618      	mov	r0, r3
2000a42a:	3710      	adds	r7, #16
2000a42c:	46bd      	mov	sp, r7
2000a42e:	bd80      	pop	{r7, pc}
2000a430:	fe00e800 	.word	0xfe00e800

2000a434 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
2000a434:	b480      	push	{r7}
2000a436:	b085      	sub	sp, #20
2000a438:	af00      	add	r7, sp, #0
2000a43a:	60f8      	str	r0, [r7, #12]
2000a43c:	607b      	str	r3, [r7, #4]
2000a43e:	460b      	mov	r3, r1
2000a440:	817b      	strh	r3, [r7, #10]
2000a442:	4613      	mov	r3, r2
2000a444:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
2000a446:	68fb      	ldr	r3, [r7, #12]
2000a448:	681b      	ldr	r3, [r3, #0]
2000a44a:	685a      	ldr	r2, [r3, #4]
2000a44c:	69bb      	ldr	r3, [r7, #24]
2000a44e:	0d5b      	lsrs	r3, r3, #21
2000a450:	f403 6180 	and.w	r1, r3, #1024	; 0x400
2000a454:	4b0d      	ldr	r3, [pc, #52]	; (2000a48c <I2C_TransferConfig+0x58>)
2000a456:	430b      	orrs	r3, r1
2000a458:	43db      	mvns	r3, r3
2000a45a:	ea02 0103 	and.w	r1, r2, r3
2000a45e:	897b      	ldrh	r3, [r7, #10]
2000a460:	f3c3 0209 	ubfx	r2, r3, #0, #10
2000a464:	7a7b      	ldrb	r3, [r7, #9]
2000a466:	041b      	lsls	r3, r3, #16
2000a468:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
2000a46c:	431a      	orrs	r2, r3
2000a46e:	687b      	ldr	r3, [r7, #4]
2000a470:	431a      	orrs	r2, r3
2000a472:	69bb      	ldr	r3, [r7, #24]
2000a474:	431a      	orrs	r2, r3
2000a476:	68fb      	ldr	r3, [r7, #12]
2000a478:	681b      	ldr	r3, [r3, #0]
2000a47a:	430a      	orrs	r2, r1
2000a47c:	605a      	str	r2, [r3, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
2000a47e:	bf00      	nop
2000a480:	3714      	adds	r7, #20
2000a482:	46bd      	mov	sp, r7
2000a484:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a488:	4770      	bx	lr
2000a48a:	bf00      	nop
2000a48c:	03ff63ff 	.word	0x03ff63ff

2000a490 <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2000a490:	b480      	push	{r7}
2000a492:	b085      	sub	sp, #20
2000a494:	af00      	add	r7, sp, #0
2000a496:	6078      	str	r0, [r7, #4]
2000a498:	460b      	mov	r3, r1
2000a49a:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2000a49c:	2300      	movs	r3, #0
2000a49e:	60fb      	str	r3, [r7, #12]

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2000a4a0:	687b      	ldr	r3, [r7, #4]
2000a4a2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000a4a4:	4a2f      	ldr	r2, [pc, #188]	; (2000a564 <I2C_Enable_IRQ+0xd4>)
2000a4a6:	4293      	cmp	r3, r2
2000a4a8:	d004      	beq.n	2000a4b4 <I2C_Enable_IRQ+0x24>
      (hi2c->XferISR == I2C_Slave_ISR_DMA))
2000a4aa:	687b      	ldr	r3, [r7, #4]
2000a4ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2000a4ae:	4a2e      	ldr	r2, [pc, #184]	; (2000a568 <I2C_Enable_IRQ+0xd8>)
2000a4b0:	4293      	cmp	r3, r2
2000a4b2:	d124      	bne.n	2000a4fe <I2C_Enable_IRQ+0x6e>
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2000a4b4:	887b      	ldrh	r3, [r7, #2]
2000a4b6:	f003 0304 	and.w	r3, r3, #4
2000a4ba:	2b00      	cmp	r3, #0
2000a4bc:	d003      	beq.n	2000a4c6 <I2C_Enable_IRQ+0x36>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2000a4be:	68fb      	ldr	r3, [r7, #12]
2000a4c0:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2000a4c4:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
2000a4c6:	887b      	ldrh	r3, [r7, #2]
2000a4c8:	f003 0311 	and.w	r3, r3, #17
2000a4cc:	2b11      	cmp	r3, #17
2000a4ce:	d103      	bne.n	2000a4d8 <I2C_Enable_IRQ+0x48>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2000a4d0:	68fb      	ldr	r3, [r7, #12]
2000a4d2:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2000a4d6:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
2000a4d8:	887b      	ldrh	r3, [r7, #2]
2000a4da:	f003 0312 	and.w	r3, r3, #18
2000a4de:	2b12      	cmp	r3, #18
2000a4e0:	d103      	bne.n	2000a4ea <I2C_Enable_IRQ+0x5a>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
2000a4e2:	68fb      	ldr	r3, [r7, #12]
2000a4e4:	f043 0320 	orr.w	r3, r3, #32
2000a4e8:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
2000a4ea:	887b      	ldrh	r3, [r7, #2]
2000a4ec:	f003 0312 	and.w	r3, r3, #18
2000a4f0:	2b12      	cmp	r3, #18
2000a4f2:	d128      	bne.n	2000a546 <I2C_Enable_IRQ+0xb6>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
2000a4f4:	68fb      	ldr	r3, [r7, #12]
2000a4f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2000a4fa:	60fb      	str	r3, [r7, #12]
    if ((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
2000a4fc:	e023      	b.n	2000a546 <I2C_Enable_IRQ+0xb6>
    }
  }
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2000a4fe:	887b      	ldrh	r3, [r7, #2]
2000a500:	f003 0304 	and.w	r3, r3, #4
2000a504:	2b00      	cmp	r3, #0
2000a506:	d003      	beq.n	2000a510 <I2C_Enable_IRQ+0x80>
    {
      /* Enable ERR, STOP, NACK, and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2000a508:	68fb      	ldr	r3, [r7, #12]
2000a50a:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2000a50e:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2000a510:	887b      	ldrh	r3, [r7, #2]
2000a512:	f003 0301 	and.w	r3, r3, #1
2000a516:	2b00      	cmp	r3, #0
2000a518:	d003      	beq.n	2000a522 <I2C_Enable_IRQ+0x92>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
2000a51a:	68fb      	ldr	r3, [r7, #12]
2000a51c:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
2000a520:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2000a522:	887b      	ldrh	r3, [r7, #2]
2000a524:	f003 0302 	and.w	r3, r3, #2
2000a528:	2b00      	cmp	r3, #0
2000a52a:	d003      	beq.n	2000a534 <I2C_Enable_IRQ+0xa4>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
2000a52c:	68fb      	ldr	r3, [r7, #12]
2000a52e:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
2000a532:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
2000a534:	887b      	ldrh	r3, [r7, #2]
2000a536:	f003 0312 	and.w	r3, r3, #18
2000a53a:	2b12      	cmp	r3, #18
2000a53c:	d103      	bne.n	2000a546 <I2C_Enable_IRQ+0xb6>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
2000a53e:	68fb      	ldr	r3, [r7, #12]
2000a540:	f043 0320 	orr.w	r3, r3, #32
2000a544:	60fb      	str	r3, [r7, #12]
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
2000a546:	687b      	ldr	r3, [r7, #4]
2000a548:	681b      	ldr	r3, [r3, #0]
2000a54a:	6819      	ldr	r1, [r3, #0]
2000a54c:	687b      	ldr	r3, [r7, #4]
2000a54e:	681b      	ldr	r3, [r3, #0]
2000a550:	68fa      	ldr	r2, [r7, #12]
2000a552:	430a      	orrs	r2, r1
2000a554:	601a      	str	r2, [r3, #0]
}
2000a556:	bf00      	nop
2000a558:	3714      	adds	r7, #20
2000a55a:	46bd      	mov	sp, r7
2000a55c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a560:	4770      	bx	lr
2000a562:	bf00      	nop
2000a564:	20009293 	.word	0x20009293
2000a568:	20009479 	.word	0x20009479

2000a56c <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2000a56c:	b480      	push	{r7}
2000a56e:	b085      	sub	sp, #20
2000a570:	af00      	add	r7, sp, #0
2000a572:	6078      	str	r0, [r7, #4]
2000a574:	460b      	mov	r3, r1
2000a576:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2000a578:	2300      	movs	r3, #0
2000a57a:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2000a57c:	887b      	ldrh	r3, [r7, #2]
2000a57e:	f003 0301 	and.w	r3, r3, #1
2000a582:	2b00      	cmp	r3, #0
2000a584:	d00f      	beq.n	2000a5a6 <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
2000a586:	68fb      	ldr	r3, [r7, #12]
2000a588:	f043 0342 	orr.w	r3, r3, #66	; 0x42
2000a58c:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2000a58e:	687b      	ldr	r3, [r7, #4]
2000a590:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000a594:	b2db      	uxtb	r3, r3
2000a596:	f003 0328 	and.w	r3, r3, #40	; 0x28
2000a59a:	2b28      	cmp	r3, #40	; 0x28
2000a59c:	d003      	beq.n	2000a5a6 <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2000a59e:	68fb      	ldr	r3, [r7, #12]
2000a5a0:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2000a5a4:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2000a5a6:	887b      	ldrh	r3, [r7, #2]
2000a5a8:	f003 0302 	and.w	r3, r3, #2
2000a5ac:	2b00      	cmp	r3, #0
2000a5ae:	d00f      	beq.n	2000a5d0 <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
2000a5b0:	68fb      	ldr	r3, [r7, #12]
2000a5b2:	f043 0344 	orr.w	r3, r3, #68	; 0x44
2000a5b6:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2000a5b8:	687b      	ldr	r3, [r7, #4]
2000a5ba:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000a5be:	b2db      	uxtb	r3, r3
2000a5c0:	f003 0328 	and.w	r3, r3, #40	; 0x28
2000a5c4:	2b28      	cmp	r3, #40	; 0x28
2000a5c6:	d003      	beq.n	2000a5d0 <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2000a5c8:	68fb      	ldr	r3, [r7, #12]
2000a5ca:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2000a5ce:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2000a5d0:	887b      	ldrh	r3, [r7, #2]
2000a5d2:	f003 0304 	and.w	r3, r3, #4
2000a5d6:	2b00      	cmp	r3, #0
2000a5d8:	d003      	beq.n	2000a5e2 <I2C_Disable_IRQ+0x76>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2000a5da:	68fb      	ldr	r3, [r7, #12]
2000a5dc:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2000a5e0:	60fb      	str	r3, [r7, #12]
  }

  if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
2000a5e2:	887b      	ldrh	r3, [r7, #2]
2000a5e4:	f003 0311 	and.w	r3, r3, #17
2000a5e8:	2b11      	cmp	r3, #17
2000a5ea:	d103      	bne.n	2000a5f4 <I2C_Disable_IRQ+0x88>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2000a5ec:	68fb      	ldr	r3, [r7, #12]
2000a5ee:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2000a5f2:	60fb      	str	r3, [r7, #12]
  }

  if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
2000a5f4:	887b      	ldrh	r3, [r7, #2]
2000a5f6:	f003 0312 	and.w	r3, r3, #18
2000a5fa:	2b12      	cmp	r3, #18
2000a5fc:	d103      	bne.n	2000a606 <I2C_Disable_IRQ+0x9a>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
2000a5fe:	68fb      	ldr	r3, [r7, #12]
2000a600:	f043 0320 	orr.w	r3, r3, #32
2000a604:	60fb      	str	r3, [r7, #12]
  }

  if ((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
2000a606:	887b      	ldrh	r3, [r7, #2]
2000a608:	f003 0312 	and.w	r3, r3, #18
2000a60c:	2b12      	cmp	r3, #18
2000a60e:	d103      	bne.n	2000a618 <I2C_Disable_IRQ+0xac>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
2000a610:	68fb      	ldr	r3, [r7, #12]
2000a612:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2000a616:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
2000a618:	687b      	ldr	r3, [r7, #4]
2000a61a:	681b      	ldr	r3, [r3, #0]
2000a61c:	6819      	ldr	r1, [r3, #0]
2000a61e:	68fb      	ldr	r3, [r7, #12]
2000a620:	43da      	mvns	r2, r3
2000a622:	687b      	ldr	r3, [r7, #4]
2000a624:	681b      	ldr	r3, [r3, #0]
2000a626:	400a      	ands	r2, r1
2000a628:	601a      	str	r2, [r3, #0]
}
2000a62a:	bf00      	nop
2000a62c:	3714      	adds	r7, #20
2000a62e:	46bd      	mov	sp, r7
2000a630:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a634:	4770      	bx	lr

2000a636 <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
2000a636:	b480      	push	{r7}
2000a638:	b083      	sub	sp, #12
2000a63a:	af00      	add	r7, sp, #0
2000a63c:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
2000a63e:	687b      	ldr	r3, [r7, #4]
2000a640:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000a642:	2baa      	cmp	r3, #170	; 0xaa
2000a644:	d103      	bne.n	2000a64e <I2C_ConvertOtherXferOptions+0x18>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
2000a646:	687b      	ldr	r3, [r7, #4]
2000a648:	2200      	movs	r2, #0
2000a64a:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
2000a64c:	e008      	b.n	2000a660 <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
2000a64e:	687b      	ldr	r3, [r7, #4]
2000a650:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000a652:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2000a656:	d103      	bne.n	2000a660 <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
2000a658:	687b      	ldr	r3, [r7, #4]
2000a65a:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
2000a65e:	62da      	str	r2, [r3, #44]	; 0x2c
}
2000a660:	bf00      	nop
2000a662:	370c      	adds	r7, #12
2000a664:	46bd      	mov	sp, r7
2000a666:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a66a:	4770      	bx	lr

2000a66c <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
2000a66c:	b480      	push	{r7}
2000a66e:	b083      	sub	sp, #12
2000a670:	af00      	add	r7, sp, #0
2000a672:	6078      	str	r0, [r7, #4]
2000a674:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2000a676:	687b      	ldr	r3, [r7, #4]
2000a678:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000a67c:	b2db      	uxtb	r3, r3
2000a67e:	2b20      	cmp	r3, #32
2000a680:	d138      	bne.n	2000a6f4 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000a682:	687b      	ldr	r3, [r7, #4]
2000a684:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000a688:	2b01      	cmp	r3, #1
2000a68a:	d101      	bne.n	2000a690 <HAL_I2CEx_ConfigAnalogFilter+0x24>
2000a68c:	2302      	movs	r3, #2
2000a68e:	e032      	b.n	2000a6f6 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
2000a690:	687b      	ldr	r3, [r7, #4]
2000a692:	2201      	movs	r2, #1
2000a694:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2000a698:	687b      	ldr	r3, [r7, #4]
2000a69a:	2224      	movs	r2, #36	; 0x24
2000a69c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2000a6a0:	687b      	ldr	r3, [r7, #4]
2000a6a2:	681b      	ldr	r3, [r3, #0]
2000a6a4:	681a      	ldr	r2, [r3, #0]
2000a6a6:	687b      	ldr	r3, [r7, #4]
2000a6a8:	681b      	ldr	r3, [r3, #0]
2000a6aa:	f022 0201 	bic.w	r2, r2, #1
2000a6ae:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
2000a6b0:	687b      	ldr	r3, [r7, #4]
2000a6b2:	681b      	ldr	r3, [r3, #0]
2000a6b4:	681a      	ldr	r2, [r3, #0]
2000a6b6:	687b      	ldr	r3, [r7, #4]
2000a6b8:	681b      	ldr	r3, [r3, #0]
2000a6ba:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2000a6be:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
2000a6c0:	687b      	ldr	r3, [r7, #4]
2000a6c2:	681b      	ldr	r3, [r3, #0]
2000a6c4:	6819      	ldr	r1, [r3, #0]
2000a6c6:	687b      	ldr	r3, [r7, #4]
2000a6c8:	681b      	ldr	r3, [r3, #0]
2000a6ca:	683a      	ldr	r2, [r7, #0]
2000a6cc:	430a      	orrs	r2, r1
2000a6ce:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2000a6d0:	687b      	ldr	r3, [r7, #4]
2000a6d2:	681b      	ldr	r3, [r3, #0]
2000a6d4:	681a      	ldr	r2, [r3, #0]
2000a6d6:	687b      	ldr	r3, [r7, #4]
2000a6d8:	681b      	ldr	r3, [r3, #0]
2000a6da:	f042 0201 	orr.w	r2, r2, #1
2000a6de:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2000a6e0:	687b      	ldr	r3, [r7, #4]
2000a6e2:	2220      	movs	r2, #32
2000a6e4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000a6e8:	687b      	ldr	r3, [r7, #4]
2000a6ea:	2200      	movs	r2, #0
2000a6ec:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000a6f0:	2300      	movs	r3, #0
2000a6f2:	e000      	b.n	2000a6f6 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
2000a6f4:	2302      	movs	r3, #2
  }
}
2000a6f6:	4618      	mov	r0, r3
2000a6f8:	370c      	adds	r7, #12
2000a6fa:	46bd      	mov	sp, r7
2000a6fc:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a700:	4770      	bx	lr

2000a702 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
2000a702:	b480      	push	{r7}
2000a704:	b085      	sub	sp, #20
2000a706:	af00      	add	r7, sp, #0
2000a708:	6078      	str	r0, [r7, #4]
2000a70a:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2000a70c:	687b      	ldr	r3, [r7, #4]
2000a70e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000a712:	b2db      	uxtb	r3, r3
2000a714:	2b20      	cmp	r3, #32
2000a716:	d139      	bne.n	2000a78c <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2000a718:	687b      	ldr	r3, [r7, #4]
2000a71a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000a71e:	2b01      	cmp	r3, #1
2000a720:	d101      	bne.n	2000a726 <HAL_I2CEx_ConfigDigitalFilter+0x24>
2000a722:	2302      	movs	r3, #2
2000a724:	e033      	b.n	2000a78e <HAL_I2CEx_ConfigDigitalFilter+0x8c>
2000a726:	687b      	ldr	r3, [r7, #4]
2000a728:	2201      	movs	r2, #1
2000a72a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2000a72e:	687b      	ldr	r3, [r7, #4]
2000a730:	2224      	movs	r2, #36	; 0x24
2000a732:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2000a736:	687b      	ldr	r3, [r7, #4]
2000a738:	681b      	ldr	r3, [r3, #0]
2000a73a:	681a      	ldr	r2, [r3, #0]
2000a73c:	687b      	ldr	r3, [r7, #4]
2000a73e:	681b      	ldr	r3, [r3, #0]
2000a740:	f022 0201 	bic.w	r2, r2, #1
2000a744:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
2000a746:	687b      	ldr	r3, [r7, #4]
2000a748:	681b      	ldr	r3, [r3, #0]
2000a74a:	681b      	ldr	r3, [r3, #0]
2000a74c:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
2000a74e:	68fb      	ldr	r3, [r7, #12]
2000a750:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
2000a754:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
2000a756:	683b      	ldr	r3, [r7, #0]
2000a758:	021b      	lsls	r3, r3, #8
2000a75a:	68fa      	ldr	r2, [r7, #12]
2000a75c:	4313      	orrs	r3, r2
2000a75e:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
2000a760:	687b      	ldr	r3, [r7, #4]
2000a762:	681b      	ldr	r3, [r3, #0]
2000a764:	68fa      	ldr	r2, [r7, #12]
2000a766:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2000a768:	687b      	ldr	r3, [r7, #4]
2000a76a:	681b      	ldr	r3, [r3, #0]
2000a76c:	681a      	ldr	r2, [r3, #0]
2000a76e:	687b      	ldr	r3, [r7, #4]
2000a770:	681b      	ldr	r3, [r3, #0]
2000a772:	f042 0201 	orr.w	r2, r2, #1
2000a776:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2000a778:	687b      	ldr	r3, [r7, #4]
2000a77a:	2220      	movs	r2, #32
2000a77c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2000a780:	687b      	ldr	r3, [r7, #4]
2000a782:	2200      	movs	r2, #0
2000a784:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2000a788:	2300      	movs	r3, #0
2000a78a:	e000      	b.n	2000a78e <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
2000a78c:	2302      	movs	r3, #2
  }
}
2000a78e:	4618      	mov	r0, r3
2000a790:	3714      	adds	r7, #20
2000a792:	46bd      	mov	sp, r7
2000a794:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a798:	4770      	bx	lr
	...

2000a79c <HAL_I2CEx_EnableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)
{
2000a79c:	b480      	push	{r7}
2000a79e:	b085      	sub	sp, #20
2000a7a0:	af00      	add	r7, sp, #0
2000a7a2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2000a7a4:	4b0b      	ldr	r3, [pc, #44]	; (2000a7d4 <HAL_I2CEx_EnableFastModePlus+0x38>)
2000a7a6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a7a8:	4a0a      	ldr	r2, [pc, #40]	; (2000a7d4 <HAL_I2CEx_EnableFastModePlus+0x38>)
2000a7aa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
2000a7ae:	6453      	str	r3, [r2, #68]	; 0x44
2000a7b0:	4b08      	ldr	r3, [pc, #32]	; (2000a7d4 <HAL_I2CEx_EnableFastModePlus+0x38>)
2000a7b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a7b4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000a7b8:	60fb      	str	r3, [r7, #12]
2000a7ba:	68fb      	ldr	r3, [r7, #12]

  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->PMC, (uint32_t)ConfigFastModePlus);
2000a7bc:	4b06      	ldr	r3, [pc, #24]	; (2000a7d8 <HAL_I2CEx_EnableFastModePlus+0x3c>)
2000a7be:	685a      	ldr	r2, [r3, #4]
2000a7c0:	4905      	ldr	r1, [pc, #20]	; (2000a7d8 <HAL_I2CEx_EnableFastModePlus+0x3c>)
2000a7c2:	687b      	ldr	r3, [r7, #4]
2000a7c4:	4313      	orrs	r3, r2
2000a7c6:	604b      	str	r3, [r1, #4]
}
2000a7c8:	bf00      	nop
2000a7ca:	3714      	adds	r7, #20
2000a7cc:	46bd      	mov	sp, r7
2000a7ce:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a7d2:	4770      	bx	lr
2000a7d4:	40023800 	.word	0x40023800
2000a7d8:	40013800 	.word	0x40013800

2000a7dc <HAL_I2CEx_DisableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)
{
2000a7dc:	b480      	push	{r7}
2000a7de:	b085      	sub	sp, #20
2000a7e0:	af00      	add	r7, sp, #0
2000a7e2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2000a7e4:	4b0c      	ldr	r3, [pc, #48]	; (2000a818 <HAL_I2CEx_DisableFastModePlus+0x3c>)
2000a7e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a7e8:	4a0b      	ldr	r2, [pc, #44]	; (2000a818 <HAL_I2CEx_DisableFastModePlus+0x3c>)
2000a7ea:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
2000a7ee:	6453      	str	r3, [r2, #68]	; 0x44
2000a7f0:	4b09      	ldr	r3, [pc, #36]	; (2000a818 <HAL_I2CEx_DisableFastModePlus+0x3c>)
2000a7f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000a7f4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000a7f8:	60fb      	str	r3, [r7, #12]
2000a7fa:	68fb      	ldr	r3, [r7, #12]

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->PMC, (uint32_t)ConfigFastModePlus);
2000a7fc:	4b07      	ldr	r3, [pc, #28]	; (2000a81c <HAL_I2CEx_DisableFastModePlus+0x40>)
2000a7fe:	685a      	ldr	r2, [r3, #4]
2000a800:	687b      	ldr	r3, [r7, #4]
2000a802:	43db      	mvns	r3, r3
2000a804:	4905      	ldr	r1, [pc, #20]	; (2000a81c <HAL_I2CEx_DisableFastModePlus+0x40>)
2000a806:	4013      	ands	r3, r2
2000a808:	604b      	str	r3, [r1, #4]
}
2000a80a:	bf00      	nop
2000a80c:	3714      	adds	r7, #20
2000a80e:	46bd      	mov	sp, r7
2000a810:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a814:	4770      	bx	lr
2000a816:	bf00      	nop
2000a818:	40023800 	.word	0x40023800
2000a81c:	40013800 	.word	0x40013800

2000a820 <HAL_PWR_DeInit>:
/**
  * @brief Deinitializes the HAL PWR peripheral registers to their default reset values.
  * @retval None
  */
void HAL_PWR_DeInit(void)
{
2000a820:	b480      	push	{r7}
2000a822:	af00      	add	r7, sp, #0
  __HAL_RCC_PWR_FORCE_RESET();
2000a824:	4b08      	ldr	r3, [pc, #32]	; (2000a848 <HAL_PWR_DeInit+0x28>)
2000a826:	6a1b      	ldr	r3, [r3, #32]
2000a828:	4a07      	ldr	r2, [pc, #28]	; (2000a848 <HAL_PWR_DeInit+0x28>)
2000a82a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000a82e:	6213      	str	r3, [r2, #32]
  __HAL_RCC_PWR_RELEASE_RESET();
2000a830:	4b05      	ldr	r3, [pc, #20]	; (2000a848 <HAL_PWR_DeInit+0x28>)
2000a832:	6a1b      	ldr	r3, [r3, #32]
2000a834:	4a04      	ldr	r2, [pc, #16]	; (2000a848 <HAL_PWR_DeInit+0x28>)
2000a836:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2000a83a:	6213      	str	r3, [r2, #32]
}
2000a83c:	bf00      	nop
2000a83e:	46bd      	mov	sp, r7
2000a840:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a844:	4770      	bx	lr
2000a846:	bf00      	nop
2000a848:	40023800 	.word	0x40023800

2000a84c <HAL_PWR_EnableBkUpAccess>:
  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
2000a84c:	b480      	push	{r7}
2000a84e:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
2000a850:	4b05      	ldr	r3, [pc, #20]	; (2000a868 <HAL_PWR_EnableBkUpAccess+0x1c>)
2000a852:	681b      	ldr	r3, [r3, #0]
2000a854:	4a04      	ldr	r2, [pc, #16]	; (2000a868 <HAL_PWR_EnableBkUpAccess+0x1c>)
2000a856:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000a85a:	6013      	str	r3, [r2, #0]
}
2000a85c:	bf00      	nop
2000a85e:	46bd      	mov	sp, r7
2000a860:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a864:	4770      	bx	lr
2000a866:	bf00      	nop
2000a868:	40007000 	.word	0x40007000

2000a86c <HAL_PWR_DisableBkUpAccess>:
  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */
void HAL_PWR_DisableBkUpAccess(void)
{
2000a86c:	b480      	push	{r7}
2000a86e:	af00      	add	r7, sp, #0
  /* Disable access to RTC and backup registers */
	CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);
2000a870:	4b05      	ldr	r3, [pc, #20]	; (2000a888 <HAL_PWR_DisableBkUpAccess+0x1c>)
2000a872:	681b      	ldr	r3, [r3, #0]
2000a874:	4a04      	ldr	r2, [pc, #16]	; (2000a888 <HAL_PWR_DisableBkUpAccess+0x1c>)
2000a876:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2000a87a:	6013      	str	r3, [r2, #0]
}
2000a87c:	bf00      	nop
2000a87e:	46bd      	mov	sp, r7
2000a880:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a884:	4770      	bx	lr
2000a886:	bf00      	nop
2000a888:	40007000 	.word	0x40007000

2000a88c <HAL_PWR_ConfigPVD>:
  *         more details about the voltage threshold corresponding to each 
  *         detection level.
  * @retval None
  */
void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
{
2000a88c:	b480      	push	{r7}
2000a88e:	b083      	sub	sp, #12
2000a890:	af00      	add	r7, sp, #0
2000a892:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
  
  /* Set PLS[7:5] bits according to PVDLevel value */
  MODIFY_REG(PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
2000a894:	4b2b      	ldr	r3, [pc, #172]	; (2000a944 <HAL_PWR_ConfigPVD+0xb8>)
2000a896:	681b      	ldr	r3, [r3, #0]
2000a898:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
2000a89c:	687b      	ldr	r3, [r7, #4]
2000a89e:	681b      	ldr	r3, [r3, #0]
2000a8a0:	4928      	ldr	r1, [pc, #160]	; (2000a944 <HAL_PWR_ConfigPVD+0xb8>)
2000a8a2:	4313      	orrs	r3, r2
2000a8a4:	600b      	str	r3, [r1, #0]
  
  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
2000a8a6:	4b28      	ldr	r3, [pc, #160]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8a8:	685b      	ldr	r3, [r3, #4]
2000a8aa:	4a27      	ldr	r2, [pc, #156]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8ac:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000a8b0:	6053      	str	r3, [r2, #4]
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
2000a8b2:	4b25      	ldr	r3, [pc, #148]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8b4:	681b      	ldr	r3, [r3, #0]
2000a8b6:	4a24      	ldr	r2, [pc, #144]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8b8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000a8bc:	6013      	str	r3, [r2, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
2000a8be:	4b22      	ldr	r3, [pc, #136]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8c0:	689b      	ldr	r3, [r3, #8]
2000a8c2:	4a21      	ldr	r2, [pc, #132]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8c4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000a8c8:	6093      	str	r3, [r2, #8]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
2000a8ca:	4b1f      	ldr	r3, [pc, #124]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8cc:	68db      	ldr	r3, [r3, #12]
2000a8ce:	4a1e      	ldr	r2, [pc, #120]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8d0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000a8d4:	60d3      	str	r3, [r2, #12]

  /* Configure interrupt mode */
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
2000a8d6:	687b      	ldr	r3, [r7, #4]
2000a8d8:	685b      	ldr	r3, [r3, #4]
2000a8da:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000a8de:	2b00      	cmp	r3, #0
2000a8e0:	d005      	beq.n	2000a8ee <HAL_PWR_ConfigPVD+0x62>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
2000a8e2:	4b19      	ldr	r3, [pc, #100]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8e4:	681b      	ldr	r3, [r3, #0]
2000a8e6:	4a18      	ldr	r2, [pc, #96]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000a8ec:	6013      	str	r3, [r2, #0]
  }
  
  /* Configure event mode */
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
2000a8ee:	687b      	ldr	r3, [r7, #4]
2000a8f0:	685b      	ldr	r3, [r3, #4]
2000a8f2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000a8f6:	2b00      	cmp	r3, #0
2000a8f8:	d005      	beq.n	2000a906 <HAL_PWR_ConfigPVD+0x7a>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
2000a8fa:	4b13      	ldr	r3, [pc, #76]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a8fc:	685b      	ldr	r3, [r3, #4]
2000a8fe:	4a12      	ldr	r2, [pc, #72]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a900:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000a904:	6053      	str	r3, [r2, #4]
  }
  
  /* Configure the edge */
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
2000a906:	687b      	ldr	r3, [r7, #4]
2000a908:	685b      	ldr	r3, [r3, #4]
2000a90a:	f003 0301 	and.w	r3, r3, #1
2000a90e:	2b00      	cmp	r3, #0
2000a910:	d005      	beq.n	2000a91e <HAL_PWR_ConfigPVD+0x92>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
2000a912:	4b0d      	ldr	r3, [pc, #52]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a914:	689b      	ldr	r3, [r3, #8]
2000a916:	4a0c      	ldr	r2, [pc, #48]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a918:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000a91c:	6093      	str	r3, [r2, #8]
  }
  
  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
2000a91e:	687b      	ldr	r3, [r7, #4]
2000a920:	685b      	ldr	r3, [r3, #4]
2000a922:	f003 0302 	and.w	r3, r3, #2
2000a926:	2b00      	cmp	r3, #0
2000a928:	d005      	beq.n	2000a936 <HAL_PWR_ConfigPVD+0xaa>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
2000a92a:	4b07      	ldr	r3, [pc, #28]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a92c:	68db      	ldr	r3, [r3, #12]
2000a92e:	4a06      	ldr	r2, [pc, #24]	; (2000a948 <HAL_PWR_ConfigPVD+0xbc>)
2000a930:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000a934:	60d3      	str	r3, [r2, #12]
  }
}
2000a936:	bf00      	nop
2000a938:	370c      	adds	r7, #12
2000a93a:	46bd      	mov	sp, r7
2000a93c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a940:	4770      	bx	lr
2000a942:	bf00      	nop
2000a944:	40007000 	.word	0x40007000
2000a948:	40013c00 	.word	0x40013c00

2000a94c <HAL_PWR_EnablePVD>:
/**
  * @brief Enables the Power Voltage Detector(PVD).
  * @retval None
  */
void HAL_PWR_EnablePVD(void)
{
2000a94c:	b480      	push	{r7}
2000a94e:	af00      	add	r7, sp, #0
  /* Enable the power voltage detector */
	SET_BIT(PWR->CR1, PWR_CR1_PVDE);
2000a950:	4b05      	ldr	r3, [pc, #20]	; (2000a968 <HAL_PWR_EnablePVD+0x1c>)
2000a952:	681b      	ldr	r3, [r3, #0]
2000a954:	4a04      	ldr	r2, [pc, #16]	; (2000a968 <HAL_PWR_EnablePVD+0x1c>)
2000a956:	f043 0310 	orr.w	r3, r3, #16
2000a95a:	6013      	str	r3, [r2, #0]
}
2000a95c:	bf00      	nop
2000a95e:	46bd      	mov	sp, r7
2000a960:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a964:	4770      	bx	lr
2000a966:	bf00      	nop
2000a968:	40007000 	.word	0x40007000

2000a96c <HAL_PWR_DisablePVD>:
/**
  * @brief Disables the Power Voltage Detector(PVD).
  * @retval None
  */
void HAL_PWR_DisablePVD(void)
{
2000a96c:	b480      	push	{r7}
2000a96e:	af00      	add	r7, sp, #0
  /* Disable the power voltage detector */
	CLEAR_BIT(PWR->CR1, PWR_CR1_PVDE);
2000a970:	4b05      	ldr	r3, [pc, #20]	; (2000a988 <HAL_PWR_DisablePVD+0x1c>)
2000a972:	681b      	ldr	r3, [r3, #0]
2000a974:	4a04      	ldr	r2, [pc, #16]	; (2000a988 <HAL_PWR_DisablePVD+0x1c>)
2000a976:	f023 0310 	bic.w	r3, r3, #16
2000a97a:	6013      	str	r3, [r2, #0]
}
2000a97c:	bf00      	nop
2000a97e:	46bd      	mov	sp, r7
2000a980:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a984:	4770      	bx	lr
2000a986:	bf00      	nop
2000a988:	40007000 	.word	0x40007000

2000a98c <HAL_PWR_EnableWakeUpPin>:
  *           @arg PWR_WAKEUP_PIN6_HIGH or PWR_WAKEUP_PIN6_LOW 
  * @note  PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.               
  * @retval None
  */
void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity)
{
2000a98c:	b480      	push	{r7}
2000a98e:	b083      	sub	sp, #12
2000a990:	af00      	add	r7, sp, #0
2000a992:	6078      	str	r0, [r7, #4]
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity));
  
  /* Enable wake-up pin */
  SET_BIT(PWR->CSR2, (PWR_EWUP_MASK & WakeUpPinPolarity));
2000a994:	4b0c      	ldr	r3, [pc, #48]	; (2000a9c8 <HAL_PWR_EnableWakeUpPin+0x3c>)
2000a996:	68da      	ldr	r2, [r3, #12]
2000a998:	687b      	ldr	r3, [r7, #4]
2000a99a:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
2000a99e:	490a      	ldr	r1, [pc, #40]	; (2000a9c8 <HAL_PWR_EnableWakeUpPin+0x3c>)
2000a9a0:	4313      	orrs	r3, r2
2000a9a2:	60cb      	str	r3, [r1, #12]
	
  /* Specifies the Wake-Up pin polarity for the event detection
    (rising or falling edge) */
  MODIFY_REG(PWR->CR2, (PWR_EWUP_MASK & WakeUpPinPolarity), (WakeUpPinPolarity >> 0x06));
2000a9a4:	4b08      	ldr	r3, [pc, #32]	; (2000a9c8 <HAL_PWR_EnableWakeUpPin+0x3c>)
2000a9a6:	689a      	ldr	r2, [r3, #8]
2000a9a8:	687b      	ldr	r3, [r7, #4]
2000a9aa:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
2000a9ae:	43db      	mvns	r3, r3
2000a9b0:	401a      	ands	r2, r3
2000a9b2:	687b      	ldr	r3, [r7, #4]
2000a9b4:	099b      	lsrs	r3, r3, #6
2000a9b6:	4904      	ldr	r1, [pc, #16]	; (2000a9c8 <HAL_PWR_EnableWakeUpPin+0x3c>)
2000a9b8:	4313      	orrs	r3, r2
2000a9ba:	608b      	str	r3, [r1, #8]
}
2000a9bc:	bf00      	nop
2000a9be:	370c      	adds	r7, #12
2000a9c0:	46bd      	mov	sp, r7
2000a9c2:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a9c6:	4770      	bx	lr
2000a9c8:	40007000 	.word	0x40007000

2000a9cc <HAL_PWR_DisableWakeUpPin>:
  *           @arg PWR_WAKEUP_PIN5
  *           @arg PWR_WAKEUP_PIN6 
  * @retval None
  */
void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
{
2000a9cc:	b480      	push	{r7}
2000a9ce:	b083      	sub	sp, #12
2000a9d0:	af00      	add	r7, sp, #0
2000a9d2:	6078      	str	r0, [r7, #4]
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));

  CLEAR_BIT(PWR->CSR2, WakeUpPinx);
2000a9d4:	4b06      	ldr	r3, [pc, #24]	; (2000a9f0 <HAL_PWR_DisableWakeUpPin+0x24>)
2000a9d6:	68da      	ldr	r2, [r3, #12]
2000a9d8:	687b      	ldr	r3, [r7, #4]
2000a9da:	43db      	mvns	r3, r3
2000a9dc:	4904      	ldr	r1, [pc, #16]	; (2000a9f0 <HAL_PWR_DisableWakeUpPin+0x24>)
2000a9de:	4013      	ands	r3, r2
2000a9e0:	60cb      	str	r3, [r1, #12]
}
2000a9e2:	bf00      	nop
2000a9e4:	370c      	adds	r7, #12
2000a9e6:	46bd      	mov	sp, r7
2000a9e8:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a9ec:	4770      	bx	lr
2000a9ee:	bf00      	nop
2000a9f0:	40007000 	.word	0x40007000

2000a9f4 <HAL_PWR_EnterSLEEPMode>:
  *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
  *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
2000a9f4:	b480      	push	{r7}
2000a9f6:	b083      	sub	sp, #12
2000a9f8:	af00      	add	r7, sp, #0
2000a9fa:	6078      	str	r0, [r7, #4]
2000a9fc:	460b      	mov	r3, r1
2000a9fe:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
2000aa00:	4b0b      	ldr	r3, [pc, #44]	; (2000aa30 <HAL_PWR_EnterSLEEPMode+0x3c>)
2000aa02:	691b      	ldr	r3, [r3, #16]
2000aa04:	4a0a      	ldr	r2, [pc, #40]	; (2000aa30 <HAL_PWR_EnterSLEEPMode+0x3c>)
2000aa06:	f023 0304 	bic.w	r3, r3, #4
2000aa0a:	6113      	str	r3, [r2, #16]
2000aa0c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2000aa10:	f3bf 8f6f 	isb	sy
  /* Ensure that all instructions done before entering SLEEP mode */
  __DSB();
  __ISB();

  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
2000aa14:	78fb      	ldrb	r3, [r7, #3]
2000aa16:	2b01      	cmp	r3, #1
2000aa18:	d101      	bne.n	2000aa1e <HAL_PWR_EnterSLEEPMode+0x2a>
  {   
    /* Request Wait For Interrupt */
    __WFI();
2000aa1a:	bf30      	wfi
    /* Request Wait For Event */
    __SEV();
    __WFE();
    __WFE();
  }
}
2000aa1c:	e002      	b.n	2000aa24 <HAL_PWR_EnterSLEEPMode+0x30>
    __SEV();
2000aa1e:	bf40      	sev
    __WFE();
2000aa20:	bf20      	wfe
    __WFE();
2000aa22:	bf20      	wfe
}
2000aa24:	bf00      	nop
2000aa26:	370c      	adds	r7, #12
2000aa28:	46bd      	mov	sp, r7
2000aa2a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000aa2e:	4770      	bx	lr
2000aa30:	e000ed00 	.word	0xe000ed00

2000aa34 <HAL_PWR_EnterSTOPMode>:
  *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
  *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction
  * @retval None
  */
void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
2000aa34:	b480      	push	{r7}
2000aa36:	b085      	sub	sp, #20
2000aa38:	af00      	add	r7, sp, #0
2000aa3a:	6078      	str	r0, [r7, #4]
2000aa3c:	460b      	mov	r3, r1
2000aa3e:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
2000aa40:	2300      	movs	r3, #0
2000aa42:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Select the regulator state in Stop mode ---------------------------------*/
  tmpreg = PWR->CR1;
2000aa44:	4b15      	ldr	r3, [pc, #84]	; (2000aa9c <HAL_PWR_EnterSTOPMode+0x68>)
2000aa46:	681b      	ldr	r3, [r3, #0]
2000aa48:	60fb      	str	r3, [r7, #12]
  /* Clear PDDS and LPDS bits */
  tmpreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS);
2000aa4a:	68fb      	ldr	r3, [r7, #12]
2000aa4c:	f023 0303 	bic.w	r3, r3, #3
2000aa50:	60fb      	str	r3, [r7, #12]

  /* Set LPDS, MRLVDS and LPLVDS bits according to Regulator value */
  tmpreg |= Regulator;
2000aa52:	68fa      	ldr	r2, [r7, #12]
2000aa54:	687b      	ldr	r3, [r7, #4]
2000aa56:	4313      	orrs	r3, r2
2000aa58:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  PWR->CR1 = tmpreg;
2000aa5a:	4a10      	ldr	r2, [pc, #64]	; (2000aa9c <HAL_PWR_EnterSTOPMode+0x68>)
2000aa5c:	68fb      	ldr	r3, [r7, #12]
2000aa5e:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
2000aa60:	4b0f      	ldr	r3, [pc, #60]	; (2000aaa0 <HAL_PWR_EnterSTOPMode+0x6c>)
2000aa62:	691b      	ldr	r3, [r3, #16]
2000aa64:	4a0e      	ldr	r2, [pc, #56]	; (2000aaa0 <HAL_PWR_EnterSTOPMode+0x6c>)
2000aa66:	f043 0304 	orr.w	r3, r3, #4
2000aa6a:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
2000aa6c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2000aa70:	f3bf 8f6f 	isb	sy
  /* Ensure that all instructions done before entering STOP mode */
  __DSB();
  __ISB();

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
2000aa74:	78fb      	ldrb	r3, [r7, #3]
2000aa76:	2b01      	cmp	r3, #1
2000aa78:	d101      	bne.n	2000aa7e <HAL_PWR_EnterSTOPMode+0x4a>
  {   
    /* Request Wait For Interrupt */
    __WFI();
2000aa7a:	bf30      	wfi
2000aa7c:	e002      	b.n	2000aa84 <HAL_PWR_EnterSTOPMode+0x50>
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
2000aa7e:	bf40      	sev
    __WFE();
2000aa80:	bf20      	wfe
    __WFE();
2000aa82:	bf20      	wfe
  }
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
2000aa84:	4b06      	ldr	r3, [pc, #24]	; (2000aaa0 <HAL_PWR_EnterSTOPMode+0x6c>)
2000aa86:	691b      	ldr	r3, [r3, #16]
2000aa88:	4a05      	ldr	r2, [pc, #20]	; (2000aaa0 <HAL_PWR_EnterSTOPMode+0x6c>)
2000aa8a:	f023 0304 	bic.w	r3, r3, #4
2000aa8e:	6113      	str	r3, [r2, #16]
}
2000aa90:	bf00      	nop
2000aa92:	3714      	adds	r7, #20
2000aa94:	46bd      	mov	sp, r7
2000aa96:	f85d 7b04 	ldr.w	r7, [sp], #4
2000aa9a:	4770      	bx	lr
2000aa9c:	40007000 	.word	0x40007000
2000aaa0:	e000ed00 	.word	0xe000ed00

2000aaa4 <HAL_PWR_EnterSTANDBYMode>:
  *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
  *          - WKUP pins if enabled.       
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
2000aaa4:	b480      	push	{r7}
2000aaa6:	af00      	add	r7, sp, #0
  /* Select Standby mode */
  PWR->CR1 |= PWR_CR1_PDDS;
2000aaa8:	4b08      	ldr	r3, [pc, #32]	; (2000aacc <HAL_PWR_EnterSTANDBYMode+0x28>)
2000aaaa:	681b      	ldr	r3, [r3, #0]
2000aaac:	4a07      	ldr	r2, [pc, #28]	; (2000aacc <HAL_PWR_EnterSTANDBYMode+0x28>)
2000aaae:	f043 0302 	orr.w	r3, r3, #2
2000aab2:	6013      	str	r3, [r2, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
2000aab4:	4b06      	ldr	r3, [pc, #24]	; (2000aad0 <HAL_PWR_EnterSTANDBYMode+0x2c>)
2000aab6:	691b      	ldr	r3, [r3, #16]
2000aab8:	4a05      	ldr	r2, [pc, #20]	; (2000aad0 <HAL_PWR_EnterSTANDBYMode+0x2c>)
2000aaba:	f043 0304 	orr.w	r3, r3, #4
2000aabe:	6113      	str	r3, [r2, #16]
  /* This option is used to ensure that store operations are completed */
#if defined ( __CC_ARM)
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
2000aac0:	bf30      	wfi
}
2000aac2:	bf00      	nop
2000aac4:	46bd      	mov	sp, r7
2000aac6:	f85d 7b04 	ldr.w	r7, [sp], #4
2000aaca:	4770      	bx	lr
2000aacc:	40007000 	.word	0x40007000
2000aad0:	e000ed00 	.word	0xe000ed00

2000aad4 <HAL_PWR_PVD_IRQHandler>:
  * @brief This function handles the PWR PVD interrupt request.
  * @note This API should be called under the PVD_IRQHandler().
  * @retval None
  */
void HAL_PWR_PVD_IRQHandler(void)
{
2000aad4:	b580      	push	{r7, lr}
2000aad6:	af00      	add	r7, sp, #0
  /* Check PWR Exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
2000aad8:	4b06      	ldr	r3, [pc, #24]	; (2000aaf4 <HAL_PWR_PVD_IRQHandler+0x20>)
2000aada:	695b      	ldr	r3, [r3, #20]
2000aadc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000aae0:	2b00      	cmp	r3, #0
2000aae2:	d005      	beq.n	2000aaf0 <HAL_PWR_PVD_IRQHandler+0x1c>
  {
    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback();
2000aae4:	f000 f808 	bl	2000aaf8 <HAL_PWR_PVDCallback>
    
    /* Clear PWR Exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
2000aae8:	4b02      	ldr	r3, [pc, #8]	; (2000aaf4 <HAL_PWR_PVD_IRQHandler+0x20>)
2000aaea:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000aaee:	615a      	str	r2, [r3, #20]
  }
}
2000aaf0:	bf00      	nop
2000aaf2:	bd80      	pop	{r7, pc}
2000aaf4:	40013c00 	.word	0x40013c00

2000aaf8 <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback
  * @retval None
  */
__weak void HAL_PWR_PVDCallback(void)
{
2000aaf8:	b480      	push	{r7}
2000aafa:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback could be implemented in the user file
   */ 
}
2000aafc:	bf00      	nop
2000aafe:	46bd      	mov	sp, r7
2000ab00:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ab04:	4770      	bx	lr
	...

2000ab08 <HAL_PWR_EnableSleepOnExit>:
  *       Setting this bit is useful when the processor is expected to run only on
  *       interruptions handling.         
  * @retval None
  */
void HAL_PWR_EnableSleepOnExit(void)
{
2000ab08:	b480      	push	{r7}
2000ab0a:	af00      	add	r7, sp, #0
  /* Set SLEEPONEXIT bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
2000ab0c:	4b05      	ldr	r3, [pc, #20]	; (2000ab24 <HAL_PWR_EnableSleepOnExit+0x1c>)
2000ab0e:	691b      	ldr	r3, [r3, #16]
2000ab10:	4a04      	ldr	r2, [pc, #16]	; (2000ab24 <HAL_PWR_EnableSleepOnExit+0x1c>)
2000ab12:	f043 0302 	orr.w	r3, r3, #2
2000ab16:	6113      	str	r3, [r2, #16]
}
2000ab18:	bf00      	nop
2000ab1a:	46bd      	mov	sp, r7
2000ab1c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ab20:	4770      	bx	lr
2000ab22:	bf00      	nop
2000ab24:	e000ed00 	.word	0xe000ed00

2000ab28 <HAL_PWR_DisableSleepOnExit>:
  * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
  *       re-enters SLEEP mode when an interruption handling is over.          
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit(void)
{
2000ab28:	b480      	push	{r7}
2000ab2a:	af00      	add	r7, sp, #0
  /* Clear SLEEPONEXIT bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
2000ab2c:	4b05      	ldr	r3, [pc, #20]	; (2000ab44 <HAL_PWR_DisableSleepOnExit+0x1c>)
2000ab2e:	691b      	ldr	r3, [r3, #16]
2000ab30:	4a04      	ldr	r2, [pc, #16]	; (2000ab44 <HAL_PWR_DisableSleepOnExit+0x1c>)
2000ab32:	f023 0302 	bic.w	r3, r3, #2
2000ab36:	6113      	str	r3, [r2, #16]
}
2000ab38:	bf00      	nop
2000ab3a:	46bd      	mov	sp, r7
2000ab3c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ab40:	4770      	bx	lr
2000ab42:	bf00      	nop
2000ab44:	e000ed00 	.word	0xe000ed00

2000ab48 <HAL_PWR_EnableSEVOnPend>:
  * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
  *       WFE to wake up when an interrupt moves from inactive to pended.
  * @retval None
  */
void HAL_PWR_EnableSEVOnPend(void)
{
2000ab48:	b480      	push	{r7}
2000ab4a:	af00      	add	r7, sp, #0
  /* Set SEVONPEND bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
2000ab4c:	4b05      	ldr	r3, [pc, #20]	; (2000ab64 <HAL_PWR_EnableSEVOnPend+0x1c>)
2000ab4e:	691b      	ldr	r3, [r3, #16]
2000ab50:	4a04      	ldr	r2, [pc, #16]	; (2000ab64 <HAL_PWR_EnableSEVOnPend+0x1c>)
2000ab52:	f043 0310 	orr.w	r3, r3, #16
2000ab56:	6113      	str	r3, [r2, #16]
}
2000ab58:	bf00      	nop
2000ab5a:	46bd      	mov	sp, r7
2000ab5c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ab60:	4770      	bx	lr
2000ab62:	bf00      	nop
2000ab64:	e000ed00 	.word	0xe000ed00

2000ab68 <HAL_PWR_DisableSEVOnPend>:
  * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
  *       WFE to wake up when an interrupt moves from inactive to pended.         
  * @retval None
  */
void HAL_PWR_DisableSEVOnPend(void)
{
2000ab68:	b480      	push	{r7}
2000ab6a:	af00      	add	r7, sp, #0
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
2000ab6c:	4b05      	ldr	r3, [pc, #20]	; (2000ab84 <HAL_PWR_DisableSEVOnPend+0x1c>)
2000ab6e:	691b      	ldr	r3, [r3, #16]
2000ab70:	4a04      	ldr	r2, [pc, #16]	; (2000ab84 <HAL_PWR_DisableSEVOnPend+0x1c>)
2000ab72:	f023 0310 	bic.w	r3, r3, #16
2000ab76:	6113      	str	r3, [r2, #16]
}
2000ab78:	bf00      	nop
2000ab7a:	46bd      	mov	sp, r7
2000ab7c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ab80:	4770      	bx	lr
2000ab82:	bf00      	nop
2000ab84:	e000ed00 	.word	0xe000ed00

2000ab88 <HAL_PWREx_EnableBkUpReg>:
/**
  * @brief Enables the Backup Regulator.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
{
2000ab88:	b580      	push	{r7, lr}
2000ab8a:	b082      	sub	sp, #8
2000ab8c:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
2000ab8e:	2300      	movs	r3, #0
2000ab90:	607b      	str	r3, [r7, #4]

  /* Enable Backup regulator */
  PWR->CSR1 |= PWR_CSR1_BRE;
2000ab92:	4b12      	ldr	r3, [pc, #72]	; (2000abdc <HAL_PWREx_EnableBkUpReg+0x54>)
2000ab94:	685b      	ldr	r3, [r3, #4]
2000ab96:	4a11      	ldr	r2, [pc, #68]	; (2000abdc <HAL_PWREx_EnableBkUpReg+0x54>)
2000ab98:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2000ab9c:	6053      	str	r3, [r2, #4]
    
  /* Workaround for the following hardware bug: */
  /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
  PWR->CSR1 |= PWR_CSR1_EIWUP;
2000ab9e:	4b0f      	ldr	r3, [pc, #60]	; (2000abdc <HAL_PWREx_EnableBkUpReg+0x54>)
2000aba0:	685b      	ldr	r3, [r3, #4]
2000aba2:	4a0e      	ldr	r2, [pc, #56]	; (2000abdc <HAL_PWREx_EnableBkUpReg+0x54>)
2000aba4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000aba8:	6053      	str	r3, [r2, #4]

  /* Get tick */
  tickstart = HAL_GetTick();
2000abaa:	f7f7 f8e9 	bl	20001d80 <HAL_GetTick>
2000abae:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is set */  
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
2000abb0:	e009      	b.n	2000abc6 <HAL_PWREx_EnableBkUpReg+0x3e>
  {
    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
2000abb2:	f7f7 f8e5 	bl	20001d80 <HAL_GetTick>
2000abb6:	4602      	mov	r2, r0
2000abb8:	687b      	ldr	r3, [r7, #4]
2000abba:	1ad3      	subs	r3, r2, r3
2000abbc:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000abc0:	d901      	bls.n	2000abc6 <HAL_PWREx_EnableBkUpReg+0x3e>
    {
      return HAL_TIMEOUT;
2000abc2:	2303      	movs	r3, #3
2000abc4:	e006      	b.n	2000abd4 <HAL_PWREx_EnableBkUpReg+0x4c>
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
2000abc6:	4b05      	ldr	r3, [pc, #20]	; (2000abdc <HAL_PWREx_EnableBkUpReg+0x54>)
2000abc8:	685b      	ldr	r3, [r3, #4]
2000abca:	f003 0308 	and.w	r3, r3, #8
2000abce:	2b08      	cmp	r3, #8
2000abd0:	d1ef      	bne.n	2000abb2 <HAL_PWREx_EnableBkUpReg+0x2a>
    } 
  }
  return HAL_OK;
2000abd2:	2300      	movs	r3, #0
}
2000abd4:	4618      	mov	r0, r3
2000abd6:	3708      	adds	r7, #8
2000abd8:	46bd      	mov	sp, r7
2000abda:	bd80      	pop	{r7, pc}
2000abdc:	40007000 	.word	0x40007000

2000abe0 <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disables the Backup Regulator.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
{
2000abe0:	b580      	push	{r7, lr}
2000abe2:	b082      	sub	sp, #8
2000abe4:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
2000abe6:	2300      	movs	r3, #0
2000abe8:	607b      	str	r3, [r7, #4]
  
  /* Disable Backup regulator */
  PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
2000abea:	4b12      	ldr	r3, [pc, #72]	; (2000ac34 <HAL_PWREx_DisableBkUpReg+0x54>)
2000abec:	685b      	ldr	r3, [r3, #4]
2000abee:	4a11      	ldr	r2, [pc, #68]	; (2000ac34 <HAL_PWREx_DisableBkUpReg+0x54>)
2000abf0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2000abf4:	6053      	str	r3, [r2, #4]
  
  /* Workaround for the following hardware bug: */
  /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
  PWR->CSR1 |= PWR_CSR1_EIWUP;
2000abf6:	4b0f      	ldr	r3, [pc, #60]	; (2000ac34 <HAL_PWREx_DisableBkUpReg+0x54>)
2000abf8:	685b      	ldr	r3, [r3, #4]
2000abfa:	4a0e      	ldr	r2, [pc, #56]	; (2000ac34 <HAL_PWREx_DisableBkUpReg+0x54>)
2000abfc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000ac00:	6053      	str	r3, [r2, #4]

  /* Get tick */
  tickstart = HAL_GetTick();
2000ac02:	f7f7 f8bd 	bl	20001d80 <HAL_GetTick>
2000ac06:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is set */  
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
2000ac08:	e009      	b.n	2000ac1e <HAL_PWREx_DisableBkUpReg+0x3e>
  {
    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
2000ac0a:	f7f7 f8b9 	bl	20001d80 <HAL_GetTick>
2000ac0e:	4602      	mov	r2, r0
2000ac10:	687b      	ldr	r3, [r7, #4]
2000ac12:	1ad3      	subs	r3, r2, r3
2000ac14:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000ac18:	d901      	bls.n	2000ac1e <HAL_PWREx_DisableBkUpReg+0x3e>
    {
      return HAL_TIMEOUT;
2000ac1a:	2303      	movs	r3, #3
2000ac1c:	e006      	b.n	2000ac2c <HAL_PWREx_DisableBkUpReg+0x4c>
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
2000ac1e:	4b05      	ldr	r3, [pc, #20]	; (2000ac34 <HAL_PWREx_DisableBkUpReg+0x54>)
2000ac20:	685b      	ldr	r3, [r3, #4]
2000ac22:	f003 0308 	and.w	r3, r3, #8
2000ac26:	2b08      	cmp	r3, #8
2000ac28:	d0ef      	beq.n	2000ac0a <HAL_PWREx_DisableBkUpReg+0x2a>
    } 
  }
  return HAL_OK;
2000ac2a:	2300      	movs	r3, #0
}
2000ac2c:	4618      	mov	r0, r3
2000ac2e:	3708      	adds	r7, #8
2000ac30:	46bd      	mov	sp, r7
2000ac32:	bd80      	pop	{r7, pc}
2000ac34:	40007000 	.word	0x40007000

2000ac38 <HAL_PWREx_EnableFlashPowerDown>:
/**
  * @brief Enables the Flash Power Down in Stop mode.
  * @retval None
  */
void HAL_PWREx_EnableFlashPowerDown(void)
{
2000ac38:	b480      	push	{r7}
2000ac3a:	af00      	add	r7, sp, #0
  /* Enable the Flash Power Down */
  PWR->CR1 |= PWR_CR1_FPDS;
2000ac3c:	4b05      	ldr	r3, [pc, #20]	; (2000ac54 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
2000ac3e:	681b      	ldr	r3, [r3, #0]
2000ac40:	4a04      	ldr	r2, [pc, #16]	; (2000ac54 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
2000ac42:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2000ac46:	6013      	str	r3, [r2, #0]
}
2000ac48:	bf00      	nop
2000ac4a:	46bd      	mov	sp, r7
2000ac4c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ac50:	4770      	bx	lr
2000ac52:	bf00      	nop
2000ac54:	40007000 	.word	0x40007000

2000ac58 <HAL_PWREx_DisableFlashPowerDown>:
/**
  * @brief Disables the Flash Power Down in Stop mode.
  * @retval None
  */
void HAL_PWREx_DisableFlashPowerDown(void)
{
2000ac58:	b480      	push	{r7}
2000ac5a:	af00      	add	r7, sp, #0
  /* Disable the Flash Power Down */
  PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
2000ac5c:	4b05      	ldr	r3, [pc, #20]	; (2000ac74 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
2000ac5e:	681b      	ldr	r3, [r3, #0]
2000ac60:	4a04      	ldr	r2, [pc, #16]	; (2000ac74 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
2000ac62:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2000ac66:	6013      	str	r3, [r2, #0]
}
2000ac68:	bf00      	nop
2000ac6a:	46bd      	mov	sp, r7
2000ac6c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ac70:	4770      	bx	lr
2000ac72:	bf00      	nop
2000ac74:	40007000 	.word	0x40007000

2000ac78 <HAL_PWREx_EnableMainRegulatorLowVoltage>:
/**
  * @brief Enables Main Regulator low voltage mode.
  * @retval None
  */
void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
{
2000ac78:	b480      	push	{r7}
2000ac7a:	af00      	add	r7, sp, #0
  /* Enable Main regulator low voltage */
  PWR->CR1 |= PWR_CR1_MRUDS;
2000ac7c:	4b05      	ldr	r3, [pc, #20]	; (2000ac94 <HAL_PWREx_EnableMainRegulatorLowVoltage+0x1c>)
2000ac7e:	681b      	ldr	r3, [r3, #0]
2000ac80:	4a04      	ldr	r2, [pc, #16]	; (2000ac94 <HAL_PWREx_EnableMainRegulatorLowVoltage+0x1c>)
2000ac82:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
2000ac86:	6013      	str	r3, [r2, #0]
}
2000ac88:	bf00      	nop
2000ac8a:	46bd      	mov	sp, r7
2000ac8c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ac90:	4770      	bx	lr
2000ac92:	bf00      	nop
2000ac94:	40007000 	.word	0x40007000

2000ac98 <HAL_PWREx_DisableMainRegulatorLowVoltage>:
/**
  * @brief Disables Main Regulator low voltage mode.
  * @retval None
  */
void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
{  
2000ac98:	b480      	push	{r7}
2000ac9a:	af00      	add	r7, sp, #0
  /* Disable Main regulator low voltage */
  PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
2000ac9c:	4b05      	ldr	r3, [pc, #20]	; (2000acb4 <HAL_PWREx_DisableMainRegulatorLowVoltage+0x1c>)
2000ac9e:	681b      	ldr	r3, [r3, #0]
2000aca0:	4a04      	ldr	r2, [pc, #16]	; (2000acb4 <HAL_PWREx_DisableMainRegulatorLowVoltage+0x1c>)
2000aca2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
2000aca6:	6013      	str	r3, [r2, #0]
}
2000aca8:	bf00      	nop
2000acaa:	46bd      	mov	sp, r7
2000acac:	f85d 7b04 	ldr.w	r7, [sp], #4
2000acb0:	4770      	bx	lr
2000acb2:	bf00      	nop
2000acb4:	40007000 	.word	0x40007000

2000acb8 <HAL_PWREx_EnableLowRegulatorLowVoltage>:
/**
  * @brief Enables Low Power Regulator low voltage mode.
  * @retval None
  */
void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
{
2000acb8:	b480      	push	{r7}
2000acba:	af00      	add	r7, sp, #0
  /* Enable low power regulator */
  PWR->CR1 |= PWR_CR1_LPUDS;
2000acbc:	4b05      	ldr	r3, [pc, #20]	; (2000acd4 <HAL_PWREx_EnableLowRegulatorLowVoltage+0x1c>)
2000acbe:	681b      	ldr	r3, [r3, #0]
2000acc0:	4a04      	ldr	r2, [pc, #16]	; (2000acd4 <HAL_PWREx_EnableLowRegulatorLowVoltage+0x1c>)
2000acc2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
2000acc6:	6013      	str	r3, [r2, #0]
}
2000acc8:	bf00      	nop
2000acca:	46bd      	mov	sp, r7
2000accc:	f85d 7b04 	ldr.w	r7, [sp], #4
2000acd0:	4770      	bx	lr
2000acd2:	bf00      	nop
2000acd4:	40007000 	.word	0x40007000

2000acd8 <HAL_PWREx_DisableLowRegulatorLowVoltage>:
/**
  * @brief Disables Low Power Regulator low voltage mode.
  * @retval None
  */
void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
{
2000acd8:	b480      	push	{r7}
2000acda:	af00      	add	r7, sp, #0
  /* Disable low power regulator */
  PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
2000acdc:	4b05      	ldr	r3, [pc, #20]	; (2000acf4 <HAL_PWREx_DisableLowRegulatorLowVoltage+0x1c>)
2000acde:	681b      	ldr	r3, [r3, #0]
2000ace0:	4a04      	ldr	r2, [pc, #16]	; (2000acf4 <HAL_PWREx_DisableLowRegulatorLowVoltage+0x1c>)
2000ace2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
2000ace6:	6013      	str	r3, [r2, #0]
}
2000ace8:	bf00      	nop
2000acea:	46bd      	mov	sp, r7
2000acec:	f85d 7b04 	ldr.w	r7, [sp], #4
2000acf0:	4770      	bx	lr
2000acf2:	bf00      	nop
2000acf4:	40007000 	.word	0x40007000

2000acf8 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
2000acf8:	b580      	push	{r7, lr}
2000acfa:	b082      	sub	sp, #8
2000acfc:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
2000acfe:	2300      	movs	r3, #0
2000ad00:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
2000ad02:	4b23      	ldr	r3, [pc, #140]	; (2000ad90 <HAL_PWREx_EnableOverDrive+0x98>)
2000ad04:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000ad06:	4a22      	ldr	r2, [pc, #136]	; (2000ad90 <HAL_PWREx_EnableOverDrive+0x98>)
2000ad08:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000ad0c:	6413      	str	r3, [r2, #64]	; 0x40
2000ad0e:	4b20      	ldr	r3, [pc, #128]	; (2000ad90 <HAL_PWREx_EnableOverDrive+0x98>)
2000ad10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000ad12:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000ad16:	603b      	str	r3, [r7, #0]
2000ad18:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
2000ad1a:	4b1e      	ldr	r3, [pc, #120]	; (2000ad94 <HAL_PWREx_EnableOverDrive+0x9c>)
2000ad1c:	681b      	ldr	r3, [r3, #0]
2000ad1e:	4a1d      	ldr	r2, [pc, #116]	; (2000ad94 <HAL_PWREx_EnableOverDrive+0x9c>)
2000ad20:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000ad24:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
2000ad26:	f7f7 f82b 	bl	20001d80 <HAL_GetTick>
2000ad2a:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
2000ad2c:	e009      	b.n	2000ad42 <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
2000ad2e:	f7f7 f827 	bl	20001d80 <HAL_GetTick>
2000ad32:	4602      	mov	r2, r0
2000ad34:	687b      	ldr	r3, [r7, #4]
2000ad36:	1ad3      	subs	r3, r2, r3
2000ad38:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000ad3c:	d901      	bls.n	2000ad42 <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
2000ad3e:	2303      	movs	r3, #3
2000ad40:	e022      	b.n	2000ad88 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
2000ad42:	4b14      	ldr	r3, [pc, #80]	; (2000ad94 <HAL_PWREx_EnableOverDrive+0x9c>)
2000ad44:	685b      	ldr	r3, [r3, #4]
2000ad46:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000ad4a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000ad4e:	d1ee      	bne.n	2000ad2e <HAL_PWREx_EnableOverDrive+0x36>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
2000ad50:	4b10      	ldr	r3, [pc, #64]	; (2000ad94 <HAL_PWREx_EnableOverDrive+0x9c>)
2000ad52:	681b      	ldr	r3, [r3, #0]
2000ad54:	4a0f      	ldr	r2, [pc, #60]	; (2000ad94 <HAL_PWREx_EnableOverDrive+0x9c>)
2000ad56:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2000ad5a:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
2000ad5c:	f7f7 f810 	bl	20001d80 <HAL_GetTick>
2000ad60:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
2000ad62:	e009      	b.n	2000ad78 <HAL_PWREx_EnableOverDrive+0x80>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
2000ad64:	f7f7 f80c 	bl	20001d80 <HAL_GetTick>
2000ad68:	4602      	mov	r2, r0
2000ad6a:	687b      	ldr	r3, [r7, #4]
2000ad6c:	1ad3      	subs	r3, r2, r3
2000ad6e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000ad72:	d901      	bls.n	2000ad78 <HAL_PWREx_EnableOverDrive+0x80>
    {
      return HAL_TIMEOUT;
2000ad74:	2303      	movs	r3, #3
2000ad76:	e007      	b.n	2000ad88 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
2000ad78:	4b06      	ldr	r3, [pc, #24]	; (2000ad94 <HAL_PWREx_EnableOverDrive+0x9c>)
2000ad7a:	685b      	ldr	r3, [r3, #4]
2000ad7c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000ad80:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2000ad84:	d1ee      	bne.n	2000ad64 <HAL_PWREx_EnableOverDrive+0x6c>
    }
  } 
  return HAL_OK;
2000ad86:	2300      	movs	r3, #0
}
2000ad88:	4618      	mov	r0, r3
2000ad8a:	3708      	adds	r7, #8
2000ad8c:	46bd      	mov	sp, r7
2000ad8e:	bd80      	pop	{r7, pc}
2000ad90:	40023800 	.word	0x40023800
2000ad94:	40007000 	.word	0x40007000

2000ad98 <HAL_PWREx_DisableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
{
2000ad98:	b580      	push	{r7, lr}
2000ad9a:	b082      	sub	sp, #8
2000ad9c:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
2000ad9e:	2300      	movs	r3, #0
2000ada0:	607b      	str	r3, [r7, #4]
  
  __HAL_RCC_PWR_CLK_ENABLE();
2000ada2:	4b23      	ldr	r3, [pc, #140]	; (2000ae30 <HAL_PWREx_DisableOverDrive+0x98>)
2000ada4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000ada6:	4a22      	ldr	r2, [pc, #136]	; (2000ae30 <HAL_PWREx_DisableOverDrive+0x98>)
2000ada8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000adac:	6413      	str	r3, [r2, #64]	; 0x40
2000adae:	4b20      	ldr	r3, [pc, #128]	; (2000ae30 <HAL_PWREx_DisableOverDrive+0x98>)
2000adb0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000adb2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000adb6:	603b      	str	r3, [r7, #0]
2000adb8:	683b      	ldr	r3, [r7, #0]
    
  /* Disable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
2000adba:	4b1e      	ldr	r3, [pc, #120]	; (2000ae34 <HAL_PWREx_DisableOverDrive+0x9c>)
2000adbc:	681b      	ldr	r3, [r3, #0]
2000adbe:	4a1d      	ldr	r2, [pc, #116]	; (2000ae34 <HAL_PWREx_DisableOverDrive+0x9c>)
2000adc0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
2000adc4:	6013      	str	r3, [r2, #0]
  
  /* Get tick */
  tickstart = HAL_GetTick();
2000adc6:	f7f6 ffdb 	bl	20001d80 <HAL_GetTick>
2000adca:	6078      	str	r0, [r7, #4]
 
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
2000adcc:	e009      	b.n	2000ade2 <HAL_PWREx_DisableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
2000adce:	f7f6 ffd7 	bl	20001d80 <HAL_GetTick>
2000add2:	4602      	mov	r2, r0
2000add4:	687b      	ldr	r3, [r7, #4]
2000add6:	1ad3      	subs	r3, r2, r3
2000add8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000addc:	d901      	bls.n	2000ade2 <HAL_PWREx_DisableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
2000adde:	2303      	movs	r3, #3
2000ade0:	e022      	b.n	2000ae28 <HAL_PWREx_DisableOverDrive+0x90>
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
2000ade2:	4b14      	ldr	r3, [pc, #80]	; (2000ae34 <HAL_PWREx_DisableOverDrive+0x9c>)
2000ade4:	685b      	ldr	r3, [r3, #4]
2000ade6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000adea:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2000adee:	d0ee      	beq.n	2000adce <HAL_PWREx_DisableOverDrive+0x36>
    }
  } 
  
  /* Disable the Over-drive */
  __HAL_PWR_OVERDRIVE_DISABLE();
2000adf0:	4b10      	ldr	r3, [pc, #64]	; (2000ae34 <HAL_PWREx_DisableOverDrive+0x9c>)
2000adf2:	681b      	ldr	r3, [r3, #0]
2000adf4:	4a0f      	ldr	r2, [pc, #60]	; (2000ae34 <HAL_PWREx_DisableOverDrive+0x9c>)
2000adf6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000adfa:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
2000adfc:	f7f6 ffc0 	bl	20001d80 <HAL_GetTick>
2000ae00:	6078      	str	r0, [r7, #4]

  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
2000ae02:	e009      	b.n	2000ae18 <HAL_PWREx_DisableOverDrive+0x80>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
2000ae04:	f7f6 ffbc 	bl	20001d80 <HAL_GetTick>
2000ae08:	4602      	mov	r2, r0
2000ae0a:	687b      	ldr	r3, [r7, #4]
2000ae0c:	1ad3      	subs	r3, r2, r3
2000ae0e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000ae12:	d901      	bls.n	2000ae18 <HAL_PWREx_DisableOverDrive+0x80>
    {
      return HAL_TIMEOUT;
2000ae14:	2303      	movs	r3, #3
2000ae16:	e007      	b.n	2000ae28 <HAL_PWREx_DisableOverDrive+0x90>
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
2000ae18:	4b06      	ldr	r3, [pc, #24]	; (2000ae34 <HAL_PWREx_DisableOverDrive+0x9c>)
2000ae1a:	685b      	ldr	r3, [r3, #4]
2000ae1c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000ae20:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000ae24:	d0ee      	beq.n	2000ae04 <HAL_PWREx_DisableOverDrive+0x6c>
    }
  }
  
  return HAL_OK;
2000ae26:	2300      	movs	r3, #0
}
2000ae28:	4618      	mov	r0, r3
2000ae2a:	3708      	adds	r7, #8
2000ae2c:	46bd      	mov	sp, r7
2000ae2e:	bd80      	pop	{r7, pc}
2000ae30:	40023800 	.word	0x40023800
2000ae34:	40007000 	.word	0x40007000

2000ae38 <HAL_PWREx_EnterUnderDriveSTOPMode>:
  *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
  *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
  * @retval None
  */
HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
2000ae38:	b580      	push	{r7, lr}
2000ae3a:	b086      	sub	sp, #24
2000ae3c:	af00      	add	r7, sp, #0
2000ae3e:	6078      	str	r0, [r7, #4]
2000ae40:	460b      	mov	r3, r1
2000ae42:	70fb      	strb	r3, [r7, #3]
  uint32_t tempreg = 0;
2000ae44:	2300      	movs	r3, #0
2000ae46:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = 0;
2000ae48:	2300      	movs	r3, #0
2000ae4a:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
  
  /* Enable Power ctrl clock */
  __HAL_RCC_PWR_CLK_ENABLE();
2000ae4c:	4b28      	ldr	r3, [pc, #160]	; (2000aef0 <HAL_PWREx_EnterUnderDriveSTOPMode+0xb8>)
2000ae4e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000ae50:	4a27      	ldr	r2, [pc, #156]	; (2000aef0 <HAL_PWREx_EnterUnderDriveSTOPMode+0xb8>)
2000ae52:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000ae56:	6413      	str	r3, [r2, #64]	; 0x40
2000ae58:	4b25      	ldr	r3, [pc, #148]	; (2000aef0 <HAL_PWREx_EnterUnderDriveSTOPMode+0xb8>)
2000ae5a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000ae5c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000ae60:	60fb      	str	r3, [r7, #12]
2000ae62:	68fb      	ldr	r3, [r7, #12]
  /* Enable the Under-drive Mode ---------------------------------------------*/
  /* Clear Under-drive flag */
  __HAL_PWR_CLEAR_ODRUDR_FLAG();
2000ae64:	4b23      	ldr	r3, [pc, #140]	; (2000aef4 <HAL_PWREx_EnterUnderDriveSTOPMode+0xbc>)
2000ae66:	685b      	ldr	r3, [r3, #4]
2000ae68:	4a22      	ldr	r2, [pc, #136]	; (2000aef4 <HAL_PWREx_EnterUnderDriveSTOPMode+0xbc>)
2000ae6a:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
2000ae6e:	6053      	str	r3, [r2, #4]
  
  /* Enable the Under-drive */ 
  __HAL_PWR_UNDERDRIVE_ENABLE();
2000ae70:	4b20      	ldr	r3, [pc, #128]	; (2000aef4 <HAL_PWREx_EnterUnderDriveSTOPMode+0xbc>)
2000ae72:	681b      	ldr	r3, [r3, #0]
2000ae74:	4a1f      	ldr	r2, [pc, #124]	; (2000aef4 <HAL_PWREx_EnterUnderDriveSTOPMode+0xbc>)
2000ae76:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
2000ae7a:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
2000ae7c:	f7f6 ff80 	bl	20001d80 <HAL_GetTick>
2000ae80:	6138      	str	r0, [r7, #16]

  /* Wait for UnderDrive mode is ready */
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
2000ae82:	e009      	b.n	2000ae98 <HAL_PWREx_EnterUnderDriveSTOPMode+0x60>
  {
    if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
2000ae84:	f7f6 ff7c 	bl	20001d80 <HAL_GetTick>
2000ae88:	4602      	mov	r2, r0
2000ae8a:	693b      	ldr	r3, [r7, #16]
2000ae8c:	1ad3      	subs	r3, r2, r3
2000ae8e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000ae92:	d901      	bls.n	2000ae98 <HAL_PWREx_EnterUnderDriveSTOPMode+0x60>
    {
      return HAL_TIMEOUT;
2000ae94:	2303      	movs	r3, #3
2000ae96:	e027      	b.n	2000aee8 <HAL_PWREx_EnterUnderDriveSTOPMode+0xb0>
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
2000ae98:	4b16      	ldr	r3, [pc, #88]	; (2000aef4 <HAL_PWREx_EnterUnderDriveSTOPMode+0xbc>)
2000ae9a:	685b      	ldr	r3, [r3, #4]
2000ae9c:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
2000aea0:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
2000aea4:	d0ee      	beq.n	2000ae84 <HAL_PWREx_EnterUnderDriveSTOPMode+0x4c>
    }
  }
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tempreg = PWR->CR1;
2000aea6:	4b13      	ldr	r3, [pc, #76]	; (2000aef4 <HAL_PWREx_EnterUnderDriveSTOPMode+0xbc>)
2000aea8:	681b      	ldr	r3, [r3, #0]
2000aeaa:	617b      	str	r3, [r7, #20]
  /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
  tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
2000aeac:	697a      	ldr	r2, [r7, #20]
2000aeae:	4b12      	ldr	r3, [pc, #72]	; (2000aef8 <HAL_PWREx_EnterUnderDriveSTOPMode+0xc0>)
2000aeb0:	4013      	ands	r3, r2
2000aeb2:	617b      	str	r3, [r7, #20]
  
  /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
  tempreg |= Regulator;
2000aeb4:	697a      	ldr	r2, [r7, #20]
2000aeb6:	687b      	ldr	r3, [r7, #4]
2000aeb8:	4313      	orrs	r3, r2
2000aeba:	617b      	str	r3, [r7, #20]
  
  /* Store the new value */
  PWR->CR1 = tempreg;
2000aebc:	4a0d      	ldr	r2, [pc, #52]	; (2000aef4 <HAL_PWREx_EnterUnderDriveSTOPMode+0xbc>)
2000aebe:	697b      	ldr	r3, [r7, #20]
2000aec0:	6013      	str	r3, [r2, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
2000aec2:	4b0e      	ldr	r3, [pc, #56]	; (2000aefc <HAL_PWREx_EnterUnderDriveSTOPMode+0xc4>)
2000aec4:	691b      	ldr	r3, [r3, #16]
2000aec6:	4a0d      	ldr	r2, [pc, #52]	; (2000aefc <HAL_PWREx_EnterUnderDriveSTOPMode+0xc4>)
2000aec8:	f043 0304 	orr.w	r3, r3, #4
2000aecc:	6113      	str	r3, [r2, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_SLEEPENTRY_WFI)
2000aece:	78fb      	ldrb	r3, [r7, #3]
2000aed0:	2b01      	cmp	r3, #1
2000aed2:	d101      	bne.n	2000aed8 <HAL_PWREx_EnterUnderDriveSTOPMode+0xa0>
  {   
    /* Request Wait For Interrupt */
    __WFI();
2000aed4:	bf30      	wfi
2000aed6:	e000      	b.n	2000aeda <HAL_PWREx_EnterUnderDriveSTOPMode+0xa2>
  }
  else
  {
    /* Request Wait For Event */
    __WFE();
2000aed8:	bf20      	wfe
  }
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
2000aeda:	4b08      	ldr	r3, [pc, #32]	; (2000aefc <HAL_PWREx_EnterUnderDriveSTOPMode+0xc4>)
2000aedc:	691b      	ldr	r3, [r3, #16]
2000aede:	4a07      	ldr	r2, [pc, #28]	; (2000aefc <HAL_PWREx_EnterUnderDriveSTOPMode+0xc4>)
2000aee0:	f023 0304 	bic.w	r3, r3, #4
2000aee4:	6113      	str	r3, [r2, #16]

  return HAL_OK;  
2000aee6:	2300      	movs	r3, #0
}
2000aee8:	4618      	mov	r0, r3
2000aeea:	3718      	adds	r7, #24
2000aeec:	46bd      	mov	sp, r7
2000aeee:	bd80      	pop	{r7, pc}
2000aef0:	40023800 	.word	0x40023800
2000aef4:	40007000 	.word	0x40007000
2000aef8:	fffff3fc 	.word	0xfffff3fc
2000aefc:	e000ed00 	.word	0xe000ed00

2000af00 <HAL_PWREx_GetVoltageRange>:
  * @brief Returns Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or 
  *            PWR_REGULATOR_VOLTAGE_SCALE3)PWR_REGULATOR_VOLTAGE_SCALE1
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
2000af00:	b480      	push	{r7}
2000af02:	af00      	add	r7, sp, #0
  return  (PWR->CR1 & PWR_CR1_VOS);
2000af04:	4b04      	ldr	r3, [pc, #16]	; (2000af18 <HAL_PWREx_GetVoltageRange+0x18>)
2000af06:	681b      	ldr	r3, [r3, #0]
2000af08:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
2000af0c:	4618      	mov	r0, r3
2000af0e:	46bd      	mov	sp, r7
2000af10:	f85d 7b04 	ldr.w	r7, [sp], #4
2000af14:	4770      	bx	lr
2000af16:	bf00      	nop
2000af18:	40007000 	.word	0x40007000

2000af1c <HAL_PWREx_ControlVoltageScaling>:
  * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.
  * @note The new voltage scale is active only when the PLL is ON.  
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
2000af1c:	b580      	push	{r7, lr}
2000af1e:	b086      	sub	sp, #24
2000af20:	af00      	add	r7, sp, #0
2000af22:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
2000af24:	2300      	movs	r3, #0
2000af26:	617b      	str	r3, [r7, #20]

  assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));

  /* Enable Power ctrl clock */
  __HAL_RCC_PWR_CLK_ENABLE();
2000af28:	4b37      	ldr	r3, [pc, #220]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af2a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000af2c:	4a36      	ldr	r2, [pc, #216]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af2e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000af32:	6413      	str	r3, [r2, #64]	; 0x40
2000af34:	4b34      	ldr	r3, [pc, #208]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af36:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000af38:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000af3c:	613b      	str	r3, [r7, #16]
2000af3e:	693b      	ldr	r3, [r7, #16]

  /* Check if the PLL is used as system clock or not */
  if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
2000af40:	4b31      	ldr	r3, [pc, #196]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af42:	689b      	ldr	r3, [r3, #8]
2000af44:	f003 030c 	and.w	r3, r3, #12
2000af48:	2b08      	cmp	r3, #8
2000af4a:	d055      	beq.n	2000aff8 <HAL_PWREx_ControlVoltageScaling+0xdc>
  {
    /* Disable the main PLL */
    __HAL_RCC_PLL_DISABLE();
2000af4c:	4b2e      	ldr	r3, [pc, #184]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af4e:	681b      	ldr	r3, [r3, #0]
2000af50:	4a2d      	ldr	r2, [pc, #180]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af52:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2000af56:	6013      	str	r3, [r2, #0]
    
    /* Get Start Tick */
    tickstart = HAL_GetTick();    
2000af58:	f7f6 ff12 	bl	20001d80 <HAL_GetTick>
2000af5c:	6178      	str	r0, [r7, #20]
    /* Wait till PLL is disabled */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
2000af5e:	e008      	b.n	2000af72 <HAL_PWREx_ControlVoltageScaling+0x56>
    {
      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2000af60:	f7f6 ff0e 	bl	20001d80 <HAL_GetTick>
2000af64:	4602      	mov	r2, r0
2000af66:	697b      	ldr	r3, [r7, #20]
2000af68:	1ad3      	subs	r3, r2, r3
2000af6a:	2b02      	cmp	r3, #2
2000af6c:	d901      	bls.n	2000af72 <HAL_PWREx_ControlVoltageScaling+0x56>
      {
        return HAL_TIMEOUT;
2000af6e:	2303      	movs	r3, #3
2000af70:	e045      	b.n	2000affe <HAL_PWREx_ControlVoltageScaling+0xe2>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
2000af72:	4b25      	ldr	r3, [pc, #148]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af74:	681b      	ldr	r3, [r3, #0]
2000af76:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000af7a:	2b00      	cmp	r3, #0
2000af7c:	d1f0      	bne.n	2000af60 <HAL_PWREx_ControlVoltageScaling+0x44>
      }
    }
    
    /* Set Range */
    __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
2000af7e:	4b23      	ldr	r3, [pc, #140]	; (2000b00c <HAL_PWREx_ControlVoltageScaling+0xf0>)
2000af80:	681b      	ldr	r3, [r3, #0]
2000af82:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
2000af86:	4921      	ldr	r1, [pc, #132]	; (2000b00c <HAL_PWREx_ControlVoltageScaling+0xf0>)
2000af88:	687b      	ldr	r3, [r7, #4]
2000af8a:	4313      	orrs	r3, r2
2000af8c:	600b      	str	r3, [r1, #0]
2000af8e:	4b1f      	ldr	r3, [pc, #124]	; (2000b00c <HAL_PWREx_ControlVoltageScaling+0xf0>)
2000af90:	681b      	ldr	r3, [r3, #0]
2000af92:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
2000af96:	60fb      	str	r3, [r7, #12]
2000af98:	68fb      	ldr	r3, [r7, #12]
    
    /* Enable the main PLL */
    __HAL_RCC_PLL_ENABLE();
2000af9a:	4b1b      	ldr	r3, [pc, #108]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000af9c:	681b      	ldr	r3, [r3, #0]
2000af9e:	4a1a      	ldr	r2, [pc, #104]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000afa0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
2000afa4:	6013      	str	r3, [r2, #0]
    
    /* Get Start Tick */
    tickstart = HAL_GetTick();
2000afa6:	f7f6 feeb 	bl	20001d80 <HAL_GetTick>
2000afaa:	6178      	str	r0, [r7, #20]
    /* Wait till PLL is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
2000afac:	e008      	b.n	2000afc0 <HAL_PWREx_ControlVoltageScaling+0xa4>
    {
      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2000afae:	f7f6 fee7 	bl	20001d80 <HAL_GetTick>
2000afb2:	4602      	mov	r2, r0
2000afb4:	697b      	ldr	r3, [r7, #20]
2000afb6:	1ad3      	subs	r3, r2, r3
2000afb8:	2b02      	cmp	r3, #2
2000afba:	d901      	bls.n	2000afc0 <HAL_PWREx_ControlVoltageScaling+0xa4>
      {
        return HAL_TIMEOUT;
2000afbc:	2303      	movs	r3, #3
2000afbe:	e01e      	b.n	2000affe <HAL_PWREx_ControlVoltageScaling+0xe2>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
2000afc0:	4b11      	ldr	r3, [pc, #68]	; (2000b008 <HAL_PWREx_ControlVoltageScaling+0xec>)
2000afc2:	681b      	ldr	r3, [r3, #0]
2000afc4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000afc8:	2b00      	cmp	r3, #0
2000afca:	d0f0      	beq.n	2000afae <HAL_PWREx_ControlVoltageScaling+0x92>
      } 
    }
    
    /* Get Start Tick */
    tickstart = HAL_GetTick();
2000afcc:	f7f6 fed8 	bl	20001d80 <HAL_GetTick>
2000afd0:	6178      	str	r0, [r7, #20]
    while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
2000afd2:	e009      	b.n	2000afe8 <HAL_PWREx_ControlVoltageScaling+0xcc>
    {
      if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
2000afd4:	f7f6 fed4 	bl	20001d80 <HAL_GetTick>
2000afd8:	4602      	mov	r2, r0
2000afda:	697b      	ldr	r3, [r7, #20]
2000afdc:	1ad3      	subs	r3, r2, r3
2000afde:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2000afe2:	d901      	bls.n	2000afe8 <HAL_PWREx_ControlVoltageScaling+0xcc>
      {
        return HAL_TIMEOUT;
2000afe4:	2303      	movs	r3, #3
2000afe6:	e00a      	b.n	2000affe <HAL_PWREx_ControlVoltageScaling+0xe2>
    while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
2000afe8:	4b08      	ldr	r3, [pc, #32]	; (2000b00c <HAL_PWREx_ControlVoltageScaling+0xf0>)
2000afea:	685b      	ldr	r3, [r3, #4]
2000afec:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000aff0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2000aff4:	d1ee      	bne.n	2000afd4 <HAL_PWREx_ControlVoltageScaling+0xb8>
2000aff6:	e001      	b.n	2000affc <HAL_PWREx_ControlVoltageScaling+0xe0>
      } 
    }
  }
  else
  {
    return HAL_ERROR;
2000aff8:	2301      	movs	r3, #1
2000affa:	e000      	b.n	2000affe <HAL_PWREx_ControlVoltageScaling+0xe2>
  }
  return HAL_OK;
2000affc:	2300      	movs	r3, #0
}
2000affe:	4618      	mov	r0, r3
2000b000:	3718      	adds	r7, #24
2000b002:	46bd      	mov	sp, r7
2000b004:	bd80      	pop	{r7, pc}
2000b006:	bf00      	nop
2000b008:	40023800 	.word	0x40023800
2000b00c:	40007000 	.word	0x40007000

2000b010 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and creates the associated handle.
  * @param hqspi qspi handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
2000b010:	b580      	push	{r7, lr}
2000b012:	b086      	sub	sp, #24
2000b014:	af02      	add	r7, sp, #8
2000b016:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
2000b018:	2301      	movs	r3, #1
2000b01a:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
2000b01c:	f7f6 feb0 	bl	20001d80 <HAL_GetTick>
2000b020:	60b8      	str	r0, [r7, #8]
  
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
2000b022:	687b      	ldr	r3, [r7, #4]
2000b024:	2b00      	cmp	r3, #0
2000b026:	d101      	bne.n	2000b02c <HAL_QSPI_Init+0x1c>
  {
    return HAL_ERROR;
2000b028:	2301      	movs	r3, #1
2000b02a:	e073      	b.n	2000b114 <HAL_QSPI_Init+0x104>
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000b02c:	687b      	ldr	r3, [r7, #4]
2000b02e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b032:	b2db      	uxtb	r3, r3
2000b034:	2b01      	cmp	r3, #1
2000b036:	d101      	bne.n	2000b03c <HAL_QSPI_Init+0x2c>
2000b038:	2302      	movs	r3, #2
2000b03a:	e06b      	b.n	2000b114 <HAL_QSPI_Init+0x104>
2000b03c:	687b      	ldr	r3, [r7, #4]
2000b03e:	2201      	movs	r2, #1
2000b040:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    
  if(hqspi->State == HAL_QSPI_STATE_RESET)
2000b044:	687b      	ldr	r3, [r7, #4]
2000b046:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b04a:	b2db      	uxtb	r3, r3
2000b04c:	2b00      	cmp	r3, #0
2000b04e:	d10b      	bne.n	2000b068 <HAL_QSPI_Init+0x58>
  { 
    /* Allocate lock resource and initialize it */
    hqspi->Lock = HAL_UNLOCKED;
2000b050:	687b      	ldr	r3, [r7, #4]
2000b052:	2200      	movs	r2, #0
2000b054:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
2000b058:	6878      	ldr	r0, [r7, #4]
2000b05a:	f7f5 ffbb 	bl	20000fd4 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QPSI_TIMEOUT_DEFAULT_VALUE);
2000b05e:	f241 3188 	movw	r1, #5000	; 0x1388
2000b062:	6878      	ldr	r0, [r7, #4]
2000b064:	f001 f99a 	bl	2000c39c <HAL_QSPI_SetTimeout>
  }
  
  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1) << 8));
2000b068:	687b      	ldr	r3, [r7, #4]
2000b06a:	681b      	ldr	r3, [r3, #0]
2000b06c:	681b      	ldr	r3, [r3, #0]
2000b06e:	f423 51f8 	bic.w	r1, r3, #7936	; 0x1f00
2000b072:	687b      	ldr	r3, [r7, #4]
2000b074:	689b      	ldr	r3, [r3, #8]
2000b076:	3b01      	subs	r3, #1
2000b078:	021a      	lsls	r2, r3, #8
2000b07a:	687b      	ldr	r3, [r7, #4]
2000b07c:	681b      	ldr	r3, [r3, #0]
2000b07e:	430a      	orrs	r2, r1
2000b080:	601a      	str	r2, [r3, #0]

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2000b082:	687b      	ldr	r3, [r7, #4]
2000b084:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000b086:	9300      	str	r3, [sp, #0]
2000b088:	68bb      	ldr	r3, [r7, #8]
2000b08a:	2200      	movs	r2, #0
2000b08c:	2120      	movs	r1, #32
2000b08e:	6878      	ldr	r0, [r7, #4]
2000b090:	f001 fa81 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b094:	4603      	mov	r3, r0
2000b096:	73fb      	strb	r3, [r7, #15]

  if(status == HAL_OK)
2000b098:	7bfb      	ldrb	r3, [r7, #15]
2000b09a:	2b00      	cmp	r3, #0
2000b09c:	d135      	bne.n	2000b10a <HAL_QSPI_Init+0xfa>
  {
                
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
2000b09e:	687b      	ldr	r3, [r7, #4]
2000b0a0:	681b      	ldr	r3, [r3, #0]
2000b0a2:	681a      	ldr	r2, [r3, #0]
2000b0a4:	4b1d      	ldr	r3, [pc, #116]	; (2000b11c <HAL_QSPI_Init+0x10c>)
2000b0a6:	4013      	ands	r3, r2
2000b0a8:	687a      	ldr	r2, [r7, #4]
2000b0aa:	6852      	ldr	r2, [r2, #4]
2000b0ac:	0611      	lsls	r1, r2, #24
2000b0ae:	687a      	ldr	r2, [r7, #4]
2000b0b0:	68d2      	ldr	r2, [r2, #12]
2000b0b2:	4311      	orrs	r1, r2
2000b0b4:	687a      	ldr	r2, [r7, #4]
2000b0b6:	69d2      	ldr	r2, [r2, #28]
2000b0b8:	4311      	orrs	r1, r2
2000b0ba:	687a      	ldr	r2, [r7, #4]
2000b0bc:	6a12      	ldr	r2, [r2, #32]
2000b0be:	4311      	orrs	r1, r2
2000b0c0:	687a      	ldr	r2, [r7, #4]
2000b0c2:	6812      	ldr	r2, [r2, #0]
2000b0c4:	430b      	orrs	r3, r1
2000b0c6:	6013      	str	r3, [r2, #0]
        
    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
2000b0c8:	687b      	ldr	r3, [r7, #4]
2000b0ca:	681b      	ldr	r3, [r3, #0]
2000b0cc:	685a      	ldr	r2, [r3, #4]
2000b0ce:	4b14      	ldr	r3, [pc, #80]	; (2000b120 <HAL_QSPI_Init+0x110>)
2000b0d0:	4013      	ands	r3, r2
2000b0d2:	687a      	ldr	r2, [r7, #4]
2000b0d4:	6912      	ldr	r2, [r2, #16]
2000b0d6:	0411      	lsls	r1, r2, #16
2000b0d8:	687a      	ldr	r2, [r7, #4]
2000b0da:	6952      	ldr	r2, [r2, #20]
2000b0dc:	4311      	orrs	r1, r2
2000b0de:	687a      	ldr	r2, [r7, #4]
2000b0e0:	6992      	ldr	r2, [r2, #24]
2000b0e2:	4311      	orrs	r1, r2
2000b0e4:	687a      	ldr	r2, [r7, #4]
2000b0e6:	6812      	ldr	r2, [r2, #0]
2000b0e8:	430b      	orrs	r3, r1
2000b0ea:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << 16) | hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));
    
    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
2000b0ec:	687b      	ldr	r3, [r7, #4]
2000b0ee:	681b      	ldr	r3, [r3, #0]
2000b0f0:	681a      	ldr	r2, [r3, #0]
2000b0f2:	687b      	ldr	r3, [r7, #4]
2000b0f4:	681b      	ldr	r3, [r3, #0]
2000b0f6:	f042 0201 	orr.w	r2, r2, #1
2000b0fa:	601a      	str	r2, [r3, #0]
  
    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;  
2000b0fc:	687b      	ldr	r3, [r7, #4]
2000b0fe:	2200      	movs	r2, #0
2000b100:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
2000b102:	687b      	ldr	r3, [r7, #4]
2000b104:	2201      	movs	r2, #1
2000b106:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hqspi);
2000b10a:	687b      	ldr	r3, [r7, #4]
2000b10c:	2200      	movs	r2, #0
2000b10e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
2000b112:	7bfb      	ldrb	r3, [r7, #15]
}
2000b114:	4618      	mov	r0, r3
2000b116:	3710      	adds	r7, #16
2000b118:	46bd      	mov	sp, r7
2000b11a:	bd80      	pop	{r7, pc}
2000b11c:	00ffff2f 	.word	0x00ffff2f
2000b120:	ffe0f8fe 	.word	0xffe0f8fe

2000b124 <HAL_QSPI_DeInit>:
  * @brief DeInitializes the QSPI peripheral 
  * @param hqspi qspi handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
{
2000b124:	b580      	push	{r7, lr}
2000b126:	b082      	sub	sp, #8
2000b128:	af00      	add	r7, sp, #0
2000b12a:	6078      	str	r0, [r7, #4]
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
2000b12c:	687b      	ldr	r3, [r7, #4]
2000b12e:	2b00      	cmp	r3, #0
2000b130:	d101      	bne.n	2000b136 <HAL_QSPI_DeInit+0x12>
  {
    return HAL_ERROR;
2000b132:	2301      	movs	r3, #1
2000b134:	e022      	b.n	2000b17c <HAL_QSPI_DeInit+0x58>
  }

  /* Process locked */
  __HAL_LOCK(hqspi);
2000b136:	687b      	ldr	r3, [r7, #4]
2000b138:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b13c:	b2db      	uxtb	r3, r3
2000b13e:	2b01      	cmp	r3, #1
2000b140:	d101      	bne.n	2000b146 <HAL_QSPI_DeInit+0x22>
2000b142:	2302      	movs	r3, #2
2000b144:	e01a      	b.n	2000b17c <HAL_QSPI_DeInit+0x58>
2000b146:	687b      	ldr	r3, [r7, #4]
2000b148:	2201      	movs	r2, #1
2000b14a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Disable the QSPI Peripheral Clock */
  __HAL_QSPI_DISABLE(hqspi);
2000b14e:	687b      	ldr	r3, [r7, #4]
2000b150:	681b      	ldr	r3, [r3, #0]
2000b152:	681a      	ldr	r2, [r3, #0]
2000b154:	687b      	ldr	r3, [r7, #4]
2000b156:	681b      	ldr	r3, [r3, #0]
2000b158:	f022 0201 	bic.w	r2, r2, #1
2000b15c:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware */
  hqspi->MspDeInitCallback(hqspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_QSPI_MspDeInit(hqspi);
2000b15e:	6878      	ldr	r0, [r7, #4]
2000b160:	f7f5 ffe8 	bl	20001134 <HAL_QSPI_MspDeInit>
#endif

  /* Set QSPI error code to none */
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000b164:	687b      	ldr	r3, [r7, #4]
2000b166:	2200      	movs	r2, #0
2000b168:	645a      	str	r2, [r3, #68]	; 0x44

  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;
2000b16a:	687b      	ldr	r3, [r7, #4]
2000b16c:	2200      	movs	r2, #0
2000b16e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Release Lock */
  __HAL_UNLOCK(hqspi);
2000b172:	687b      	ldr	r3, [r7, #4]
2000b174:	2200      	movs	r2, #0
2000b176:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2000b17a:	2300      	movs	r3, #0
}
2000b17c:	4618      	mov	r0, r3
2000b17e:	3708      	adds	r7, #8
2000b180:	46bd      	mov	sp, r7
2000b182:	bd80      	pop	{r7, pc}
  * @brief QSPI MSP Init
  * @param hqspi QSPI handle
  * @retval None
  */
 __weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
{
2000b184:	b480      	push	{r7}
2000b186:	b083      	sub	sp, #12
2000b188:	af00      	add	r7, sp, #0
2000b18a:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspInit can be implemented in the user file
   */ 
}
2000b18c:	bf00      	nop
2000b18e:	370c      	adds	r7, #12
2000b190:	46bd      	mov	sp, r7
2000b192:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b196:	4770      	bx	lr
  * @brief QSPI MSP DeInit
  * @param hqspi QSPI handle
  * @retval None
  */
 __weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
{
2000b198:	b480      	push	{r7}
2000b19a:	b083      	sub	sp, #12
2000b19c:	af00      	add	r7, sp, #0
2000b19e:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspDeInit can be implemented in the user file
   */ 
}
2000b1a0:	bf00      	nop
2000b1a2:	370c      	adds	r7, #12
2000b1a4:	46bd      	mov	sp, r7
2000b1a6:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b1aa:	4770      	bx	lr

2000b1ac <HAL_QSPI_IRQHandler>:
  * @brief This function handles QSPI interrupt request.
  * @param hqspi QSPI handle
  * @retval None.
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
2000b1ac:	b580      	push	{r7, lr}
2000b1ae:	b086      	sub	sp, #24
2000b1b0:	af00      	add	r7, sp, #0
2000b1b2:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
2000b1b4:	687b      	ldr	r3, [r7, #4]
2000b1b6:	681b      	ldr	r3, [r3, #0]
2000b1b8:	689b      	ldr	r3, [r3, #8]
2000b1ba:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
2000b1bc:	687b      	ldr	r3, [r7, #4]
2000b1be:	681b      	ldr	r3, [r3, #0]
2000b1c0:	681b      	ldr	r3, [r3, #0]
2000b1c2:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT)!= RESET) && ((itsource & QSPI_IT_FT)!= RESET))
2000b1c4:	697b      	ldr	r3, [r7, #20]
2000b1c6:	f003 0304 	and.w	r3, r3, #4
2000b1ca:	2b00      	cmp	r3, #0
2000b1cc:	d060      	beq.n	2000b290 <HAL_QSPI_IRQHandler+0xe4>
2000b1ce:	693b      	ldr	r3, [r7, #16]
2000b1d0:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2000b1d4:	2b00      	cmp	r3, #0
2000b1d6:	d05b      	beq.n	2000b290 <HAL_QSPI_IRQHandler+0xe4>
  {
    data_reg = &hqspi->Instance->DR;
2000b1d8:	687b      	ldr	r3, [r7, #4]
2000b1da:	681b      	ldr	r3, [r3, #0]
2000b1dc:	3320      	adds	r3, #32
2000b1de:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b1e0:	687b      	ldr	r3, [r7, #4]
2000b1e2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b1e6:	b2db      	uxtb	r3, r3
2000b1e8:	2b12      	cmp	r3, #18
2000b1ea:	d123      	bne.n	2000b234 <HAL_QSPI_IRQHandler+0x88>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != 0)
2000b1ec:	e01a      	b.n	2000b224 <HAL_QSPI_IRQHandler+0x78>
      {
        if (hqspi->TxXferCount > 0)
2000b1ee:	687b      	ldr	r3, [r7, #4]
2000b1f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000b1f2:	2b00      	cmp	r3, #0
2000b1f4:	d00d      	beq.n	2000b212 <HAL_QSPI_IRQHandler+0x66>
        {
          /* Fill the FIFO until it is full */
          *(__IO uint8_t *)data_reg = *hqspi->pTxBuffPtr++;
2000b1f6:	687b      	ldr	r3, [r7, #4]
2000b1f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000b1fa:	1c59      	adds	r1, r3, #1
2000b1fc:	687a      	ldr	r2, [r7, #4]
2000b1fe:	6251      	str	r1, [r2, #36]	; 0x24
2000b200:	781a      	ldrb	r2, [r3, #0]
2000b202:	68fb      	ldr	r3, [r7, #12]
2000b204:	701a      	strb	r2, [r3, #0]
          hqspi->TxXferCount--;
2000b206:	687b      	ldr	r3, [r7, #4]
2000b208:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000b20a:	1e5a      	subs	r2, r3, #1
2000b20c:	687b      	ldr	r3, [r7, #4]
2000b20e:	62da      	str	r2, [r3, #44]	; 0x2c
2000b210:	e008      	b.n	2000b224 <HAL_QSPI_IRQHandler+0x78>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
2000b212:	687b      	ldr	r3, [r7, #4]
2000b214:	681b      	ldr	r3, [r3, #0]
2000b216:	681a      	ldr	r2, [r3, #0]
2000b218:	687b      	ldr	r3, [r7, #4]
2000b21a:	681b      	ldr	r3, [r3, #0]
2000b21c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2000b220:	601a      	str	r2, [r3, #0]
          break;
2000b222:	e031      	b.n	2000b288 <HAL_QSPI_IRQHandler+0xdc>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != 0)
2000b224:	687b      	ldr	r3, [r7, #4]
2000b226:	681b      	ldr	r3, [r3, #0]
2000b228:	689b      	ldr	r3, [r3, #8]
2000b22a:	f003 0304 	and.w	r3, r3, #4
2000b22e:	2b00      	cmp	r3, #0
2000b230:	d1dd      	bne.n	2000b1ee <HAL_QSPI_IRQHandler+0x42>
2000b232:	e029      	b.n	2000b288 <HAL_QSPI_IRQHandler+0xdc>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
2000b234:	687b      	ldr	r3, [r7, #4]
2000b236:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b23a:	b2db      	uxtb	r3, r3
2000b23c:	2b22      	cmp	r3, #34	; 0x22
2000b23e:	d123      	bne.n	2000b288 <HAL_QSPI_IRQHandler+0xdc>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != 0)
2000b240:	e01b      	b.n	2000b27a <HAL_QSPI_IRQHandler+0xce>
      {
        if (hqspi->RxXferCount > 0)
2000b242:	687b      	ldr	r3, [r7, #4]
2000b244:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000b246:	2b00      	cmp	r3, #0
2000b248:	d00e      	beq.n	2000b268 <HAL_QSPI_IRQHandler+0xbc>
        {
          /* Read the FIFO until it is empty */
          *hqspi->pRxBuffPtr++ = *(__IO uint8_t *)data_reg;
2000b24a:	687b      	ldr	r3, [r7, #4]
2000b24c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000b24e:	1c59      	adds	r1, r3, #1
2000b250:	687a      	ldr	r2, [r7, #4]
2000b252:	6311      	str	r1, [r2, #48]	; 0x30
2000b254:	68fa      	ldr	r2, [r7, #12]
2000b256:	7812      	ldrb	r2, [r2, #0]
2000b258:	b2d2      	uxtb	r2, r2
2000b25a:	701a      	strb	r2, [r3, #0]
          hqspi->RxXferCount--;
2000b25c:	687b      	ldr	r3, [r7, #4]
2000b25e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000b260:	1e5a      	subs	r2, r3, #1
2000b262:	687b      	ldr	r3, [r7, #4]
2000b264:	639a      	str	r2, [r3, #56]	; 0x38
2000b266:	e008      	b.n	2000b27a <HAL_QSPI_IRQHandler+0xce>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
2000b268:	687b      	ldr	r3, [r7, #4]
2000b26a:	681b      	ldr	r3, [r3, #0]
2000b26c:	681a      	ldr	r2, [r3, #0]
2000b26e:	687b      	ldr	r3, [r7, #4]
2000b270:	681b      	ldr	r3, [r3, #0]
2000b272:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2000b276:	601a      	str	r2, [r3, #0]
          break;
2000b278:	e006      	b.n	2000b288 <HAL_QSPI_IRQHandler+0xdc>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != 0)
2000b27a:	687b      	ldr	r3, [r7, #4]
2000b27c:	681b      	ldr	r3, [r3, #0]
2000b27e:	689b      	ldr	r3, [r3, #8]
2000b280:	f003 0304 	and.w	r3, r3, #4
2000b284:	2b00      	cmp	r3, #0
2000b286:	d1dc      	bne.n	2000b242 <HAL_QSPI_IRQHandler+0x96>
    
    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
2000b288:	6878      	ldr	r0, [r7, #4]
2000b28a:	f000 ff8e 	bl	2000c1aa <HAL_QSPI_FifoThresholdCallback>
2000b28e:	e132      	b.n	2000b4f6 <HAL_QSPI_IRQHandler+0x34a>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC)!= RESET) && ((itsource & QSPI_IT_TC)!= RESET))
2000b290:	697b      	ldr	r3, [r7, #20]
2000b292:	f003 0302 	and.w	r3, r3, #2
2000b296:	2b00      	cmp	r3, #0
2000b298:	f000 80a6 	beq.w	2000b3e8 <HAL_QSPI_IRQHandler+0x23c>
2000b29c:	693b      	ldr	r3, [r7, #16]
2000b29e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000b2a2:	2b00      	cmp	r3, #0
2000b2a4:	f000 80a0 	beq.w	2000b3e8 <HAL_QSPI_IRQHandler+0x23c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
2000b2a8:	687b      	ldr	r3, [r7, #4]
2000b2aa:	681b      	ldr	r3, [r3, #0]
2000b2ac:	2202      	movs	r2, #2
2000b2ae:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
2000b2b0:	687b      	ldr	r3, [r7, #4]
2000b2b2:	681b      	ldr	r3, [r3, #0]
2000b2b4:	681a      	ldr	r2, [r3, #0]
2000b2b6:	687b      	ldr	r3, [r7, #4]
2000b2b8:	681b      	ldr	r3, [r3, #0]
2000b2ba:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
2000b2be:	601a      	str	r2, [r3, #0]
    
    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b2c0:	687b      	ldr	r3, [r7, #4]
2000b2c2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b2c6:	b2db      	uxtb	r3, r3
2000b2c8:	2b12      	cmp	r3, #18
2000b2ca:	d120      	bne.n	2000b30e <HAL_QSPI_IRQHandler+0x162>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000b2cc:	687b      	ldr	r3, [r7, #4]
2000b2ce:	681b      	ldr	r3, [r3, #0]
2000b2d0:	681b      	ldr	r3, [r3, #0]
2000b2d2:	f003 0304 	and.w	r3, r3, #4
2000b2d6:	2b00      	cmp	r3, #0
2000b2d8:	d011      	beq.n	2000b2fe <HAL_QSPI_IRQHandler+0x152>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000b2da:	687b      	ldr	r3, [r7, #4]
2000b2dc:	681b      	ldr	r3, [r3, #0]
2000b2de:	681a      	ldr	r2, [r3, #0]
2000b2e0:	687b      	ldr	r3, [r7, #4]
2000b2e2:	681b      	ldr	r3, [r3, #0]
2000b2e4:	f022 0204 	bic.w	r2, r2, #4
2000b2e8:	601a      	str	r2, [r3, #0]
        
        /* Disable the DMA channel */
        __HAL_DMA_DISABLE(hqspi->hdma);
2000b2ea:	687b      	ldr	r3, [r7, #4]
2000b2ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000b2ee:	681b      	ldr	r3, [r3, #0]
2000b2f0:	681a      	ldr	r2, [r3, #0]
2000b2f2:	687b      	ldr	r3, [r7, #4]
2000b2f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000b2f6:	681b      	ldr	r3, [r3, #0]
2000b2f8:	f022 0201 	bic.w	r2, r2, #1
2000b2fc:	601a      	str	r2, [r3, #0]
/* Clear Busy bit */
      HAL_QSPI_Abort_IT(hqspi);
#endif
      
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2000b2fe:	687b      	ldr	r3, [r7, #4]
2000b300:	2201      	movs	r2, #1
2000b302:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
2000b306:	6878      	ldr	r0, [r7, #4]
2000b308:	f000 ff31 	bl	2000c16e <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b30c:	e0f0      	b.n	2000b4f0 <HAL_QSPI_IRQHandler+0x344>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
2000b30e:	687b      	ldr	r3, [r7, #4]
2000b310:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b314:	b2db      	uxtb	r3, r3
2000b316:	2b22      	cmp	r3, #34	; 0x22
2000b318:	d141      	bne.n	2000b39e <HAL_QSPI_IRQHandler+0x1f2>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000b31a:	687b      	ldr	r3, [r7, #4]
2000b31c:	681b      	ldr	r3, [r3, #0]
2000b31e:	681b      	ldr	r3, [r3, #0]
2000b320:	f003 0304 	and.w	r3, r3, #4
2000b324:	2b00      	cmp	r3, #0
2000b326:	d012      	beq.n	2000b34e <HAL_QSPI_IRQHandler+0x1a2>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000b328:	687b      	ldr	r3, [r7, #4]
2000b32a:	681b      	ldr	r3, [r3, #0]
2000b32c:	681a      	ldr	r2, [r3, #0]
2000b32e:	687b      	ldr	r3, [r7, #4]
2000b330:	681b      	ldr	r3, [r3, #0]
2000b332:	f022 0204 	bic.w	r2, r2, #4
2000b336:	601a      	str	r2, [r3, #0]
        
        /* Disable the DMA channel */
        __HAL_DMA_DISABLE(hqspi->hdma);
2000b338:	687b      	ldr	r3, [r7, #4]
2000b33a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000b33c:	681b      	ldr	r3, [r3, #0]
2000b33e:	681a      	ldr	r2, [r3, #0]
2000b340:	687b      	ldr	r3, [r7, #4]
2000b342:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000b344:	681b      	ldr	r3, [r3, #0]
2000b346:	f022 0201 	bic.w	r2, r2, #1
2000b34a:	601a      	str	r2, [r3, #0]
2000b34c:	e01f      	b.n	2000b38e <HAL_QSPI_IRQHandler+0x1e2>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
2000b34e:	687b      	ldr	r3, [r7, #4]
2000b350:	681b      	ldr	r3, [r3, #0]
2000b352:	3320      	adds	r3, #32
2000b354:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0)
2000b356:	e011      	b.n	2000b37c <HAL_QSPI_IRQHandler+0x1d0>
        {
          if (hqspi->RxXferCount > 0)
2000b358:	687b      	ldr	r3, [r7, #4]
2000b35a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000b35c:	2b00      	cmp	r3, #0
2000b35e:	d015      	beq.n	2000b38c <HAL_QSPI_IRQHandler+0x1e0>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr++ = *(__IO uint8_t *)data_reg;
2000b360:	687b      	ldr	r3, [r7, #4]
2000b362:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000b364:	1c59      	adds	r1, r3, #1
2000b366:	687a      	ldr	r2, [r7, #4]
2000b368:	6311      	str	r1, [r2, #48]	; 0x30
2000b36a:	68fa      	ldr	r2, [r7, #12]
2000b36c:	7812      	ldrb	r2, [r2, #0]
2000b36e:	b2d2      	uxtb	r2, r2
2000b370:	701a      	strb	r2, [r3, #0]
            hqspi->RxXferCount--;
2000b372:	687b      	ldr	r3, [r7, #4]
2000b374:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000b376:	1e5a      	subs	r2, r3, #1
2000b378:	687b      	ldr	r3, [r7, #4]
2000b37a:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0)
2000b37c:	687b      	ldr	r3, [r7, #4]
2000b37e:	681b      	ldr	r3, [r3, #0]
2000b380:	689b      	ldr	r3, [r3, #8]
2000b382:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
2000b386:	2b00      	cmp	r3, #0
2000b388:	d1e6      	bne.n	2000b358 <HAL_QSPI_IRQHandler+0x1ac>
2000b38a:	e000      	b.n	2000b38e <HAL_QSPI_IRQHandler+0x1e2>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
2000b38c:	bf00      	nop
      /* Workaround - Extra data written in the FIFO at the end of a read transfer */
      HAL_QSPI_Abort_IT(hqspi);
#endif /* QSPI_V1_0*/      
      
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2000b38e:	687b      	ldr	r3, [r7, #4]
2000b390:	2201      	movs	r2, #1
2000b392:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
2000b396:	6878      	ldr	r0, [r7, #4]
2000b398:	f000 fedf 	bl	2000c15a <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b39c:	e0a8      	b.n	2000b4f0 <HAL_QSPI_IRQHandler+0x344>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
2000b39e:	687b      	ldr	r3, [r7, #4]
2000b3a0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b3a4:	b2db      	uxtb	r3, r3
2000b3a6:	2b02      	cmp	r3, #2
2000b3a8:	d107      	bne.n	2000b3ba <HAL_QSPI_IRQHandler+0x20e>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2000b3aa:	687b      	ldr	r3, [r7, #4]
2000b3ac:	2201      	movs	r2, #1
2000b3ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
2000b3b2:	6878      	ldr	r0, [r7, #4]
2000b3b4:	f000 fec7 	bl	2000c146 <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b3b8:	e09a      	b.n	2000b4f0 <HAL_QSPI_IRQHandler+0x344>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
2000b3ba:	687b      	ldr	r3, [r7, #4]
2000b3bc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b3c0:	b2db      	uxtb	r3, r3
2000b3c2:	2b08      	cmp	r3, #8
2000b3c4:	f040 8094 	bne.w	2000b4f0 <HAL_QSPI_IRQHandler+0x344>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2000b3c8:	687b      	ldr	r3, [r7, #4]
2000b3ca:	2201      	movs	r2, #1
2000b3cc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
2000b3d0:	687b      	ldr	r3, [r7, #4]
2000b3d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000b3d4:	2b00      	cmp	r3, #0
2000b3d6:	d103      	bne.n	2000b3e0 <HAL_QSPI_IRQHandler+0x234>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
2000b3d8:	6878      	ldr	r0, [r7, #4]
2000b3da:	f000 feaa 	bl	2000c132 <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b3de:	e087      	b.n	2000b4f0 <HAL_QSPI_IRQHandler+0x344>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
2000b3e0:	6878      	ldr	r0, [r7, #4]
2000b3e2:	f000 fe9c 	bl	2000c11e <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b3e6:	e083      	b.n	2000b4f0 <HAL_QSPI_IRQHandler+0x344>
      }
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM)!= RESET) && ((itsource & QSPI_IT_SM)!= RESET))
2000b3e8:	697b      	ldr	r3, [r7, #20]
2000b3ea:	f003 0308 	and.w	r3, r3, #8
2000b3ee:	2b00      	cmp	r3, #0
2000b3f0:	d01f      	beq.n	2000b432 <HAL_QSPI_IRQHandler+0x286>
2000b3f2:	693b      	ldr	r3, [r7, #16]
2000b3f4:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2000b3f8:	2b00      	cmp	r3, #0
2000b3fa:	d01a      	beq.n	2000b432 <HAL_QSPI_IRQHandler+0x286>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
2000b3fc:	687b      	ldr	r3, [r7, #4]
2000b3fe:	681b      	ldr	r3, [r3, #0]
2000b400:	2208      	movs	r2, #8
2000b402:	60da      	str	r2, [r3, #12]
   
    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0)
2000b404:	687b      	ldr	r3, [r7, #4]
2000b406:	681b      	ldr	r3, [r3, #0]
2000b408:	681b      	ldr	r3, [r3, #0]
2000b40a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000b40e:	2b00      	cmp	r3, #0
2000b410:	d00b      	beq.n	2000b42a <HAL_QSPI_IRQHandler+0x27e>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
2000b412:	687b      	ldr	r3, [r7, #4]
2000b414:	681b      	ldr	r3, [r3, #0]
2000b416:	681a      	ldr	r2, [r3, #0]
2000b418:	687b      	ldr	r3, [r7, #4]
2000b41a:	681b      	ldr	r3, [r3, #0]
2000b41c:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
2000b420:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2000b422:	687b      	ldr	r3, [r7, #4]
2000b424:	2201      	movs	r2, #1
2000b426:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
2000b42a:	6878      	ldr	r0, [r7, #4]
2000b42c:	f000 fec7 	bl	2000c1be <HAL_QSPI_StatusMatchCallback>
2000b430:	e061      	b.n	2000b4f6 <HAL_QSPI_IRQHandler+0x34a>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE)!= RESET) && ((itsource & QSPI_IT_TE)!= RESET))
2000b432:	697b      	ldr	r3, [r7, #20]
2000b434:	f003 0301 	and.w	r3, r3, #1
2000b438:	2b00      	cmp	r3, #0
2000b43a:	d047      	beq.n	2000b4cc <HAL_QSPI_IRQHandler+0x320>
2000b43c:	693b      	ldr	r3, [r7, #16]
2000b43e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000b442:	2b00      	cmp	r3, #0
2000b444:	d042      	beq.n	2000b4cc <HAL_QSPI_IRQHandler+0x320>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
2000b446:	687b      	ldr	r3, [r7, #4]
2000b448:	681b      	ldr	r3, [r3, #0]
2000b44a:	2201      	movs	r2, #1
2000b44c:	60da      	str	r2, [r3, #12]
    
    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
2000b44e:	687b      	ldr	r3, [r7, #4]
2000b450:	681b      	ldr	r3, [r3, #0]
2000b452:	681a      	ldr	r2, [r3, #0]
2000b454:	687b      	ldr	r3, [r7, #4]
2000b456:	681b      	ldr	r3, [r3, #0]
2000b458:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
2000b45c:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
2000b45e:	687b      	ldr	r3, [r7, #4]
2000b460:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000b462:	f043 0202 	orr.w	r2, r3, #2
2000b466:	687b      	ldr	r3, [r7, #4]
2000b468:	645a      	str	r2, [r3, #68]	; 0x44
    
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000b46a:	687b      	ldr	r3, [r7, #4]
2000b46c:	681b      	ldr	r3, [r3, #0]
2000b46e:	681b      	ldr	r3, [r3, #0]
2000b470:	f003 0304 	and.w	r3, r3, #4
2000b474:	2b00      	cmp	r3, #0
2000b476:	d021      	beq.n	2000b4bc <HAL_QSPI_IRQHandler+0x310>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000b478:	687b      	ldr	r3, [r7, #4]
2000b47a:	681b      	ldr	r3, [r3, #0]
2000b47c:	681a      	ldr	r2, [r3, #0]
2000b47e:	687b      	ldr	r3, [r7, #4]
2000b480:	681b      	ldr	r3, [r3, #0]
2000b482:	f022 0204 	bic.w	r2, r2, #4
2000b486:	601a      	str	r2, [r3, #0]
      
      /* Disable the DMA channel */
      hqspi->hdma->XferAbortCallback = QSPI_DMAAbortCplt;
2000b488:	687b      	ldr	r3, [r7, #4]
2000b48a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000b48c:	4a1c      	ldr	r2, [pc, #112]	; (2000b500 <HAL_QSPI_IRQHandler+0x354>)
2000b48e:	651a      	str	r2, [r3, #80]	; 0x50
      if (HAL_DMA_Abort_IT(hqspi->hdma) != HAL_OK)
2000b490:	687b      	ldr	r3, [r7, #4]
2000b492:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000b494:	4618      	mov	r0, r3
2000b496:	f7f7 fb4a 	bl	20002b2e <HAL_DMA_Abort_IT>
2000b49a:	4603      	mov	r3, r0
2000b49c:	2b00      	cmp	r3, #0
2000b49e:	d029      	beq.n	2000b4f4 <HAL_QSPI_IRQHandler+0x348>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2000b4a0:	687b      	ldr	r3, [r7, #4]
2000b4a2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000b4a4:	f043 0204 	orr.w	r2, r3, #4
2000b4a8:	687b      	ldr	r3, [r7, #4]
2000b4aa:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
2000b4ac:	687b      	ldr	r3, [r7, #4]
2000b4ae:	2201      	movs	r2, #1
2000b4b0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        
        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
2000b4b4:	6878      	ldr	r0, [r7, #4]
2000b4b6:	f000 fe32 	bl	2000c11e <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000b4ba:	e01b      	b.n	2000b4f4 <HAL_QSPI_IRQHandler+0x348>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2000b4bc:	687b      	ldr	r3, [r7, #4]
2000b4be:	2201      	movs	r2, #1
2000b4c0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      
      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
2000b4c4:	6878      	ldr	r0, [r7, #4]
2000b4c6:	f000 fe2a 	bl	2000c11e <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000b4ca:	e013      	b.n	2000b4f4 <HAL_QSPI_IRQHandler+0x348>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO)!= RESET) && ((itsource & QSPI_IT_TO)!= RESET))
2000b4cc:	697b      	ldr	r3, [r7, #20]
2000b4ce:	f003 0310 	and.w	r3, r3, #16
2000b4d2:	2b00      	cmp	r3, #0
2000b4d4:	d00f      	beq.n	2000b4f6 <HAL_QSPI_IRQHandler+0x34a>
2000b4d6:	693b      	ldr	r3, [r7, #16]
2000b4d8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
2000b4dc:	2b00      	cmp	r3, #0
2000b4de:	d00a      	beq.n	2000b4f6 <HAL_QSPI_IRQHandler+0x34a>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
2000b4e0:	687b      	ldr	r3, [r7, #4]
2000b4e2:	681b      	ldr	r3, [r3, #0]
2000b4e4:	2210      	movs	r2, #16
2000b4e6:	60da      	str	r2, [r3, #12]
    
    /* Time out callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
2000b4e8:	6878      	ldr	r0, [r7, #4]
2000b4ea:	f000 fe72 	bl	2000c1d2 <HAL_QSPI_TimeOutCallback>
#endif
  }
}
2000b4ee:	e002      	b.n	2000b4f6 <HAL_QSPI_IRQHandler+0x34a>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2000b4f0:	bf00      	nop
2000b4f2:	e000      	b.n	2000b4f6 <HAL_QSPI_IRQHandler+0x34a>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000b4f4:	bf00      	nop
}
2000b4f6:	bf00      	nop
2000b4f8:	3718      	adds	r7, #24
2000b4fa:	46bd      	mov	sp, r7
2000b4fc:	bd80      	pop	{r7, pc}
2000b4fe:	bf00      	nop
2000b500:	2000c531 	.word	0x2000c531

2000b504 <HAL_QSPI_Command>:
  * @param Timeout  Time out duration
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
{
2000b504:	b580      	push	{r7, lr}
2000b506:	b088      	sub	sp, #32
2000b508:	af02      	add	r7, sp, #8
2000b50a:	60f8      	str	r0, [r7, #12]
2000b50c:	60b9      	str	r1, [r7, #8]
2000b50e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
2000b510:	2301      	movs	r3, #1
2000b512:	75fb      	strb	r3, [r7, #23]
  uint32_t tickstart = HAL_GetTick();
2000b514:	f7f6 fc34 	bl	20001d80 <HAL_GetTick>
2000b518:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000b51a:	68fb      	ldr	r3, [r7, #12]
2000b51c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b520:	b2db      	uxtb	r3, r3
2000b522:	2b01      	cmp	r3, #1
2000b524:	d101      	bne.n	2000b52a <HAL_QSPI_Command+0x26>
2000b526:	2302      	movs	r3, #2
2000b528:	e048      	b.n	2000b5bc <HAL_QSPI_Command+0xb8>
2000b52a:	68fb      	ldr	r3, [r7, #12]
2000b52c:	2201      	movs	r2, #1
2000b52e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000b532:	68fb      	ldr	r3, [r7, #12]
2000b534:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b538:	b2db      	uxtb	r3, r3
2000b53a:	2b01      	cmp	r3, #1
2000b53c:	d137      	bne.n	2000b5ae <HAL_QSPI_Command+0xaa>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000b53e:	68fb      	ldr	r3, [r7, #12]
2000b540:	2200      	movs	r2, #0
2000b542:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;   
2000b544:	68fb      	ldr	r3, [r7, #12]
2000b546:	2202      	movs	r2, #2
2000b548:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
2000b54c:	687b      	ldr	r3, [r7, #4]
2000b54e:	9300      	str	r3, [sp, #0]
2000b550:	693b      	ldr	r3, [r7, #16]
2000b552:	2200      	movs	r2, #0
2000b554:	2120      	movs	r1, #32
2000b556:	68f8      	ldr	r0, [r7, #12]
2000b558:	f001 f81d 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b55c:	4603      	mov	r3, r0
2000b55e:	75fb      	strb	r3, [r7, #23]
    
    if (status == HAL_OK)
2000b560:	7dfb      	ldrb	r3, [r7, #23]
2000b562:	2b00      	cmp	r3, #0
2000b564:	d125      	bne.n	2000b5b2 <HAL_QSPI_Command+0xae>
    {
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2000b566:	2200      	movs	r2, #0
2000b568:	68b9      	ldr	r1, [r7, #8]
2000b56a:	68f8      	ldr	r0, [r7, #12]
2000b56c:	f001 f84a 	bl	2000c604 <QSPI_Config>
      
      if (cmd->DataMode == QSPI_DATA_NONE)
2000b570:	68bb      	ldr	r3, [r7, #8]
2000b572:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000b574:	2b00      	cmp	r3, #0
2000b576:	d115      	bne.n	2000b5a4 <HAL_QSPI_Command+0xa0>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done 
        so wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
2000b578:	687b      	ldr	r3, [r7, #4]
2000b57a:	9300      	str	r3, [sp, #0]
2000b57c:	693b      	ldr	r3, [r7, #16]
2000b57e:	2201      	movs	r2, #1
2000b580:	2102      	movs	r1, #2
2000b582:	68f8      	ldr	r0, [r7, #12]
2000b584:	f001 f807 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b588:	4603      	mov	r3, r0
2000b58a:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
2000b58c:	7dfb      	ldrb	r3, [r7, #23]
2000b58e:	2b00      	cmp	r3, #0
2000b590:	d10f      	bne.n	2000b5b2 <HAL_QSPI_Command+0xae>
        {
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000b592:	68fb      	ldr	r3, [r7, #12]
2000b594:	681b      	ldr	r3, [r3, #0]
2000b596:	2202      	movs	r2, #2
2000b598:	60da      	str	r2, [r3, #12]
          
          /* Update QSPI state */
          hqspi->State = HAL_QSPI_STATE_READY;   
2000b59a:	68fb      	ldr	r3, [r7, #12]
2000b59c:	2201      	movs	r2, #1
2000b59e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2000b5a2:	e006      	b.n	2000b5b2 <HAL_QSPI_Command+0xae>
        
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;   
2000b5a4:	68fb      	ldr	r3, [r7, #12]
2000b5a6:	2201      	movs	r2, #1
2000b5a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2000b5ac:	e001      	b.n	2000b5b2 <HAL_QSPI_Command+0xae>
      }
    }
  }
  else
  {
    status = HAL_BUSY;   
2000b5ae:	2302      	movs	r3, #2
2000b5b0:	75fb      	strb	r3, [r7, #23]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000b5b2:	68fb      	ldr	r3, [r7, #12]
2000b5b4:	2200      	movs	r2, #0
2000b5b6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
2000b5ba:	7dfb      	ldrb	r3, [r7, #23]
}
2000b5bc:	4618      	mov	r0, r3
2000b5be:	3718      	adds	r7, #24
2000b5c0:	46bd      	mov	sp, r7
2000b5c2:	bd80      	pop	{r7, pc}

2000b5c4 <HAL_QSPI_Command_IT>:
  * @param cmd  structure that contains the command configuration information
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
{
2000b5c4:	b580      	push	{r7, lr}
2000b5c6:	b086      	sub	sp, #24
2000b5c8:	af02      	add	r7, sp, #8
2000b5ca:	6078      	str	r0, [r7, #4]
2000b5cc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
2000b5ce:	2301      	movs	r3, #1
2000b5d0:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
2000b5d2:	f7f6 fbd5 	bl	20001d80 <HAL_GetTick>
2000b5d6:	60b8      	str	r0, [r7, #8]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000b5d8:	687b      	ldr	r3, [r7, #4]
2000b5da:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b5de:	b2db      	uxtb	r3, r3
2000b5e0:	2b01      	cmp	r3, #1
2000b5e2:	d101      	bne.n	2000b5e8 <HAL_QSPI_Command_IT+0x24>
2000b5e4:	2302      	movs	r3, #2
2000b5e6:	e051      	b.n	2000b68c <HAL_QSPI_Command_IT+0xc8>
2000b5e8:	687b      	ldr	r3, [r7, #4]
2000b5ea:	2201      	movs	r2, #1
2000b5ec:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000b5f0:	687b      	ldr	r3, [r7, #4]
2000b5f2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b5f6:	b2db      	uxtb	r3, r3
2000b5f8:	2b01      	cmp	r3, #1
2000b5fa:	d140      	bne.n	2000b67e <HAL_QSPI_Command_IT+0xba>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000b5fc:	687b      	ldr	r3, [r7, #4]
2000b5fe:	2200      	movs	r2, #0
2000b600:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;   
2000b602:	687b      	ldr	r3, [r7, #4]
2000b604:	2202      	movs	r2, #2
2000b606:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2000b60a:	687b      	ldr	r3, [r7, #4]
2000b60c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000b60e:	9300      	str	r3, [sp, #0]
2000b610:	68bb      	ldr	r3, [r7, #8]
2000b612:	2200      	movs	r2, #0
2000b614:	2120      	movs	r1, #32
2000b616:	6878      	ldr	r0, [r7, #4]
2000b618:	f000 ffbd 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b61c:	4603      	mov	r3, r0
2000b61e:	73fb      	strb	r3, [r7, #15]
    
    if (status == HAL_OK)
2000b620:	7bfb      	ldrb	r3, [r7, #15]
2000b622:	2b00      	cmp	r3, #0
2000b624:	d126      	bne.n	2000b674 <HAL_QSPI_Command_IT+0xb0>
    {
      if (cmd->DataMode == QSPI_DATA_NONE)
2000b626:	683b      	ldr	r3, [r7, #0]
2000b628:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000b62a:	2b00      	cmp	r3, #0
2000b62c:	d103      	bne.n	2000b636 <HAL_QSPI_Command_IT+0x72>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
2000b62e:	687b      	ldr	r3, [r7, #4]
2000b630:	681b      	ldr	r3, [r3, #0]
2000b632:	2203      	movs	r2, #3
2000b634:	60da      	str	r2, [r3, #12]
      }
      
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2000b636:	2200      	movs	r2, #0
2000b638:	6839      	ldr	r1, [r7, #0]
2000b63a:	6878      	ldr	r0, [r7, #4]
2000b63c:	f000 ffe2 	bl	2000c604 <QSPI_Config>
      
      if (cmd->DataMode == QSPI_DATA_NONE)
2000b640:	683b      	ldr	r3, [r7, #0]
2000b642:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000b644:	2b00      	cmp	r3, #0
2000b646:	d10c      	bne.n	2000b662 <HAL_QSPI_Command_IT+0x9e>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done 
        so activate TC and TE interrupts */
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
2000b648:	687b      	ldr	r3, [r7, #4]
2000b64a:	2200      	movs	r2, #0
2000b64c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Enable the QSPI Transfer Error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
2000b650:	687b      	ldr	r3, [r7, #4]
2000b652:	681b      	ldr	r3, [r3, #0]
2000b654:	681a      	ldr	r2, [r3, #0]
2000b656:	687b      	ldr	r3, [r7, #4]
2000b658:	681b      	ldr	r3, [r3, #0]
2000b65a:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
2000b65e:	601a      	str	r2, [r3, #0]
2000b660:	e013      	b.n	2000b68a <HAL_QSPI_Command_IT+0xc6>
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;   
2000b662:	687b      	ldr	r3, [r7, #4]
2000b664:	2201      	movs	r2, #1
2000b666:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
2000b66a:	687b      	ldr	r3, [r7, #4]
2000b66c:	2200      	movs	r2, #0
2000b66e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000b672:	e00a      	b.n	2000b68a <HAL_QSPI_Command_IT+0xc6>
      }
    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000b674:	687b      	ldr	r3, [r7, #4]
2000b676:	2200      	movs	r2, #0
2000b678:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000b67c:	e005      	b.n	2000b68a <HAL_QSPI_Command_IT+0xc6>
    }
  }
  else
  {
    status = HAL_BUSY;   
2000b67e:	2302      	movs	r3, #2
2000b680:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000b682:	687b      	ldr	r3, [r7, #4]
2000b684:	2200      	movs	r2, #0
2000b686:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }
  
  /* Return function status */
  return status;
2000b68a:	7bfb      	ldrb	r3, [r7, #15]
}
2000b68c:	4618      	mov	r0, r3
2000b68e:	3710      	adds	r7, #16
2000b690:	46bd      	mov	sp, r7
2000b692:	bd80      	pop	{r7, pc}

2000b694 <HAL_QSPI_Transmit>:
  * @param Timeout  Time out duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
2000b694:	b580      	push	{r7, lr}
2000b696:	b08a      	sub	sp, #40	; 0x28
2000b698:	af02      	add	r7, sp, #8
2000b69a:	60f8      	str	r0, [r7, #12]
2000b69c:	60b9      	str	r1, [r7, #8]
2000b69e:	607a      	str	r2, [r7, #4]
   HAL_StatusTypeDef status = HAL_OK;
2000b6a0:	2300      	movs	r3, #0
2000b6a2:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
2000b6a4:	f7f6 fb6c 	bl	20001d80 <HAL_GetTick>
2000b6a8:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
2000b6aa:	68fb      	ldr	r3, [r7, #12]
2000b6ac:	681b      	ldr	r3, [r3, #0]
2000b6ae:	3320      	adds	r3, #32
2000b6b0:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hqspi);
2000b6b2:	68fb      	ldr	r3, [r7, #12]
2000b6b4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b6b8:	b2db      	uxtb	r3, r3
2000b6ba:	2b01      	cmp	r3, #1
2000b6bc:	d101      	bne.n	2000b6c2 <HAL_QSPI_Transmit+0x2e>
2000b6be:	2302      	movs	r3, #2
2000b6c0:	e074      	b.n	2000b7ac <HAL_QSPI_Transmit+0x118>
2000b6c2:	68fb      	ldr	r3, [r7, #12]
2000b6c4:	2201      	movs	r2, #1
2000b6c6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000b6ca:	68fb      	ldr	r3, [r7, #12]
2000b6cc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b6d0:	b2db      	uxtb	r3, r3
2000b6d2:	2b01      	cmp	r3, #1
2000b6d4:	d163      	bne.n	2000b79e <HAL_QSPI_Transmit+0x10a>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000b6d6:	68fb      	ldr	r3, [r7, #12]
2000b6d8:	2200      	movs	r2, #0
2000b6da:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
2000b6dc:	68bb      	ldr	r3, [r7, #8]
2000b6de:	2b00      	cmp	r3, #0
2000b6e0:	d054      	beq.n	2000b78c <HAL_QSPI_Transmit+0xf8>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
2000b6e2:	68fb      	ldr	r3, [r7, #12]
2000b6e4:	2212      	movs	r2, #18
2000b6e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      
      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
2000b6ea:	68fb      	ldr	r3, [r7, #12]
2000b6ec:	681b      	ldr	r3, [r3, #0]
2000b6ee:	691b      	ldr	r3, [r3, #16]
2000b6f0:	1c5a      	adds	r2, r3, #1
2000b6f2:	68fb      	ldr	r3, [r7, #12]
2000b6f4:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
2000b6f6:	68fb      	ldr	r3, [r7, #12]
2000b6f8:	681b      	ldr	r3, [r3, #0]
2000b6fa:	691b      	ldr	r3, [r3, #16]
2000b6fc:	1c5a      	adds	r2, r3, #1
2000b6fe:	68fb      	ldr	r3, [r7, #12]
2000b700:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
2000b702:	68fb      	ldr	r3, [r7, #12]
2000b704:	68ba      	ldr	r2, [r7, #8]
2000b706:	625a      	str	r2, [r3, #36]	; 0x24
    
      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2000b708:	68fb      	ldr	r3, [r7, #12]
2000b70a:	681b      	ldr	r3, [r3, #0]
2000b70c:	695a      	ldr	r2, [r3, #20]
2000b70e:	68fb      	ldr	r3, [r7, #12]
2000b710:	681b      	ldr	r3, [r3, #0]
2000b712:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2000b716:	615a      	str	r2, [r3, #20]

      while(hqspi->TxXferCount > 0)
2000b718:	e019      	b.n	2000b74e <HAL_QSPI_Transmit+0xba>
      {
        /* Wait until FT flag is set to send data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
2000b71a:	687b      	ldr	r3, [r7, #4]
2000b71c:	9300      	str	r3, [sp, #0]
2000b71e:	69bb      	ldr	r3, [r7, #24]
2000b720:	2201      	movs	r2, #1
2000b722:	2104      	movs	r1, #4
2000b724:	68f8      	ldr	r0, [r7, #12]
2000b726:	f000 ff36 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b72a:	4603      	mov	r3, r0
2000b72c:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
2000b72e:	7ffb      	ldrb	r3, [r7, #31]
2000b730:	2b00      	cmp	r3, #0
2000b732:	d111      	bne.n	2000b758 <HAL_QSPI_Transmit+0xc4>
        { 
          break;
        }

        *(__IO uint8_t *)data_reg = *hqspi->pTxBuffPtr++;
2000b734:	68fb      	ldr	r3, [r7, #12]
2000b736:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000b738:	1c59      	adds	r1, r3, #1
2000b73a:	68fa      	ldr	r2, [r7, #12]
2000b73c:	6251      	str	r1, [r2, #36]	; 0x24
2000b73e:	781a      	ldrb	r2, [r3, #0]
2000b740:	697b      	ldr	r3, [r7, #20]
2000b742:	701a      	strb	r2, [r3, #0]
        hqspi->TxXferCount--;
2000b744:	68fb      	ldr	r3, [r7, #12]
2000b746:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000b748:	1e5a      	subs	r2, r3, #1
2000b74a:	68fb      	ldr	r3, [r7, #12]
2000b74c:	62da      	str	r2, [r3, #44]	; 0x2c
      while(hqspi->TxXferCount > 0)
2000b74e:	68fb      	ldr	r3, [r7, #12]
2000b750:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000b752:	2b00      	cmp	r3, #0
2000b754:	d1e1      	bne.n	2000b71a <HAL_QSPI_Transmit+0x86>
2000b756:	e000      	b.n	2000b75a <HAL_QSPI_Transmit+0xc6>
          break;
2000b758:	bf00      	nop
      }
    
      if (status == HAL_OK)
2000b75a:	7ffb      	ldrb	r3, [r7, #31]
2000b75c:	2b00      	cmp	r3, #0
2000b75e:	d110      	bne.n	2000b782 <HAL_QSPI_Transmit+0xee>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
2000b760:	687b      	ldr	r3, [r7, #4]
2000b762:	9300      	str	r3, [sp, #0]
2000b764:	69bb      	ldr	r3, [r7, #24]
2000b766:	2201      	movs	r2, #1
2000b768:	2102      	movs	r1, #2
2000b76a:	68f8      	ldr	r0, [r7, #12]
2000b76c:	f000 ff13 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b770:	4603      	mov	r3, r0
2000b772:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
2000b774:	7ffb      	ldrb	r3, [r7, #31]
2000b776:	2b00      	cmp	r3, #0
2000b778:	d103      	bne.n	2000b782 <HAL_QSPI_Transmit+0xee>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000b77a:	68fb      	ldr	r3, [r7, #12]
2000b77c:	681b      	ldr	r3, [r3, #0]
2000b77e:	2202      	movs	r2, #2
2000b780:	60da      	str	r2, [r3, #12]
#endif /* QSPI_V1_0 */ 
        }
      }
    
      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;    
2000b782:	68fb      	ldr	r3, [r7, #12]
2000b784:	2201      	movs	r2, #1
2000b786:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2000b78a:	e00a      	b.n	2000b7a2 <HAL_QSPI_Transmit+0x10e>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000b78c:	68fb      	ldr	r3, [r7, #12]
2000b78e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000b790:	f043 0208 	orr.w	r2, r3, #8
2000b794:	68fb      	ldr	r3, [r7, #12]
2000b796:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2000b798:	2301      	movs	r3, #1
2000b79a:	77fb      	strb	r3, [r7, #31]
2000b79c:	e001      	b.n	2000b7a2 <HAL_QSPI_Transmit+0x10e>
    }
  }
  else
  {
    status = HAL_BUSY;
2000b79e:	2302      	movs	r3, #2
2000b7a0:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000b7a2:	68fb      	ldr	r3, [r7, #12]
2000b7a4:	2200      	movs	r2, #0
2000b7a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
2000b7aa:	7ffb      	ldrb	r3, [r7, #31]
}
2000b7ac:	4618      	mov	r0, r3
2000b7ae:	3720      	adds	r7, #32
2000b7b0:	46bd      	mov	sp, r7
2000b7b2:	bd80      	pop	{r7, pc}

2000b7b4 <HAL_QSPI_Receive>:
  * @param Timeout  Time out duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
2000b7b4:	b580      	push	{r7, lr}
2000b7b6:	b08a      	sub	sp, #40	; 0x28
2000b7b8:	af02      	add	r7, sp, #8
2000b7ba:	60f8      	str	r0, [r7, #12]
2000b7bc:	60b9      	str	r1, [r7, #8]
2000b7be:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2000b7c0:	2300      	movs	r3, #0
2000b7c2:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
2000b7c4:	f7f6 fadc 	bl	20001d80 <HAL_GetTick>
2000b7c8:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
2000b7ca:	68fb      	ldr	r3, [r7, #12]
2000b7cc:	681b      	ldr	r3, [r3, #0]
2000b7ce:	699b      	ldr	r3, [r3, #24]
2000b7d0:	617b      	str	r3, [r7, #20]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
2000b7d2:	68fb      	ldr	r3, [r7, #12]
2000b7d4:	681b      	ldr	r3, [r3, #0]
2000b7d6:	3320      	adds	r3, #32
2000b7d8:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hqspi);
2000b7da:	68fb      	ldr	r3, [r7, #12]
2000b7dc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b7e0:	b2db      	uxtb	r3, r3
2000b7e2:	2b01      	cmp	r3, #1
2000b7e4:	d101      	bne.n	2000b7ea <HAL_QSPI_Receive+0x36>
2000b7e6:	2302      	movs	r3, #2
2000b7e8:	e07b      	b.n	2000b8e2 <HAL_QSPI_Receive+0x12e>
2000b7ea:	68fb      	ldr	r3, [r7, #12]
2000b7ec:	2201      	movs	r2, #1
2000b7ee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  if(hqspi->State == HAL_QSPI_STATE_READY)
2000b7f2:	68fb      	ldr	r3, [r7, #12]
2000b7f4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b7f8:	b2db      	uxtb	r3, r3
2000b7fa:	2b01      	cmp	r3, #1
2000b7fc:	d16a      	bne.n	2000b8d4 <HAL_QSPI_Receive+0x120>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000b7fe:	68fb      	ldr	r3, [r7, #12]
2000b800:	2200      	movs	r2, #0
2000b802:	645a      	str	r2, [r3, #68]	; 0x44
    if(pData != NULL )
2000b804:	68bb      	ldr	r3, [r7, #8]
2000b806:	2b00      	cmp	r3, #0
2000b808:	d05b      	beq.n	2000b8c2 <HAL_QSPI_Receive+0x10e>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
2000b80a:	68fb      	ldr	r3, [r7, #12]
2000b80c:	2222      	movs	r2, #34	; 0x22
2000b80e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
2000b812:	68fb      	ldr	r3, [r7, #12]
2000b814:	681b      	ldr	r3, [r3, #0]
2000b816:	691b      	ldr	r3, [r3, #16]
2000b818:	1c5a      	adds	r2, r3, #1
2000b81a:	68fb      	ldr	r3, [r7, #12]
2000b81c:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
2000b81e:	68fb      	ldr	r3, [r7, #12]
2000b820:	681b      	ldr	r3, [r3, #0]
2000b822:	691b      	ldr	r3, [r3, #16]
2000b824:	1c5a      	adds	r2, r3, #1
2000b826:	68fb      	ldr	r3, [r7, #12]
2000b828:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
2000b82a:	68fb      	ldr	r3, [r7, #12]
2000b82c:	68ba      	ldr	r2, [r7, #8]
2000b82e:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
2000b830:	68fb      	ldr	r3, [r7, #12]
2000b832:	681b      	ldr	r3, [r3, #0]
2000b834:	695b      	ldr	r3, [r3, #20]
2000b836:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
2000b83a:	68fb      	ldr	r3, [r7, #12]
2000b83c:	681b      	ldr	r3, [r3, #0]
2000b83e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
2000b842:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
2000b844:	68fb      	ldr	r3, [r7, #12]
2000b846:	681b      	ldr	r3, [r3, #0]
2000b848:	697a      	ldr	r2, [r7, #20]
2000b84a:	619a      	str	r2, [r3, #24]
      
      while(hqspi->RxXferCount > 0)
2000b84c:	e01a      	b.n	2000b884 <HAL_QSPI_Receive+0xd0>
      {
        /* Wait until FT or TC flag is set to read received data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
2000b84e:	687b      	ldr	r3, [r7, #4]
2000b850:	9300      	str	r3, [sp, #0]
2000b852:	69bb      	ldr	r3, [r7, #24]
2000b854:	2201      	movs	r2, #1
2000b856:	2106      	movs	r1, #6
2000b858:	68f8      	ldr	r0, [r7, #12]
2000b85a:	f000 fe9c 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b85e:	4603      	mov	r3, r0
2000b860:	77fb      	strb	r3, [r7, #31]

        if  (status != HAL_OK)
2000b862:	7ffb      	ldrb	r3, [r7, #31]
2000b864:	2b00      	cmp	r3, #0
2000b866:	d112      	bne.n	2000b88e <HAL_QSPI_Receive+0xda>
        { 
          break;
        }

        *hqspi->pRxBuffPtr++ = *(__IO uint8_t *)data_reg;
2000b868:	68fb      	ldr	r3, [r7, #12]
2000b86a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000b86c:	1c59      	adds	r1, r3, #1
2000b86e:	68fa      	ldr	r2, [r7, #12]
2000b870:	6311      	str	r1, [r2, #48]	; 0x30
2000b872:	693a      	ldr	r2, [r7, #16]
2000b874:	7812      	ldrb	r2, [r2, #0]
2000b876:	b2d2      	uxtb	r2, r2
2000b878:	701a      	strb	r2, [r3, #0]
        hqspi->RxXferCount--;
2000b87a:	68fb      	ldr	r3, [r7, #12]
2000b87c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000b87e:	1e5a      	subs	r2, r3, #1
2000b880:	68fb      	ldr	r3, [r7, #12]
2000b882:	639a      	str	r2, [r3, #56]	; 0x38
      while(hqspi->RxXferCount > 0)
2000b884:	68fb      	ldr	r3, [r7, #12]
2000b886:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000b888:	2b00      	cmp	r3, #0
2000b88a:	d1e0      	bne.n	2000b84e <HAL_QSPI_Receive+0x9a>
2000b88c:	e000      	b.n	2000b890 <HAL_QSPI_Receive+0xdc>
          break;
2000b88e:	bf00      	nop
      }
    
      if (status == HAL_OK)
2000b890:	7ffb      	ldrb	r3, [r7, #31]
2000b892:	2b00      	cmp	r3, #0
2000b894:	d110      	bne.n	2000b8b8 <HAL_QSPI_Receive+0x104>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
2000b896:	687b      	ldr	r3, [r7, #4]
2000b898:	9300      	str	r3, [sp, #0]
2000b89a:	69bb      	ldr	r3, [r7, #24]
2000b89c:	2201      	movs	r2, #1
2000b89e:	2102      	movs	r1, #2
2000b8a0:	68f8      	ldr	r0, [r7, #12]
2000b8a2:	f000 fe78 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000b8a6:	4603      	mov	r3, r0
2000b8a8:	77fb      	strb	r3, [r7, #31]

        if  (status == HAL_OK)
2000b8aa:	7ffb      	ldrb	r3, [r7, #31]
2000b8ac:	2b00      	cmp	r3, #0
2000b8ae:	d103      	bne.n	2000b8b8 <HAL_QSPI_Receive+0x104>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000b8b0:	68fb      	ldr	r3, [r7, #12]
2000b8b2:	681b      	ldr	r3, [r3, #0]
2000b8b4:	2202      	movs	r2, #2
2000b8b6:	60da      	str	r2, [r3, #12]
#endif /* QSPI_V1_0 */  
        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;    
2000b8b8:	68fb      	ldr	r3, [r7, #12]
2000b8ba:	2201      	movs	r2, #1
2000b8bc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2000b8c0:	e00a      	b.n	2000b8d8 <HAL_QSPI_Receive+0x124>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000b8c2:	68fb      	ldr	r3, [r7, #12]
2000b8c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000b8c6:	f043 0208 	orr.w	r2, r3, #8
2000b8ca:	68fb      	ldr	r3, [r7, #12]
2000b8cc:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2000b8ce:	2301      	movs	r3, #1
2000b8d0:	77fb      	strb	r3, [r7, #31]
2000b8d2:	e001      	b.n	2000b8d8 <HAL_QSPI_Receive+0x124>
    }
  }
  else
  {
    status = HAL_BUSY;
2000b8d4:	2302      	movs	r3, #2
2000b8d6:	77fb      	strb	r3, [r7, #31]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000b8d8:	68fb      	ldr	r3, [r7, #12]
2000b8da:	2200      	movs	r2, #0
2000b8dc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
2000b8e0:	7ffb      	ldrb	r3, [r7, #31]
}
2000b8e2:	4618      	mov	r0, r3
2000b8e4:	3720      	adds	r7, #32
2000b8e6:	46bd      	mov	sp, r7
2000b8e8:	bd80      	pop	{r7, pc}

2000b8ea <HAL_QSPI_Transmit_IT>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{  
2000b8ea:	b480      	push	{r7}
2000b8ec:	b085      	sub	sp, #20
2000b8ee:	af00      	add	r7, sp, #0
2000b8f0:	6078      	str	r0, [r7, #4]
2000b8f2:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000b8f4:	2300      	movs	r3, #0
2000b8f6:	73fb      	strb	r3, [r7, #15]
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000b8f8:	687b      	ldr	r3, [r7, #4]
2000b8fa:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b8fe:	b2db      	uxtb	r3, r3
2000b900:	2b01      	cmp	r3, #1
2000b902:	d101      	bne.n	2000b908 <HAL_QSPI_Transmit_IT+0x1e>
2000b904:	2302      	movs	r3, #2
2000b906:	e04f      	b.n	2000b9a8 <HAL_QSPI_Transmit_IT+0xbe>
2000b908:	687b      	ldr	r3, [r7, #4]
2000b90a:	2201      	movs	r2, #1
2000b90c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000b910:	687b      	ldr	r3, [r7, #4]
2000b912:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b916:	b2db      	uxtb	r3, r3
2000b918:	2b01      	cmp	r3, #1
2000b91a:	d13e      	bne.n	2000b99a <HAL_QSPI_Transmit_IT+0xb0>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000b91c:	687b      	ldr	r3, [r7, #4]
2000b91e:	2200      	movs	r2, #0
2000b920:	645a      	str	r2, [r3, #68]	; 0x44
    if(pData != NULL )
2000b922:	683b      	ldr	r3, [r7, #0]
2000b924:	2b00      	cmp	r3, #0
2000b926:	d02b      	beq.n	2000b980 <HAL_QSPI_Transmit_IT+0x96>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
2000b928:	687b      	ldr	r3, [r7, #4]
2000b92a:	2212      	movs	r2, #18
2000b92c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
2000b930:	687b      	ldr	r3, [r7, #4]
2000b932:	681b      	ldr	r3, [r3, #0]
2000b934:	691b      	ldr	r3, [r3, #16]
2000b936:	1c5a      	adds	r2, r3, #1
2000b938:	687b      	ldr	r3, [r7, #4]
2000b93a:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
2000b93c:	687b      	ldr	r3, [r7, #4]
2000b93e:	681b      	ldr	r3, [r3, #0]
2000b940:	691b      	ldr	r3, [r3, #16]
2000b942:	1c5a      	adds	r2, r3, #1
2000b944:	687b      	ldr	r3, [r7, #4]
2000b946:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
2000b948:	687b      	ldr	r3, [r7, #4]
2000b94a:	683a      	ldr	r2, [r7, #0]
2000b94c:	625a      	str	r2, [r3, #36]	; 0x24
    
      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2000b94e:	687b      	ldr	r3, [r7, #4]
2000b950:	681b      	ldr	r3, [r3, #0]
2000b952:	695a      	ldr	r2, [r3, #20]
2000b954:	687b      	ldr	r3, [r7, #4]
2000b956:	681b      	ldr	r3, [r3, #0]
2000b958:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2000b95c:	615a      	str	r2, [r3, #20]
    
      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
2000b95e:	687b      	ldr	r3, [r7, #4]
2000b960:	681b      	ldr	r3, [r3, #0]
2000b962:	2203      	movs	r2, #3
2000b964:	60da      	str	r2, [r3, #12]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000b966:	687b      	ldr	r3, [r7, #4]
2000b968:	2200      	movs	r2, #0
2000b96a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      
      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
2000b96e:	687b      	ldr	r3, [r7, #4]
2000b970:	681b      	ldr	r3, [r3, #0]
2000b972:	681a      	ldr	r2, [r3, #0]
2000b974:	687b      	ldr	r3, [r7, #4]
2000b976:	681b      	ldr	r3, [r3, #0]
2000b978:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
2000b97c:	601a      	str	r2, [r3, #0]
2000b97e:	e012      	b.n	2000b9a6 <HAL_QSPI_Transmit_IT+0xbc>
      
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000b980:	687b      	ldr	r3, [r7, #4]
2000b982:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000b984:	f043 0208 	orr.w	r2, r3, #8
2000b988:	687b      	ldr	r3, [r7, #4]
2000b98a:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2000b98c:	2301      	movs	r3, #1
2000b98e:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000b990:	687b      	ldr	r3, [r7, #4]
2000b992:	2200      	movs	r2, #0
2000b994:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000b998:	e005      	b.n	2000b9a6 <HAL_QSPI_Transmit_IT+0xbc>
    }
  }
  else
  {
    status = HAL_BUSY;
2000b99a:	2302      	movs	r3, #2
2000b99c:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000b99e:	687b      	ldr	r3, [r7, #4]
2000b9a0:	2200      	movs	r2, #0
2000b9a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
2000b9a6:	7bfb      	ldrb	r3, [r7, #15]
}
2000b9a8:	4618      	mov	r0, r3
2000b9aa:	3714      	adds	r7, #20
2000b9ac:	46bd      	mov	sp, r7
2000b9ae:	f85d 7b04 	ldr.w	r7, [sp], #4
2000b9b2:	4770      	bx	lr

2000b9b4 <HAL_QSPI_Receive_IT>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
2000b9b4:	b480      	push	{r7}
2000b9b6:	b085      	sub	sp, #20
2000b9b8:	af00      	add	r7, sp, #0
2000b9ba:	6078      	str	r0, [r7, #4]
2000b9bc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000b9be:	2300      	movs	r3, #0
2000b9c0:	73fb      	strb	r3, [r7, #15]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
2000b9c2:	687b      	ldr	r3, [r7, #4]
2000b9c4:	681b      	ldr	r3, [r3, #0]
2000b9c6:	699b      	ldr	r3, [r3, #24]
2000b9c8:	60bb      	str	r3, [r7, #8]
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000b9ca:	687b      	ldr	r3, [r7, #4]
2000b9cc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000b9d0:	b2db      	uxtb	r3, r3
2000b9d2:	2b01      	cmp	r3, #1
2000b9d4:	d101      	bne.n	2000b9da <HAL_QSPI_Receive_IT+0x26>
2000b9d6:	2302      	movs	r3, #2
2000b9d8:	e055      	b.n	2000ba86 <HAL_QSPI_Receive_IT+0xd2>
2000b9da:	687b      	ldr	r3, [r7, #4]
2000b9dc:	2201      	movs	r2, #1
2000b9de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000b9e2:	687b      	ldr	r3, [r7, #4]
2000b9e4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000b9e8:	b2db      	uxtb	r3, r3
2000b9ea:	2b01      	cmp	r3, #1
2000b9ec:	d144      	bne.n	2000ba78 <HAL_QSPI_Receive_IT+0xc4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000b9ee:	687b      	ldr	r3, [r7, #4]
2000b9f0:	2200      	movs	r2, #0
2000b9f2:	645a      	str	r2, [r3, #68]	; 0x44
    
    if(pData != NULL )
2000b9f4:	683b      	ldr	r3, [r7, #0]
2000b9f6:	2b00      	cmp	r3, #0
2000b9f8:	d031      	beq.n	2000ba5e <HAL_QSPI_Receive_IT+0xaa>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
2000b9fa:	687b      	ldr	r3, [r7, #4]
2000b9fc:	2222      	movs	r2, #34	; 0x22
2000b9fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
2000ba02:	687b      	ldr	r3, [r7, #4]
2000ba04:	681b      	ldr	r3, [r3, #0]
2000ba06:	691b      	ldr	r3, [r3, #16]
2000ba08:	1c5a      	adds	r2, r3, #1
2000ba0a:	687b      	ldr	r3, [r7, #4]
2000ba0c:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
2000ba0e:	687b      	ldr	r3, [r7, #4]
2000ba10:	681b      	ldr	r3, [r3, #0]
2000ba12:	691b      	ldr	r3, [r3, #16]
2000ba14:	1c5a      	adds	r2, r3, #1
2000ba16:	687b      	ldr	r3, [r7, #4]
2000ba18:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
2000ba1a:	687b      	ldr	r3, [r7, #4]
2000ba1c:	683a      	ldr	r2, [r7, #0]
2000ba1e:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
2000ba20:	687b      	ldr	r3, [r7, #4]
2000ba22:	681b      	ldr	r3, [r3, #0]
2000ba24:	695b      	ldr	r3, [r3, #20]
2000ba26:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
2000ba2a:	687b      	ldr	r3, [r7, #4]
2000ba2c:	681b      	ldr	r3, [r3, #0]
2000ba2e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
2000ba32:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
2000ba34:	687b      	ldr	r3, [r7, #4]
2000ba36:	681b      	ldr	r3, [r3, #0]
2000ba38:	68ba      	ldr	r2, [r7, #8]
2000ba3a:	619a      	str	r2, [r3, #24]

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
2000ba3c:	687b      	ldr	r3, [r7, #4]
2000ba3e:	681b      	ldr	r3, [r3, #0]
2000ba40:	2203      	movs	r2, #3
2000ba42:	60da      	str	r2, [r3, #12]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000ba44:	687b      	ldr	r3, [r7, #4]
2000ba46:	2200      	movs	r2, #0
2000ba48:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
2000ba4c:	687b      	ldr	r3, [r7, #4]
2000ba4e:	681b      	ldr	r3, [r3, #0]
2000ba50:	681a      	ldr	r2, [r3, #0]
2000ba52:	687b      	ldr	r3, [r7, #4]
2000ba54:	681b      	ldr	r3, [r3, #0]
2000ba56:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
2000ba5a:	601a      	str	r2, [r3, #0]
2000ba5c:	e012      	b.n	2000ba84 <HAL_QSPI_Receive_IT+0xd0>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000ba5e:	687b      	ldr	r3, [r7, #4]
2000ba60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000ba62:	f043 0208 	orr.w	r2, r3, #8
2000ba66:	687b      	ldr	r3, [r7, #4]
2000ba68:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2000ba6a:	2301      	movs	r3, #1
2000ba6c:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000ba6e:	687b      	ldr	r3, [r7, #4]
2000ba70:	2200      	movs	r2, #0
2000ba72:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000ba76:	e005      	b.n	2000ba84 <HAL_QSPI_Receive_IT+0xd0>
    }
  }
  else
  {
    status = HAL_BUSY;   
2000ba78:	2302      	movs	r3, #2
2000ba7a:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000ba7c:	687b      	ldr	r3, [r7, #4]
2000ba7e:	2200      	movs	r2, #0
2000ba80:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
2000ba84:	7bfb      	ldrb	r3, [r7, #15]
}
2000ba86:	4618      	mov	r0, r3
2000ba88:	3714      	adds	r7, #20
2000ba8a:	46bd      	mov	sp, r7
2000ba8c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000ba90:	4770      	bx	lr
	...

2000ba94 <HAL_QSPI_Transmit_DMA>:
  * @note   If DMA peripheral access is configured as word, the number 
  *         of data and the fifo threshold should be aligned on word
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
2000ba94:	b580      	push	{r7, lr}
2000ba96:	b086      	sub	sp, #24
2000ba98:	af00      	add	r7, sp, #0
2000ba9a:	6078      	str	r0, [r7, #4]
2000ba9c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000ba9e:	2300      	movs	r3, #0
2000baa0:	75fb      	strb	r3, [r7, #23]
  uint32_t *tmp;
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1);
2000baa2:	687b      	ldr	r3, [r7, #4]
2000baa4:	681b      	ldr	r3, [r3, #0]
2000baa6:	691b      	ldr	r3, [r3, #16]
2000baa8:	3301      	adds	r3, #1
2000baaa:	613b      	str	r3, [r7, #16]
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000baac:	687b      	ldr	r3, [r7, #4]
2000baae:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000bab2:	b2db      	uxtb	r3, r3
2000bab4:	2b01      	cmp	r3, #1
2000bab6:	d101      	bne.n	2000babc <HAL_QSPI_Transmit_DMA+0x28>
2000bab8:	2302      	movs	r3, #2
2000baba:	e0d2      	b.n	2000bc62 <HAL_QSPI_Transmit_DMA+0x1ce>
2000babc:	687b      	ldr	r3, [r7, #4]
2000babe:	2201      	movs	r2, #1
2000bac0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  if(hqspi->State == HAL_QSPI_STATE_READY)
2000bac4:	687b      	ldr	r3, [r7, #4]
2000bac6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000baca:	b2db      	uxtb	r3, r3
2000bacc:	2b01      	cmp	r3, #1
2000bace:	f040 80c1 	bne.w	2000bc54 <HAL_QSPI_Transmit_DMA+0x1c0>
  {
    /* Clear the error code */                
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000bad2:	687b      	ldr	r3, [r7, #4]
2000bad4:	2200      	movs	r2, #0
2000bad6:	645a      	str	r2, [r3, #68]	; 0x44
    
    if(pData != NULL ) 
2000bad8:	683b      	ldr	r3, [r7, #0]
2000bada:	2b00      	cmp	r3, #0
2000badc:	f000 80ad 	beq.w	2000bc3a <HAL_QSPI_Transmit_DMA+0x1a6>
    {
      /* Configure counters of the handle */
      if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_BYTE)
2000bae0:	687b      	ldr	r3, [r7, #4]
2000bae2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bae4:	695b      	ldr	r3, [r3, #20]
2000bae6:	2b00      	cmp	r3, #0
2000bae8:	d103      	bne.n	2000baf2 <HAL_QSPI_Transmit_DMA+0x5e>
      {
        hqspi->TxXferCount = data_size;
2000baea:	687b      	ldr	r3, [r7, #4]
2000baec:	693a      	ldr	r2, [r7, #16]
2000baee:	62da      	str	r2, [r3, #44]	; 0x2c
2000baf0:	e044      	b.n	2000bb7c <HAL_QSPI_Transmit_DMA+0xe8>
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_HALFWORD)
2000baf2:	687b      	ldr	r3, [r7, #4]
2000baf4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000baf6:	695b      	ldr	r3, [r3, #20]
2000baf8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2000bafc:	d11c      	bne.n	2000bb38 <HAL_QSPI_Transmit_DMA+0xa4>
      {
        if (((data_size % 2) != 0) || ((hqspi->Init.FifoThreshold % 2) != 0))
2000bafe:	693b      	ldr	r3, [r7, #16]
2000bb00:	f003 0301 	and.w	r3, r3, #1
2000bb04:	2b00      	cmp	r3, #0
2000bb06:	d105      	bne.n	2000bb14 <HAL_QSPI_Transmit_DMA+0x80>
2000bb08:	687b      	ldr	r3, [r7, #4]
2000bb0a:	689b      	ldr	r3, [r3, #8]
2000bb0c:	f003 0301 	and.w	r3, r3, #1
2000bb10:	2b00      	cmp	r3, #0
2000bb12:	d00c      	beq.n	2000bb2e <HAL_QSPI_Transmit_DMA+0x9a>
        {
          /* The number of data or the fifo threshold is not aligned on halfword 
          => no transfer possible with DMA peripheral access configured as halfword */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000bb14:	687b      	ldr	r3, [r7, #4]
2000bb16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000bb18:	f043 0208 	orr.w	r2, r3, #8
2000bb1c:	687b      	ldr	r3, [r7, #4]
2000bb1e:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
2000bb20:	2301      	movs	r3, #1
2000bb22:	75fb      	strb	r3, [r7, #23]
          
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
2000bb24:	687b      	ldr	r3, [r7, #4]
2000bb26:	2200      	movs	r2, #0
2000bb28:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000bb2c:	e026      	b.n	2000bb7c <HAL_QSPI_Transmit_DMA+0xe8>
        }
        else
        {
          hqspi->TxXferCount = (data_size >> 1);
2000bb2e:	693b      	ldr	r3, [r7, #16]
2000bb30:	085a      	lsrs	r2, r3, #1
2000bb32:	687b      	ldr	r3, [r7, #4]
2000bb34:	62da      	str	r2, [r3, #44]	; 0x2c
2000bb36:	e021      	b.n	2000bb7c <HAL_QSPI_Transmit_DMA+0xe8>
        }
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_WORD)
2000bb38:	687b      	ldr	r3, [r7, #4]
2000bb3a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bb3c:	695b      	ldr	r3, [r3, #20]
2000bb3e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2000bb42:	d11b      	bne.n	2000bb7c <HAL_QSPI_Transmit_DMA+0xe8>
      {
        if (((data_size % 4) != 0) || ((hqspi->Init.FifoThreshold % 4) != 0))
2000bb44:	693b      	ldr	r3, [r7, #16]
2000bb46:	f003 0303 	and.w	r3, r3, #3
2000bb4a:	2b00      	cmp	r3, #0
2000bb4c:	d105      	bne.n	2000bb5a <HAL_QSPI_Transmit_DMA+0xc6>
2000bb4e:	687b      	ldr	r3, [r7, #4]
2000bb50:	689b      	ldr	r3, [r3, #8]
2000bb52:	f003 0303 	and.w	r3, r3, #3
2000bb56:	2b00      	cmp	r3, #0
2000bb58:	d00c      	beq.n	2000bb74 <HAL_QSPI_Transmit_DMA+0xe0>
        {
          /* The number of data or the fifo threshold is not aligned on word 
          => no transfer possible with DMA peripheral access configured as word */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000bb5a:	687b      	ldr	r3, [r7, #4]
2000bb5c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000bb5e:	f043 0208 	orr.w	r2, r3, #8
2000bb62:	687b      	ldr	r3, [r7, #4]
2000bb64:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
2000bb66:	2301      	movs	r3, #1
2000bb68:	75fb      	strb	r3, [r7, #23]
          
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
2000bb6a:	687b      	ldr	r3, [r7, #4]
2000bb6c:	2200      	movs	r2, #0
2000bb6e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000bb72:	e003      	b.n	2000bb7c <HAL_QSPI_Transmit_DMA+0xe8>
        }
        else
        {
          hqspi->TxXferCount = (data_size >> 2);
2000bb74:	693b      	ldr	r3, [r7, #16]
2000bb76:	089a      	lsrs	r2, r3, #2
2000bb78:	687b      	ldr	r3, [r7, #4]
2000bb7a:	62da      	str	r2, [r3, #44]	; 0x2c
        }
      }
      
      if (status == HAL_OK)
2000bb7c:	7dfb      	ldrb	r3, [r7, #23]
2000bb7e:	2b00      	cmp	r3, #0
2000bb80:	d16e      	bne.n	2000bc60 <HAL_QSPI_Transmit_DMA+0x1cc>
      {

      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
2000bb82:	687b      	ldr	r3, [r7, #4]
2000bb84:	2212      	movs	r2, #18
2000bb86:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
2000bb8a:	687b      	ldr	r3, [r7, #4]
2000bb8c:	681b      	ldr	r3, [r3, #0]
2000bb8e:	2203      	movs	r2, #3
2000bb90:	60da      	str	r2, [r3, #12]

      /* Configure size and pointer of the handle */
      hqspi->TxXferSize = hqspi->TxXferCount;
2000bb92:	687b      	ldr	r3, [r7, #4]
2000bb94:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000bb96:	687b      	ldr	r3, [r7, #4]
2000bb98:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
2000bb9a:	683a      	ldr	r2, [r7, #0]
2000bb9c:	687b      	ldr	r3, [r7, #4]
2000bb9e:	625a      	str	r2, [r3, #36]	; 0x24
    
      /* Configure QSPI: CCR register with functional mode as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2000bba0:	687b      	ldr	r3, [r7, #4]
2000bba2:	681b      	ldr	r3, [r3, #0]
2000bba4:	695a      	ldr	r2, [r3, #20]
2000bba6:	687b      	ldr	r3, [r7, #4]
2000bba8:	681b      	ldr	r3, [r3, #0]
2000bbaa:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2000bbae:	615a      	str	r2, [r3, #20]
    
      /* Set the QSPI DMA transfer complete callback */
      hqspi->hdma->XferCpltCallback = QSPI_DMATxCplt;
2000bbb0:	687b      	ldr	r3, [r7, #4]
2000bbb2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbb4:	4a2d      	ldr	r2, [pc, #180]	; (2000bc6c <HAL_QSPI_Transmit_DMA+0x1d8>)
2000bbb6:	63da      	str	r2, [r3, #60]	; 0x3c
    
      /* Set the QSPI DMA Half transfer complete callback */
      hqspi->hdma->XferHalfCpltCallback = QSPI_DMATxHalfCplt;
2000bbb8:	687b      	ldr	r3, [r7, #4]
2000bbba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbbc:	4a2c      	ldr	r2, [pc, #176]	; (2000bc70 <HAL_QSPI_Transmit_DMA+0x1dc>)
2000bbbe:	641a      	str	r2, [r3, #64]	; 0x40
    
      /* Set the DMA error callback */
      hqspi->hdma->XferErrorCallback = QSPI_DMAError;
2000bbc0:	687b      	ldr	r3, [r7, #4]
2000bbc2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbc4:	4a2b      	ldr	r2, [pc, #172]	; (2000bc74 <HAL_QSPI_Transmit_DMA+0x1e0>)
2000bbc6:	64da      	str	r2, [r3, #76]	; 0x4c
      
      /* Clear the DMA abort callback */      
      hqspi->hdma->XferAbortCallback = NULL;
2000bbc8:	687b      	ldr	r3, [r7, #4]
2000bbca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbcc:	2200      	movs	r2, #0
2000bbce:	651a      	str	r2, [r3, #80]	; 0x50

      /* Configure the direction of the DMA */
      hqspi->hdma->Init.Direction = DMA_MEMORY_TO_PERIPH;
2000bbd0:	687b      	ldr	r3, [r7, #4]
2000bbd2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbd4:	2240      	movs	r2, #64	; 0x40
2000bbd6:	609a      	str	r2, [r3, #8]
      MODIFY_REG(hqspi->hdma->Instance->CR, DMA_SxCR_DIR, hqspi->hdma->Init.Direction);
2000bbd8:	687b      	ldr	r3, [r7, #4]
2000bbda:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbdc:	681b      	ldr	r3, [r3, #0]
2000bbde:	681b      	ldr	r3, [r3, #0]
2000bbe0:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
2000bbe4:	687b      	ldr	r3, [r7, #4]
2000bbe6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbe8:	689a      	ldr	r2, [r3, #8]
2000bbea:	687b      	ldr	r3, [r7, #4]
2000bbec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bbee:	681b      	ldr	r3, [r3, #0]
2000bbf0:	430a      	orrs	r2, r1
2000bbf2:	601a      	str	r2, [r3, #0]

      /* Enable the QSPI transmit DMA Channel */
      tmp = (uint32_t*)&pData;
2000bbf4:	463b      	mov	r3, r7
2000bbf6:	60fb      	str	r3, [r7, #12]
      HAL_DMA_Start_IT(hqspi->hdma, *(uint32_t*)tmp, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize);
2000bbf8:	687b      	ldr	r3, [r7, #4]
2000bbfa:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000bbfc:	68fb      	ldr	r3, [r7, #12]
2000bbfe:	6819      	ldr	r1, [r3, #0]
2000bc00:	687b      	ldr	r3, [r7, #4]
2000bc02:	681b      	ldr	r3, [r3, #0]
2000bc04:	3320      	adds	r3, #32
2000bc06:	461a      	mov	r2, r3
2000bc08:	687b      	ldr	r3, [r7, #4]
2000bc0a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000bc0c:	f7f6 febf 	bl	2000298e <HAL_DMA_Start_IT>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000bc10:	687b      	ldr	r3, [r7, #4]
2000bc12:	2200      	movs	r2, #0
2000bc14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
2000bc18:	687b      	ldr	r3, [r7, #4]
2000bc1a:	681b      	ldr	r3, [r3, #0]
2000bc1c:	681a      	ldr	r2, [r3, #0]
2000bc1e:	687b      	ldr	r3, [r7, #4]
2000bc20:	681b      	ldr	r3, [r3, #0]
2000bc22:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2000bc26:	601a      	str	r2, [r3, #0]

      /* Enable the DMA transfer by setting the DMAEN bit in the QSPI CR register */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000bc28:	687b      	ldr	r3, [r7, #4]
2000bc2a:	681b      	ldr	r3, [r3, #0]
2000bc2c:	681a      	ldr	r2, [r3, #0]
2000bc2e:	687b      	ldr	r3, [r7, #4]
2000bc30:	681b      	ldr	r3, [r3, #0]
2000bc32:	f042 0204 	orr.w	r2, r2, #4
2000bc36:	601a      	str	r2, [r3, #0]
2000bc38:	e012      	b.n	2000bc60 <HAL_QSPI_Transmit_DMA+0x1cc>
    }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000bc3a:	687b      	ldr	r3, [r7, #4]
2000bc3c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000bc3e:	f043 0208 	orr.w	r2, r3, #8
2000bc42:	687b      	ldr	r3, [r7, #4]
2000bc44:	645a      	str	r2, [r3, #68]	; 0x44
      
      status = HAL_ERROR;
2000bc46:	2301      	movs	r3, #1
2000bc48:	75fb      	strb	r3, [r7, #23]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000bc4a:	687b      	ldr	r3, [r7, #4]
2000bc4c:	2200      	movs	r2, #0
2000bc4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000bc52:	e005      	b.n	2000bc60 <HAL_QSPI_Transmit_DMA+0x1cc>
    }
  }
  else
  {
    status = HAL_BUSY;   
2000bc54:	2302      	movs	r3, #2
2000bc56:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000bc58:	687b      	ldr	r3, [r7, #4]
2000bc5a:	2200      	movs	r2, #0
2000bc5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
2000bc60:	7dfb      	ldrb	r3, [r7, #23]
}
2000bc62:	4618      	mov	r0, r3
2000bc64:	3718      	adds	r7, #24
2000bc66:	46bd      	mov	sp, r7
2000bc68:	bd80      	pop	{r7, pc}
2000bc6a:	bf00      	nop
2000bc6c:	2000c479 	.word	0x2000c479
2000bc70:	2000c4c5 	.word	0x2000c4c5
2000bc74:	2000c4e1 	.word	0x2000c4e1

2000bc78 <HAL_QSPI_Receive_DMA>:
  * @note   If DMA peripheral access is configured as word, the number 
  *         of data and the fifo threshold should be aligned on word
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
2000bc78:	b580      	push	{r7, lr}
2000bc7a:	b086      	sub	sp, #24
2000bc7c:	af00      	add	r7, sp, #0
2000bc7e:	6078      	str	r0, [r7, #4]
2000bc80:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000bc82:	2300      	movs	r3, #0
2000bc84:	75fb      	strb	r3, [r7, #23]
  uint32_t *tmp;
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
2000bc86:	687b      	ldr	r3, [r7, #4]
2000bc88:	681b      	ldr	r3, [r3, #0]
2000bc8a:	699b      	ldr	r3, [r3, #24]
2000bc8c:	613b      	str	r3, [r7, #16]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1);
2000bc8e:	687b      	ldr	r3, [r7, #4]
2000bc90:	681b      	ldr	r3, [r3, #0]
2000bc92:	691b      	ldr	r3, [r3, #16]
2000bc94:	3301      	adds	r3, #1
2000bc96:	60fb      	str	r3, [r7, #12]
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000bc98:	687b      	ldr	r3, [r7, #4]
2000bc9a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000bc9e:	b2db      	uxtb	r3, r3
2000bca0:	2b01      	cmp	r3, #1
2000bca2:	d101      	bne.n	2000bca8 <HAL_QSPI_Receive_DMA+0x30>
2000bca4:	2302      	movs	r3, #2
2000bca6:	e0d8      	b.n	2000be5a <HAL_QSPI_Receive_DMA+0x1e2>
2000bca8:	687b      	ldr	r3, [r7, #4]
2000bcaa:	2201      	movs	r2, #1
2000bcac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  if(hqspi->State == HAL_QSPI_STATE_READY)
2000bcb0:	687b      	ldr	r3, [r7, #4]
2000bcb2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000bcb6:	b2db      	uxtb	r3, r3
2000bcb8:	2b01      	cmp	r3, #1
2000bcba:	f040 80c7 	bne.w	2000be4c <HAL_QSPI_Receive_DMA+0x1d4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000bcbe:	687b      	ldr	r3, [r7, #4]
2000bcc0:	2200      	movs	r2, #0
2000bcc2:	645a      	str	r2, [r3, #68]	; 0x44
    
    if(pData != NULL ) 
2000bcc4:	683b      	ldr	r3, [r7, #0]
2000bcc6:	2b00      	cmp	r3, #0
2000bcc8:	f000 80b3 	beq.w	2000be32 <HAL_QSPI_Receive_DMA+0x1ba>
    {
      /* Configure counters of the handle */
      if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_BYTE)
2000bccc:	687b      	ldr	r3, [r7, #4]
2000bcce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bcd0:	695b      	ldr	r3, [r3, #20]
2000bcd2:	2b00      	cmp	r3, #0
2000bcd4:	d103      	bne.n	2000bcde <HAL_QSPI_Receive_DMA+0x66>
      {
        hqspi->RxXferCount = data_size;
2000bcd6:	687b      	ldr	r3, [r7, #4]
2000bcd8:	68fa      	ldr	r2, [r7, #12]
2000bcda:	639a      	str	r2, [r3, #56]	; 0x38
2000bcdc:	e044      	b.n	2000bd68 <HAL_QSPI_Receive_DMA+0xf0>
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_HALFWORD)
2000bcde:	687b      	ldr	r3, [r7, #4]
2000bce0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bce2:	695b      	ldr	r3, [r3, #20]
2000bce4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2000bce8:	d11c      	bne.n	2000bd24 <HAL_QSPI_Receive_DMA+0xac>
      {
        if (((data_size % 2) != 0) || ((hqspi->Init.FifoThreshold % 2) != 0))
2000bcea:	68fb      	ldr	r3, [r7, #12]
2000bcec:	f003 0301 	and.w	r3, r3, #1
2000bcf0:	2b00      	cmp	r3, #0
2000bcf2:	d105      	bne.n	2000bd00 <HAL_QSPI_Receive_DMA+0x88>
2000bcf4:	687b      	ldr	r3, [r7, #4]
2000bcf6:	689b      	ldr	r3, [r3, #8]
2000bcf8:	f003 0301 	and.w	r3, r3, #1
2000bcfc:	2b00      	cmp	r3, #0
2000bcfe:	d00c      	beq.n	2000bd1a <HAL_QSPI_Receive_DMA+0xa2>
        {
          /* The number of data or the fifo threshold is not aligned on halfword 
          => no transfer possible with DMA peripheral access configured as halfword */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000bd00:	687b      	ldr	r3, [r7, #4]
2000bd02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000bd04:	f043 0208 	orr.w	r2, r3, #8
2000bd08:	687b      	ldr	r3, [r7, #4]
2000bd0a:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
2000bd0c:	2301      	movs	r3, #1
2000bd0e:	75fb      	strb	r3, [r7, #23]
          
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
2000bd10:	687b      	ldr	r3, [r7, #4]
2000bd12:	2200      	movs	r2, #0
2000bd14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000bd18:	e026      	b.n	2000bd68 <HAL_QSPI_Receive_DMA+0xf0>
        }
        else
        {
          hqspi->RxXferCount = (data_size >> 1);
2000bd1a:	68fb      	ldr	r3, [r7, #12]
2000bd1c:	085a      	lsrs	r2, r3, #1
2000bd1e:	687b      	ldr	r3, [r7, #4]
2000bd20:	639a      	str	r2, [r3, #56]	; 0x38
2000bd22:	e021      	b.n	2000bd68 <HAL_QSPI_Receive_DMA+0xf0>
        }
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_WORD)
2000bd24:	687b      	ldr	r3, [r7, #4]
2000bd26:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bd28:	695b      	ldr	r3, [r3, #20]
2000bd2a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2000bd2e:	d11b      	bne.n	2000bd68 <HAL_QSPI_Receive_DMA+0xf0>
      {
        if (((data_size % 4) != 0) || ((hqspi->Init.FifoThreshold % 4) != 0))
2000bd30:	68fb      	ldr	r3, [r7, #12]
2000bd32:	f003 0303 	and.w	r3, r3, #3
2000bd36:	2b00      	cmp	r3, #0
2000bd38:	d105      	bne.n	2000bd46 <HAL_QSPI_Receive_DMA+0xce>
2000bd3a:	687b      	ldr	r3, [r7, #4]
2000bd3c:	689b      	ldr	r3, [r3, #8]
2000bd3e:	f003 0303 	and.w	r3, r3, #3
2000bd42:	2b00      	cmp	r3, #0
2000bd44:	d00c      	beq.n	2000bd60 <HAL_QSPI_Receive_DMA+0xe8>
        {
          /* The number of data or the fifo threshold is not aligned on word 
          => no transfer possible with DMA peripheral access configured as word */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000bd46:	687b      	ldr	r3, [r7, #4]
2000bd48:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000bd4a:	f043 0208 	orr.w	r2, r3, #8
2000bd4e:	687b      	ldr	r3, [r7, #4]
2000bd50:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
2000bd52:	2301      	movs	r3, #1
2000bd54:	75fb      	strb	r3, [r7, #23]
          
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
2000bd56:	687b      	ldr	r3, [r7, #4]
2000bd58:	2200      	movs	r2, #0
2000bd5a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000bd5e:	e003      	b.n	2000bd68 <HAL_QSPI_Receive_DMA+0xf0>
        }
        else
        {
          hqspi->RxXferCount = (data_size >> 2);
2000bd60:	68fb      	ldr	r3, [r7, #12]
2000bd62:	089a      	lsrs	r2, r3, #2
2000bd64:	687b      	ldr	r3, [r7, #4]
2000bd66:	639a      	str	r2, [r3, #56]	; 0x38
        }
      }
      
      if (status == HAL_OK)
2000bd68:	7dfb      	ldrb	r3, [r7, #23]
2000bd6a:	2b00      	cmp	r3, #0
2000bd6c:	d174      	bne.n	2000be58 <HAL_QSPI_Receive_DMA+0x1e0>
      {
        
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
2000bd6e:	687b      	ldr	r3, [r7, #4]
2000bd70:	2222      	movs	r2, #34	; 0x22
2000bd72:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
2000bd76:	687b      	ldr	r3, [r7, #4]
2000bd78:	681b      	ldr	r3, [r3, #0]
2000bd7a:	2203      	movs	r2, #3
2000bd7c:	60da      	str	r2, [r3, #12]
        
        /* Configure size and pointer of the handle */
        hqspi->RxXferSize = hqspi->RxXferCount;
2000bd7e:	687b      	ldr	r3, [r7, #4]
2000bd80:	6b9a      	ldr	r2, [r3, #56]	; 0x38
2000bd82:	687b      	ldr	r3, [r7, #4]
2000bd84:	635a      	str	r2, [r3, #52]	; 0x34
        hqspi->pRxBuffPtr = pData;
2000bd86:	683a      	ldr	r2, [r7, #0]
2000bd88:	687b      	ldr	r3, [r7, #4]
2000bd8a:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* Set the QSPI DMA transfer complete callback */
        hqspi->hdma->XferCpltCallback = QSPI_DMARxCplt;
2000bd8c:	687b      	ldr	r3, [r7, #4]
2000bd8e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bd90:	4a34      	ldr	r2, [pc, #208]	; (2000be64 <HAL_QSPI_Receive_DMA+0x1ec>)
2000bd92:	63da      	str	r2, [r3, #60]	; 0x3c
        
        /* Set the QSPI DMA Half transfer complete callback */
        hqspi->hdma->XferHalfCpltCallback = QSPI_DMARxHalfCplt;
2000bd94:	687b      	ldr	r3, [r7, #4]
2000bd96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bd98:	4a33      	ldr	r2, [pc, #204]	; (2000be68 <HAL_QSPI_Receive_DMA+0x1f0>)
2000bd9a:	641a      	str	r2, [r3, #64]	; 0x40
        
        /* Set the DMA error callback */
        hqspi->hdma->XferErrorCallback = QSPI_DMAError;
2000bd9c:	687b      	ldr	r3, [r7, #4]
2000bd9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bda0:	4a32      	ldr	r2, [pc, #200]	; (2000be6c <HAL_QSPI_Receive_DMA+0x1f4>)
2000bda2:	64da      	str	r2, [r3, #76]	; 0x4c
        
        /* Clear the DMA abort callback */      
        hqspi->hdma->XferAbortCallback = NULL;
2000bda4:	687b      	ldr	r3, [r7, #4]
2000bda6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bda8:	2200      	movs	r2, #0
2000bdaa:	651a      	str	r2, [r3, #80]	; 0x50
        
        /* Configure the direction of the DMA */
        hqspi->hdma->Init.Direction = DMA_PERIPH_TO_MEMORY;
2000bdac:	687b      	ldr	r3, [r7, #4]
2000bdae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bdb0:	2200      	movs	r2, #0
2000bdb2:	609a      	str	r2, [r3, #8]
        MODIFY_REG(hqspi->hdma->Instance->CR, DMA_SxCR_DIR, hqspi->hdma->Init.Direction);
2000bdb4:	687b      	ldr	r3, [r7, #4]
2000bdb6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bdb8:	681b      	ldr	r3, [r3, #0]
2000bdba:	681b      	ldr	r3, [r3, #0]
2000bdbc:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
2000bdc0:	687b      	ldr	r3, [r7, #4]
2000bdc2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bdc4:	689a      	ldr	r2, [r3, #8]
2000bdc6:	687b      	ldr	r3, [r7, #4]
2000bdc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000bdca:	681b      	ldr	r3, [r3, #0]
2000bdcc:	430a      	orrs	r2, r1
2000bdce:	601a      	str	r2, [r3, #0]
        
        /* Enable the DMA Channel */
        tmp = (uint32_t*)&pData;
2000bdd0:	463b      	mov	r3, r7
2000bdd2:	60bb      	str	r3, [r7, #8]
        HAL_DMA_Start_IT(hqspi->hdma, (uint32_t)&hqspi->Instance->DR, *(uint32_t*)tmp, hqspi->RxXferSize);
2000bdd4:	687b      	ldr	r3, [r7, #4]
2000bdd6:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2000bdd8:	687b      	ldr	r3, [r7, #4]
2000bdda:	681b      	ldr	r3, [r3, #0]
2000bddc:	3320      	adds	r3, #32
2000bdde:	4619      	mov	r1, r3
2000bde0:	68bb      	ldr	r3, [r7, #8]
2000bde2:	681a      	ldr	r2, [r3, #0]
2000bde4:	687b      	ldr	r3, [r7, #4]
2000bde6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000bde8:	f7f6 fdd1 	bl	2000298e <HAL_DMA_Start_IT>
        
        /* Configure QSPI: CCR register with functional as indirect read */
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
2000bdec:	687b      	ldr	r3, [r7, #4]
2000bdee:	681b      	ldr	r3, [r3, #0]
2000bdf0:	695b      	ldr	r3, [r3, #20]
2000bdf2:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
2000bdf6:	687b      	ldr	r3, [r7, #4]
2000bdf8:	681b      	ldr	r3, [r3, #0]
2000bdfa:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
2000bdfe:	615a      	str	r2, [r3, #20]
        
        /* Start the transfer by re-writing the address in AR register */
        WRITE_REG(hqspi->Instance->AR, addr_reg);
2000be00:	687b      	ldr	r3, [r7, #4]
2000be02:	681b      	ldr	r3, [r3, #0]
2000be04:	693a      	ldr	r2, [r7, #16]
2000be06:	619a      	str	r2, [r3, #24]
        
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
2000be08:	687b      	ldr	r3, [r7, #4]
2000be0a:	2200      	movs	r2, #0
2000be0c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        
        /* Enable the QSPI transfer error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
2000be10:	687b      	ldr	r3, [r7, #4]
2000be12:	681b      	ldr	r3, [r3, #0]
2000be14:	681a      	ldr	r2, [r3, #0]
2000be16:	687b      	ldr	r3, [r7, #4]
2000be18:	681b      	ldr	r3, [r3, #0]
2000be1a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2000be1e:	601a      	str	r2, [r3, #0]
        
        /* Enable the DMA transfer by setting the DMAEN bit in the QSPI CR register */
        SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000be20:	687b      	ldr	r3, [r7, #4]
2000be22:	681b      	ldr	r3, [r3, #0]
2000be24:	681a      	ldr	r2, [r3, #0]
2000be26:	687b      	ldr	r3, [r7, #4]
2000be28:	681b      	ldr	r3, [r3, #0]
2000be2a:	f042 0204 	orr.w	r2, r2, #4
2000be2e:	601a      	str	r2, [r3, #0]
2000be30:	e012      	b.n	2000be58 <HAL_QSPI_Receive_DMA+0x1e0>
      }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000be32:	687b      	ldr	r3, [r7, #4]
2000be34:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000be36:	f043 0208 	orr.w	r2, r3, #8
2000be3a:	687b      	ldr	r3, [r7, #4]
2000be3c:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2000be3e:	2301      	movs	r3, #1
2000be40:	75fb      	strb	r3, [r7, #23]
      
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000be42:	687b      	ldr	r3, [r7, #4]
2000be44:	2200      	movs	r2, #0
2000be46:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000be4a:	e005      	b.n	2000be58 <HAL_QSPI_Receive_DMA+0x1e0>
    }
  }
  else
  {
    status = HAL_BUSY; 
2000be4c:	2302      	movs	r3, #2
2000be4e:	75fb      	strb	r3, [r7, #23]
    
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000be50:	687b      	ldr	r3, [r7, #4]
2000be52:	2200      	movs	r2, #0
2000be54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }
  
  return status;
2000be58:	7dfb      	ldrb	r3, [r7, #23]
}
2000be5a:	4618      	mov	r0, r3
2000be5c:	3718      	adds	r7, #24
2000be5e:	46bd      	mov	sp, r7
2000be60:	bd80      	pop	{r7, pc}
2000be62:	bf00      	nop
2000be64:	2000c449 	.word	0x2000c449
2000be68:	2000c4a9 	.word	0x2000c4a9
2000be6c:	2000c4e1 	.word	0x2000c4e1

2000be70 <HAL_QSPI_AutoPolling>:
  * @param  Timeout  Time out duration
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
2000be70:	b580      	push	{r7, lr}
2000be72:	b088      	sub	sp, #32
2000be74:	af02      	add	r7, sp, #8
2000be76:	60f8      	str	r0, [r7, #12]
2000be78:	60b9      	str	r1, [r7, #8]
2000be7a:	607a      	str	r2, [r7, #4]
2000be7c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
2000be7e:	2301      	movs	r3, #1
2000be80:	75fb      	strb	r3, [r7, #23]
  uint32_t tickstart = HAL_GetTick();
2000be82:	f7f5 ff7d 	bl	20001d80 <HAL_GetTick>
2000be86:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000be88:	68fb      	ldr	r3, [r7, #12]
2000be8a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000be8e:	b2db      	uxtb	r3, r3
2000be90:	2b01      	cmp	r3, #1
2000be92:	d101      	bne.n	2000be98 <HAL_QSPI_AutoPolling+0x28>
2000be94:	2302      	movs	r3, #2
2000be96:	e060      	b.n	2000bf5a <HAL_QSPI_AutoPolling+0xea>
2000be98:	68fb      	ldr	r3, [r7, #12]
2000be9a:	2201      	movs	r2, #1
2000be9c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  if(hqspi->State == HAL_QSPI_STATE_READY)
2000bea0:	68fb      	ldr	r3, [r7, #12]
2000bea2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000bea6:	b2db      	uxtb	r3, r3
2000bea8:	2b01      	cmp	r3, #1
2000beaa:	d14f      	bne.n	2000bf4c <HAL_QSPI_AutoPolling+0xdc>
  {
    
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000beac:	68fb      	ldr	r3, [r7, #12]
2000beae:	2200      	movs	r2, #0
2000beb0:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
2000beb2:	68fb      	ldr	r3, [r7, #12]
2000beb4:	2242      	movs	r2, #66	; 0x42
2000beb6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
2000beba:	683b      	ldr	r3, [r7, #0]
2000bebc:	9300      	str	r3, [sp, #0]
2000bebe:	693b      	ldr	r3, [r7, #16]
2000bec0:	2200      	movs	r2, #0
2000bec2:	2120      	movs	r1, #32
2000bec4:	68f8      	ldr	r0, [r7, #12]
2000bec6:	f000 fb66 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000beca:	4603      	mov	r3, r0
2000becc:	75fb      	strb	r3, [r7, #23]
    
    if (status == HAL_OK)
2000bece:	7dfb      	ldrb	r3, [r7, #23]
2000bed0:	2b00      	cmp	r3, #0
2000bed2:	d13d      	bne.n	2000bf50 <HAL_QSPI_AutoPolling+0xe0>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
2000bed4:	68fb      	ldr	r3, [r7, #12]
2000bed6:	681b      	ldr	r3, [r3, #0]
2000bed8:	687a      	ldr	r2, [r7, #4]
2000beda:	6812      	ldr	r2, [r2, #0]
2000bedc:	629a      	str	r2, [r3, #40]	; 0x28
      
      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
2000bede:	68fb      	ldr	r3, [r7, #12]
2000bee0:	681b      	ldr	r3, [r3, #0]
2000bee2:	687a      	ldr	r2, [r7, #4]
2000bee4:	6852      	ldr	r2, [r2, #4]
2000bee6:	625a      	str	r2, [r3, #36]	; 0x24
      
      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
2000bee8:	68fb      	ldr	r3, [r7, #12]
2000beea:	681b      	ldr	r3, [r3, #0]
2000beec:	687a      	ldr	r2, [r7, #4]
2000beee:	6892      	ldr	r2, [r2, #8]
2000bef0:	62da      	str	r2, [r3, #44]	; 0x2c
      
      /* Configure QSPI: CR register with Match mode and Automatic stop enabled 
      (otherwise there will be an infinite loop in blocking mode) */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
2000bef2:	68fb      	ldr	r3, [r7, #12]
2000bef4:	681b      	ldr	r3, [r3, #0]
2000bef6:	681b      	ldr	r3, [r3, #0]
2000bef8:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
2000befc:	687b      	ldr	r3, [r7, #4]
2000befe:	691b      	ldr	r3, [r3, #16]
2000bf00:	431a      	orrs	r2, r3
2000bf02:	68fb      	ldr	r3, [r7, #12]
2000bf04:	681b      	ldr	r3, [r3, #0]
2000bf06:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
2000bf0a:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));
      
      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
2000bf0c:	687b      	ldr	r3, [r7, #4]
2000bf0e:	68da      	ldr	r2, [r3, #12]
2000bf10:	68bb      	ldr	r3, [r7, #8]
2000bf12:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
2000bf14:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
2000bf18:	68b9      	ldr	r1, [r7, #8]
2000bf1a:	68f8      	ldr	r0, [r7, #12]
2000bf1c:	f000 fb72 	bl	2000c604 <QSPI_Config>
      
      /* Wait until SM flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
2000bf20:	683b      	ldr	r3, [r7, #0]
2000bf22:	9300      	str	r3, [sp, #0]
2000bf24:	693b      	ldr	r3, [r7, #16]
2000bf26:	2201      	movs	r2, #1
2000bf28:	2108      	movs	r1, #8
2000bf2a:	68f8      	ldr	r0, [r7, #12]
2000bf2c:	f000 fb33 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000bf30:	4603      	mov	r3, r0
2000bf32:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
2000bf34:	7dfb      	ldrb	r3, [r7, #23]
2000bf36:	2b00      	cmp	r3, #0
2000bf38:	d10a      	bne.n	2000bf50 <HAL_QSPI_AutoPolling+0xe0>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
2000bf3a:	68fb      	ldr	r3, [r7, #12]
2000bf3c:	681b      	ldr	r3, [r3, #0]
2000bf3e:	2208      	movs	r2, #8
2000bf40:	60da      	str	r2, [r3, #12]
        
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
2000bf42:	68fb      	ldr	r3, [r7, #12]
2000bf44:	2201      	movs	r2, #1
2000bf46:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2000bf4a:	e001      	b.n	2000bf50 <HAL_QSPI_AutoPolling+0xe0>
      }
    }
  }
  else
  {
    status = HAL_BUSY;   
2000bf4c:	2302      	movs	r3, #2
2000bf4e:	75fb      	strb	r3, [r7, #23]
  }
  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000bf50:	68fb      	ldr	r3, [r7, #12]
2000bf52:	2200      	movs	r2, #0
2000bf54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  /* Return function status */
  return status;  
2000bf58:	7dfb      	ldrb	r3, [r7, #23]
}
2000bf5a:	4618      	mov	r0, r3
2000bf5c:	3718      	adds	r7, #24
2000bf5e:	46bd      	mov	sp, r7
2000bf60:	bd80      	pop	{r7, pc}

2000bf62 <HAL_QSPI_AutoPolling_IT>:
  * @param  cfg structure that contains the polling configuration information.
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
{
2000bf62:	b580      	push	{r7, lr}
2000bf64:	b088      	sub	sp, #32
2000bf66:	af02      	add	r7, sp, #8
2000bf68:	60f8      	str	r0, [r7, #12]
2000bf6a:	60b9      	str	r1, [r7, #8]
2000bf6c:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
2000bf6e:	2301      	movs	r3, #1
2000bf70:	75fb      	strb	r3, [r7, #23]
  uint32_t tickstart = HAL_GetTick();
2000bf72:	f7f5 ff05 	bl	20001d80 <HAL_GetTick>
2000bf76:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
  assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000bf78:	68fb      	ldr	r3, [r7, #12]
2000bf7a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000bf7e:	b2db      	uxtb	r3, r3
2000bf80:	2b01      	cmp	r3, #1
2000bf82:	d101      	bne.n	2000bf88 <HAL_QSPI_AutoPolling_IT+0x26>
2000bf84:	2302      	movs	r3, #2
2000bf86:	e062      	b.n	2000c04e <HAL_QSPI_AutoPolling_IT+0xec>
2000bf88:	68fb      	ldr	r3, [r7, #12]
2000bf8a:	2201      	movs	r2, #1
2000bf8c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  if(hqspi->State == HAL_QSPI_STATE_READY)
2000bf90:	68fb      	ldr	r3, [r7, #12]
2000bf92:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000bf96:	b2db      	uxtb	r3, r3
2000bf98:	2b01      	cmp	r3, #1
2000bf9a:	d151      	bne.n	2000c040 <HAL_QSPI_AutoPolling_IT+0xde>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000bf9c:	68fb      	ldr	r3, [r7, #12]
2000bf9e:	2200      	movs	r2, #0
2000bfa0:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
2000bfa2:	68fb      	ldr	r3, [r7, #12]
2000bfa4:	2242      	movs	r2, #66	; 0x42
2000bfa6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2000bfaa:	68fb      	ldr	r3, [r7, #12]
2000bfac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000bfae:	9300      	str	r3, [sp, #0]
2000bfb0:	693b      	ldr	r3, [r7, #16]
2000bfb2:	2200      	movs	r2, #0
2000bfb4:	2120      	movs	r1, #32
2000bfb6:	68f8      	ldr	r0, [r7, #12]
2000bfb8:	f000 faed 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000bfbc:	4603      	mov	r3, r0
2000bfbe:	75fb      	strb	r3, [r7, #23]
    
    if (status == HAL_OK)
2000bfc0:	7dfb      	ldrb	r3, [r7, #23]
2000bfc2:	2b00      	cmp	r3, #0
2000bfc4:	d137      	bne.n	2000c036 <HAL_QSPI_AutoPolling_IT+0xd4>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
2000bfc6:	68fb      	ldr	r3, [r7, #12]
2000bfc8:	681b      	ldr	r3, [r3, #0]
2000bfca:	687a      	ldr	r2, [r7, #4]
2000bfcc:	6812      	ldr	r2, [r2, #0]
2000bfce:	629a      	str	r2, [r3, #40]	; 0x28
      
      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
2000bfd0:	68fb      	ldr	r3, [r7, #12]
2000bfd2:	681b      	ldr	r3, [r3, #0]
2000bfd4:	687a      	ldr	r2, [r7, #4]
2000bfd6:	6852      	ldr	r2, [r2, #4]
2000bfd8:	625a      	str	r2, [r3, #36]	; 0x24
      
      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
2000bfda:	68fb      	ldr	r3, [r7, #12]
2000bfdc:	681b      	ldr	r3, [r3, #0]
2000bfde:	687a      	ldr	r2, [r7, #4]
2000bfe0:	6892      	ldr	r2, [r2, #8]
2000bfe2:	62da      	str	r2, [r3, #44]	; 0x2c
      
      /* Configure QSPI: CR register with Match mode and Automatic stop mode */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
2000bfe4:	68fb      	ldr	r3, [r7, #12]
2000bfe6:	681b      	ldr	r3, [r3, #0]
2000bfe8:	681b      	ldr	r3, [r3, #0]
2000bfea:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
2000bfee:	687b      	ldr	r3, [r7, #4]
2000bff0:	691a      	ldr	r2, [r3, #16]
2000bff2:	687b      	ldr	r3, [r7, #4]
2000bff4:	695b      	ldr	r3, [r3, #20]
2000bff6:	431a      	orrs	r2, r3
2000bff8:	68fb      	ldr	r3, [r7, #12]
2000bffa:	681b      	ldr	r3, [r3, #0]
2000bffc:	430a      	orrs	r2, r1
2000bffe:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | cfg->AutomaticStop));
      
      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
2000c000:	68fb      	ldr	r3, [r7, #12]
2000c002:	681b      	ldr	r3, [r3, #0]
2000c004:	2209      	movs	r2, #9
2000c006:	60da      	str	r2, [r3, #12]
      
      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
2000c008:	687b      	ldr	r3, [r7, #4]
2000c00a:	68da      	ldr	r2, [r3, #12]
2000c00c:	68bb      	ldr	r3, [r7, #8]
2000c00e:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
2000c010:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
2000c014:	68b9      	ldr	r1, [r7, #8]
2000c016:	68f8      	ldr	r0, [r7, #12]
2000c018:	f000 faf4 	bl	2000c604 <QSPI_Config>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000c01c:	68fb      	ldr	r3, [r7, #12]
2000c01e:	2200      	movs	r2, #0
2000c020:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
      /* Enable the QSPI Transfer Error and status match Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
2000c024:	68fb      	ldr	r3, [r7, #12]
2000c026:	681b      	ldr	r3, [r3, #0]
2000c028:	681a      	ldr	r2, [r3, #0]
2000c02a:	68fb      	ldr	r3, [r7, #12]
2000c02c:	681b      	ldr	r3, [r3, #0]
2000c02e:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
2000c032:	601a      	str	r2, [r3, #0]
2000c034:	e00a      	b.n	2000c04c <HAL_QSPI_AutoPolling_IT+0xea>

    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000c036:	68fb      	ldr	r3, [r7, #12]
2000c038:	2200      	movs	r2, #0
2000c03a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2000c03e:	e005      	b.n	2000c04c <HAL_QSPI_AutoPolling_IT+0xea>
    }
  }
  else
  {
    status = HAL_BUSY;   
2000c040:	2302      	movs	r3, #2
2000c042:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000c044:	68fb      	ldr	r3, [r7, #12]
2000c046:	2200      	movs	r2, #0
2000c048:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }
  
  /* Return function status */
  return status;  
2000c04c:	7dfb      	ldrb	r3, [r7, #23]
}
2000c04e:	4618      	mov	r0, r3
2000c050:	3718      	adds	r7, #24
2000c052:	46bd      	mov	sp, r7
2000c054:	bd80      	pop	{r7, pc}

2000c056 <HAL_QSPI_MemoryMapped>:
  * @param  cfg structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
{
2000c056:	b580      	push	{r7, lr}
2000c058:	b088      	sub	sp, #32
2000c05a:	af02      	add	r7, sp, #8
2000c05c:	60f8      	str	r0, [r7, #12]
2000c05e:	60b9      	str	r1, [r7, #8]
2000c060:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
2000c062:	2301      	movs	r3, #1
2000c064:	75fb      	strb	r3, [r7, #23]
  uint32_t tickstart = HAL_GetTick();
2000c066:	f7f5 fe8b 	bl	20001d80 <HAL_GetTick>
2000c06a:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));
  
  /* Process locked */
  __HAL_LOCK(hqspi);
2000c06c:	68fb      	ldr	r3, [r7, #12]
2000c06e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000c072:	b2db      	uxtb	r3, r3
2000c074:	2b01      	cmp	r3, #1
2000c076:	d101      	bne.n	2000c07c <HAL_QSPI_MemoryMapped+0x26>
2000c078:	2302      	movs	r3, #2
2000c07a:	e04c      	b.n	2000c116 <HAL_QSPI_MemoryMapped+0xc0>
2000c07c:	68fb      	ldr	r3, [r7, #12]
2000c07e:	2201      	movs	r2, #1
2000c080:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  if(hqspi->State == HAL_QSPI_STATE_READY)
2000c084:	68fb      	ldr	r3, [r7, #12]
2000c086:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000c08a:	b2db      	uxtb	r3, r3
2000c08c:	2b01      	cmp	r3, #1
2000c08e:	d13b      	bne.n	2000c108 <HAL_QSPI_MemoryMapped+0xb2>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2000c090:	68fb      	ldr	r3, [r7, #12]
2000c092:	2200      	movs	r2, #0
2000c094:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
2000c096:	68fb      	ldr	r3, [r7, #12]
2000c098:	2282      	movs	r2, #130	; 0x82
2000c09a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2000c09e:	68fb      	ldr	r3, [r7, #12]
2000c0a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000c0a2:	9300      	str	r3, [sp, #0]
2000c0a4:	693b      	ldr	r3, [r7, #16]
2000c0a6:	2200      	movs	r2, #0
2000c0a8:	2120      	movs	r1, #32
2000c0aa:	68f8      	ldr	r0, [r7, #12]
2000c0ac:	f000 fa73 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000c0b0:	4603      	mov	r3, r0
2000c0b2:	75fb      	strb	r3, [r7, #23]
    
    if (status == HAL_OK)
2000c0b4:	7dfb      	ldrb	r3, [r7, #23]
2000c0b6:	2b00      	cmp	r3, #0
2000c0b8:	d128      	bne.n	2000c10c <HAL_QSPI_MemoryMapped+0xb6>
    {
      /* Configure QSPI: CR register with timeout counter enable */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
2000c0ba:	68fb      	ldr	r3, [r7, #12]
2000c0bc:	681b      	ldr	r3, [r3, #0]
2000c0be:	681b      	ldr	r3, [r3, #0]
2000c0c0:	f023 0108 	bic.w	r1, r3, #8
2000c0c4:	687b      	ldr	r3, [r7, #4]
2000c0c6:	685a      	ldr	r2, [r3, #4]
2000c0c8:	68fb      	ldr	r3, [r7, #12]
2000c0ca:	681b      	ldr	r3, [r3, #0]
2000c0cc:	430a      	orrs	r2, r1
2000c0ce:	601a      	str	r2, [r3, #0]

    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
2000c0d0:	687b      	ldr	r3, [r7, #4]
2000c0d2:	685b      	ldr	r3, [r3, #4]
2000c0d4:	2b08      	cmp	r3, #8
2000c0d6:	d110      	bne.n	2000c0fa <HAL_QSPI_MemoryMapped+0xa4>
      {
        assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));
        
        /* Configure QSPI: LPTR register with the low-power timeout value */
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
2000c0d8:	68fb      	ldr	r3, [r7, #12]
2000c0da:	681b      	ldr	r3, [r3, #0]
2000c0dc:	687a      	ldr	r2, [r7, #4]
2000c0de:	6812      	ldr	r2, [r2, #0]
2000c0e0:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
2000c0e2:	68fb      	ldr	r3, [r7, #12]
2000c0e4:	681b      	ldr	r3, [r3, #0]
2000c0e6:	2210      	movs	r2, #16
2000c0e8:	60da      	str	r2, [r3, #12]

        /* Enable the QSPI TimeOut Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
2000c0ea:	68fb      	ldr	r3, [r7, #12]
2000c0ec:	681b      	ldr	r3, [r3, #0]
2000c0ee:	681a      	ldr	r2, [r3, #0]
2000c0f0:	68fb      	ldr	r3, [r7, #12]
2000c0f2:	681b      	ldr	r3, [r3, #0]
2000c0f4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
2000c0f8:	601a      	str	r2, [r3, #0]
      }
      
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
2000c0fa:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
2000c0fe:	68b9      	ldr	r1, [r7, #8]
2000c100:	68f8      	ldr	r0, [r7, #12]
2000c102:	f000 fa7f 	bl	2000c604 <QSPI_Config>
2000c106:	e001      	b.n	2000c10c <HAL_QSPI_MemoryMapped+0xb6>
    }
  }
  else
  {
    status = HAL_BUSY;   
2000c108:	2302      	movs	r3, #2
2000c10a:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000c10c:	68fb      	ldr	r3, [r7, #12]
2000c10e:	2200      	movs	r2, #0
2000c110:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  
  /* Return function status */
  return status;  
2000c114:	7dfb      	ldrb	r3, [r7, #23]
}
2000c116:	4618      	mov	r0, r3
2000c118:	3718      	adds	r7, #24
2000c11a:	46bd      	mov	sp, r7
2000c11c:	bd80      	pop	{r7, pc}

2000c11e <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callbacks
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
2000c11e:	b480      	push	{r7}
2000c120:	b083      	sub	sp, #12
2000c122:	af00      	add	r7, sp, #0
2000c124:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
2000c126:	bf00      	nop
2000c128:	370c      	adds	r7, #12
2000c12a:	46bd      	mov	sp, r7
2000c12c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c130:	4770      	bx	lr

2000c132 <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000c132:	b480      	push	{r7}
2000c134:	b083      	sub	sp, #12
2000c136:	af00      	add	r7, sp, #0
2000c138:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
2000c13a:	bf00      	nop
2000c13c:	370c      	adds	r7, #12
2000c13e:	46bd      	mov	sp, r7
2000c140:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c144:	4770      	bx	lr

2000c146 <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000c146:	b480      	push	{r7}
2000c148:	b083      	sub	sp, #12
2000c14a:	af00      	add	r7, sp, #0
2000c14c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
2000c14e:	bf00      	nop
2000c150:	370c      	adds	r7, #12
2000c152:	46bd      	mov	sp, r7
2000c154:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c158:	4770      	bx	lr

2000c15a <HAL_QSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callbacks.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000c15a:	b480      	push	{r7}
2000c15c:	b083      	sub	sp, #12
2000c15e:	af00      	add	r7, sp, #0
2000c160:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_QSPI_RxCpltCallback could be implemented in the user file
   */
}
2000c162:	bf00      	nop
2000c164:	370c      	adds	r7, #12
2000c166:	46bd      	mov	sp, r7
2000c168:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c16c:	4770      	bx	lr

2000c16e <HAL_QSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callbacks.
  * @param  hqspi QSPI handle
  * @retval None
  */
 __weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000c16e:	b480      	push	{r7}
2000c170:	b083      	sub	sp, #12
2000c172:	af00      	add	r7, sp, #0
2000c174:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_QSPI_TxCpltCallback could be implemented in the user file
   */ 
}
2000c176:	bf00      	nop
2000c178:	370c      	adds	r7, #12
2000c17a:	46bd      	mov	sp, r7
2000c17c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c180:	4770      	bx	lr

2000c182 <HAL_QSPI_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callbacks.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxHalfCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000c182:	b480      	push	{r7}
2000c184:	b083      	sub	sp, #12
2000c186:	af00      	add	r7, sp, #0
2000c188:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_QSPI_RxHalfCpltCallback could be implemented in the user file
   */
}
2000c18a:	bf00      	nop
2000c18c:	370c      	adds	r7, #12
2000c18e:	46bd      	mov	sp, r7
2000c190:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c194:	4770      	bx	lr

2000c196 <HAL_QSPI_TxHalfCpltCallback>:
  * @brief  Tx Half Transfer completed callbacks.
  * @param  hqspi QSPI handle
  * @retval None
  */
 __weak void HAL_QSPI_TxHalfCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000c196:	b480      	push	{r7}
2000c198:	b083      	sub	sp, #12
2000c19a:	af00      	add	r7, sp, #0
2000c19c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_QSPI_TxHalfCpltCallback could be implemented in the user file
   */ 
}
2000c19e:	bf00      	nop
2000c1a0:	370c      	adds	r7, #12
2000c1a2:	46bd      	mov	sp, r7
2000c1a4:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c1a8:	4770      	bx	lr

2000c1aa <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callbacks
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
2000c1aa:	b480      	push	{r7}
2000c1ac:	b083      	sub	sp, #12
2000c1ae:	af00      	add	r7, sp, #0
2000c1b0:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
2000c1b2:	bf00      	nop
2000c1b4:	370c      	adds	r7, #12
2000c1b6:	46bd      	mov	sp, r7
2000c1b8:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c1bc:	4770      	bx	lr

2000c1be <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callbacks
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
2000c1be:	b480      	push	{r7}
2000c1c0:	b083      	sub	sp, #12
2000c1c2:	af00      	add	r7, sp, #0
2000c1c4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
    
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
2000c1c6:	bf00      	nop
2000c1c8:	370c      	adds	r7, #12
2000c1ca:	46bd      	mov	sp, r7
2000c1cc:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c1d0:	4770      	bx	lr

2000c1d2 <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callbacks
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
2000c1d2:	b480      	push	{r7}
2000c1d4:	b083      	sub	sp, #12
2000c1d6:	af00      	add	r7, sp, #0
2000c1d8:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);
  
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
2000c1da:	bf00      	nop
2000c1dc:	370c      	adds	r7, #12
2000c1de:	46bd      	mov	sp, r7
2000c1e0:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c1e4:	4770      	bx	lr

2000c1e6 <HAL_QSPI_GetState>:
  * @brief  Return the QSPI handle state.
  * @param  hqspi QSPI handle
  * @retval HAL state
  */
HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
{
2000c1e6:	b480      	push	{r7}
2000c1e8:	b083      	sub	sp, #12
2000c1ea:	af00      	add	r7, sp, #0
2000c1ec:	6078      	str	r0, [r7, #4]
  /* Return QSPI handle state */
  return hqspi->State;
2000c1ee:	687b      	ldr	r3, [r7, #4]
2000c1f0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000c1f4:	b2db      	uxtb	r3, r3
}
2000c1f6:	4618      	mov	r0, r3
2000c1f8:	370c      	adds	r7, #12
2000c1fa:	46bd      	mov	sp, r7
2000c1fc:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c200:	4770      	bx	lr

2000c202 <HAL_QSPI_GetError>:
* @brief  Return the QSPI error code
* @param  hqspi QSPI handle
* @retval QSPI Error Code
*/
uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
{
2000c202:	b480      	push	{r7}
2000c204:	b083      	sub	sp, #12
2000c206:	af00      	add	r7, sp, #0
2000c208:	6078      	str	r0, [r7, #4]
  return hqspi->ErrorCode;
2000c20a:	687b      	ldr	r3, [r7, #4]
2000c20c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2000c20e:	4618      	mov	r0, r3
2000c210:	370c      	adds	r7, #12
2000c212:	46bd      	mov	sp, r7
2000c214:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c218:	4770      	bx	lr

2000c21a <HAL_QSPI_Abort>:
* @brief  Abort the current transmission
* @param  hqspi QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
{
2000c21a:	b580      	push	{r7, lr}
2000c21c:	b086      	sub	sp, #24
2000c21e:	af02      	add	r7, sp, #8
2000c220:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2000c222:	2300      	movs	r3, #0
2000c224:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
2000c226:	f7f5 fdab 	bl	20001d80 <HAL_GetTick>
2000c22a:	60b8      	str	r0, [r7, #8]
  
  /* Check if the state is in one of the busy states */
  if ((hqspi->State & 0x2) != 0)
2000c22c:	687b      	ldr	r3, [r7, #4]
2000c22e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000c232:	b2db      	uxtb	r3, r3
2000c234:	f003 0302 	and.w	r3, r3, #2
2000c238:	2b00      	cmp	r3, #0
2000c23a:	d04e      	beq.n	2000c2da <HAL_QSPI_Abort+0xc0>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000c23c:	687b      	ldr	r3, [r7, #4]
2000c23e:	2200      	movs	r2, #0
2000c240:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000c244:	687b      	ldr	r3, [r7, #4]
2000c246:	681b      	ldr	r3, [r3, #0]
2000c248:	681b      	ldr	r3, [r3, #0]
2000c24a:	f003 0304 	and.w	r3, r3, #4
2000c24e:	2b00      	cmp	r3, #0
2000c250:	d017      	beq.n	2000c282 <HAL_QSPI_Abort+0x68>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000c252:	687b      	ldr	r3, [r7, #4]
2000c254:	681b      	ldr	r3, [r3, #0]
2000c256:	681a      	ldr	r2, [r3, #0]
2000c258:	687b      	ldr	r3, [r7, #4]
2000c25a:	681b      	ldr	r3, [r3, #0]
2000c25c:	f022 0204 	bic.w	r2, r2, #4
2000c260:	601a      	str	r2, [r3, #0]
      
      /* Abort DMA channel */
      status = HAL_DMA_Abort(hqspi->hdma);
2000c262:	687b      	ldr	r3, [r7, #4]
2000c264:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000c266:	4618      	mov	r0, r3
2000c268:	f7f6 fbf1 	bl	20002a4e <HAL_DMA_Abort>
2000c26c:	4603      	mov	r3, r0
2000c26e:	73fb      	strb	r3, [r7, #15]
      if(status != HAL_OK)
2000c270:	7bfb      	ldrb	r3, [r7, #15]
2000c272:	2b00      	cmp	r3, #0
2000c274:	d005      	beq.n	2000c282 <HAL_QSPI_Abort+0x68>
      {
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2000c276:	687b      	ldr	r3, [r7, #4]
2000c278:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000c27a:	f043 0204 	orr.w	r2, r3, #4
2000c27e:	687b      	ldr	r3, [r7, #4]
2000c280:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }  
    
    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
2000c282:	687b      	ldr	r3, [r7, #4]
2000c284:	681b      	ldr	r3, [r3, #0]
2000c286:	681a      	ldr	r2, [r3, #0]
2000c288:	687b      	ldr	r3, [r7, #4]
2000c28a:	681b      	ldr	r3, [r3, #0]
2000c28c:	f042 0202 	orr.w	r2, r2, #2
2000c290:	601a      	str	r2, [r3, #0]
    
    /* Wait until TC flag is set to go back in idle state */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
2000c292:	687b      	ldr	r3, [r7, #4]
2000c294:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000c296:	9300      	str	r3, [sp, #0]
2000c298:	68bb      	ldr	r3, [r7, #8]
2000c29a:	2201      	movs	r2, #1
2000c29c:	2102      	movs	r1, #2
2000c29e:	6878      	ldr	r0, [r7, #4]
2000c2a0:	f000 f979 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000c2a4:	4603      	mov	r3, r0
2000c2a6:	73fb      	strb	r3, [r7, #15]

    if(status == HAL_OK)
2000c2a8:	7bfb      	ldrb	r3, [r7, #15]
2000c2aa:	2b00      	cmp	r3, #0
2000c2ac:	d10e      	bne.n	2000c2cc <HAL_QSPI_Abort+0xb2>
    {
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000c2ae:	687b      	ldr	r3, [r7, #4]
2000c2b0:	681b      	ldr	r3, [r3, #0]
2000c2b2:	2202      	movs	r2, #2
2000c2b4:	60da      	str	r2, [r3, #12]
      
      /* Wait until BUSY flag is reset */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2000c2b6:	687b      	ldr	r3, [r7, #4]
2000c2b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000c2ba:	9300      	str	r3, [sp, #0]
2000c2bc:	68bb      	ldr	r3, [r7, #8]
2000c2be:	2200      	movs	r2, #0
2000c2c0:	2120      	movs	r1, #32
2000c2c2:	6878      	ldr	r0, [r7, #4]
2000c2c4:	f000 f967 	bl	2000c596 <QSPI_WaitFlagStateUntilTimeout>
2000c2c8:	4603      	mov	r3, r0
2000c2ca:	73fb      	strb	r3, [r7, #15]
    }
    
    if (status == HAL_OK)
2000c2cc:	7bfb      	ldrb	r3, [r7, #15]
2000c2ce:	2b00      	cmp	r3, #0
2000c2d0:	d103      	bne.n	2000c2da <HAL_QSPI_Abort+0xc0>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_READY;
2000c2d2:	687b      	ldr	r3, [r7, #4]
2000c2d4:	2201      	movs	r2, #1
2000c2d6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
  }

  return status;
2000c2da:	7bfb      	ldrb	r3, [r7, #15]
}
2000c2dc:	4618      	mov	r0, r3
2000c2de:	3710      	adds	r7, #16
2000c2e0:	46bd      	mov	sp, r7
2000c2e2:	bd80      	pop	{r7, pc}

2000c2e4 <HAL_QSPI_Abort_IT>:
* @brief  Abort the current transmission (non-blocking function)
* @param  hqspi QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
{
2000c2e4:	b580      	push	{r7, lr}
2000c2e6:	b084      	sub	sp, #16
2000c2e8:	af00      	add	r7, sp, #0
2000c2ea:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2000c2ec:	2300      	movs	r3, #0
2000c2ee:	73fb      	strb	r3, [r7, #15]
  
  /* Check if the state is in one of the busy states */
  if ((hqspi->State & 0x2) != 0)
2000c2f0:	687b      	ldr	r3, [r7, #4]
2000c2f2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000c2f6:	b2db      	uxtb	r3, r3
2000c2f8:	f003 0302 	and.w	r3, r3, #2
2000c2fc:	2b00      	cmp	r3, #0
2000c2fe:	d046      	beq.n	2000c38e <HAL_QSPI_Abort_IT+0xaa>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000c300:	687b      	ldr	r3, [r7, #4]
2000c302:	2200      	movs	r2, #0
2000c304:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    
    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_ABORT;   
2000c308:	687b      	ldr	r3, [r7, #4]
2000c30a:	2208      	movs	r2, #8
2000c30c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    
    /* Disable all interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
2000c310:	687b      	ldr	r3, [r7, #4]
2000c312:	681b      	ldr	r3, [r3, #0]
2000c314:	681a      	ldr	r2, [r3, #0]
2000c316:	687b      	ldr	r3, [r7, #4]
2000c318:	681b      	ldr	r3, [r3, #0]
2000c31a:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
2000c31e:	601a      	str	r2, [r3, #0]
    
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
2000c320:	687b      	ldr	r3, [r7, #4]
2000c322:	681b      	ldr	r3, [r3, #0]
2000c324:	681b      	ldr	r3, [r3, #0]
2000c326:	f003 0304 	and.w	r3, r3, #4
2000c32a:	2b00      	cmp	r3, #0
2000c32c:	d01b      	beq.n	2000c366 <HAL_QSPI_Abort_IT+0x82>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000c32e:	687b      	ldr	r3, [r7, #4]
2000c330:	681b      	ldr	r3, [r3, #0]
2000c332:	681a      	ldr	r2, [r3, #0]
2000c334:	687b      	ldr	r3, [r7, #4]
2000c336:	681b      	ldr	r3, [r3, #0]
2000c338:	f022 0204 	bic.w	r2, r2, #4
2000c33c:	601a      	str	r2, [r3, #0]
      
      /* Abort DMA channel */
      hqspi->hdma->XferAbortCallback = QSPI_DMAAbortCplt;
2000c33e:	687b      	ldr	r3, [r7, #4]
2000c340:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000c342:	4a15      	ldr	r2, [pc, #84]	; (2000c398 <HAL_QSPI_Abort_IT+0xb4>)
2000c344:	651a      	str	r2, [r3, #80]	; 0x50
      if (HAL_DMA_Abort_IT(hqspi->hdma) != HAL_OK)
2000c346:	687b      	ldr	r3, [r7, #4]
2000c348:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000c34a:	4618      	mov	r0, r3
2000c34c:	f7f6 fbef 	bl	20002b2e <HAL_DMA_Abort_IT>
2000c350:	4603      	mov	r3, r0
2000c352:	2b00      	cmp	r3, #0
2000c354:	d01b      	beq.n	2000c38e <HAL_QSPI_Abort_IT+0xaa>
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
2000c356:	687b      	ldr	r3, [r7, #4]
2000c358:	2201      	movs	r2, #1
2000c35a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        
        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
2000c35e:	6878      	ldr	r0, [r7, #4]
2000c360:	f7ff fee7 	bl	2000c132 <HAL_QSPI_AbortCpltCallback>
2000c364:	e013      	b.n	2000c38e <HAL_QSPI_Abort_IT+0xaa>
      }
    }
    else
    {
      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000c366:	687b      	ldr	r3, [r7, #4]
2000c368:	681b      	ldr	r3, [r3, #0]
2000c36a:	2202      	movs	r2, #2
2000c36c:	60da      	str	r2, [r3, #12]
      
      /* Enable the QSPI Transfer Complete Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
2000c36e:	687b      	ldr	r3, [r7, #4]
2000c370:	681b      	ldr	r3, [r3, #0]
2000c372:	681a      	ldr	r2, [r3, #0]
2000c374:	687b      	ldr	r3, [r7, #4]
2000c376:	681b      	ldr	r3, [r3, #0]
2000c378:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2000c37c:	601a      	str	r2, [r3, #0]
      
      /* Configure QSPI: CR register with Abort request */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
2000c37e:	687b      	ldr	r3, [r7, #4]
2000c380:	681b      	ldr	r3, [r3, #0]
2000c382:	681a      	ldr	r2, [r3, #0]
2000c384:	687b      	ldr	r3, [r7, #4]
2000c386:	681b      	ldr	r3, [r3, #0]
2000c388:	f042 0202 	orr.w	r2, r2, #2
2000c38c:	601a      	str	r2, [r3, #0]
    }
  }

  return status;
2000c38e:	7bfb      	ldrb	r3, [r7, #15]
}
2000c390:	4618      	mov	r0, r3
2000c392:	3710      	adds	r7, #16
2000c394:	46bd      	mov	sp, r7
2000c396:	bd80      	pop	{r7, pc}
2000c398:	2000c531 	.word	0x2000c531

2000c39c <HAL_QSPI_SetTimeout>:
  * @param  hqspi QSPI handle.
  * @param  Timeout Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
2000c39c:	b480      	push	{r7}
2000c39e:	b083      	sub	sp, #12
2000c3a0:	af00      	add	r7, sp, #0
2000c3a2:	6078      	str	r0, [r7, #4]
2000c3a4:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
2000c3a6:	687b      	ldr	r3, [r7, #4]
2000c3a8:	683a      	ldr	r2, [r7, #0]
2000c3aa:	649a      	str	r2, [r3, #72]	; 0x48
}
2000c3ac:	bf00      	nop
2000c3ae:	370c      	adds	r7, #12
2000c3b0:	46bd      	mov	sp, r7
2000c3b2:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c3b6:	4770      	bx	lr

2000c3b8 <HAL_QSPI_SetFifoThreshold>:
  * @param  hqspi QSPI handle.
  * @param  Threshold Threshold of the Fifo (value between 1 and 16).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
{
2000c3b8:	b480      	push	{r7}
2000c3ba:	b085      	sub	sp, #20
2000c3bc:	af00      	add	r7, sp, #0
2000c3be:	6078      	str	r0, [r7, #4]
2000c3c0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000c3c2:	2300      	movs	r3, #0
2000c3c4:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
2000c3c6:	687b      	ldr	r3, [r7, #4]
2000c3c8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000c3cc:	b2db      	uxtb	r3, r3
2000c3ce:	2b01      	cmp	r3, #1
2000c3d0:	d101      	bne.n	2000c3d6 <HAL_QSPI_SetFifoThreshold+0x1e>
2000c3d2:	2302      	movs	r3, #2
2000c3d4:	e021      	b.n	2000c41a <HAL_QSPI_SetFifoThreshold+0x62>
2000c3d6:	687b      	ldr	r3, [r7, #4]
2000c3d8:	2201      	movs	r2, #1
2000c3da:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000c3de:	687b      	ldr	r3, [r7, #4]
2000c3e0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000c3e4:	b2db      	uxtb	r3, r3
2000c3e6:	2b01      	cmp	r3, #1
2000c3e8:	d110      	bne.n	2000c40c <HAL_QSPI_SetFifoThreshold+0x54>
  {
    /* Synchronize init structure with new FIFO threshold value */
    hqspi->Init.FifoThreshold = Threshold;
2000c3ea:	687b      	ldr	r3, [r7, #4]
2000c3ec:	683a      	ldr	r2, [r7, #0]
2000c3ee:	609a      	str	r2, [r3, #8]
    
    /* Configure QSPI FIFO Threshold */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, 
2000c3f0:	687b      	ldr	r3, [r7, #4]
2000c3f2:	681b      	ldr	r3, [r3, #0]
2000c3f4:	681b      	ldr	r3, [r3, #0]
2000c3f6:	f423 51f8 	bic.w	r1, r3, #7936	; 0x1f00
2000c3fa:	687b      	ldr	r3, [r7, #4]
2000c3fc:	689b      	ldr	r3, [r3, #8]
2000c3fe:	3b01      	subs	r3, #1
2000c400:	021a      	lsls	r2, r3, #8
2000c402:	687b      	ldr	r3, [r7, #4]
2000c404:	681b      	ldr	r3, [r3, #0]
2000c406:	430a      	orrs	r2, r1
2000c408:	601a      	str	r2, [r3, #0]
2000c40a:	e001      	b.n	2000c410 <HAL_QSPI_SetFifoThreshold+0x58>
               ((hqspi->Init.FifoThreshold - 1) << QUADSPI_CR_FTHRES_Pos));
  }
  else
  {
    status = HAL_BUSY;   
2000c40c:	2302      	movs	r3, #2
2000c40e:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000c410:	687b      	ldr	r3, [r7, #4]
2000c412:	2200      	movs	r2, #0
2000c414:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
2000c418:	7bfb      	ldrb	r3, [r7, #15]
}
2000c41a:	4618      	mov	r0, r3
2000c41c:	3714      	adds	r7, #20
2000c41e:	46bd      	mov	sp, r7
2000c420:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c424:	4770      	bx	lr

2000c426 <HAL_QSPI_GetFifoThreshold>:
/** @brief Get QSPI Fifo threshold.
  * @param  hqspi QSPI handle.
  * @retval Fifo threshold (value between 1 and 16)
  */
uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
{
2000c426:	b480      	push	{r7}
2000c428:	b083      	sub	sp, #12
2000c42a:	af00      	add	r7, sp, #0
2000c42c:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1);
2000c42e:	687b      	ldr	r3, [r7, #4]
2000c430:	681b      	ldr	r3, [r3, #0]
2000c432:	681b      	ldr	r3, [r3, #0]
2000c434:	0a1b      	lsrs	r3, r3, #8
2000c436:	f003 031f 	and.w	r3, r3, #31
2000c43a:	3301      	adds	r3, #1
}
2000c43c:	4618      	mov	r0, r3
2000c43e:	370c      	adds	r7, #12
2000c440:	46bd      	mov	sp, r7
2000c442:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c446:	4770      	bx	lr

2000c448 <QSPI_DMARxCplt>:
  * @brief  DMA QSPI receive process complete callback. 
  * @param  hdma DMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(DMA_HandleTypeDef *hdma)  
{
2000c448:	b480      	push	{r7}
2000c44a:	b085      	sub	sp, #20
2000c44c:	af00      	add	r7, sp, #0
2000c44e:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
2000c450:	687b      	ldr	r3, [r7, #4]
2000c452:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000c454:	60fb      	str	r3, [r7, #12]
  hqspi->RxXferCount = 0;
2000c456:	68fb      	ldr	r3, [r7, #12]
2000c458:	2200      	movs	r2, #0
2000c45a:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
2000c45c:	68fb      	ldr	r3, [r7, #12]
2000c45e:	681b      	ldr	r3, [r3, #0]
2000c460:	681a      	ldr	r2, [r3, #0]
2000c462:	68fb      	ldr	r3, [r7, #12]
2000c464:	681b      	ldr	r3, [r3, #0]
2000c466:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2000c46a:	601a      	str	r2, [r3, #0]
}
2000c46c:	bf00      	nop
2000c46e:	3714      	adds	r7, #20
2000c470:	46bd      	mov	sp, r7
2000c472:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c476:	4770      	bx	lr

2000c478 <QSPI_DMATxCplt>:
  * @brief  DMA QSPI transmit process complete callback. 
  * @param  hdma DMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(DMA_HandleTypeDef *hdma)     
{
2000c478:	b480      	push	{r7}
2000c47a:	b085      	sub	sp, #20
2000c47c:	af00      	add	r7, sp, #0
2000c47e:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
2000c480:	687b      	ldr	r3, [r7, #4]
2000c482:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000c484:	60fb      	str	r3, [r7, #12]
  hqspi->TxXferCount = 0;
2000c486:	68fb      	ldr	r3, [r7, #12]
2000c488:	2200      	movs	r2, #0
2000c48a:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
2000c48c:	68fb      	ldr	r3, [r7, #12]
2000c48e:	681b      	ldr	r3, [r3, #0]
2000c490:	681a      	ldr	r2, [r3, #0]
2000c492:	68fb      	ldr	r3, [r7, #12]
2000c494:	681b      	ldr	r3, [r3, #0]
2000c496:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2000c49a:	601a      	str	r2, [r3, #0]
}
2000c49c:	bf00      	nop
2000c49e:	3714      	adds	r7, #20
2000c4a0:	46bd      	mov	sp, r7
2000c4a2:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c4a6:	4770      	bx	lr

2000c4a8 <QSPI_DMARxHalfCplt>:
  * @brief  DMA QSPI receive process half complete callback 
  * @param  hdma  DMA handle
  * @retval None
  */
static void QSPI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
2000c4a8:	b580      	push	{r7, lr}
2000c4aa:	b084      	sub	sp, #16
2000c4ac:	af00      	add	r7, sp, #0
2000c4ae:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
2000c4b0:	687b      	ldr	r3, [r7, #4]
2000c4b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000c4b4:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
  hqspi->RxHalfCpltCallback(hqspi);
#else
  HAL_QSPI_RxHalfCpltCallback(hqspi);
2000c4b6:	68f8      	ldr	r0, [r7, #12]
2000c4b8:	f7ff fe63 	bl	2000c182 <HAL_QSPI_RxHalfCpltCallback>
#endif
}
2000c4bc:	bf00      	nop
2000c4be:	3710      	adds	r7, #16
2000c4c0:	46bd      	mov	sp, r7
2000c4c2:	bd80      	pop	{r7, pc}

2000c4c4 <QSPI_DMATxHalfCplt>:
  * @brief  DMA QSPI transmit process half complete callback 
  * @param  hdma  DMA handle
  * @retval None
  */
static void QSPI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
2000c4c4:	b580      	push	{r7, lr}
2000c4c6:	b084      	sub	sp, #16
2000c4c8:	af00      	add	r7, sp, #0
2000c4ca:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
2000c4cc:	687b      	ldr	r3, [r7, #4]
2000c4ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000c4d0:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
  hqspi->TxHalfCpltCallback(hqspi);
#else
  HAL_QSPI_TxHalfCpltCallback(hqspi);
2000c4d2:	68f8      	ldr	r0, [r7, #12]
2000c4d4:	f7ff fe5f 	bl	2000c196 <HAL_QSPI_TxHalfCpltCallback>
#endif
}
2000c4d8:	bf00      	nop
2000c4da:	3710      	adds	r7, #16
2000c4dc:	46bd      	mov	sp, r7
2000c4de:	bd80      	pop	{r7, pc}

2000c4e0 <QSPI_DMAError>:
  * @brief  DMA QSPI communication error callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void QSPI_DMAError(DMA_HandleTypeDef *hdma)   
{
2000c4e0:	b580      	push	{r7, lr}
2000c4e2:	b084      	sub	sp, #16
2000c4e4:	af00      	add	r7, sp, #0
2000c4e6:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
2000c4e8:	687b      	ldr	r3, [r7, #4]
2000c4ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000c4ec:	60fb      	str	r3, [r7, #12]
  
  /* if DMA error is FIFO error ignore it */
  if(HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
2000c4ee:	6878      	ldr	r0, [r7, #4]
2000c4f0:	f7f6 fe74 	bl	200031dc <HAL_DMA_GetError>
2000c4f4:	4603      	mov	r3, r0
2000c4f6:	2b02      	cmp	r3, #2
2000c4f8:	d016      	beq.n	2000c528 <QSPI_DMAError+0x48>
  {
    hqspi->RxXferCount = 0;
2000c4fa:	68fb      	ldr	r3, [r7, #12]
2000c4fc:	2200      	movs	r2, #0
2000c4fe:	639a      	str	r2, [r3, #56]	; 0x38
    hqspi->TxXferCount = 0;
2000c500:	68fb      	ldr	r3, [r7, #12]
2000c502:	2200      	movs	r2, #0
2000c504:	62da      	str	r2, [r3, #44]	; 0x2c
    hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
2000c506:	68fb      	ldr	r3, [r7, #12]
2000c508:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000c50a:	f043 0204 	orr.w	r2, r3, #4
2000c50e:	68fb      	ldr	r3, [r7, #12]
2000c510:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
    CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2000c512:	68fb      	ldr	r3, [r7, #12]
2000c514:	681b      	ldr	r3, [r3, #0]
2000c516:	681a      	ldr	r2, [r3, #0]
2000c518:	68fb      	ldr	r3, [r7, #12]
2000c51a:	681b      	ldr	r3, [r3, #0]
2000c51c:	f022 0204 	bic.w	r2, r2, #4
2000c520:	601a      	str	r2, [r3, #0]
    
    /* Abort the QSPI */
    HAL_QSPI_Abort_IT(hqspi);
2000c522:	68f8      	ldr	r0, [r7, #12]
2000c524:	f7ff fede 	bl	2000c2e4 <HAL_QSPI_Abort_IT>
  }
}
2000c528:	bf00      	nop
2000c52a:	3710      	adds	r7, #16
2000c52c:	46bd      	mov	sp, r7
2000c52e:	bd80      	pop	{r7, pc}

2000c530 <QSPI_DMAAbortCplt>:
  * @brief  DMA QSPI abort complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(DMA_HandleTypeDef *hdma)   
{
2000c530:	b580      	push	{r7, lr}
2000c532:	b084      	sub	sp, #16
2000c534:	af00      	add	r7, sp, #0
2000c536:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
2000c538:	687b      	ldr	r3, [r7, #4]
2000c53a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000c53c:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0;
2000c53e:	68fb      	ldr	r3, [r7, #12]
2000c540:	2200      	movs	r2, #0
2000c542:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0;
2000c544:	68fb      	ldr	r3, [r7, #12]
2000c546:	2200      	movs	r2, #0
2000c548:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
2000c54a:	68fb      	ldr	r3, [r7, #12]
2000c54c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000c550:	b2db      	uxtb	r3, r3
2000c552:	2b08      	cmp	r3, #8
2000c554:	d114      	bne.n	2000c580 <QSPI_DMAAbortCplt+0x50>
  {
    /* DMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000c556:	68fb      	ldr	r3, [r7, #12]
2000c558:	681b      	ldr	r3, [r3, #0]
2000c55a:	2202      	movs	r2, #2
2000c55c:	60da      	str	r2, [r3, #12]
    
    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
2000c55e:	68fb      	ldr	r3, [r7, #12]
2000c560:	681b      	ldr	r3, [r3, #0]
2000c562:	681a      	ldr	r2, [r3, #0]
2000c564:	68fb      	ldr	r3, [r7, #12]
2000c566:	681b      	ldr	r3, [r3, #0]
2000c568:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2000c56c:	601a      	str	r2, [r3, #0]
    
    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
2000c56e:	68fb      	ldr	r3, [r7, #12]
2000c570:	681b      	ldr	r3, [r3, #0]
2000c572:	681a      	ldr	r2, [r3, #0]
2000c574:	68fb      	ldr	r3, [r7, #12]
2000c576:	681b      	ldr	r3, [r3, #0]
2000c578:	f042 0202 	orr.w	r2, r2, #2
2000c57c:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
2000c57e:	e006      	b.n	2000c58e <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
2000c580:	68fb      	ldr	r3, [r7, #12]
2000c582:	2201      	movs	r2, #1
2000c584:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
2000c588:	68f8      	ldr	r0, [r7, #12]
2000c58a:	f7ff fdc8 	bl	2000c11e <HAL_QSPI_ErrorCallback>
}
2000c58e:	bf00      	nop
2000c590:	3710      	adds	r7, #16
2000c592:	46bd      	mov	sp, r7
2000c594:	bd80      	pop	{r7, pc}

2000c596 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout Duration of the time out
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag, 
                                                        FlagStatus State, uint32_t tickstart, uint32_t Timeout)
{
2000c596:	b580      	push	{r7, lr}
2000c598:	b084      	sub	sp, #16
2000c59a:	af00      	add	r7, sp, #0
2000c59c:	60f8      	str	r0, [r7, #12]
2000c59e:	60b9      	str	r1, [r7, #8]
2000c5a0:	603b      	str	r3, [r7, #0]
2000c5a2:	4613      	mov	r3, r2
2000c5a4:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */    
  while((FlagStatus)(__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
2000c5a6:	e01a      	b.n	2000c5de <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2000c5a8:	69bb      	ldr	r3, [r7, #24]
2000c5aa:	f1b3 3fff 	cmp.w	r3, #4294967295
2000c5ae:	d016      	beq.n	2000c5de <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
2000c5b0:	69bb      	ldr	r3, [r7, #24]
2000c5b2:	2b00      	cmp	r3, #0
2000c5b4:	d007      	beq.n	2000c5c6 <QSPI_WaitFlagStateUntilTimeout+0x30>
2000c5b6:	f7f5 fbe3 	bl	20001d80 <HAL_GetTick>
2000c5ba:	4602      	mov	r2, r0
2000c5bc:	683b      	ldr	r3, [r7, #0]
2000c5be:	1ad3      	subs	r3, r2, r3
2000c5c0:	69ba      	ldr	r2, [r7, #24]
2000c5c2:	429a      	cmp	r2, r3
2000c5c4:	d20b      	bcs.n	2000c5de <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
2000c5c6:	68fb      	ldr	r3, [r7, #12]
2000c5c8:	2204      	movs	r2, #4
2000c5ca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
2000c5ce:	68fb      	ldr	r3, [r7, #12]
2000c5d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000c5d2:	f043 0201 	orr.w	r2, r3, #1
2000c5d6:	68fb      	ldr	r3, [r7, #12]
2000c5d8:	645a      	str	r2, [r3, #68]	; 0x44
        
        return HAL_ERROR;
2000c5da:	2301      	movs	r3, #1
2000c5dc:	e00e      	b.n	2000c5fc <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((FlagStatus)(__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
2000c5de:	68fb      	ldr	r3, [r7, #12]
2000c5e0:	681b      	ldr	r3, [r3, #0]
2000c5e2:	689a      	ldr	r2, [r3, #8]
2000c5e4:	68bb      	ldr	r3, [r7, #8]
2000c5e6:	4013      	ands	r3, r2
2000c5e8:	2b00      	cmp	r3, #0
2000c5ea:	bf14      	ite	ne
2000c5ec:	2301      	movne	r3, #1
2000c5ee:	2300      	moveq	r3, #0
2000c5f0:	b2db      	uxtb	r3, r3
2000c5f2:	461a      	mov	r2, r3
2000c5f4:	79fb      	ldrb	r3, [r7, #7]
2000c5f6:	429a      	cmp	r2, r3
2000c5f8:	d1d6      	bne.n	2000c5a8 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2000c5fa:	2300      	movs	r3, #0
}
2000c5fc:	4618      	mov	r0, r3
2000c5fe:	3710      	adds	r7, #16
2000c600:	46bd      	mov	sp, r7
2000c602:	bd80      	pop	{r7, pc}

2000c604 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
2000c604:	b480      	push	{r7}
2000c606:	b085      	sub	sp, #20
2000c608:	af00      	add	r7, sp, #0
2000c60a:	60f8      	str	r0, [r7, #12]
2000c60c:	60b9      	str	r1, [r7, #8]
2000c60e:	607a      	str	r2, [r7, #4]
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
2000c610:	68bb      	ldr	r3, [r7, #8]
2000c612:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c614:	2b00      	cmp	r3, #0
2000c616:	d009      	beq.n	2000c62c <QSPI_Config+0x28>
2000c618:	687b      	ldr	r3, [r7, #4]
2000c61a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2000c61e:	d005      	beq.n	2000c62c <QSPI_Config+0x28>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1));
2000c620:	68bb      	ldr	r3, [r7, #8]
2000c622:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2000c624:	68fb      	ldr	r3, [r7, #12]
2000c626:	681b      	ldr	r3, [r3, #0]
2000c628:	3a01      	subs	r2, #1
2000c62a:	611a      	str	r2, [r3, #16]
  }
      
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
2000c62c:	68bb      	ldr	r3, [r7, #8]
2000c62e:	699b      	ldr	r3, [r3, #24]
2000c630:	2b00      	cmp	r3, #0
2000c632:	f000 80b9 	beq.w	2000c7a8 <QSPI_Config+0x1a4>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
2000c636:	68bb      	ldr	r3, [r7, #8]
2000c638:	6a1b      	ldr	r3, [r3, #32]
2000c63a:	2b00      	cmp	r3, #0
2000c63c:	d05f      	beq.n	2000c6fe <QSPI_Config+0xfa>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
2000c63e:	68fb      	ldr	r3, [r7, #12]
2000c640:	681b      	ldr	r3, [r3, #0]
2000c642:	68ba      	ldr	r2, [r7, #8]
2000c644:	6892      	ldr	r2, [r2, #8]
2000c646:	61da      	str	r2, [r3, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2000c648:	68bb      	ldr	r3, [r7, #8]
2000c64a:	69db      	ldr	r3, [r3, #28]
2000c64c:	2b00      	cmp	r3, #0
2000c64e:	d031      	beq.n	2000c6b4 <QSPI_Config+0xb0>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c650:	68bb      	ldr	r3, [r7, #8]
2000c652:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c654:	68bb      	ldr	r3, [r7, #8]
2000c656:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c658:	431a      	orrs	r2, r3
2000c65a:	68bb      	ldr	r3, [r7, #8]
2000c65c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c65e:	431a      	orrs	r2, r3
2000c660:	68bb      	ldr	r3, [r7, #8]
2000c662:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c664:	431a      	orrs	r2, r3
2000c666:	68bb      	ldr	r3, [r7, #8]
2000c668:	695b      	ldr	r3, [r3, #20]
2000c66a:	049b      	lsls	r3, r3, #18
2000c66c:	431a      	orrs	r2, r3
2000c66e:	68bb      	ldr	r3, [r7, #8]
2000c670:	691b      	ldr	r3, [r3, #16]
2000c672:	431a      	orrs	r2, r3
2000c674:	68bb      	ldr	r3, [r7, #8]
2000c676:	6a1b      	ldr	r3, [r3, #32]
2000c678:	431a      	orrs	r2, r3
2000c67a:	68bb      	ldr	r3, [r7, #8]
2000c67c:	68db      	ldr	r3, [r3, #12]
2000c67e:	431a      	orrs	r2, r3
2000c680:	68bb      	ldr	r3, [r7, #8]
2000c682:	69db      	ldr	r3, [r3, #28]
2000c684:	431a      	orrs	r2, r3
2000c686:	68bb      	ldr	r3, [r7, #8]
2000c688:	699b      	ldr	r3, [r3, #24]
2000c68a:	431a      	orrs	r2, r3
2000c68c:	68bb      	ldr	r3, [r7, #8]
2000c68e:	681b      	ldr	r3, [r3, #0]
2000c690:	ea42 0103 	orr.w	r1, r2, r3
2000c694:	68fb      	ldr	r3, [r7, #12]
2000c696:	681b      	ldr	r3, [r3, #0]
2000c698:	687a      	ldr	r2, [r7, #4]
2000c69a:	430a      	orrs	r2, r1
2000c69c:	615a      	str	r2, [r3, #20]
                                         cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateBytesSize |
                                         cmd->AlternateByteMode | cmd->AddressSize | cmd->AddressMode |
                                         cmd->InstructionMode | cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2000c69e:	687b      	ldr	r3, [r7, #4]
2000c6a0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2000c6a4:	f000 812e 	beq.w	2000c904 <QSPI_Config+0x300>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
2000c6a8:	68fb      	ldr	r3, [r7, #12]
2000c6aa:	681b      	ldr	r3, [r3, #0]
2000c6ac:	68ba      	ldr	r2, [r7, #8]
2000c6ae:	6852      	ldr	r2, [r2, #4]
2000c6b0:	619a      	str	r2, [r3, #24]
                                           cmd->AddressMode | cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
2000c6b2:	e127      	b.n	2000c904 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c6b4:	68bb      	ldr	r3, [r7, #8]
2000c6b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c6b8:	68bb      	ldr	r3, [r7, #8]
2000c6ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c6bc:	431a      	orrs	r2, r3
2000c6be:	68bb      	ldr	r3, [r7, #8]
2000c6c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c6c2:	431a      	orrs	r2, r3
2000c6c4:	68bb      	ldr	r3, [r7, #8]
2000c6c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c6c8:	431a      	orrs	r2, r3
2000c6ca:	68bb      	ldr	r3, [r7, #8]
2000c6cc:	695b      	ldr	r3, [r3, #20]
2000c6ce:	049b      	lsls	r3, r3, #18
2000c6d0:	431a      	orrs	r2, r3
2000c6d2:	68bb      	ldr	r3, [r7, #8]
2000c6d4:	691b      	ldr	r3, [r3, #16]
2000c6d6:	431a      	orrs	r2, r3
2000c6d8:	68bb      	ldr	r3, [r7, #8]
2000c6da:	6a1b      	ldr	r3, [r3, #32]
2000c6dc:	431a      	orrs	r2, r3
2000c6de:	68bb      	ldr	r3, [r7, #8]
2000c6e0:	69db      	ldr	r3, [r3, #28]
2000c6e2:	431a      	orrs	r2, r3
2000c6e4:	68bb      	ldr	r3, [r7, #8]
2000c6e6:	699b      	ldr	r3, [r3, #24]
2000c6e8:	431a      	orrs	r2, r3
2000c6ea:	68bb      	ldr	r3, [r7, #8]
2000c6ec:	681b      	ldr	r3, [r3, #0]
2000c6ee:	ea42 0103 	orr.w	r1, r2, r3
2000c6f2:	68fb      	ldr	r3, [r7, #12]
2000c6f4:	681b      	ldr	r3, [r3, #0]
2000c6f6:	687a      	ldr	r2, [r7, #4]
2000c6f8:	430a      	orrs	r2, r1
2000c6fa:	615a      	str	r2, [r3, #20]
}
2000c6fc:	e102      	b.n	2000c904 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2000c6fe:	68bb      	ldr	r3, [r7, #8]
2000c700:	69db      	ldr	r3, [r3, #28]
2000c702:	2b00      	cmp	r3, #0
2000c704:	d02e      	beq.n	2000c764 <QSPI_Config+0x160>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c706:	68bb      	ldr	r3, [r7, #8]
2000c708:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c70a:	68bb      	ldr	r3, [r7, #8]
2000c70c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c70e:	431a      	orrs	r2, r3
2000c710:	68bb      	ldr	r3, [r7, #8]
2000c712:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c714:	431a      	orrs	r2, r3
2000c716:	68bb      	ldr	r3, [r7, #8]
2000c718:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c71a:	431a      	orrs	r2, r3
2000c71c:	68bb      	ldr	r3, [r7, #8]
2000c71e:	695b      	ldr	r3, [r3, #20]
2000c720:	049b      	lsls	r3, r3, #18
2000c722:	431a      	orrs	r2, r3
2000c724:	68bb      	ldr	r3, [r7, #8]
2000c726:	6a1b      	ldr	r3, [r3, #32]
2000c728:	431a      	orrs	r2, r3
2000c72a:	68bb      	ldr	r3, [r7, #8]
2000c72c:	68db      	ldr	r3, [r3, #12]
2000c72e:	431a      	orrs	r2, r3
2000c730:	68bb      	ldr	r3, [r7, #8]
2000c732:	69db      	ldr	r3, [r3, #28]
2000c734:	431a      	orrs	r2, r3
2000c736:	68bb      	ldr	r3, [r7, #8]
2000c738:	699b      	ldr	r3, [r3, #24]
2000c73a:	431a      	orrs	r2, r3
2000c73c:	68bb      	ldr	r3, [r7, #8]
2000c73e:	681b      	ldr	r3, [r3, #0]
2000c740:	ea42 0103 	orr.w	r1, r2, r3
2000c744:	68fb      	ldr	r3, [r7, #12]
2000c746:	681b      	ldr	r3, [r3, #0]
2000c748:	687a      	ldr	r2, [r7, #4]
2000c74a:	430a      	orrs	r2, r1
2000c74c:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2000c74e:	687b      	ldr	r3, [r7, #4]
2000c750:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2000c754:	f000 80d6 	beq.w	2000c904 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
2000c758:	68fb      	ldr	r3, [r7, #12]
2000c75a:	681b      	ldr	r3, [r3, #0]
2000c75c:	68ba      	ldr	r2, [r7, #8]
2000c75e:	6852      	ldr	r2, [r2, #4]
2000c760:	619a      	str	r2, [r3, #24]
}
2000c762:	e0cf      	b.n	2000c904 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c764:	68bb      	ldr	r3, [r7, #8]
2000c766:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c768:	68bb      	ldr	r3, [r7, #8]
2000c76a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c76c:	431a      	orrs	r2, r3
2000c76e:	68bb      	ldr	r3, [r7, #8]
2000c770:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c772:	431a      	orrs	r2, r3
2000c774:	68bb      	ldr	r3, [r7, #8]
2000c776:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c778:	431a      	orrs	r2, r3
2000c77a:	68bb      	ldr	r3, [r7, #8]
2000c77c:	695b      	ldr	r3, [r3, #20]
2000c77e:	049b      	lsls	r3, r3, #18
2000c780:	431a      	orrs	r2, r3
2000c782:	68bb      	ldr	r3, [r7, #8]
2000c784:	6a1b      	ldr	r3, [r3, #32]
2000c786:	431a      	orrs	r2, r3
2000c788:	68bb      	ldr	r3, [r7, #8]
2000c78a:	69db      	ldr	r3, [r3, #28]
2000c78c:	431a      	orrs	r2, r3
2000c78e:	68bb      	ldr	r3, [r7, #8]
2000c790:	699b      	ldr	r3, [r3, #24]
2000c792:	431a      	orrs	r2, r3
2000c794:	68bb      	ldr	r3, [r7, #8]
2000c796:	681b      	ldr	r3, [r3, #0]
2000c798:	ea42 0103 	orr.w	r1, r2, r3
2000c79c:	68fb      	ldr	r3, [r7, #12]
2000c79e:	681b      	ldr	r3, [r3, #0]
2000c7a0:	687a      	ldr	r2, [r7, #4]
2000c7a2:	430a      	orrs	r2, r1
2000c7a4:	615a      	str	r2, [r3, #20]
}
2000c7a6:	e0ad      	b.n	2000c904 <QSPI_Config+0x300>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
2000c7a8:	68bb      	ldr	r3, [r7, #8]
2000c7aa:	6a1b      	ldr	r3, [r3, #32]
2000c7ac:	2b00      	cmp	r3, #0
2000c7ae:	d058      	beq.n	2000c862 <QSPI_Config+0x25e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
2000c7b0:	68fb      	ldr	r3, [r7, #12]
2000c7b2:	681b      	ldr	r3, [r3, #0]
2000c7b4:	68ba      	ldr	r2, [r7, #8]
2000c7b6:	6892      	ldr	r2, [r2, #8]
2000c7b8:	61da      	str	r2, [r3, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2000c7ba:	68bb      	ldr	r3, [r7, #8]
2000c7bc:	69db      	ldr	r3, [r3, #28]
2000c7be:	2b00      	cmp	r3, #0
2000c7c0:	d02d      	beq.n	2000c81e <QSPI_Config+0x21a>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c7c2:	68bb      	ldr	r3, [r7, #8]
2000c7c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c7c6:	68bb      	ldr	r3, [r7, #8]
2000c7c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c7ca:	431a      	orrs	r2, r3
2000c7cc:	68bb      	ldr	r3, [r7, #8]
2000c7ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c7d0:	431a      	orrs	r2, r3
2000c7d2:	68bb      	ldr	r3, [r7, #8]
2000c7d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c7d6:	431a      	orrs	r2, r3
2000c7d8:	68bb      	ldr	r3, [r7, #8]
2000c7da:	695b      	ldr	r3, [r3, #20]
2000c7dc:	049b      	lsls	r3, r3, #18
2000c7de:	431a      	orrs	r2, r3
2000c7e0:	68bb      	ldr	r3, [r7, #8]
2000c7e2:	691b      	ldr	r3, [r3, #16]
2000c7e4:	431a      	orrs	r2, r3
2000c7e6:	68bb      	ldr	r3, [r7, #8]
2000c7e8:	6a1b      	ldr	r3, [r3, #32]
2000c7ea:	431a      	orrs	r2, r3
2000c7ec:	68bb      	ldr	r3, [r7, #8]
2000c7ee:	68db      	ldr	r3, [r3, #12]
2000c7f0:	431a      	orrs	r2, r3
2000c7f2:	68bb      	ldr	r3, [r7, #8]
2000c7f4:	69db      	ldr	r3, [r3, #28]
2000c7f6:	431a      	orrs	r2, r3
2000c7f8:	68bb      	ldr	r3, [r7, #8]
2000c7fa:	699b      	ldr	r3, [r3, #24]
2000c7fc:	ea42 0103 	orr.w	r1, r2, r3
2000c800:	68fb      	ldr	r3, [r7, #12]
2000c802:	681b      	ldr	r3, [r3, #0]
2000c804:	687a      	ldr	r2, [r7, #4]
2000c806:	430a      	orrs	r2, r1
2000c808:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2000c80a:	687b      	ldr	r3, [r7, #4]
2000c80c:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2000c810:	d078      	beq.n	2000c904 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
2000c812:	68fb      	ldr	r3, [r7, #12]
2000c814:	681b      	ldr	r3, [r3, #0]
2000c816:	68ba      	ldr	r2, [r7, #8]
2000c818:	6852      	ldr	r2, [r2, #4]
2000c81a:	619a      	str	r2, [r3, #24]
}
2000c81c:	e072      	b.n	2000c904 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c81e:	68bb      	ldr	r3, [r7, #8]
2000c820:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c822:	68bb      	ldr	r3, [r7, #8]
2000c824:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c826:	431a      	orrs	r2, r3
2000c828:	68bb      	ldr	r3, [r7, #8]
2000c82a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c82c:	431a      	orrs	r2, r3
2000c82e:	68bb      	ldr	r3, [r7, #8]
2000c830:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c832:	431a      	orrs	r2, r3
2000c834:	68bb      	ldr	r3, [r7, #8]
2000c836:	695b      	ldr	r3, [r3, #20]
2000c838:	049b      	lsls	r3, r3, #18
2000c83a:	431a      	orrs	r2, r3
2000c83c:	68bb      	ldr	r3, [r7, #8]
2000c83e:	691b      	ldr	r3, [r3, #16]
2000c840:	431a      	orrs	r2, r3
2000c842:	68bb      	ldr	r3, [r7, #8]
2000c844:	6a1b      	ldr	r3, [r3, #32]
2000c846:	431a      	orrs	r2, r3
2000c848:	68bb      	ldr	r3, [r7, #8]
2000c84a:	69db      	ldr	r3, [r3, #28]
2000c84c:	431a      	orrs	r2, r3
2000c84e:	68bb      	ldr	r3, [r7, #8]
2000c850:	699b      	ldr	r3, [r3, #24]
2000c852:	ea42 0103 	orr.w	r1, r2, r3
2000c856:	68fb      	ldr	r3, [r7, #12]
2000c858:	681b      	ldr	r3, [r3, #0]
2000c85a:	687a      	ldr	r2, [r7, #4]
2000c85c:	430a      	orrs	r2, r1
2000c85e:	615a      	str	r2, [r3, #20]
}
2000c860:	e050      	b.n	2000c904 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2000c862:	68bb      	ldr	r3, [r7, #8]
2000c864:	69db      	ldr	r3, [r3, #28]
2000c866:	2b00      	cmp	r3, #0
2000c868:	d02a      	beq.n	2000c8c0 <QSPI_Config+0x2bc>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c86a:	68bb      	ldr	r3, [r7, #8]
2000c86c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c86e:	68bb      	ldr	r3, [r7, #8]
2000c870:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c872:	431a      	orrs	r2, r3
2000c874:	68bb      	ldr	r3, [r7, #8]
2000c876:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c878:	431a      	orrs	r2, r3
2000c87a:	68bb      	ldr	r3, [r7, #8]
2000c87c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c87e:	431a      	orrs	r2, r3
2000c880:	68bb      	ldr	r3, [r7, #8]
2000c882:	695b      	ldr	r3, [r3, #20]
2000c884:	049b      	lsls	r3, r3, #18
2000c886:	431a      	orrs	r2, r3
2000c888:	68bb      	ldr	r3, [r7, #8]
2000c88a:	6a1b      	ldr	r3, [r3, #32]
2000c88c:	431a      	orrs	r2, r3
2000c88e:	68bb      	ldr	r3, [r7, #8]
2000c890:	68db      	ldr	r3, [r3, #12]
2000c892:	431a      	orrs	r2, r3
2000c894:	68bb      	ldr	r3, [r7, #8]
2000c896:	69db      	ldr	r3, [r3, #28]
2000c898:	431a      	orrs	r2, r3
2000c89a:	68bb      	ldr	r3, [r7, #8]
2000c89c:	699b      	ldr	r3, [r3, #24]
2000c89e:	ea42 0103 	orr.w	r1, r2, r3
2000c8a2:	68fb      	ldr	r3, [r7, #12]
2000c8a4:	681b      	ldr	r3, [r3, #0]
2000c8a6:	687a      	ldr	r2, [r7, #4]
2000c8a8:	430a      	orrs	r2, r1
2000c8aa:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2000c8ac:	687b      	ldr	r3, [r7, #4]
2000c8ae:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2000c8b2:	d027      	beq.n	2000c904 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
2000c8b4:	68fb      	ldr	r3, [r7, #12]
2000c8b6:	681b      	ldr	r3, [r3, #0]
2000c8b8:	68ba      	ldr	r2, [r7, #8]
2000c8ba:	6852      	ldr	r2, [r2, #4]
2000c8bc:	619a      	str	r2, [r3, #24]
}
2000c8be:	e021      	b.n	2000c904 <QSPI_Config+0x300>
        if (cmd->DataMode != QSPI_DATA_NONE)
2000c8c0:	68bb      	ldr	r3, [r7, #8]
2000c8c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c8c4:	2b00      	cmp	r3, #0
2000c8c6:	d01d      	beq.n	2000c904 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000c8c8:	68bb      	ldr	r3, [r7, #8]
2000c8ca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000c8cc:	68bb      	ldr	r3, [r7, #8]
2000c8ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000c8d0:	431a      	orrs	r2, r3
2000c8d2:	68bb      	ldr	r3, [r7, #8]
2000c8d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000c8d6:	431a      	orrs	r2, r3
2000c8d8:	68bb      	ldr	r3, [r7, #8]
2000c8da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000c8dc:	431a      	orrs	r2, r3
2000c8de:	68bb      	ldr	r3, [r7, #8]
2000c8e0:	695b      	ldr	r3, [r3, #20]
2000c8e2:	049b      	lsls	r3, r3, #18
2000c8e4:	431a      	orrs	r2, r3
2000c8e6:	68bb      	ldr	r3, [r7, #8]
2000c8e8:	6a1b      	ldr	r3, [r3, #32]
2000c8ea:	431a      	orrs	r2, r3
2000c8ec:	68bb      	ldr	r3, [r7, #8]
2000c8ee:	69db      	ldr	r3, [r3, #28]
2000c8f0:	431a      	orrs	r2, r3
2000c8f2:	68bb      	ldr	r3, [r7, #8]
2000c8f4:	699b      	ldr	r3, [r3, #24]
2000c8f6:	ea42 0103 	orr.w	r1, r2, r3
2000c8fa:	68fb      	ldr	r3, [r7, #12]
2000c8fc:	681b      	ldr	r3, [r3, #0]
2000c8fe:	687a      	ldr	r2, [r7, #4]
2000c900:	430a      	orrs	r2, r1
2000c902:	615a      	str	r2, [r3, #20]
}
2000c904:	bf00      	nop
2000c906:	3714      	adds	r7, #20
2000c908:	46bd      	mov	sp, r7
2000c90a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000c90e:	4770      	bx	lr

2000c910 <HAL_RCC_DeInit>:
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
2000c910:	b580      	push	{r7, lr}
2000c912:	b082      	sub	sp, #8
2000c914:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2000c916:	f7f5 fa33 	bl	20001d80 <HAL_GetTick>
2000c91a:	6078      	str	r0, [r7, #4]

  /* Set HSION bit to the reset value */
  SET_BIT(RCC->CR, RCC_CR_HSION);
2000c91c:	4b65      	ldr	r3, [pc, #404]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c91e:	681b      	ldr	r3, [r3, #0]
2000c920:	4a64      	ldr	r2, [pc, #400]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c922:	f043 0301 	orr.w	r3, r3, #1
2000c926:	6013      	str	r3, [r2, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
2000c928:	e008      	b.n	2000c93c <HAL_RCC_DeInit+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2000c92a:	f7f5 fa29 	bl	20001d80 <HAL_GetTick>
2000c92e:	4602      	mov	r2, r0
2000c930:	687b      	ldr	r3, [r7, #4]
2000c932:	1ad3      	subs	r3, r2, r3
2000c934:	2b02      	cmp	r3, #2
2000c936:	d901      	bls.n	2000c93c <HAL_RCC_DeInit+0x2c>
    {
      return HAL_TIMEOUT;
2000c938:	2303      	movs	r3, #3
2000c93a:	e0b6      	b.n	2000caaa <HAL_RCC_DeInit+0x19a>
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
2000c93c:	4b5d      	ldr	r3, [pc, #372]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c93e:	681b      	ldr	r3, [r3, #0]
2000c940:	f003 0302 	and.w	r3, r3, #2
2000c944:	2b00      	cmp	r3, #0
2000c946:	d0f0      	beq.n	2000c92a <HAL_RCC_DeInit+0x1a>
    }
  }

  /* Set HSITRIM[4:0] bits to the reset value */
  SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);
2000c948:	4b5a      	ldr	r3, [pc, #360]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c94a:	681b      	ldr	r3, [r3, #0]
2000c94c:	4a59      	ldr	r2, [pc, #356]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c94e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2000c952:	6013      	str	r3, [r2, #0]

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2000c954:	f7f5 fa14 	bl	20001d80 <HAL_GetTick>
2000c958:	6078      	str	r0, [r7, #4]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
2000c95a:	4b56      	ldr	r3, [pc, #344]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c95c:	2200      	movs	r2, #0
2000c95e:	609a      	str	r2, [r3, #8]

  /* Wait till clock switch is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
2000c960:	e00a      	b.n	2000c978 <HAL_RCC_DeInit+0x68>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2000c962:	f7f5 fa0d 	bl	20001d80 <HAL_GetTick>
2000c966:	4602      	mov	r2, r0
2000c968:	687b      	ldr	r3, [r7, #4]
2000c96a:	1ad3      	subs	r3, r2, r3
2000c96c:	f241 3288 	movw	r2, #5000	; 0x1388
2000c970:	4293      	cmp	r3, r2
2000c972:	d901      	bls.n	2000c978 <HAL_RCC_DeInit+0x68>
    {
      return HAL_TIMEOUT;
2000c974:	2303      	movs	r3, #3
2000c976:	e098      	b.n	2000caaa <HAL_RCC_DeInit+0x19a>
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
2000c978:	4b4e      	ldr	r3, [pc, #312]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c97a:	689b      	ldr	r3, [r3, #8]
2000c97c:	f003 030c 	and.w	r3, r3, #12
2000c980:	2b00      	cmp	r3, #0
2000c982:	d1ee      	bne.n	2000c962 <HAL_RCC_DeInit+0x52>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2000c984:	f7f5 f9fc 	bl	20001d80 <HAL_GetTick>
2000c988:	6078      	str	r0, [r7, #4]

  /* Clear HSEON, HSEBYP and CSSON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);
2000c98a:	4b4a      	ldr	r3, [pc, #296]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c98c:	681b      	ldr	r3, [r3, #0]
2000c98e:	4a49      	ldr	r2, [pc, #292]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c990:	f423 2350 	bic.w	r3, r3, #851968	; 0xd0000
2000c994:	6013      	str	r3, [r2, #0]

  /* Wait till HSE is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
2000c996:	e008      	b.n	2000c9aa <HAL_RCC_DeInit+0x9a>
  {
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
2000c998:	f7f5 f9f2 	bl	20001d80 <HAL_GetTick>
2000c99c:	4602      	mov	r2, r0
2000c99e:	687b      	ldr	r3, [r7, #4]
2000c9a0:	1ad3      	subs	r3, r2, r3
2000c9a2:	2b64      	cmp	r3, #100	; 0x64
2000c9a4:	d901      	bls.n	2000c9aa <HAL_RCC_DeInit+0x9a>
    {
      return HAL_TIMEOUT;
2000c9a6:	2303      	movs	r3, #3
2000c9a8:	e07f      	b.n	2000caaa <HAL_RCC_DeInit+0x19a>
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
2000c9aa:	4b42      	ldr	r3, [pc, #264]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c9ac:	681b      	ldr	r3, [r3, #0]
2000c9ae:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000c9b2:	2b00      	cmp	r3, #0
2000c9b4:	d1f0      	bne.n	2000c998 <HAL_RCC_DeInit+0x88>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2000c9b6:	f7f5 f9e3 	bl	20001d80 <HAL_GetTick>
2000c9ba:	6078      	str	r0, [r7, #4]

  /* Clear PLLON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
2000c9bc:	4b3d      	ldr	r3, [pc, #244]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c9be:	681b      	ldr	r3, [r3, #0]
2000c9c0:	4a3c      	ldr	r2, [pc, #240]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c9c2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2000c9c6:	6013      	str	r3, [r2, #0]

  /* Wait till PLL is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
2000c9c8:	e008      	b.n	2000c9dc <HAL_RCC_DeInit+0xcc>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2000c9ca:	f7f5 f9d9 	bl	20001d80 <HAL_GetTick>
2000c9ce:	4602      	mov	r2, r0
2000c9d0:	687b      	ldr	r3, [r7, #4]
2000c9d2:	1ad3      	subs	r3, r2, r3
2000c9d4:	2b02      	cmp	r3, #2
2000c9d6:	d901      	bls.n	2000c9dc <HAL_RCC_DeInit+0xcc>
    {
      return HAL_TIMEOUT;
2000c9d8:	2303      	movs	r3, #3
2000c9da:	e066      	b.n	2000caaa <HAL_RCC_DeInit+0x19a>
  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
2000c9dc:	4b35      	ldr	r3, [pc, #212]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c9de:	681b      	ldr	r3, [r3, #0]
2000c9e0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000c9e4:	2b00      	cmp	r3, #0
2000c9e6:	d1f0      	bne.n	2000c9ca <HAL_RCC_DeInit+0xba>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2000c9e8:	f7f5 f9ca 	bl	20001d80 <HAL_GetTick>
2000c9ec:	6078      	str	r0, [r7, #4]

  /* Reset PLLI2SON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);
2000c9ee:	4b31      	ldr	r3, [pc, #196]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c9f0:	681b      	ldr	r3, [r3, #0]
2000c9f2:	4a30      	ldr	r2, [pc, #192]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000c9f4:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
2000c9f8:	6013      	str	r3, [r2, #0]

  /* Wait till PLLI2S is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
2000c9fa:	e008      	b.n	2000ca0e <HAL_RCC_DeInit+0xfe>
  {
    if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
2000c9fc:	f7f5 f9c0 	bl	20001d80 <HAL_GetTick>
2000ca00:	4602      	mov	r2, r0
2000ca02:	687b      	ldr	r3, [r7, #4]
2000ca04:	1ad3      	subs	r3, r2, r3
2000ca06:	2b64      	cmp	r3, #100	; 0x64
2000ca08:	d901      	bls.n	2000ca0e <HAL_RCC_DeInit+0xfe>
    {
      return HAL_TIMEOUT;
2000ca0a:	2303      	movs	r3, #3
2000ca0c:	e04d      	b.n	2000caaa <HAL_RCC_DeInit+0x19a>
  while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
2000ca0e:	4b29      	ldr	r3, [pc, #164]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca10:	681b      	ldr	r3, [r3, #0]
2000ca12:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000ca16:	2b00      	cmp	r3, #0
2000ca18:	d1f0      	bne.n	2000c9fc <HAL_RCC_DeInit+0xec>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2000ca1a:	f7f5 f9b1 	bl	20001d80 <HAL_GetTick>
2000ca1e:	6078      	str	r0, [r7, #4]

  /* Reset PLLSAI bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);
2000ca20:	4b24      	ldr	r3, [pc, #144]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca22:	681b      	ldr	r3, [r3, #0]
2000ca24:	4a23      	ldr	r2, [pc, #140]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca26:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2000ca2a:	6013      	str	r3, [r2, #0]

  /* Wait till PLLSAI is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)
2000ca2c:	e008      	b.n	2000ca40 <HAL_RCC_DeInit+0x130>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
2000ca2e:	f7f5 f9a7 	bl	20001d80 <HAL_GetTick>
2000ca32:	4602      	mov	r2, r0
2000ca34:	687b      	ldr	r3, [r7, #4]
2000ca36:	1ad3      	subs	r3, r2, r3
2000ca38:	2b64      	cmp	r3, #100	; 0x64
2000ca3a:	d901      	bls.n	2000ca40 <HAL_RCC_DeInit+0x130>
    {
      return HAL_TIMEOUT;
2000ca3c:	2303      	movs	r3, #3
2000ca3e:	e034      	b.n	2000caaa <HAL_RCC_DeInit+0x19a>
  while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)
2000ca40:	4b1c      	ldr	r3, [pc, #112]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca42:	681b      	ldr	r3, [r3, #0]
2000ca44:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000ca48:	2b00      	cmp	r3, #0
2000ca4a:	d1f0      	bne.n	2000ca2e <HAL_RCC_DeInit+0x11e>
    }
  }

  /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */
  RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | 0x20000000U;
2000ca4c:	4b19      	ldr	r3, [pc, #100]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca4e:	4a1a      	ldr	r2, [pc, #104]	; (2000cab8 <HAL_RCC_DeInit+0x1a8>)
2000ca50:	605a      	str	r2, [r3, #4]

  /* Reset PLLI2SCFGR register to default value */
  RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;
2000ca52:	4b18      	ldr	r3, [pc, #96]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca54:	4a19      	ldr	r2, [pc, #100]	; (2000cabc <HAL_RCC_DeInit+0x1ac>)
2000ca56:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Reset PLLSAICFGR register to default value */
  RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 | 0x20000000U;
2000ca5a:	4b16      	ldr	r3, [pc, #88]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca5c:	4a17      	ldr	r2, [pc, #92]	; (2000cabc <HAL_RCC_DeInit+0x1ac>)
2000ca5e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Disable all interrupts */
  CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE | RCC_CIR_PLLI2SRDYIE | RCC_CIR_PLLSAIRDYIE);
2000ca62:	4b14      	ldr	r3, [pc, #80]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca64:	68db      	ldr	r3, [r3, #12]
2000ca66:	4a13      	ldr	r2, [pc, #76]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca68:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
2000ca6c:	60d3      	str	r3, [r2, #12]

  /* Clear all interrupt flags */
  SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_PLLI2SRDYC | RCC_CIR_PLLSAIRDYC | RCC_CIR_CSSC);
2000ca6e:	4b11      	ldr	r3, [pc, #68]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca70:	68db      	ldr	r3, [r3, #12]
2000ca72:	4a10      	ldr	r2, [pc, #64]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca74:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
2000ca78:	60d3      	str	r3, [r2, #12]

  /* Clear LSION bit */
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
2000ca7a:	4b0e      	ldr	r3, [pc, #56]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca7c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000ca7e:	4a0d      	ldr	r2, [pc, #52]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca80:	f023 0301 	bic.w	r3, r3, #1
2000ca84:	6753      	str	r3, [r2, #116]	; 0x74

  /* Reset all CSR flags */
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
2000ca86:	4b0b      	ldr	r3, [pc, #44]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca88:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000ca8a:	4a0a      	ldr	r2, [pc, #40]	; (2000cab4 <HAL_RCC_DeInit+0x1a4>)
2000ca8c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
2000ca90:	6753      	str	r3, [r2, #116]	; 0x74

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HSI_VALUE;
2000ca92:	4b0b      	ldr	r3, [pc, #44]	; (2000cac0 <HAL_RCC_DeInit+0x1b0>)
2000ca94:	4a0b      	ldr	r2, [pc, #44]	; (2000cac4 <HAL_RCC_DeInit+0x1b4>)
2000ca96:	601a      	str	r2, [r3, #0]

  /* Adapt Systick interrupt period */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
2000ca98:	2000      	movs	r0, #0
2000ca9a:	f7f5 f92d 	bl	20001cf8 <HAL_InitTick>
2000ca9e:	4603      	mov	r3, r0
2000caa0:	2b00      	cmp	r3, #0
2000caa2:	d001      	beq.n	2000caa8 <HAL_RCC_DeInit+0x198>
  {
    return HAL_ERROR;
2000caa4:	2301      	movs	r3, #1
2000caa6:	e000      	b.n	2000caaa <HAL_RCC_DeInit+0x19a>
  }
  else
  {
    return HAL_OK;
2000caa8:	2300      	movs	r3, #0
  }
}
2000caaa:	4618      	mov	r0, r3
2000caac:	3708      	adds	r7, #8
2000caae:	46bd      	mov	sp, r7
2000cab0:	bd80      	pop	{r7, pc}
2000cab2:	bf00      	nop
2000cab4:	40023800 	.word	0x40023800
2000cab8:	24003010 	.word	0x24003010
2000cabc:	24003000 	.word	0x24003000
2000cac0:	20000410 	.word	0x20000410
2000cac4:	00f42400 	.word	0x00f42400

2000cac8 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
2000cac8:	b580      	push	{r7, lr}
2000caca:	b086      	sub	sp, #24
2000cacc:	af00      	add	r7, sp, #0
2000cace:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;
2000cad0:	2300      	movs	r3, #0
2000cad2:	75fb      	strb	r3, [r7, #23]

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
2000cad4:	687b      	ldr	r3, [r7, #4]
2000cad6:	2b00      	cmp	r3, #0
2000cad8:	d101      	bne.n	2000cade <HAL_RCC_OscConfig+0x16>
  {
    return HAL_ERROR;
2000cada:	2301      	movs	r3, #1
2000cadc:	e25e      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
2000cade:	687b      	ldr	r3, [r7, #4]
2000cae0:	681b      	ldr	r3, [r3, #0]
2000cae2:	f003 0301 	and.w	r3, r3, #1
2000cae6:	2b00      	cmp	r3, #0
2000cae8:	f000 8087 	beq.w	2000cbfa <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
2000caec:	4b96      	ldr	r3, [pc, #600]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000caee:	689b      	ldr	r3, [r3, #8]
2000caf0:	f003 030c 	and.w	r3, r3, #12
2000caf4:	2b04      	cmp	r3, #4
2000caf6:	d00c      	beq.n	2000cb12 <HAL_RCC_OscConfig+0x4a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
2000caf8:	4b93      	ldr	r3, [pc, #588]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cafa:	689b      	ldr	r3, [r3, #8]
2000cafc:	f003 030c 	and.w	r3, r3, #12
2000cb00:	2b08      	cmp	r3, #8
2000cb02:	d112      	bne.n	2000cb2a <HAL_RCC_OscConfig+0x62>
2000cb04:	4b90      	ldr	r3, [pc, #576]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb06:	685b      	ldr	r3, [r3, #4]
2000cb08:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000cb0c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2000cb10:	d10b      	bne.n	2000cb2a <HAL_RCC_OscConfig+0x62>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
2000cb12:	4b8d      	ldr	r3, [pc, #564]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb14:	681b      	ldr	r3, [r3, #0]
2000cb16:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000cb1a:	2b00      	cmp	r3, #0
2000cb1c:	d06c      	beq.n	2000cbf8 <HAL_RCC_OscConfig+0x130>
2000cb1e:	687b      	ldr	r3, [r7, #4]
2000cb20:	685b      	ldr	r3, [r3, #4]
2000cb22:	2b00      	cmp	r3, #0
2000cb24:	d168      	bne.n	2000cbf8 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
2000cb26:	2301      	movs	r3, #1
2000cb28:	e238      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
2000cb2a:	687b      	ldr	r3, [r7, #4]
2000cb2c:	685b      	ldr	r3, [r3, #4]
2000cb2e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000cb32:	d106      	bne.n	2000cb42 <HAL_RCC_OscConfig+0x7a>
2000cb34:	4b84      	ldr	r3, [pc, #528]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb36:	681b      	ldr	r3, [r3, #0]
2000cb38:	4a83      	ldr	r2, [pc, #524]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb3a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000cb3e:	6013      	str	r3, [r2, #0]
2000cb40:	e02e      	b.n	2000cba0 <HAL_RCC_OscConfig+0xd8>
2000cb42:	687b      	ldr	r3, [r7, #4]
2000cb44:	685b      	ldr	r3, [r3, #4]
2000cb46:	2b00      	cmp	r3, #0
2000cb48:	d10c      	bne.n	2000cb64 <HAL_RCC_OscConfig+0x9c>
2000cb4a:	4b7f      	ldr	r3, [pc, #508]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb4c:	681b      	ldr	r3, [r3, #0]
2000cb4e:	4a7e      	ldr	r2, [pc, #504]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb50:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000cb54:	6013      	str	r3, [r2, #0]
2000cb56:	4b7c      	ldr	r3, [pc, #496]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb58:	681b      	ldr	r3, [r3, #0]
2000cb5a:	4a7b      	ldr	r2, [pc, #492]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb5c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
2000cb60:	6013      	str	r3, [r2, #0]
2000cb62:	e01d      	b.n	2000cba0 <HAL_RCC_OscConfig+0xd8>
2000cb64:	687b      	ldr	r3, [r7, #4]
2000cb66:	685b      	ldr	r3, [r3, #4]
2000cb68:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
2000cb6c:	d10c      	bne.n	2000cb88 <HAL_RCC_OscConfig+0xc0>
2000cb6e:	4b76      	ldr	r3, [pc, #472]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb70:	681b      	ldr	r3, [r3, #0]
2000cb72:	4a75      	ldr	r2, [pc, #468]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb74:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2000cb78:	6013      	str	r3, [r2, #0]
2000cb7a:	4b73      	ldr	r3, [pc, #460]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb7c:	681b      	ldr	r3, [r3, #0]
2000cb7e:	4a72      	ldr	r2, [pc, #456]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb80:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000cb84:	6013      	str	r3, [r2, #0]
2000cb86:	e00b      	b.n	2000cba0 <HAL_RCC_OscConfig+0xd8>
2000cb88:	4b6f      	ldr	r3, [pc, #444]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb8a:	681b      	ldr	r3, [r3, #0]
2000cb8c:	4a6e      	ldr	r2, [pc, #440]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb8e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000cb92:	6013      	str	r3, [r2, #0]
2000cb94:	4b6c      	ldr	r3, [pc, #432]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb96:	681b      	ldr	r3, [r3, #0]
2000cb98:	4a6b      	ldr	r2, [pc, #428]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cb9a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
2000cb9e:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
2000cba0:	687b      	ldr	r3, [r7, #4]
2000cba2:	685b      	ldr	r3, [r3, #4]
2000cba4:	2b00      	cmp	r3, #0
2000cba6:	d013      	beq.n	2000cbd0 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000cba8:	f7f5 f8ea 	bl	20001d80 <HAL_GetTick>
2000cbac:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2000cbae:	e008      	b.n	2000cbc2 <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
2000cbb0:	f7f5 f8e6 	bl	20001d80 <HAL_GetTick>
2000cbb4:	4602      	mov	r2, r0
2000cbb6:	693b      	ldr	r3, [r7, #16]
2000cbb8:	1ad3      	subs	r3, r2, r3
2000cbba:	2b64      	cmp	r3, #100	; 0x64
2000cbbc:	d901      	bls.n	2000cbc2 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
2000cbbe:	2303      	movs	r3, #3
2000cbc0:	e1ec      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2000cbc2:	4b61      	ldr	r3, [pc, #388]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cbc4:	681b      	ldr	r3, [r3, #0]
2000cbc6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000cbca:	2b00      	cmp	r3, #0
2000cbcc:	d0f0      	beq.n	2000cbb0 <HAL_RCC_OscConfig+0xe8>
2000cbce:	e014      	b.n	2000cbfa <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000cbd0:	f7f5 f8d6 	bl	20001d80 <HAL_GetTick>
2000cbd4:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
2000cbd6:	e008      	b.n	2000cbea <HAL_RCC_OscConfig+0x122>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
2000cbd8:	f7f5 f8d2 	bl	20001d80 <HAL_GetTick>
2000cbdc:	4602      	mov	r2, r0
2000cbde:	693b      	ldr	r3, [r7, #16]
2000cbe0:	1ad3      	subs	r3, r2, r3
2000cbe2:	2b64      	cmp	r3, #100	; 0x64
2000cbe4:	d901      	bls.n	2000cbea <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
2000cbe6:	2303      	movs	r3, #3
2000cbe8:	e1d8      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
2000cbea:	4b57      	ldr	r3, [pc, #348]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cbec:	681b      	ldr	r3, [r3, #0]
2000cbee:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000cbf2:	2b00      	cmp	r3, #0
2000cbf4:	d1f0      	bne.n	2000cbd8 <HAL_RCC_OscConfig+0x110>
2000cbf6:	e000      	b.n	2000cbfa <HAL_RCC_OscConfig+0x132>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
2000cbf8:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
2000cbfa:	687b      	ldr	r3, [r7, #4]
2000cbfc:	681b      	ldr	r3, [r3, #0]
2000cbfe:	f003 0302 	and.w	r3, r3, #2
2000cc02:	2b00      	cmp	r3, #0
2000cc04:	d069      	beq.n	2000ccda <HAL_RCC_OscConfig+0x212>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
2000cc06:	4b50      	ldr	r3, [pc, #320]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc08:	689b      	ldr	r3, [r3, #8]
2000cc0a:	f003 030c 	and.w	r3, r3, #12
2000cc0e:	2b00      	cmp	r3, #0
2000cc10:	d00b      	beq.n	2000cc2a <HAL_RCC_OscConfig+0x162>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
2000cc12:	4b4d      	ldr	r3, [pc, #308]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc14:	689b      	ldr	r3, [r3, #8]
2000cc16:	f003 030c 	and.w	r3, r3, #12
2000cc1a:	2b08      	cmp	r3, #8
2000cc1c:	d11c      	bne.n	2000cc58 <HAL_RCC_OscConfig+0x190>
2000cc1e:	4b4a      	ldr	r3, [pc, #296]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc20:	685b      	ldr	r3, [r3, #4]
2000cc22:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000cc26:	2b00      	cmp	r3, #0
2000cc28:	d116      	bne.n	2000cc58 <HAL_RCC_OscConfig+0x190>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
2000cc2a:	4b47      	ldr	r3, [pc, #284]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc2c:	681b      	ldr	r3, [r3, #0]
2000cc2e:	f003 0302 	and.w	r3, r3, #2
2000cc32:	2b00      	cmp	r3, #0
2000cc34:	d005      	beq.n	2000cc42 <HAL_RCC_OscConfig+0x17a>
2000cc36:	687b      	ldr	r3, [r7, #4]
2000cc38:	68db      	ldr	r3, [r3, #12]
2000cc3a:	2b01      	cmp	r3, #1
2000cc3c:	d001      	beq.n	2000cc42 <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
2000cc3e:	2301      	movs	r3, #1
2000cc40:	e1ac      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
2000cc42:	4b41      	ldr	r3, [pc, #260]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc44:	681b      	ldr	r3, [r3, #0]
2000cc46:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
2000cc4a:	687b      	ldr	r3, [r7, #4]
2000cc4c:	691b      	ldr	r3, [r3, #16]
2000cc4e:	00db      	lsls	r3, r3, #3
2000cc50:	493d      	ldr	r1, [pc, #244]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc52:	4313      	orrs	r3, r2
2000cc54:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
2000cc56:	e040      	b.n	2000ccda <HAL_RCC_OscConfig+0x212>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
2000cc58:	687b      	ldr	r3, [r7, #4]
2000cc5a:	68db      	ldr	r3, [r3, #12]
2000cc5c:	2b00      	cmp	r3, #0
2000cc5e:	d023      	beq.n	2000cca8 <HAL_RCC_OscConfig+0x1e0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
2000cc60:	4b39      	ldr	r3, [pc, #228]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc62:	681b      	ldr	r3, [r3, #0]
2000cc64:	4a38      	ldr	r2, [pc, #224]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc66:	f043 0301 	orr.w	r3, r3, #1
2000cc6a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000cc6c:	f7f5 f888 	bl	20001d80 <HAL_GetTick>
2000cc70:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2000cc72:	e008      	b.n	2000cc86 <HAL_RCC_OscConfig+0x1be>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
2000cc74:	f7f5 f884 	bl	20001d80 <HAL_GetTick>
2000cc78:	4602      	mov	r2, r0
2000cc7a:	693b      	ldr	r3, [r7, #16]
2000cc7c:	1ad3      	subs	r3, r2, r3
2000cc7e:	2b02      	cmp	r3, #2
2000cc80:	d901      	bls.n	2000cc86 <HAL_RCC_OscConfig+0x1be>
          {
            return HAL_TIMEOUT;
2000cc82:	2303      	movs	r3, #3
2000cc84:	e18a      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2000cc86:	4b30      	ldr	r3, [pc, #192]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc88:	681b      	ldr	r3, [r3, #0]
2000cc8a:	f003 0302 	and.w	r3, r3, #2
2000cc8e:	2b00      	cmp	r3, #0
2000cc90:	d0f0      	beq.n	2000cc74 <HAL_RCC_OscConfig+0x1ac>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
2000cc92:	4b2d      	ldr	r3, [pc, #180]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cc94:	681b      	ldr	r3, [r3, #0]
2000cc96:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
2000cc9a:	687b      	ldr	r3, [r7, #4]
2000cc9c:	691b      	ldr	r3, [r3, #16]
2000cc9e:	00db      	lsls	r3, r3, #3
2000cca0:	4929      	ldr	r1, [pc, #164]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cca2:	4313      	orrs	r3, r2
2000cca4:	600b      	str	r3, [r1, #0]
2000cca6:	e018      	b.n	2000ccda <HAL_RCC_OscConfig+0x212>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
2000cca8:	4b27      	ldr	r3, [pc, #156]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000ccaa:	681b      	ldr	r3, [r3, #0]
2000ccac:	4a26      	ldr	r2, [pc, #152]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000ccae:	f023 0301 	bic.w	r3, r3, #1
2000ccb2:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000ccb4:	f7f5 f864 	bl	20001d80 <HAL_GetTick>
2000ccb8:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
2000ccba:	e008      	b.n	2000ccce <HAL_RCC_OscConfig+0x206>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
2000ccbc:	f7f5 f860 	bl	20001d80 <HAL_GetTick>
2000ccc0:	4602      	mov	r2, r0
2000ccc2:	693b      	ldr	r3, [r7, #16]
2000ccc4:	1ad3      	subs	r3, r2, r3
2000ccc6:	2b02      	cmp	r3, #2
2000ccc8:	d901      	bls.n	2000ccce <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
2000ccca:	2303      	movs	r3, #3
2000cccc:	e166      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
2000ccce:	4b1e      	ldr	r3, [pc, #120]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000ccd0:	681b      	ldr	r3, [r3, #0]
2000ccd2:	f003 0302 	and.w	r3, r3, #2
2000ccd6:	2b00      	cmp	r3, #0
2000ccd8:	d1f0      	bne.n	2000ccbc <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
2000ccda:	687b      	ldr	r3, [r7, #4]
2000ccdc:	681b      	ldr	r3, [r3, #0]
2000ccde:	f003 0308 	and.w	r3, r3, #8
2000cce2:	2b00      	cmp	r3, #0
2000cce4:	d038      	beq.n	2000cd58 <HAL_RCC_OscConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
2000cce6:	687b      	ldr	r3, [r7, #4]
2000cce8:	695b      	ldr	r3, [r3, #20]
2000ccea:	2b00      	cmp	r3, #0
2000ccec:	d019      	beq.n	2000cd22 <HAL_RCC_OscConfig+0x25a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
2000ccee:	4b16      	ldr	r3, [pc, #88]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000ccf0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000ccf2:	4a15      	ldr	r2, [pc, #84]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000ccf4:	f043 0301 	orr.w	r3, r3, #1
2000ccf8:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2000ccfa:	f7f5 f841 	bl	20001d80 <HAL_GetTick>
2000ccfe:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
2000cd00:	e008      	b.n	2000cd14 <HAL_RCC_OscConfig+0x24c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
2000cd02:	f7f5 f83d 	bl	20001d80 <HAL_GetTick>
2000cd06:	4602      	mov	r2, r0
2000cd08:	693b      	ldr	r3, [r7, #16]
2000cd0a:	1ad3      	subs	r3, r2, r3
2000cd0c:	2b02      	cmp	r3, #2
2000cd0e:	d901      	bls.n	2000cd14 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
2000cd10:	2303      	movs	r3, #3
2000cd12:	e143      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
2000cd14:	4b0c      	ldr	r3, [pc, #48]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cd16:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000cd18:	f003 0302 	and.w	r3, r3, #2
2000cd1c:	2b00      	cmp	r3, #0
2000cd1e:	d0f0      	beq.n	2000cd02 <HAL_RCC_OscConfig+0x23a>
2000cd20:	e01a      	b.n	2000cd58 <HAL_RCC_OscConfig+0x290>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
2000cd22:	4b09      	ldr	r3, [pc, #36]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cd24:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000cd26:	4a08      	ldr	r2, [pc, #32]	; (2000cd48 <HAL_RCC_OscConfig+0x280>)
2000cd28:	f023 0301 	bic.w	r3, r3, #1
2000cd2c:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2000cd2e:	f7f5 f827 	bl	20001d80 <HAL_GetTick>
2000cd32:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
2000cd34:	e00a      	b.n	2000cd4c <HAL_RCC_OscConfig+0x284>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
2000cd36:	f7f5 f823 	bl	20001d80 <HAL_GetTick>
2000cd3a:	4602      	mov	r2, r0
2000cd3c:	693b      	ldr	r3, [r7, #16]
2000cd3e:	1ad3      	subs	r3, r2, r3
2000cd40:	2b02      	cmp	r3, #2
2000cd42:	d903      	bls.n	2000cd4c <HAL_RCC_OscConfig+0x284>
        {
          return HAL_TIMEOUT;
2000cd44:	2303      	movs	r3, #3
2000cd46:	e129      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
2000cd48:	40023800 	.word	0x40023800
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
2000cd4c:	4b95      	ldr	r3, [pc, #596]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cd4e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000cd50:	f003 0302 	and.w	r3, r3, #2
2000cd54:	2b00      	cmp	r3, #0
2000cd56:	d1ee      	bne.n	2000cd36 <HAL_RCC_OscConfig+0x26e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
2000cd58:	687b      	ldr	r3, [r7, #4]
2000cd5a:	681b      	ldr	r3, [r3, #0]
2000cd5c:	f003 0304 	and.w	r3, r3, #4
2000cd60:	2b00      	cmp	r3, #0
2000cd62:	f000 80a4 	beq.w	2000ceae <HAL_RCC_OscConfig+0x3e6>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
2000cd66:	4b8f      	ldr	r3, [pc, #572]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cd68:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000cd6a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000cd6e:	2b00      	cmp	r3, #0
2000cd70:	d10d      	bne.n	2000cd8e <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
2000cd72:	4b8c      	ldr	r3, [pc, #560]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cd74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000cd76:	4a8b      	ldr	r2, [pc, #556]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cd78:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000cd7c:	6413      	str	r3, [r2, #64]	; 0x40
2000cd7e:	4b89      	ldr	r3, [pc, #548]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cd80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000cd82:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000cd86:	60fb      	str	r3, [r7, #12]
2000cd88:	68fb      	ldr	r3, [r7, #12]
      pwrclkchanged = SET;
2000cd8a:	2301      	movs	r3, #1
2000cd8c:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
2000cd8e:	4b86      	ldr	r3, [pc, #536]	; (2000cfa8 <HAL_RCC_OscConfig+0x4e0>)
2000cd90:	681b      	ldr	r3, [r3, #0]
2000cd92:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000cd96:	2b00      	cmp	r3, #0
2000cd98:	d118      	bne.n	2000cdcc <HAL_RCC_OscConfig+0x304>
    {
      /* Enable write access to Backup domain */
      PWR->CR1 |= PWR_CR1_DBP;
2000cd9a:	4b83      	ldr	r3, [pc, #524]	; (2000cfa8 <HAL_RCC_OscConfig+0x4e0>)
2000cd9c:	681b      	ldr	r3, [r3, #0]
2000cd9e:	4a82      	ldr	r2, [pc, #520]	; (2000cfa8 <HAL_RCC_OscConfig+0x4e0>)
2000cda0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000cda4:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
2000cda6:	f7f4 ffeb 	bl	20001d80 <HAL_GetTick>
2000cdaa:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
2000cdac:	e008      	b.n	2000cdc0 <HAL_RCC_OscConfig+0x2f8>
      {
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
2000cdae:	f7f4 ffe7 	bl	20001d80 <HAL_GetTick>
2000cdb2:	4602      	mov	r2, r0
2000cdb4:	693b      	ldr	r3, [r7, #16]
2000cdb6:	1ad3      	subs	r3, r2, r3
2000cdb8:	2b64      	cmp	r3, #100	; 0x64
2000cdba:	d901      	bls.n	2000cdc0 <HAL_RCC_OscConfig+0x2f8>
        {
          return HAL_TIMEOUT;
2000cdbc:	2303      	movs	r3, #3
2000cdbe:	e0ed      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
2000cdc0:	4b79      	ldr	r3, [pc, #484]	; (2000cfa8 <HAL_RCC_OscConfig+0x4e0>)
2000cdc2:	681b      	ldr	r3, [r3, #0]
2000cdc4:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000cdc8:	2b00      	cmp	r3, #0
2000cdca:	d0f0      	beq.n	2000cdae <HAL_RCC_OscConfig+0x2e6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
2000cdcc:	687b      	ldr	r3, [r7, #4]
2000cdce:	689b      	ldr	r3, [r3, #8]
2000cdd0:	2b01      	cmp	r3, #1
2000cdd2:	d106      	bne.n	2000cde2 <HAL_RCC_OscConfig+0x31a>
2000cdd4:	4b73      	ldr	r3, [pc, #460]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cdd6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000cdd8:	4a72      	ldr	r2, [pc, #456]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cdda:	f043 0301 	orr.w	r3, r3, #1
2000cdde:	6713      	str	r3, [r2, #112]	; 0x70
2000cde0:	e02d      	b.n	2000ce3e <HAL_RCC_OscConfig+0x376>
2000cde2:	687b      	ldr	r3, [r7, #4]
2000cde4:	689b      	ldr	r3, [r3, #8]
2000cde6:	2b00      	cmp	r3, #0
2000cde8:	d10c      	bne.n	2000ce04 <HAL_RCC_OscConfig+0x33c>
2000cdea:	4b6e      	ldr	r3, [pc, #440]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cdec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000cdee:	4a6d      	ldr	r2, [pc, #436]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cdf0:	f023 0301 	bic.w	r3, r3, #1
2000cdf4:	6713      	str	r3, [r2, #112]	; 0x70
2000cdf6:	4b6b      	ldr	r3, [pc, #428]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cdf8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000cdfa:	4a6a      	ldr	r2, [pc, #424]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cdfc:	f023 0304 	bic.w	r3, r3, #4
2000ce00:	6713      	str	r3, [r2, #112]	; 0x70
2000ce02:	e01c      	b.n	2000ce3e <HAL_RCC_OscConfig+0x376>
2000ce04:	687b      	ldr	r3, [r7, #4]
2000ce06:	689b      	ldr	r3, [r3, #8]
2000ce08:	2b05      	cmp	r3, #5
2000ce0a:	d10c      	bne.n	2000ce26 <HAL_RCC_OscConfig+0x35e>
2000ce0c:	4b65      	ldr	r3, [pc, #404]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce0e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000ce10:	4a64      	ldr	r2, [pc, #400]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce12:	f043 0304 	orr.w	r3, r3, #4
2000ce16:	6713      	str	r3, [r2, #112]	; 0x70
2000ce18:	4b62      	ldr	r3, [pc, #392]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce1a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000ce1c:	4a61      	ldr	r2, [pc, #388]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce1e:	f043 0301 	orr.w	r3, r3, #1
2000ce22:	6713      	str	r3, [r2, #112]	; 0x70
2000ce24:	e00b      	b.n	2000ce3e <HAL_RCC_OscConfig+0x376>
2000ce26:	4b5f      	ldr	r3, [pc, #380]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce28:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000ce2a:	4a5e      	ldr	r2, [pc, #376]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce2c:	f023 0301 	bic.w	r3, r3, #1
2000ce30:	6713      	str	r3, [r2, #112]	; 0x70
2000ce32:	4b5c      	ldr	r3, [pc, #368]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce34:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000ce36:	4a5b      	ldr	r2, [pc, #364]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce38:	f023 0304 	bic.w	r3, r3, #4
2000ce3c:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
2000ce3e:	687b      	ldr	r3, [r7, #4]
2000ce40:	689b      	ldr	r3, [r3, #8]
2000ce42:	2b00      	cmp	r3, #0
2000ce44:	d015      	beq.n	2000ce72 <HAL_RCC_OscConfig+0x3aa>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2000ce46:	f7f4 ff9b 	bl	20001d80 <HAL_GetTick>
2000ce4a:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
2000ce4c:	e00a      	b.n	2000ce64 <HAL_RCC_OscConfig+0x39c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
2000ce4e:	f7f4 ff97 	bl	20001d80 <HAL_GetTick>
2000ce52:	4602      	mov	r2, r0
2000ce54:	693b      	ldr	r3, [r7, #16]
2000ce56:	1ad3      	subs	r3, r2, r3
2000ce58:	f241 3288 	movw	r2, #5000	; 0x1388
2000ce5c:	4293      	cmp	r3, r2
2000ce5e:	d901      	bls.n	2000ce64 <HAL_RCC_OscConfig+0x39c>
        {
          return HAL_TIMEOUT;
2000ce60:	2303      	movs	r3, #3
2000ce62:	e09b      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
2000ce64:	4b4f      	ldr	r3, [pc, #316]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce66:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000ce68:	f003 0302 	and.w	r3, r3, #2
2000ce6c:	2b00      	cmp	r3, #0
2000ce6e:	d0ee      	beq.n	2000ce4e <HAL_RCC_OscConfig+0x386>
2000ce70:	e014      	b.n	2000ce9c <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2000ce72:	f7f4 ff85 	bl	20001d80 <HAL_GetTick>
2000ce76:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
2000ce78:	e00a      	b.n	2000ce90 <HAL_RCC_OscConfig+0x3c8>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
2000ce7a:	f7f4 ff81 	bl	20001d80 <HAL_GetTick>
2000ce7e:	4602      	mov	r2, r0
2000ce80:	693b      	ldr	r3, [r7, #16]
2000ce82:	1ad3      	subs	r3, r2, r3
2000ce84:	f241 3288 	movw	r2, #5000	; 0x1388
2000ce88:	4293      	cmp	r3, r2
2000ce8a:	d901      	bls.n	2000ce90 <HAL_RCC_OscConfig+0x3c8>
        {
          return HAL_TIMEOUT;
2000ce8c:	2303      	movs	r3, #3
2000ce8e:	e085      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
2000ce90:	4b44      	ldr	r3, [pc, #272]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ce92:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000ce94:	f003 0302 	and.w	r3, r3, #2
2000ce98:	2b00      	cmp	r3, #0
2000ce9a:	d1ee      	bne.n	2000ce7a <HAL_RCC_OscConfig+0x3b2>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
2000ce9c:	7dfb      	ldrb	r3, [r7, #23]
2000ce9e:	2b01      	cmp	r3, #1
2000cea0:	d105      	bne.n	2000ceae <HAL_RCC_OscConfig+0x3e6>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
2000cea2:	4b40      	ldr	r3, [pc, #256]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cea4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000cea6:	4a3f      	ldr	r2, [pc, #252]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cea8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2000ceac:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
2000ceae:	687b      	ldr	r3, [r7, #4]
2000ceb0:	699b      	ldr	r3, [r3, #24]
2000ceb2:	2b00      	cmp	r3, #0
2000ceb4:	d071      	beq.n	2000cf9a <HAL_RCC_OscConfig+0x4d2>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
2000ceb6:	4b3b      	ldr	r3, [pc, #236]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ceb8:	689b      	ldr	r3, [r3, #8]
2000ceba:	f003 030c 	and.w	r3, r3, #12
2000cebe:	2b08      	cmp	r3, #8
2000cec0:	d069      	beq.n	2000cf96 <HAL_RCC_OscConfig+0x4ce>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
2000cec2:	687b      	ldr	r3, [r7, #4]
2000cec4:	699b      	ldr	r3, [r3, #24]
2000cec6:	2b02      	cmp	r3, #2
2000cec8:	d14b      	bne.n	2000cf62 <HAL_RCC_OscConfig+0x49a>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
2000ceca:	4b36      	ldr	r3, [pc, #216]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cecc:	681b      	ldr	r3, [r3, #0]
2000cece:	4a35      	ldr	r2, [pc, #212]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000ced0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2000ced4:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000ced6:	f7f4 ff53 	bl	20001d80 <HAL_GetTick>
2000ceda:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
2000cedc:	e008      	b.n	2000cef0 <HAL_RCC_OscConfig+0x428>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2000cede:	f7f4 ff4f 	bl	20001d80 <HAL_GetTick>
2000cee2:	4602      	mov	r2, r0
2000cee4:	693b      	ldr	r3, [r7, #16]
2000cee6:	1ad3      	subs	r3, r2, r3
2000cee8:	2b02      	cmp	r3, #2
2000ceea:	d901      	bls.n	2000cef0 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
2000ceec:	2303      	movs	r3, #3
2000ceee:	e055      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
2000cef0:	4b2c      	ldr	r3, [pc, #176]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cef2:	681b      	ldr	r3, [r3, #0]
2000cef4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000cef8:	2b00      	cmp	r3, #0
2000cefa:	d1f0      	bne.n	2000cede <HAL_RCC_OscConfig+0x416>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
#if defined (RCC_PLLCFGR_PLLR)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
2000cefc:	687b      	ldr	r3, [r7, #4]
2000cefe:	69da      	ldr	r2, [r3, #28]
2000cf00:	687b      	ldr	r3, [r7, #4]
2000cf02:	6a1b      	ldr	r3, [r3, #32]
2000cf04:	431a      	orrs	r2, r3
2000cf06:	687b      	ldr	r3, [r7, #4]
2000cf08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000cf0a:	019b      	lsls	r3, r3, #6
2000cf0c:	431a      	orrs	r2, r3
2000cf0e:	687b      	ldr	r3, [r7, #4]
2000cf10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000cf12:	085b      	lsrs	r3, r3, #1
2000cf14:	3b01      	subs	r3, #1
2000cf16:	041b      	lsls	r3, r3, #16
2000cf18:	431a      	orrs	r2, r3
2000cf1a:	687b      	ldr	r3, [r7, #4]
2000cf1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000cf1e:	061b      	lsls	r3, r3, #24
2000cf20:	431a      	orrs	r2, r3
2000cf22:	687b      	ldr	r3, [r7, #4]
2000cf24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000cf26:	071b      	lsls	r3, r3, #28
2000cf28:	491e      	ldr	r1, [pc, #120]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cf2a:	4313      	orrs	r3, r2
2000cf2c:	604b      	str	r3, [r1, #4]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
#endif

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
2000cf2e:	4b1d      	ldr	r3, [pc, #116]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cf30:	681b      	ldr	r3, [r3, #0]
2000cf32:	4a1c      	ldr	r2, [pc, #112]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cf34:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
2000cf38:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000cf3a:	f7f4 ff21 	bl	20001d80 <HAL_GetTick>
2000cf3e:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
2000cf40:	e008      	b.n	2000cf54 <HAL_RCC_OscConfig+0x48c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2000cf42:	f7f4 ff1d 	bl	20001d80 <HAL_GetTick>
2000cf46:	4602      	mov	r2, r0
2000cf48:	693b      	ldr	r3, [r7, #16]
2000cf4a:	1ad3      	subs	r3, r2, r3
2000cf4c:	2b02      	cmp	r3, #2
2000cf4e:	d901      	bls.n	2000cf54 <HAL_RCC_OscConfig+0x48c>
          {
            return HAL_TIMEOUT;
2000cf50:	2303      	movs	r3, #3
2000cf52:	e023      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
2000cf54:	4b13      	ldr	r3, [pc, #76]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cf56:	681b      	ldr	r3, [r3, #0]
2000cf58:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000cf5c:	2b00      	cmp	r3, #0
2000cf5e:	d0f0      	beq.n	2000cf42 <HAL_RCC_OscConfig+0x47a>
2000cf60:	e01b      	b.n	2000cf9a <HAL_RCC_OscConfig+0x4d2>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
2000cf62:	4b10      	ldr	r3, [pc, #64]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cf64:	681b      	ldr	r3, [r3, #0]
2000cf66:	4a0f      	ldr	r2, [pc, #60]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cf68:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2000cf6c:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000cf6e:	f7f4 ff07 	bl	20001d80 <HAL_GetTick>
2000cf72:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
2000cf74:	e008      	b.n	2000cf88 <HAL_RCC_OscConfig+0x4c0>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2000cf76:	f7f4 ff03 	bl	20001d80 <HAL_GetTick>
2000cf7a:	4602      	mov	r2, r0
2000cf7c:	693b      	ldr	r3, [r7, #16]
2000cf7e:	1ad3      	subs	r3, r2, r3
2000cf80:	2b02      	cmp	r3, #2
2000cf82:	d901      	bls.n	2000cf88 <HAL_RCC_OscConfig+0x4c0>
          {
            return HAL_TIMEOUT;
2000cf84:	2303      	movs	r3, #3
2000cf86:	e009      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
2000cf88:	4b06      	ldr	r3, [pc, #24]	; (2000cfa4 <HAL_RCC_OscConfig+0x4dc>)
2000cf8a:	681b      	ldr	r3, [r3, #0]
2000cf8c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000cf90:	2b00      	cmp	r3, #0
2000cf92:	d1f0      	bne.n	2000cf76 <HAL_RCC_OscConfig+0x4ae>
2000cf94:	e001      	b.n	2000cf9a <HAL_RCC_OscConfig+0x4d2>
        }
      }
    }
    else
    {
      return HAL_ERROR;
2000cf96:	2301      	movs	r3, #1
2000cf98:	e000      	b.n	2000cf9c <HAL_RCC_OscConfig+0x4d4>
    }
  }
  return HAL_OK;
2000cf9a:	2300      	movs	r3, #0
}
2000cf9c:	4618      	mov	r0, r3
2000cf9e:	3718      	adds	r7, #24
2000cfa0:	46bd      	mov	sp, r7
2000cfa2:	bd80      	pop	{r7, pc}
2000cfa4:	40023800 	.word	0x40023800
2000cfa8:	40007000 	.word	0x40007000

2000cfac <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
2000cfac:	b580      	push	{r7, lr}
2000cfae:	b084      	sub	sp, #16
2000cfb0:	af00      	add	r7, sp, #0
2000cfb2:	6078      	str	r0, [r7, #4]
2000cfb4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
2000cfb6:	2300      	movs	r3, #0
2000cfb8:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
2000cfba:	687b      	ldr	r3, [r7, #4]
2000cfbc:	2b00      	cmp	r3, #0
2000cfbe:	d101      	bne.n	2000cfc4 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
2000cfc0:	2301      	movs	r3, #1
2000cfc2:	e0ce      	b.n	2000d162 <HAL_RCC_ClockConfig+0x1b6>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
2000cfc4:	4b69      	ldr	r3, [pc, #420]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000cfc6:	681b      	ldr	r3, [r3, #0]
2000cfc8:	f003 030f 	and.w	r3, r3, #15
2000cfcc:	683a      	ldr	r2, [r7, #0]
2000cfce:	429a      	cmp	r2, r3
2000cfd0:	d910      	bls.n	2000cff4 <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
2000cfd2:	4b66      	ldr	r3, [pc, #408]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000cfd4:	681b      	ldr	r3, [r3, #0]
2000cfd6:	f023 020f 	bic.w	r2, r3, #15
2000cfda:	4964      	ldr	r1, [pc, #400]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000cfdc:	683b      	ldr	r3, [r7, #0]
2000cfde:	4313      	orrs	r3, r2
2000cfe0:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
2000cfe2:	4b62      	ldr	r3, [pc, #392]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000cfe4:	681b      	ldr	r3, [r3, #0]
2000cfe6:	f003 030f 	and.w	r3, r3, #15
2000cfea:	683a      	ldr	r2, [r7, #0]
2000cfec:	429a      	cmp	r2, r3
2000cfee:	d001      	beq.n	2000cff4 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
2000cff0:	2301      	movs	r3, #1
2000cff2:	e0b6      	b.n	2000d162 <HAL_RCC_ClockConfig+0x1b6>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
2000cff4:	687b      	ldr	r3, [r7, #4]
2000cff6:	681b      	ldr	r3, [r3, #0]
2000cff8:	f003 0302 	and.w	r3, r3, #2
2000cffc:	2b00      	cmp	r3, #0
2000cffe:	d020      	beq.n	2000d042 <HAL_RCC_ClockConfig+0x96>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
2000d000:	687b      	ldr	r3, [r7, #4]
2000d002:	681b      	ldr	r3, [r3, #0]
2000d004:	f003 0304 	and.w	r3, r3, #4
2000d008:	2b00      	cmp	r3, #0
2000d00a:	d005      	beq.n	2000d018 <HAL_RCC_ClockConfig+0x6c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
2000d00c:	4b58      	ldr	r3, [pc, #352]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d00e:	689b      	ldr	r3, [r3, #8]
2000d010:	4a57      	ldr	r2, [pc, #348]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d012:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
2000d016:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
2000d018:	687b      	ldr	r3, [r7, #4]
2000d01a:	681b      	ldr	r3, [r3, #0]
2000d01c:	f003 0308 	and.w	r3, r3, #8
2000d020:	2b00      	cmp	r3, #0
2000d022:	d005      	beq.n	2000d030 <HAL_RCC_ClockConfig+0x84>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
2000d024:	4b52      	ldr	r3, [pc, #328]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d026:	689b      	ldr	r3, [r3, #8]
2000d028:	4a51      	ldr	r2, [pc, #324]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d02a:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
2000d02e:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
2000d030:	4b4f      	ldr	r3, [pc, #316]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d032:	689b      	ldr	r3, [r3, #8]
2000d034:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
2000d038:	687b      	ldr	r3, [r7, #4]
2000d03a:	689b      	ldr	r3, [r3, #8]
2000d03c:	494c      	ldr	r1, [pc, #304]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d03e:	4313      	orrs	r3, r2
2000d040:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
2000d042:	687b      	ldr	r3, [r7, #4]
2000d044:	681b      	ldr	r3, [r3, #0]
2000d046:	f003 0301 	and.w	r3, r3, #1
2000d04a:	2b00      	cmp	r3, #0
2000d04c:	d040      	beq.n	2000d0d0 <HAL_RCC_ClockConfig+0x124>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
2000d04e:	687b      	ldr	r3, [r7, #4]
2000d050:	685b      	ldr	r3, [r3, #4]
2000d052:	2b01      	cmp	r3, #1
2000d054:	d107      	bne.n	2000d066 <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2000d056:	4b46      	ldr	r3, [pc, #280]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d058:	681b      	ldr	r3, [r3, #0]
2000d05a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000d05e:	2b00      	cmp	r3, #0
2000d060:	d115      	bne.n	2000d08e <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
2000d062:	2301      	movs	r3, #1
2000d064:	e07d      	b.n	2000d162 <HAL_RCC_ClockConfig+0x1b6>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
2000d066:	687b      	ldr	r3, [r7, #4]
2000d068:	685b      	ldr	r3, [r3, #4]
2000d06a:	2b02      	cmp	r3, #2
2000d06c:	d107      	bne.n	2000d07e <HAL_RCC_ClockConfig+0xd2>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
2000d06e:	4b40      	ldr	r3, [pc, #256]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d070:	681b      	ldr	r3, [r3, #0]
2000d072:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000d076:	2b00      	cmp	r3, #0
2000d078:	d109      	bne.n	2000d08e <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
2000d07a:	2301      	movs	r3, #1
2000d07c:	e071      	b.n	2000d162 <HAL_RCC_ClockConfig+0x1b6>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2000d07e:	4b3c      	ldr	r3, [pc, #240]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d080:	681b      	ldr	r3, [r3, #0]
2000d082:	f003 0302 	and.w	r3, r3, #2
2000d086:	2b00      	cmp	r3, #0
2000d088:	d101      	bne.n	2000d08e <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
2000d08a:	2301      	movs	r3, #1
2000d08c:	e069      	b.n	2000d162 <HAL_RCC_ClockConfig+0x1b6>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
2000d08e:	4b38      	ldr	r3, [pc, #224]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d090:	689b      	ldr	r3, [r3, #8]
2000d092:	f023 0203 	bic.w	r2, r3, #3
2000d096:	687b      	ldr	r3, [r7, #4]
2000d098:	685b      	ldr	r3, [r3, #4]
2000d09a:	4935      	ldr	r1, [pc, #212]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d09c:	4313      	orrs	r3, r2
2000d09e:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2000d0a0:	f7f4 fe6e 	bl	20001d80 <HAL_GetTick>
2000d0a4:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
2000d0a6:	e00a      	b.n	2000d0be <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2000d0a8:	f7f4 fe6a 	bl	20001d80 <HAL_GetTick>
2000d0ac:	4602      	mov	r2, r0
2000d0ae:	68fb      	ldr	r3, [r7, #12]
2000d0b0:	1ad3      	subs	r3, r2, r3
2000d0b2:	f241 3288 	movw	r2, #5000	; 0x1388
2000d0b6:	4293      	cmp	r3, r2
2000d0b8:	d901      	bls.n	2000d0be <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
2000d0ba:	2303      	movs	r3, #3
2000d0bc:	e051      	b.n	2000d162 <HAL_RCC_ClockConfig+0x1b6>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
2000d0be:	4b2c      	ldr	r3, [pc, #176]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d0c0:	689b      	ldr	r3, [r3, #8]
2000d0c2:	f003 020c 	and.w	r2, r3, #12
2000d0c6:	687b      	ldr	r3, [r7, #4]
2000d0c8:	685b      	ldr	r3, [r3, #4]
2000d0ca:	009b      	lsls	r3, r3, #2
2000d0cc:	429a      	cmp	r2, r3
2000d0ce:	d1eb      	bne.n	2000d0a8 <HAL_RCC_ClockConfig+0xfc>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
2000d0d0:	4b26      	ldr	r3, [pc, #152]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000d0d2:	681b      	ldr	r3, [r3, #0]
2000d0d4:	f003 030f 	and.w	r3, r3, #15
2000d0d8:	683a      	ldr	r2, [r7, #0]
2000d0da:	429a      	cmp	r2, r3
2000d0dc:	d210      	bcs.n	2000d100 <HAL_RCC_ClockConfig+0x154>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
2000d0de:	4b23      	ldr	r3, [pc, #140]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000d0e0:	681b      	ldr	r3, [r3, #0]
2000d0e2:	f023 020f 	bic.w	r2, r3, #15
2000d0e6:	4921      	ldr	r1, [pc, #132]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000d0e8:	683b      	ldr	r3, [r7, #0]
2000d0ea:	4313      	orrs	r3, r2
2000d0ec:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
2000d0ee:	4b1f      	ldr	r3, [pc, #124]	; (2000d16c <HAL_RCC_ClockConfig+0x1c0>)
2000d0f0:	681b      	ldr	r3, [r3, #0]
2000d0f2:	f003 030f 	and.w	r3, r3, #15
2000d0f6:	683a      	ldr	r2, [r7, #0]
2000d0f8:	429a      	cmp	r2, r3
2000d0fa:	d001      	beq.n	2000d100 <HAL_RCC_ClockConfig+0x154>
    {
      return HAL_ERROR;
2000d0fc:	2301      	movs	r3, #1
2000d0fe:	e030      	b.n	2000d162 <HAL_RCC_ClockConfig+0x1b6>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
2000d100:	687b      	ldr	r3, [r7, #4]
2000d102:	681b      	ldr	r3, [r3, #0]
2000d104:	f003 0304 	and.w	r3, r3, #4
2000d108:	2b00      	cmp	r3, #0
2000d10a:	d008      	beq.n	2000d11e <HAL_RCC_ClockConfig+0x172>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
2000d10c:	4b18      	ldr	r3, [pc, #96]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d10e:	689b      	ldr	r3, [r3, #8]
2000d110:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
2000d114:	687b      	ldr	r3, [r7, #4]
2000d116:	68db      	ldr	r3, [r3, #12]
2000d118:	4915      	ldr	r1, [pc, #84]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d11a:	4313      	orrs	r3, r2
2000d11c:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
2000d11e:	687b      	ldr	r3, [r7, #4]
2000d120:	681b      	ldr	r3, [r3, #0]
2000d122:	f003 0308 	and.w	r3, r3, #8
2000d126:	2b00      	cmp	r3, #0
2000d128:	d009      	beq.n	2000d13e <HAL_RCC_ClockConfig+0x192>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
2000d12a:	4b11      	ldr	r3, [pc, #68]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d12c:	689b      	ldr	r3, [r3, #8]
2000d12e:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
2000d132:	687b      	ldr	r3, [r7, #4]
2000d134:	691b      	ldr	r3, [r3, #16]
2000d136:	00db      	lsls	r3, r3, #3
2000d138:	490d      	ldr	r1, [pc, #52]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d13a:	4313      	orrs	r3, r2
2000d13c:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
2000d13e:	f000 f8a1 	bl	2000d284 <HAL_RCC_GetSysClockFreq>
2000d142:	4601      	mov	r1, r0
2000d144:	4b0a      	ldr	r3, [pc, #40]	; (2000d170 <HAL_RCC_ClockConfig+0x1c4>)
2000d146:	689b      	ldr	r3, [r3, #8]
2000d148:	091b      	lsrs	r3, r3, #4
2000d14a:	f003 030f 	and.w	r3, r3, #15
2000d14e:	4a09      	ldr	r2, [pc, #36]	; (2000d174 <HAL_RCC_ClockConfig+0x1c8>)
2000d150:	5cd3      	ldrb	r3, [r2, r3]
2000d152:	fa21 f303 	lsr.w	r3, r1, r3
2000d156:	4a08      	ldr	r2, [pc, #32]	; (2000d178 <HAL_RCC_ClockConfig+0x1cc>)
2000d158:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
2000d15a:	2000      	movs	r0, #0
2000d15c:	f7f4 fdcc 	bl	20001cf8 <HAL_InitTick>

  return HAL_OK;
2000d160:	2300      	movs	r3, #0
}
2000d162:	4618      	mov	r0, r3
2000d164:	3710      	adds	r7, #16
2000d166:	46bd      	mov	sp, r7
2000d168:	bd80      	pop	{r7, pc}
2000d16a:	bf00      	nop
2000d16c:	40023c00 	.word	0x40023c00
2000d170:	40023800 	.word	0x40023800
2000d174:	2000e6e8 	.word	0x2000e6e8
2000d178:	20000410 	.word	0x20000410

2000d17c <HAL_RCC_MCOConfig>:
  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
2000d17c:	b580      	push	{r7, lr}
2000d17e:	b08c      	sub	sp, #48	; 0x30
2000d180:	af00      	add	r7, sp, #0
2000d182:	60f8      	str	r0, [r7, #12]
2000d184:	60b9      	str	r1, [r7, #8]
2000d186:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
2000d188:	68fb      	ldr	r3, [r7, #12]
2000d18a:	2b00      	cmp	r3, #0
2000d18c:	d127      	bne.n	2000d1de <HAL_RCC_MCOConfig+0x62>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
2000d18e:	4b2a      	ldr	r3, [pc, #168]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d190:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000d192:	4a29      	ldr	r2, [pc, #164]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d194:	f043 0301 	orr.w	r3, r3, #1
2000d198:	6313      	str	r3, [r2, #48]	; 0x30
2000d19a:	4b27      	ldr	r3, [pc, #156]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d19c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000d19e:	f003 0301 	and.w	r3, r3, #1
2000d1a2:	61bb      	str	r3, [r7, #24]
2000d1a4:	69bb      	ldr	r3, [r7, #24]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
2000d1a6:	f44f 7380 	mov.w	r3, #256	; 0x100
2000d1aa:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2000d1ac:	2302      	movs	r3, #2
2000d1ae:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
2000d1b0:	2303      	movs	r3, #3
2000d1b2:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
2000d1b4:	2300      	movs	r3, #0
2000d1b6:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
2000d1b8:	2300      	movs	r3, #0
2000d1ba:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
2000d1bc:	f107 031c 	add.w	r3, r7, #28
2000d1c0:	4619      	mov	r1, r3
2000d1c2:	481e      	ldr	r0, [pc, #120]	; (2000d23c <HAL_RCC_MCOConfig+0xc0>)
2000d1c4:	f7f8 fab2 	bl	2000572c <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
2000d1c8:	4b1b      	ldr	r3, [pc, #108]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d1ca:	689b      	ldr	r3, [r3, #8]
2000d1cc:	f023 62ec 	bic.w	r2, r3, #123731968	; 0x7600000
2000d1d0:	68b9      	ldr	r1, [r7, #8]
2000d1d2:	687b      	ldr	r3, [r7, #4]
2000d1d4:	430b      	orrs	r3, r1
2000d1d6:	4918      	ldr	r1, [pc, #96]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d1d8:	4313      	orrs	r3, r2
2000d1da:	608b      	str	r3, [r1, #8]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
  }
}
2000d1dc:	e027      	b.n	2000d22e <HAL_RCC_MCOConfig+0xb2>
    MCO2_CLK_ENABLE();
2000d1de:	4b16      	ldr	r3, [pc, #88]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d1e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000d1e2:	4a15      	ldr	r2, [pc, #84]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d1e4:	f043 0304 	orr.w	r3, r3, #4
2000d1e8:	6313      	str	r3, [r2, #48]	; 0x30
2000d1ea:	4b13      	ldr	r3, [pc, #76]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d1ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000d1ee:	f003 0304 	and.w	r3, r3, #4
2000d1f2:	617b      	str	r3, [r7, #20]
2000d1f4:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
2000d1f6:	f44f 7300 	mov.w	r3, #512	; 0x200
2000d1fa:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2000d1fc:	2302      	movs	r3, #2
2000d1fe:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
2000d200:	2303      	movs	r3, #3
2000d202:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
2000d204:	2300      	movs	r3, #0
2000d206:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
2000d208:	2300      	movs	r3, #0
2000d20a:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
2000d20c:	f107 031c 	add.w	r3, r7, #28
2000d210:	4619      	mov	r1, r3
2000d212:	480b      	ldr	r0, [pc, #44]	; (2000d240 <HAL_RCC_MCOConfig+0xc4>)
2000d214:	f7f8 fa8a 	bl	2000572c <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
2000d218:	4b07      	ldr	r3, [pc, #28]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d21a:	689b      	ldr	r3, [r3, #8]
2000d21c:	f023 4278 	bic.w	r2, r3, #4160749568	; 0xf8000000
2000d220:	687b      	ldr	r3, [r7, #4]
2000d222:	00d9      	lsls	r1, r3, #3
2000d224:	68bb      	ldr	r3, [r7, #8]
2000d226:	430b      	orrs	r3, r1
2000d228:	4903      	ldr	r1, [pc, #12]	; (2000d238 <HAL_RCC_MCOConfig+0xbc>)
2000d22a:	4313      	orrs	r3, r2
2000d22c:	608b      	str	r3, [r1, #8]
}
2000d22e:	bf00      	nop
2000d230:	3730      	adds	r7, #48	; 0x30
2000d232:	46bd      	mov	sp, r7
2000d234:	bd80      	pop	{r7, pc}
2000d236:	bf00      	nop
2000d238:	40023800 	.word	0x40023800
2000d23c:	40020000 	.word	0x40020000
2000d240:	40020800 	.word	0x40020800

2000d244 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M7 NMI (Non-Maskable Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
2000d244:	b480      	push	{r7}
2000d246:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSON);
2000d248:	4b05      	ldr	r3, [pc, #20]	; (2000d260 <HAL_RCC_EnableCSS+0x1c>)
2000d24a:	681b      	ldr	r3, [r3, #0]
2000d24c:	4a04      	ldr	r2, [pc, #16]	; (2000d260 <HAL_RCC_EnableCSS+0x1c>)
2000d24e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
2000d252:	6013      	str	r3, [r2, #0]
}
2000d254:	bf00      	nop
2000d256:	46bd      	mov	sp, r7
2000d258:	f85d 7b04 	ldr.w	r7, [sp], #4
2000d25c:	4770      	bx	lr
2000d25e:	bf00      	nop
2000d260:	40023800 	.word	0x40023800

2000d264 <HAL_RCC_DisableCSS>:
/**
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
2000d264:	b480      	push	{r7}
2000d266:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
2000d268:	4b05      	ldr	r3, [pc, #20]	; (2000d280 <HAL_RCC_DisableCSS+0x1c>)
2000d26a:	681b      	ldr	r3, [r3, #0]
2000d26c:	4a04      	ldr	r2, [pc, #16]	; (2000d280 <HAL_RCC_DisableCSS+0x1c>)
2000d26e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
2000d272:	6013      	str	r3, [r2, #0]
}
2000d274:	bf00      	nop
2000d276:	46bd      	mov	sp, r7
2000d278:	f85d 7b04 	ldr.w	r7, [sp], #4
2000d27c:	4770      	bx	lr
2000d27e:	bf00      	nop
2000d280:	40023800 	.word	0x40023800

2000d284 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
2000d284:	b5f0      	push	{r4, r5, r6, r7, lr}
2000d286:	b085      	sub	sp, #20
2000d288:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
2000d28a:	2300      	movs	r3, #0
2000d28c:	607b      	str	r3, [r7, #4]
2000d28e:	2300      	movs	r3, #0
2000d290:	60fb      	str	r3, [r7, #12]
2000d292:	2300      	movs	r3, #0
2000d294:	603b      	str	r3, [r7, #0]
  uint32_t sysclockfreq = 0;
2000d296:	2300      	movs	r3, #0
2000d298:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
2000d29a:	4b50      	ldr	r3, [pc, #320]	; (2000d3dc <HAL_RCC_GetSysClockFreq+0x158>)
2000d29c:	689b      	ldr	r3, [r3, #8]
2000d29e:	f003 030c 	and.w	r3, r3, #12
2000d2a2:	2b04      	cmp	r3, #4
2000d2a4:	d007      	beq.n	2000d2b6 <HAL_RCC_GetSysClockFreq+0x32>
2000d2a6:	2b08      	cmp	r3, #8
2000d2a8:	d008      	beq.n	2000d2bc <HAL_RCC_GetSysClockFreq+0x38>
2000d2aa:	2b00      	cmp	r3, #0
2000d2ac:	f040 808d 	bne.w	2000d3ca <HAL_RCC_GetSysClockFreq+0x146>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
2000d2b0:	4b4b      	ldr	r3, [pc, #300]	; (2000d3e0 <HAL_RCC_GetSysClockFreq+0x15c>)
2000d2b2:	60bb      	str	r3, [r7, #8]
       break;
2000d2b4:	e08c      	b.n	2000d3d0 <HAL_RCC_GetSysClockFreq+0x14c>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
2000d2b6:	4b4b      	ldr	r3, [pc, #300]	; (2000d3e4 <HAL_RCC_GetSysClockFreq+0x160>)
2000d2b8:	60bb      	str	r3, [r7, #8]
      break;
2000d2ba:	e089      	b.n	2000d3d0 <HAL_RCC_GetSysClockFreq+0x14c>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
2000d2bc:	4b47      	ldr	r3, [pc, #284]	; (2000d3dc <HAL_RCC_GetSysClockFreq+0x158>)
2000d2be:	685b      	ldr	r3, [r3, #4]
2000d2c0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000d2c4:	607b      	str	r3, [r7, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
2000d2c6:	4b45      	ldr	r3, [pc, #276]	; (2000d3dc <HAL_RCC_GetSysClockFreq+0x158>)
2000d2c8:	685b      	ldr	r3, [r3, #4]
2000d2ca:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000d2ce:	2b00      	cmp	r3, #0
2000d2d0:	d023      	beq.n	2000d31a <HAL_RCC_GetSysClockFreq+0x96>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
2000d2d2:	4b42      	ldr	r3, [pc, #264]	; (2000d3dc <HAL_RCC_GetSysClockFreq+0x158>)
2000d2d4:	685b      	ldr	r3, [r3, #4]
2000d2d6:	099b      	lsrs	r3, r3, #6
2000d2d8:	f04f 0400 	mov.w	r4, #0
2000d2dc:	f240 11ff 	movw	r1, #511	; 0x1ff
2000d2e0:	f04f 0200 	mov.w	r2, #0
2000d2e4:	ea03 0501 	and.w	r5, r3, r1
2000d2e8:	ea04 0602 	and.w	r6, r4, r2
2000d2ec:	4a3d      	ldr	r2, [pc, #244]	; (2000d3e4 <HAL_RCC_GetSysClockFreq+0x160>)
2000d2ee:	fb02 f106 	mul.w	r1, r2, r6
2000d2f2:	2200      	movs	r2, #0
2000d2f4:	fb02 f205 	mul.w	r2, r2, r5
2000d2f8:	440a      	add	r2, r1
2000d2fa:	493a      	ldr	r1, [pc, #232]	; (2000d3e4 <HAL_RCC_GetSysClockFreq+0x160>)
2000d2fc:	fba5 0101 	umull	r0, r1, r5, r1
2000d300:	1853      	adds	r3, r2, r1
2000d302:	4619      	mov	r1, r3
2000d304:	687b      	ldr	r3, [r7, #4]
2000d306:	f04f 0400 	mov.w	r4, #0
2000d30a:	461a      	mov	r2, r3
2000d30c:	4623      	mov	r3, r4
2000d30e:	f7f3 f963 	bl	200005d8 <__aeabi_uldivmod>
2000d312:	4603      	mov	r3, r0
2000d314:	460c      	mov	r4, r1
2000d316:	60fb      	str	r3, [r7, #12]
2000d318:	e049      	b.n	2000d3ae <HAL_RCC_GetSysClockFreq+0x12a>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
2000d31a:	4b30      	ldr	r3, [pc, #192]	; (2000d3dc <HAL_RCC_GetSysClockFreq+0x158>)
2000d31c:	685b      	ldr	r3, [r3, #4]
2000d31e:	099b      	lsrs	r3, r3, #6
2000d320:	f04f 0400 	mov.w	r4, #0
2000d324:	f240 11ff 	movw	r1, #511	; 0x1ff
2000d328:	f04f 0200 	mov.w	r2, #0
2000d32c:	ea03 0501 	and.w	r5, r3, r1
2000d330:	ea04 0602 	and.w	r6, r4, r2
2000d334:	4629      	mov	r1, r5
2000d336:	4632      	mov	r2, r6
2000d338:	f04f 0300 	mov.w	r3, #0
2000d33c:	f04f 0400 	mov.w	r4, #0
2000d340:	0154      	lsls	r4, r2, #5
2000d342:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
2000d346:	014b      	lsls	r3, r1, #5
2000d348:	4619      	mov	r1, r3
2000d34a:	4622      	mov	r2, r4
2000d34c:	1b49      	subs	r1, r1, r5
2000d34e:	eb62 0206 	sbc.w	r2, r2, r6
2000d352:	f04f 0300 	mov.w	r3, #0
2000d356:	f04f 0400 	mov.w	r4, #0
2000d35a:	0194      	lsls	r4, r2, #6
2000d35c:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
2000d360:	018b      	lsls	r3, r1, #6
2000d362:	1a5b      	subs	r3, r3, r1
2000d364:	eb64 0402 	sbc.w	r4, r4, r2
2000d368:	f04f 0100 	mov.w	r1, #0
2000d36c:	f04f 0200 	mov.w	r2, #0
2000d370:	00e2      	lsls	r2, r4, #3
2000d372:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
2000d376:	00d9      	lsls	r1, r3, #3
2000d378:	460b      	mov	r3, r1
2000d37a:	4614      	mov	r4, r2
2000d37c:	195b      	adds	r3, r3, r5
2000d37e:	eb44 0406 	adc.w	r4, r4, r6
2000d382:	f04f 0100 	mov.w	r1, #0
2000d386:	f04f 0200 	mov.w	r2, #0
2000d38a:	02a2      	lsls	r2, r4, #10
2000d38c:	ea42 5293 	orr.w	r2, r2, r3, lsr #22
2000d390:	0299      	lsls	r1, r3, #10
2000d392:	460b      	mov	r3, r1
2000d394:	4614      	mov	r4, r2
2000d396:	4618      	mov	r0, r3
2000d398:	4621      	mov	r1, r4
2000d39a:	687b      	ldr	r3, [r7, #4]
2000d39c:	f04f 0400 	mov.w	r4, #0
2000d3a0:	461a      	mov	r2, r3
2000d3a2:	4623      	mov	r3, r4
2000d3a4:	f7f3 f918 	bl	200005d8 <__aeabi_uldivmod>
2000d3a8:	4603      	mov	r3, r0
2000d3aa:	460c      	mov	r4, r1
2000d3ac:	60fb      	str	r3, [r7, #12]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
2000d3ae:	4b0b      	ldr	r3, [pc, #44]	; (2000d3dc <HAL_RCC_GetSysClockFreq+0x158>)
2000d3b0:	685b      	ldr	r3, [r3, #4]
2000d3b2:	0c1b      	lsrs	r3, r3, #16
2000d3b4:	f003 0303 	and.w	r3, r3, #3
2000d3b8:	3301      	adds	r3, #1
2000d3ba:	005b      	lsls	r3, r3, #1
2000d3bc:	603b      	str	r3, [r7, #0]

      sysclockfreq = pllvco/pllp;
2000d3be:	68fa      	ldr	r2, [r7, #12]
2000d3c0:	683b      	ldr	r3, [r7, #0]
2000d3c2:	fbb2 f3f3 	udiv	r3, r2, r3
2000d3c6:	60bb      	str	r3, [r7, #8]
      break;
2000d3c8:	e002      	b.n	2000d3d0 <HAL_RCC_GetSysClockFreq+0x14c>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
2000d3ca:	4b05      	ldr	r3, [pc, #20]	; (2000d3e0 <HAL_RCC_GetSysClockFreq+0x15c>)
2000d3cc:	60bb      	str	r3, [r7, #8]
      break;
2000d3ce:	bf00      	nop
    }
  }
  return sysclockfreq;
2000d3d0:	68bb      	ldr	r3, [r7, #8]
}
2000d3d2:	4618      	mov	r0, r3
2000d3d4:	3714      	adds	r7, #20
2000d3d6:	46bd      	mov	sp, r7
2000d3d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
2000d3da:	bf00      	nop
2000d3dc:	40023800 	.word	0x40023800
2000d3e0:	00f42400 	.word	0x00f42400
2000d3e4:	017d7840 	.word	0x017d7840

2000d3e8 <HAL_RCC_GetHCLKFreq>:
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
2000d3e8:	b480      	push	{r7}
2000d3ea:	af00      	add	r7, sp, #0
  return SystemCoreClock;
2000d3ec:	4b03      	ldr	r3, [pc, #12]	; (2000d3fc <HAL_RCC_GetHCLKFreq+0x14>)
2000d3ee:	681b      	ldr	r3, [r3, #0]
}
2000d3f0:	4618      	mov	r0, r3
2000d3f2:	46bd      	mov	sp, r7
2000d3f4:	f85d 7b04 	ldr.w	r7, [sp], #4
2000d3f8:	4770      	bx	lr
2000d3fa:	bf00      	nop
2000d3fc:	20000410 	.word	0x20000410

2000d400 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
2000d400:	b580      	push	{r7, lr}
2000d402:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
2000d404:	f7ff fff0 	bl	2000d3e8 <HAL_RCC_GetHCLKFreq>
2000d408:	4601      	mov	r1, r0
2000d40a:	4b05      	ldr	r3, [pc, #20]	; (2000d420 <HAL_RCC_GetPCLK1Freq+0x20>)
2000d40c:	689b      	ldr	r3, [r3, #8]
2000d40e:	0a9b      	lsrs	r3, r3, #10
2000d410:	f003 0307 	and.w	r3, r3, #7
2000d414:	4a03      	ldr	r2, [pc, #12]	; (2000d424 <HAL_RCC_GetPCLK1Freq+0x24>)
2000d416:	5cd3      	ldrb	r3, [r2, r3]
2000d418:	fa21 f303 	lsr.w	r3, r1, r3
}
2000d41c:	4618      	mov	r0, r3
2000d41e:	bd80      	pop	{r7, pc}
2000d420:	40023800 	.word	0x40023800
2000d424:	2000e6f8 	.word	0x2000e6f8

2000d428 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
2000d428:	b580      	push	{r7, lr}
2000d42a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
2000d42c:	f7ff ffdc 	bl	2000d3e8 <HAL_RCC_GetHCLKFreq>
2000d430:	4601      	mov	r1, r0
2000d432:	4b05      	ldr	r3, [pc, #20]	; (2000d448 <HAL_RCC_GetPCLK2Freq+0x20>)
2000d434:	689b      	ldr	r3, [r3, #8]
2000d436:	0b5b      	lsrs	r3, r3, #13
2000d438:	f003 0307 	and.w	r3, r3, #7
2000d43c:	4a03      	ldr	r2, [pc, #12]	; (2000d44c <HAL_RCC_GetPCLK2Freq+0x24>)
2000d43e:	5cd3      	ldrb	r3, [r2, r3]
2000d440:	fa21 f303 	lsr.w	r3, r1, r3
}
2000d444:	4618      	mov	r0, r3
2000d446:	bd80      	pop	{r7, pc}
2000d448:	40023800 	.word	0x40023800
2000d44c:	2000e6f8 	.word	0x2000e6f8

2000d450 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
2000d450:	b480      	push	{r7}
2000d452:	b085      	sub	sp, #20
2000d454:	af00      	add	r7, sp, #0
2000d456:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
2000d458:	687b      	ldr	r3, [r7, #4]
2000d45a:	220f      	movs	r2, #15
2000d45c:	601a      	str	r2, [r3, #0]

  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
2000d45e:	4b4f      	ldr	r3, [pc, #316]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d460:	681b      	ldr	r3, [r3, #0]
2000d462:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2000d466:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2000d46a:	d104      	bne.n	2000d476 <HAL_RCC_GetOscConfig+0x26>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
2000d46c:	687b      	ldr	r3, [r7, #4]
2000d46e:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
2000d472:	605a      	str	r2, [r3, #4]
2000d474:	e00e      	b.n	2000d494 <HAL_RCC_GetOscConfig+0x44>
  }
  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
2000d476:	4b49      	ldr	r3, [pc, #292]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d478:	681b      	ldr	r3, [r3, #0]
2000d47a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000d47e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000d482:	d104      	bne.n	2000d48e <HAL_RCC_GetOscConfig+0x3e>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
2000d484:	687b      	ldr	r3, [r7, #4]
2000d486:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2000d48a:	605a      	str	r2, [r3, #4]
2000d48c:	e002      	b.n	2000d494 <HAL_RCC_GetOscConfig+0x44>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
2000d48e:	687b      	ldr	r3, [r7, #4]
2000d490:	2200      	movs	r2, #0
2000d492:	605a      	str	r2, [r3, #4]
  }

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
2000d494:	4b41      	ldr	r3, [pc, #260]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d496:	681b      	ldr	r3, [r3, #0]
2000d498:	f003 0301 	and.w	r3, r3, #1
2000d49c:	2b01      	cmp	r3, #1
2000d49e:	d103      	bne.n	2000d4a8 <HAL_RCC_GetOscConfig+0x58>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
2000d4a0:	687b      	ldr	r3, [r7, #4]
2000d4a2:	2201      	movs	r2, #1
2000d4a4:	60da      	str	r2, [r3, #12]
2000d4a6:	e002      	b.n	2000d4ae <HAL_RCC_GetOscConfig+0x5e>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
2000d4a8:	687b      	ldr	r3, [r7, #4]
2000d4aa:	2200      	movs	r2, #0
2000d4ac:	60da      	str	r2, [r3, #12]
  }

  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);
2000d4ae:	4b3b      	ldr	r3, [pc, #236]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d4b0:	681b      	ldr	r3, [r3, #0]
2000d4b2:	08db      	lsrs	r3, r3, #3
2000d4b4:	f003 021f 	and.w	r2, r3, #31
2000d4b8:	687b      	ldr	r3, [r7, #4]
2000d4ba:	611a      	str	r2, [r3, #16]

  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
2000d4bc:	4b37      	ldr	r3, [pc, #220]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d4be:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d4c0:	f003 0304 	and.w	r3, r3, #4
2000d4c4:	2b04      	cmp	r3, #4
2000d4c6:	d103      	bne.n	2000d4d0 <HAL_RCC_GetOscConfig+0x80>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
2000d4c8:	687b      	ldr	r3, [r7, #4]
2000d4ca:	2205      	movs	r2, #5
2000d4cc:	609a      	str	r2, [r3, #8]
2000d4ce:	e00c      	b.n	2000d4ea <HAL_RCC_GetOscConfig+0x9a>
  }
  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
2000d4d0:	4b32      	ldr	r3, [pc, #200]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d4d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d4d4:	f003 0301 	and.w	r3, r3, #1
2000d4d8:	2b01      	cmp	r3, #1
2000d4da:	d103      	bne.n	2000d4e4 <HAL_RCC_GetOscConfig+0x94>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
2000d4dc:	687b      	ldr	r3, [r7, #4]
2000d4de:	2201      	movs	r2, #1
2000d4e0:	609a      	str	r2, [r3, #8]
2000d4e2:	e002      	b.n	2000d4ea <HAL_RCC_GetOscConfig+0x9a>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
2000d4e4:	687b      	ldr	r3, [r7, #4]
2000d4e6:	2200      	movs	r2, #0
2000d4e8:	609a      	str	r2, [r3, #8]
  }

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
2000d4ea:	4b2c      	ldr	r3, [pc, #176]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d4ec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000d4ee:	f003 0301 	and.w	r3, r3, #1
2000d4f2:	2b01      	cmp	r3, #1
2000d4f4:	d103      	bne.n	2000d4fe <HAL_RCC_GetOscConfig+0xae>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
2000d4f6:	687b      	ldr	r3, [r7, #4]
2000d4f8:	2201      	movs	r2, #1
2000d4fa:	615a      	str	r2, [r3, #20]
2000d4fc:	e002      	b.n	2000d504 <HAL_RCC_GetOscConfig+0xb4>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
2000d4fe:	687b      	ldr	r3, [r7, #4]
2000d500:	2200      	movs	r2, #0
2000d502:	615a      	str	r2, [r3, #20]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
2000d504:	4b25      	ldr	r3, [pc, #148]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d506:	681b      	ldr	r3, [r3, #0]
2000d508:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000d50c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2000d510:	d103      	bne.n	2000d51a <HAL_RCC_GetOscConfig+0xca>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
2000d512:	687b      	ldr	r3, [r7, #4]
2000d514:	2202      	movs	r2, #2
2000d516:	619a      	str	r2, [r3, #24]
2000d518:	e002      	b.n	2000d520 <HAL_RCC_GetOscConfig+0xd0>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
2000d51a:	687b      	ldr	r3, [r7, #4]
2000d51c:	2201      	movs	r2, #1
2000d51e:	619a      	str	r2, [r3, #24]
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
2000d520:	4b1e      	ldr	r3, [pc, #120]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d522:	685b      	ldr	r3, [r3, #4]
2000d524:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
2000d528:	687b      	ldr	r3, [r7, #4]
2000d52a:	61da      	str	r2, [r3, #28]
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
2000d52c:	4b1b      	ldr	r3, [pc, #108]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d52e:	685b      	ldr	r3, [r3, #4]
2000d530:	f003 023f 	and.w	r2, r3, #63	; 0x3f
2000d534:	687b      	ldr	r3, [r7, #4]
2000d536:	621a      	str	r2, [r3, #32]
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
2000d538:	4b18      	ldr	r3, [pc, #96]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d53a:	685b      	ldr	r3, [r3, #4]
2000d53c:	099b      	lsrs	r3, r3, #6
2000d53e:	f3c3 0208 	ubfx	r2, r3, #0, #9
2000d542:	687b      	ldr	r3, [r7, #4]
2000d544:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> RCC_PLLCFGR_PLLP_Pos);
2000d546:	4b15      	ldr	r3, [pc, #84]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d548:	685b      	ldr	r3, [r3, #4]
2000d54a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
2000d54e:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
2000d552:	005b      	lsls	r3, r3, #1
2000d554:	0c1a      	lsrs	r2, r3, #16
2000d556:	687b      	ldr	r3, [r7, #4]
2000d558:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos);
2000d55a:	4b10      	ldr	r3, [pc, #64]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d55c:	685b      	ldr	r3, [r3, #4]
2000d55e:	0e1b      	lsrs	r3, r3, #24
2000d560:	f003 020f 	and.w	r2, r3, #15
2000d564:	687b      	ldr	r3, [r7, #4]
2000d566:	62da      	str	r2, [r3, #44]	; 0x2c
#if defined (RCC_PLLCFGR_PLLR)
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR));
2000d568:	4b0c      	ldr	r3, [pc, #48]	; (2000d59c <HAL_RCC_GetOscConfig+0x14c>)
2000d56a:	685b      	ldr	r3, [r3, #4]
2000d56c:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
2000d570:	f04f 42e0 	mov.w	r2, #1879048192	; 0x70000000
2000d574:	60fa      	str	r2, [r7, #12]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2000d576:	68fa      	ldr	r2, [r7, #12]
2000d578:	fa92 f2a2 	rbit	r2, r2
2000d57c:	60ba      	str	r2, [r7, #8]
  return result;
2000d57e:	68ba      	ldr	r2, [r7, #8]
2000d580:	fab2 f282 	clz	r2, r2
2000d584:	b2d2      	uxtb	r2, r2
2000d586:	fa23 f202 	lsr.w	r2, r3, r2
2000d58a:	687b      	ldr	r3, [r7, #4]
2000d58c:	631a      	str	r2, [r3, #48]	; 0x30
#endif
}
2000d58e:	bf00      	nop
2000d590:	3714      	adds	r7, #20
2000d592:	46bd      	mov	sp, r7
2000d594:	f85d 7b04 	ldr.w	r7, [sp], #4
2000d598:	4770      	bx	lr
2000d59a:	bf00      	nop
2000d59c:	40023800 	.word	0x40023800

2000d5a0 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
2000d5a0:	b480      	push	{r7}
2000d5a2:	b083      	sub	sp, #12
2000d5a4:	af00      	add	r7, sp, #0
2000d5a6:	6078      	str	r0, [r7, #4]
2000d5a8:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
2000d5aa:	687b      	ldr	r3, [r7, #4]
2000d5ac:	220f      	movs	r2, #15
2000d5ae:	601a      	str	r2, [r3, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
2000d5b0:	4b12      	ldr	r3, [pc, #72]	; (2000d5fc <HAL_RCC_GetClockConfig+0x5c>)
2000d5b2:	689b      	ldr	r3, [r3, #8]
2000d5b4:	f003 0203 	and.w	r2, r3, #3
2000d5b8:	687b      	ldr	r3, [r7, #4]
2000d5ba:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
2000d5bc:	4b0f      	ldr	r3, [pc, #60]	; (2000d5fc <HAL_RCC_GetClockConfig+0x5c>)
2000d5be:	689b      	ldr	r3, [r3, #8]
2000d5c0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
2000d5c4:	687b      	ldr	r3, [r7, #4]
2000d5c6:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
2000d5c8:	4b0c      	ldr	r3, [pc, #48]	; (2000d5fc <HAL_RCC_GetClockConfig+0x5c>)
2000d5ca:	689b      	ldr	r3, [r3, #8]
2000d5cc:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
2000d5d0:	687b      	ldr	r3, [r7, #4]
2000d5d2:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
2000d5d4:	4b09      	ldr	r3, [pc, #36]	; (2000d5fc <HAL_RCC_GetClockConfig+0x5c>)
2000d5d6:	689b      	ldr	r3, [r3, #8]
2000d5d8:	08db      	lsrs	r3, r3, #3
2000d5da:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
2000d5de:	687b      	ldr	r3, [r7, #4]
2000d5e0:	611a      	str	r2, [r3, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
2000d5e2:	4b07      	ldr	r3, [pc, #28]	; (2000d600 <HAL_RCC_GetClockConfig+0x60>)
2000d5e4:	681b      	ldr	r3, [r3, #0]
2000d5e6:	f003 020f 	and.w	r2, r3, #15
2000d5ea:	683b      	ldr	r3, [r7, #0]
2000d5ec:	601a      	str	r2, [r3, #0]
}
2000d5ee:	bf00      	nop
2000d5f0:	370c      	adds	r7, #12
2000d5f2:	46bd      	mov	sp, r7
2000d5f4:	f85d 7b04 	ldr.w	r7, [sp], #4
2000d5f8:	4770      	bx	lr
2000d5fa:	bf00      	nop
2000d5fc:	40023800 	.word	0x40023800
2000d600:	40023c00 	.word	0x40023c00

2000d604 <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
2000d604:	b580      	push	{r7, lr}
2000d606:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
2000d608:	4b06      	ldr	r3, [pc, #24]	; (2000d624 <HAL_RCC_NMI_IRQHandler+0x20>)
2000d60a:	68db      	ldr	r3, [r3, #12]
2000d60c:	f003 0380 	and.w	r3, r3, #128	; 0x80
2000d610:	2b80      	cmp	r3, #128	; 0x80
2000d612:	d104      	bne.n	2000d61e <HAL_RCC_NMI_IRQHandler+0x1a>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
2000d614:	f000 f80a 	bl	2000d62c <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
2000d618:	4b03      	ldr	r3, [pc, #12]	; (2000d628 <HAL_RCC_NMI_IRQHandler+0x24>)
2000d61a:	2280      	movs	r2, #128	; 0x80
2000d61c:	701a      	strb	r2, [r3, #0]
  }
}
2000d61e:	bf00      	nop
2000d620:	bd80      	pop	{r7, pc}
2000d622:	bf00      	nop
2000d624:	40023800 	.word	0x40023800
2000d628:	4002380e 	.word	0x4002380e

2000d62c <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval None
  */
__weak void HAL_RCC_CSSCallback(void)
{
2000d62c:	b480      	push	{r7}
2000d62e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   */
}
2000d630:	bf00      	nop
2000d632:	46bd      	mov	sp, r7
2000d634:	f85d 7b04 	ldr.w	r7, [sp], #4
2000d638:	4770      	bx	lr
	...

2000d63c <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
2000d63c:	b580      	push	{r7, lr}
2000d63e:	b088      	sub	sp, #32
2000d640:	af00      	add	r7, sp, #0
2000d642:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
2000d644:	2300      	movs	r3, #0
2000d646:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg0 = 0;
2000d648:	2300      	movs	r3, #0
2000d64a:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg1 = 0;
2000d64c:	2300      	movs	r3, #0
2000d64e:	60fb      	str	r3, [r7, #12]
  uint32_t plli2sused = 0;
2000d650:	2300      	movs	r3, #0
2000d652:	61fb      	str	r3, [r7, #28]
  uint32_t pllsaiused = 0;
2000d654:	2300      	movs	r3, #0
2000d656:	61bb      	str	r3, [r7, #24]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
2000d658:	687b      	ldr	r3, [r7, #4]
2000d65a:	681b      	ldr	r3, [r3, #0]
2000d65c:	f003 0301 	and.w	r3, r3, #1
2000d660:	2b00      	cmp	r3, #0
2000d662:	d012      	beq.n	2000d68a <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
2000d664:	4b69      	ldr	r3, [pc, #420]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d666:	689b      	ldr	r3, [r3, #8]
2000d668:	4a68      	ldr	r2, [pc, #416]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d66a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
2000d66e:	6093      	str	r3, [r2, #8]
2000d670:	4b66      	ldr	r3, [pc, #408]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d672:	689a      	ldr	r2, [r3, #8]
2000d674:	687b      	ldr	r3, [r7, #4]
2000d676:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000d678:	4964      	ldr	r1, [pc, #400]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d67a:	4313      	orrs	r3, r2
2000d67c:	608b      	str	r3, [r1, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
2000d67e:	687b      	ldr	r3, [r7, #4]
2000d680:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000d682:	2b00      	cmp	r3, #0
2000d684:	d101      	bne.n	2000d68a <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      plli2sused = 1;
2000d686:	2301      	movs	r3, #1
2000d688:	61fb      	str	r3, [r7, #28]
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
2000d68a:	687b      	ldr	r3, [r7, #4]
2000d68c:	681b      	ldr	r3, [r3, #0]
2000d68e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2000d692:	2b00      	cmp	r3, #0
2000d694:	d017      	beq.n	2000d6c6 <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
2000d696:	4b5d      	ldr	r3, [pc, #372]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d698:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000d69c:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
2000d6a0:	687b      	ldr	r3, [r7, #4]
2000d6a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d6a4:	4959      	ldr	r1, [pc, #356]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d6a6:	4313      	orrs	r3, r2
2000d6a8:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
2000d6ac:	687b      	ldr	r3, [r7, #4]
2000d6ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d6b0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2000d6b4:	d101      	bne.n	2000d6ba <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      plli2sused = 1;
2000d6b6:	2301      	movs	r3, #1
2000d6b8:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
2000d6ba:	687b      	ldr	r3, [r7, #4]
2000d6bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000d6be:	2b00      	cmp	r3, #0
2000d6c0:	d101      	bne.n	2000d6c6 <HAL_RCCEx_PeriphCLKConfig+0x8a>
    {
      pllsaiused = 1;
2000d6c2:	2301      	movs	r3, #1
2000d6c4:	61bb      	str	r3, [r7, #24]
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
2000d6c6:	687b      	ldr	r3, [r7, #4]
2000d6c8:	681b      	ldr	r3, [r3, #0]
2000d6ca:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
2000d6ce:	2b00      	cmp	r3, #0
2000d6d0:	d017      	beq.n	2000d702 <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
2000d6d2:	4b4e      	ldr	r3, [pc, #312]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d6d4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000d6d8:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
2000d6dc:	687b      	ldr	r3, [r7, #4]
2000d6de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000d6e0:	494a      	ldr	r1, [pc, #296]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d6e2:	4313      	orrs	r3, r2
2000d6e4:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
2000d6e8:	687b      	ldr	r3, [r7, #4]
2000d6ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000d6ec:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2000d6f0:	d101      	bne.n	2000d6f6 <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
      plli2sused = 1;
2000d6f2:	2301      	movs	r3, #1
2000d6f4:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
2000d6f6:	687b      	ldr	r3, [r7, #4]
2000d6f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000d6fa:	2b00      	cmp	r3, #0
2000d6fc:	d101      	bne.n	2000d702 <HAL_RCCEx_PeriphCLKConfig+0xc6>
    {
      pllsaiused = 1;
2000d6fe:	2301      	movs	r3, #1
2000d700:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
2000d702:	687b      	ldr	r3, [r7, #4]
2000d704:	681b      	ldr	r3, [r3, #0]
2000d706:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000d70a:	2b00      	cmp	r3, #0
2000d70c:	d001      	beq.n	2000d712 <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
      plli2sused = 1;
2000d70e:	2301      	movs	r3, #1
2000d710:	61fb      	str	r3, [r7, #28]
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
2000d712:	687b      	ldr	r3, [r7, #4]
2000d714:	681b      	ldr	r3, [r3, #0]
2000d716:	f003 0320 	and.w	r3, r3, #32
2000d71a:	2b00      	cmp	r3, #0
2000d71c:	f000 808b 	beq.w	2000d836 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
2000d720:	4b3a      	ldr	r3, [pc, #232]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d722:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000d724:	4a39      	ldr	r2, [pc, #228]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d726:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000d72a:	6413      	str	r3, [r2, #64]	; 0x40
2000d72c:	4b37      	ldr	r3, [pc, #220]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d72e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000d730:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000d734:	60bb      	str	r3, [r7, #8]
2000d736:	68bb      	ldr	r3, [r7, #8]

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
2000d738:	4b35      	ldr	r3, [pc, #212]	; (2000d810 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
2000d73a:	681b      	ldr	r3, [r3, #0]
2000d73c:	4a34      	ldr	r2, [pc, #208]	; (2000d810 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
2000d73e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2000d742:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2000d744:	f7f4 fb1c 	bl	20001d80 <HAL_GetTick>
2000d748:	6178      	str	r0, [r7, #20]

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
2000d74a:	e008      	b.n	2000d75e <HAL_RCCEx_PeriphCLKConfig+0x122>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
2000d74c:	f7f4 fb18 	bl	20001d80 <HAL_GetTick>
2000d750:	4602      	mov	r2, r0
2000d752:	697b      	ldr	r3, [r7, #20]
2000d754:	1ad3      	subs	r3, r2, r3
2000d756:	2b64      	cmp	r3, #100	; 0x64
2000d758:	d901      	bls.n	2000d75e <HAL_RCCEx_PeriphCLKConfig+0x122>
      {
        return HAL_TIMEOUT;
2000d75a:	2303      	movs	r3, #3
2000d75c:	e38d      	b.n	2000de7a <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
2000d75e:	4b2c      	ldr	r3, [pc, #176]	; (2000d810 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
2000d760:	681b      	ldr	r3, [r3, #0]
2000d762:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000d766:	2b00      	cmp	r3, #0
2000d768:	d0f0      	beq.n	2000d74c <HAL_RCCEx_PeriphCLKConfig+0x110>
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
2000d76a:	4b28      	ldr	r3, [pc, #160]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d76c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d76e:	f403 7340 	and.w	r3, r3, #768	; 0x300
2000d772:	613b      	str	r3, [r7, #16]

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
2000d774:	693b      	ldr	r3, [r7, #16]
2000d776:	2b00      	cmp	r3, #0
2000d778:	d035      	beq.n	2000d7e6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
2000d77a:	687b      	ldr	r3, [r7, #4]
2000d77c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000d77e:	f403 7340 	and.w	r3, r3, #768	; 0x300
2000d782:	693a      	ldr	r2, [r7, #16]
2000d784:	429a      	cmp	r2, r3
2000d786:	d02e      	beq.n	2000d7e6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
2000d788:	4b20      	ldr	r3, [pc, #128]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d78a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d78c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
2000d790:	613b      	str	r3, [r7, #16]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
2000d792:	4b1e      	ldr	r3, [pc, #120]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d794:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d796:	4a1d      	ldr	r2, [pc, #116]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d798:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2000d79c:	6713      	str	r3, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
2000d79e:	4b1b      	ldr	r3, [pc, #108]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d7a0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d7a2:	4a1a      	ldr	r2, [pc, #104]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d7a4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000d7a8:	6713      	str	r3, [r2, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
2000d7aa:	4a18      	ldr	r2, [pc, #96]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d7ac:	693b      	ldr	r3, [r7, #16]
2000d7ae:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
2000d7b0:	4b16      	ldr	r3, [pc, #88]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d7b2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d7b4:	f003 0301 	and.w	r3, r3, #1
2000d7b8:	2b01      	cmp	r3, #1
2000d7ba:	d114      	bne.n	2000d7e6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2000d7bc:	f7f4 fae0 	bl	20001d80 <HAL_GetTick>
2000d7c0:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
2000d7c2:	e00a      	b.n	2000d7da <HAL_RCCEx_PeriphCLKConfig+0x19e>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
2000d7c4:	f7f4 fadc 	bl	20001d80 <HAL_GetTick>
2000d7c8:	4602      	mov	r2, r0
2000d7ca:	697b      	ldr	r3, [r7, #20]
2000d7cc:	1ad3      	subs	r3, r2, r3
2000d7ce:	f241 3288 	movw	r2, #5000	; 0x1388
2000d7d2:	4293      	cmp	r3, r2
2000d7d4:	d901      	bls.n	2000d7da <HAL_RCCEx_PeriphCLKConfig+0x19e>
          {
            return HAL_TIMEOUT;
2000d7d6:	2303      	movs	r3, #3
2000d7d8:	e34f      	b.n	2000de7a <HAL_RCCEx_PeriphCLKConfig+0x83e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
2000d7da:	4b0c      	ldr	r3, [pc, #48]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d7dc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d7de:	f003 0302 	and.w	r3, r3, #2
2000d7e2:	2b00      	cmp	r3, #0
2000d7e4:	d0ee      	beq.n	2000d7c4 <HAL_RCCEx_PeriphCLKConfig+0x188>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
2000d7e6:	687b      	ldr	r3, [r7, #4]
2000d7e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000d7ea:	f403 7340 	and.w	r3, r3, #768	; 0x300
2000d7ee:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
2000d7f2:	d111      	bne.n	2000d818 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
2000d7f4:	4b05      	ldr	r3, [pc, #20]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d7f6:	689b      	ldr	r3, [r3, #8]
2000d7f8:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
2000d7fc:	687b      	ldr	r3, [r7, #4]
2000d7fe:	6b19      	ldr	r1, [r3, #48]	; 0x30
2000d800:	4b04      	ldr	r3, [pc, #16]	; (2000d814 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
2000d802:	400b      	ands	r3, r1
2000d804:	4901      	ldr	r1, [pc, #4]	; (2000d80c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
2000d806:	4313      	orrs	r3, r2
2000d808:	608b      	str	r3, [r1, #8]
2000d80a:	e00b      	b.n	2000d824 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
2000d80c:	40023800 	.word	0x40023800
2000d810:	40007000 	.word	0x40007000
2000d814:	0ffffcff 	.word	0x0ffffcff
2000d818:	4bb3      	ldr	r3, [pc, #716]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d81a:	689b      	ldr	r3, [r3, #8]
2000d81c:	4ab2      	ldr	r2, [pc, #712]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d81e:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
2000d822:	6093      	str	r3, [r2, #8]
2000d824:	4bb0      	ldr	r3, [pc, #704]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d826:	6f1a      	ldr	r2, [r3, #112]	; 0x70
2000d828:	687b      	ldr	r3, [r7, #4]
2000d82a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000d82c:	f3c3 030b 	ubfx	r3, r3, #0, #12
2000d830:	49ad      	ldr	r1, [pc, #692]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d832:	4313      	orrs	r3, r2
2000d834:	670b      	str	r3, [r1, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
2000d836:	687b      	ldr	r3, [r7, #4]
2000d838:	681b      	ldr	r3, [r3, #0]
2000d83a:	f003 0310 	and.w	r3, r3, #16
2000d83e:	2b00      	cmp	r3, #0
2000d840:	d010      	beq.n	2000d864 <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
2000d842:	4ba9      	ldr	r3, [pc, #676]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d844:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000d848:	4aa7      	ldr	r2, [pc, #668]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d84a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2000d84e:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
2000d852:	4ba5      	ldr	r3, [pc, #660]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d854:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
2000d858:	687b      	ldr	r3, [r7, #4]
2000d85a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000d85c:	49a2      	ldr	r1, [pc, #648]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d85e:	4313      	orrs	r3, r2
2000d860:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
2000d864:	687b      	ldr	r3, [r7, #4]
2000d866:	681b      	ldr	r3, [r3, #0]
2000d868:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2000d86c:	2b00      	cmp	r3, #0
2000d86e:	d00a      	beq.n	2000d886 <HAL_RCCEx_PeriphCLKConfig+0x24a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
2000d870:	4b9d      	ldr	r3, [pc, #628]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d872:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d876:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
2000d87a:	687b      	ldr	r3, [r7, #4]
2000d87c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2000d87e:	499a      	ldr	r1, [pc, #616]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d880:	4313      	orrs	r3, r2
2000d882:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
2000d886:	687b      	ldr	r3, [r7, #4]
2000d888:	681b      	ldr	r3, [r3, #0]
2000d88a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2000d88e:	2b00      	cmp	r3, #0
2000d890:	d00a      	beq.n	2000d8a8 <HAL_RCCEx_PeriphCLKConfig+0x26c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
2000d892:	4b95      	ldr	r3, [pc, #596]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d894:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d898:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
2000d89c:	687b      	ldr	r3, [r7, #4]
2000d89e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2000d8a0:	4991      	ldr	r1, [pc, #580]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d8a2:	4313      	orrs	r3, r2
2000d8a4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
2000d8a8:	687b      	ldr	r3, [r7, #4]
2000d8aa:	681b      	ldr	r3, [r3, #0]
2000d8ac:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000d8b0:	2b00      	cmp	r3, #0
2000d8b2:	d00a      	beq.n	2000d8ca <HAL_RCCEx_PeriphCLKConfig+0x28e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
2000d8b4:	4b8c      	ldr	r3, [pc, #560]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d8b6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d8ba:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
2000d8be:	687b      	ldr	r3, [r7, #4]
2000d8c0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2000d8c2:	4989      	ldr	r1, [pc, #548]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d8c4:	4313      	orrs	r3, r2
2000d8c6:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
2000d8ca:	687b      	ldr	r3, [r7, #4]
2000d8cc:	681b      	ldr	r3, [r3, #0]
2000d8ce:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000d8d2:	2b00      	cmp	r3, #0
2000d8d4:	d00a      	beq.n	2000d8ec <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
2000d8d6:	4b84      	ldr	r3, [pc, #528]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d8d8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d8dc:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
2000d8e0:	687b      	ldr	r3, [r7, #4]
2000d8e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000d8e4:	4980      	ldr	r1, [pc, #512]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d8e6:	4313      	orrs	r3, r2
2000d8e8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
2000d8ec:	687b      	ldr	r3, [r7, #4]
2000d8ee:	681b      	ldr	r3, [r3, #0]
2000d8f0:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000d8f4:	2b00      	cmp	r3, #0
2000d8f6:	d00a      	beq.n	2000d90e <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
2000d8f8:	4b7b      	ldr	r3, [pc, #492]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d8fa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d8fe:	f023 0203 	bic.w	r2, r3, #3
2000d902:	687b      	ldr	r3, [r7, #4]
2000d904:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000d906:	4978      	ldr	r1, [pc, #480]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d908:	4313      	orrs	r3, r2
2000d90a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
2000d90e:	687b      	ldr	r3, [r7, #4]
2000d910:	681b      	ldr	r3, [r3, #0]
2000d912:	f003 0380 	and.w	r3, r3, #128	; 0x80
2000d916:	2b00      	cmp	r3, #0
2000d918:	d00a      	beq.n	2000d930 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
2000d91a:	4b73      	ldr	r3, [pc, #460]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d91c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d920:	f023 020c 	bic.w	r2, r3, #12
2000d924:	687b      	ldr	r3, [r7, #4]
2000d926:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000d928:	496f      	ldr	r1, [pc, #444]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d92a:	4313      	orrs	r3, r2
2000d92c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
2000d930:	687b      	ldr	r3, [r7, #4]
2000d932:	681b      	ldr	r3, [r3, #0]
2000d934:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000d938:	2b00      	cmp	r3, #0
2000d93a:	d00a      	beq.n	2000d952 <HAL_RCCEx_PeriphCLKConfig+0x316>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
2000d93c:	4b6a      	ldr	r3, [pc, #424]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d93e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d942:	f023 0230 	bic.w	r2, r3, #48	; 0x30
2000d946:	687b      	ldr	r3, [r7, #4]
2000d948:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000d94a:	4967      	ldr	r1, [pc, #412]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d94c:	4313      	orrs	r3, r2
2000d94e:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
2000d952:	687b      	ldr	r3, [r7, #4]
2000d954:	681b      	ldr	r3, [r3, #0]
2000d956:	f403 7300 	and.w	r3, r3, #512	; 0x200
2000d95a:	2b00      	cmp	r3, #0
2000d95c:	d00a      	beq.n	2000d974 <HAL_RCCEx_PeriphCLKConfig+0x338>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
2000d95e:	4b62      	ldr	r3, [pc, #392]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d960:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d964:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
2000d968:	687b      	ldr	r3, [r7, #4]
2000d96a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000d96c:	495e      	ldr	r1, [pc, #376]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d96e:	4313      	orrs	r3, r2
2000d970:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
2000d974:	687b      	ldr	r3, [r7, #4]
2000d976:	681b      	ldr	r3, [r3, #0]
2000d978:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000d97c:	2b00      	cmp	r3, #0
2000d97e:	d00a      	beq.n	2000d996 <HAL_RCCEx_PeriphCLKConfig+0x35a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
2000d980:	4b59      	ldr	r3, [pc, #356]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d982:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d986:	f423 7240 	bic.w	r2, r3, #768	; 0x300
2000d98a:	687b      	ldr	r3, [r7, #4]
2000d98c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2000d98e:	4956      	ldr	r1, [pc, #344]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d990:	4313      	orrs	r3, r2
2000d992:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
2000d996:	687b      	ldr	r3, [r7, #4]
2000d998:	681b      	ldr	r3, [r3, #0]
2000d99a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
2000d99e:	2b00      	cmp	r3, #0
2000d9a0:	d00a      	beq.n	2000d9b8 <HAL_RCCEx_PeriphCLKConfig+0x37c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
2000d9a2:	4b51      	ldr	r3, [pc, #324]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d9a4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d9a8:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
2000d9ac:	687b      	ldr	r3, [r7, #4]
2000d9ae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2000d9b0:	494d      	ldr	r1, [pc, #308]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d9b2:	4313      	orrs	r3, r2
2000d9b4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
2000d9b8:	687b      	ldr	r3, [r7, #4]
2000d9ba:	681b      	ldr	r3, [r3, #0]
2000d9bc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
2000d9c0:	2b00      	cmp	r3, #0
2000d9c2:	d00a      	beq.n	2000d9da <HAL_RCCEx_PeriphCLKConfig+0x39e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
2000d9c4:	4b48      	ldr	r3, [pc, #288]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d9c6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d9ca:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
2000d9ce:	687b      	ldr	r3, [r7, #4]
2000d9d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000d9d2:	4945      	ldr	r1, [pc, #276]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d9d4:	4313      	orrs	r3, r2
2000d9d6:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
2000d9da:	687b      	ldr	r3, [r7, #4]
2000d9dc:	681b      	ldr	r3, [r3, #0]
2000d9de:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2000d9e2:	2b00      	cmp	r3, #0
2000d9e4:	d00a      	beq.n	2000d9fc <HAL_RCCEx_PeriphCLKConfig+0x3c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
2000d9e6:	4b40      	ldr	r3, [pc, #256]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d9e8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000d9ec:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
2000d9f0:	687b      	ldr	r3, [r7, #4]
2000d9f2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000d9f4:	493c      	ldr	r1, [pc, #240]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000d9f6:	4313      	orrs	r3, r2
2000d9f8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
2000d9fc:	687b      	ldr	r3, [r7, #4]
2000d9fe:	681b      	ldr	r3, [r3, #0]
2000da00:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000da04:	2b00      	cmp	r3, #0
2000da06:	d00a      	beq.n	2000da1e <HAL_RCCEx_PeriphCLKConfig+0x3e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
2000da08:	4b37      	ldr	r3, [pc, #220]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da0a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000da0e:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
2000da12:	687b      	ldr	r3, [r7, #4]
2000da14:	6f9b      	ldr	r3, [r3, #120]	; 0x78
2000da16:	4934      	ldr	r1, [pc, #208]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da18:	4313      	orrs	r3, r2
2000da1a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
2000da1e:	687b      	ldr	r3, [r7, #4]
2000da20:	681b      	ldr	r3, [r3, #0]
2000da22:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2000da26:	2b00      	cmp	r3, #0
2000da28:	d011      	beq.n	2000da4e <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
2000da2a:	4b2f      	ldr	r3, [pc, #188]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da2c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000da30:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
2000da34:	687b      	ldr	r3, [r7, #4]
2000da36:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2000da38:	492b      	ldr	r1, [pc, #172]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da3a:	4313      	orrs	r3, r2
2000da3c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
2000da40:	687b      	ldr	r3, [r7, #4]
2000da42:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2000da44:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000da48:	d101      	bne.n	2000da4e <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      pllsaiused = 1;
2000da4a:	2301      	movs	r3, #1
2000da4c:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
2000da4e:	687b      	ldr	r3, [r7, #4]
2000da50:	681b      	ldr	r3, [r3, #0]
2000da52:	f003 0308 	and.w	r3, r3, #8
2000da56:	2b00      	cmp	r3, #0
2000da58:	d001      	beq.n	2000da5e <HAL_RCCEx_PeriphCLKConfig+0x422>
  {
    pllsaiused = 1;
2000da5a:	2301      	movs	r3, #1
2000da5c:	61bb      	str	r3, [r7, #24]
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
2000da5e:	687b      	ldr	r3, [r7, #4]
2000da60:	681b      	ldr	r3, [r3, #0]
2000da62:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2000da66:	2b00      	cmp	r3, #0
2000da68:	d00a      	beq.n	2000da80 <HAL_RCCEx_PeriphCLKConfig+0x444>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
2000da6a:	4b1f      	ldr	r3, [pc, #124]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da6c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000da70:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
2000da74:	687b      	ldr	r3, [r7, #4]
2000da76:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000da78:	491b      	ldr	r1, [pc, #108]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da7a:	4313      	orrs	r3, r2
2000da7c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
2000da80:	687b      	ldr	r3, [r7, #4]
2000da82:	681b      	ldr	r3, [r3, #0]
2000da84:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
2000da88:	2b00      	cmp	r3, #0
2000da8a:	d00b      	beq.n	2000daa4 <HAL_RCCEx_PeriphCLKConfig+0x468>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
2000da8c:	4b16      	ldr	r3, [pc, #88]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da8e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000da92:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
2000da96:	687b      	ldr	r3, [r7, #4]
2000da98:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2000da9c:	4912      	ldr	r1, [pc, #72]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000da9e:	4313      	orrs	r3, r2
2000daa0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
2000daa4:	687b      	ldr	r3, [r7, #4]
2000daa6:	681b      	ldr	r3, [r3, #0]
2000daa8:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2000daac:	2b00      	cmp	r3, #0
2000daae:	d00b      	beq.n	2000dac8 <HAL_RCCEx_PeriphCLKConfig+0x48c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
2000dab0:	4b0d      	ldr	r3, [pc, #52]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000dab2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dab6:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
2000daba:	687b      	ldr	r3, [r7, #4]
2000dabc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000dac0:	4909      	ldr	r1, [pc, #36]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000dac2:	4313      	orrs	r3, r2
2000dac4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
2000dac8:	687b      	ldr	r3, [r7, #4]
2000daca:	681b      	ldr	r3, [r3, #0]
2000dacc:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000dad0:	2b00      	cmp	r3, #0
2000dad2:	d00f      	beq.n	2000daf4 <HAL_RCCEx_PeriphCLKConfig+0x4b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
2000dad4:	4b04      	ldr	r3, [pc, #16]	; (2000dae8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
2000dad6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000dada:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
2000dade:	687b      	ldr	r3, [r7, #4]
2000dae0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000dae4:	e002      	b.n	2000daec <HAL_RCCEx_PeriphCLKConfig+0x4b0>
2000dae6:	bf00      	nop
2000dae8:	40023800 	.word	0x40023800
2000daec:	4985      	ldr	r1, [pc, #532]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000daee:	4313      	orrs	r3, r2
2000daf0:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
2000daf4:	687b      	ldr	r3, [r7, #4]
2000daf6:	681b      	ldr	r3, [r3, #0]
2000daf8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000dafc:	2b00      	cmp	r3, #0
2000dafe:	d00b      	beq.n	2000db18 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
2000db00:	4b80      	ldr	r3, [pc, #512]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000db02:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000db06:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
2000db0a:	687b      	ldr	r3, [r7, #4]
2000db0c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000db10:	497c      	ldr	r1, [pc, #496]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000db12:	4313      	orrs	r3, r2
2000db14:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
2000db18:	69fb      	ldr	r3, [r7, #28]
2000db1a:	2b01      	cmp	r3, #1
2000db1c:	d005      	beq.n	2000db2a <HAL_RCCEx_PeriphCLKConfig+0x4ee>
2000db1e:	687b      	ldr	r3, [r7, #4]
2000db20:	681b      	ldr	r3, [r3, #0]
2000db22:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000db26:	f040 80d6 	bne.w	2000dcd6 <HAL_RCCEx_PeriphCLKConfig+0x69a>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
2000db2a:	4b76      	ldr	r3, [pc, #472]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000db2c:	681b      	ldr	r3, [r3, #0]
2000db2e:	4a75      	ldr	r2, [pc, #468]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000db30:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
2000db34:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2000db36:	f7f4 f923 	bl	20001d80 <HAL_GetTick>
2000db3a:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
2000db3c:	e008      	b.n	2000db50 <HAL_RCCEx_PeriphCLKConfig+0x514>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
2000db3e:	f7f4 f91f 	bl	20001d80 <HAL_GetTick>
2000db42:	4602      	mov	r2, r0
2000db44:	697b      	ldr	r3, [r7, #20]
2000db46:	1ad3      	subs	r3, r2, r3
2000db48:	2b64      	cmp	r3, #100	; 0x64
2000db4a:	d901      	bls.n	2000db50 <HAL_RCCEx_PeriphCLKConfig+0x514>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
2000db4c:	2303      	movs	r3, #3
2000db4e:	e194      	b.n	2000de7a <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
2000db50:	4b6c      	ldr	r3, [pc, #432]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000db52:	681b      	ldr	r3, [r3, #0]
2000db54:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000db58:	2b00      	cmp	r3, #0
2000db5a:	d1f0      	bne.n	2000db3e <HAL_RCCEx_PeriphCLKConfig+0x502>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
2000db5c:	687b      	ldr	r3, [r7, #4]
2000db5e:	681b      	ldr	r3, [r3, #0]
2000db60:	f003 0301 	and.w	r3, r3, #1
2000db64:	2b00      	cmp	r3, #0
2000db66:	d021      	beq.n	2000dbac <HAL_RCCEx_PeriphCLKConfig+0x570>
2000db68:	687b      	ldr	r3, [r7, #4]
2000db6a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000db6c:	2b00      	cmp	r3, #0
2000db6e:	d11d      	bne.n	2000dbac <HAL_RCCEx_PeriphCLKConfig+0x570>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
2000db70:	4b64      	ldr	r3, [pc, #400]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000db72:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000db76:	0c1b      	lsrs	r3, r3, #16
2000db78:	f003 0303 	and.w	r3, r3, #3
2000db7c:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
2000db7e:	4b61      	ldr	r3, [pc, #388]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000db80:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000db84:	0e1b      	lsrs	r3, r3, #24
2000db86:	f003 030f 	and.w	r3, r3, #15
2000db8a:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
2000db8c:	687b      	ldr	r3, [r7, #4]
2000db8e:	685b      	ldr	r3, [r3, #4]
2000db90:	019a      	lsls	r2, r3, #6
2000db92:	693b      	ldr	r3, [r7, #16]
2000db94:	041b      	lsls	r3, r3, #16
2000db96:	431a      	orrs	r2, r3
2000db98:	68fb      	ldr	r3, [r7, #12]
2000db9a:	061b      	lsls	r3, r3, #24
2000db9c:	431a      	orrs	r2, r3
2000db9e:	687b      	ldr	r3, [r7, #4]
2000dba0:	689b      	ldr	r3, [r3, #8]
2000dba2:	071b      	lsls	r3, r3, #28
2000dba4:	4957      	ldr	r1, [pc, #348]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dba6:	4313      	orrs	r3, r2
2000dba8:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
2000dbac:	687b      	ldr	r3, [r7, #4]
2000dbae:	681b      	ldr	r3, [r3, #0]
2000dbb0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2000dbb4:	2b00      	cmp	r3, #0
2000dbb6:	d004      	beq.n	2000dbc2 <HAL_RCCEx_PeriphCLKConfig+0x586>
2000dbb8:	687b      	ldr	r3, [r7, #4]
2000dbba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000dbbc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2000dbc0:	d00a      	beq.n	2000dbd8 <HAL_RCCEx_PeriphCLKConfig+0x59c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
2000dbc2:	687b      	ldr	r3, [r7, #4]
2000dbc4:	681b      	ldr	r3, [r3, #0]
2000dbc6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
2000dbca:	2b00      	cmp	r3, #0
2000dbcc:	d02e      	beq.n	2000dc2c <HAL_RCCEx_PeriphCLKConfig+0x5f0>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
2000dbce:	687b      	ldr	r3, [r7, #4]
2000dbd0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000dbd2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2000dbd6:	d129      	bne.n	2000dc2c <HAL_RCCEx_PeriphCLKConfig+0x5f0>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
2000dbd8:	4b4a      	ldr	r3, [pc, #296]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dbda:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000dbde:	0c1b      	lsrs	r3, r3, #16
2000dbe0:	f003 0303 	and.w	r3, r3, #3
2000dbe4:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
2000dbe6:	4b47      	ldr	r3, [pc, #284]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dbe8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000dbec:	0f1b      	lsrs	r3, r3, #28
2000dbee:	f003 0307 	and.w	r3, r3, #7
2000dbf2:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
2000dbf4:	687b      	ldr	r3, [r7, #4]
2000dbf6:	685b      	ldr	r3, [r3, #4]
2000dbf8:	019a      	lsls	r2, r3, #6
2000dbfa:	693b      	ldr	r3, [r7, #16]
2000dbfc:	041b      	lsls	r3, r3, #16
2000dbfe:	431a      	orrs	r2, r3
2000dc00:	687b      	ldr	r3, [r7, #4]
2000dc02:	68db      	ldr	r3, [r3, #12]
2000dc04:	061b      	lsls	r3, r3, #24
2000dc06:	431a      	orrs	r2, r3
2000dc08:	68fb      	ldr	r3, [r7, #12]
2000dc0a:	071b      	lsls	r3, r3, #28
2000dc0c:	493d      	ldr	r1, [pc, #244]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dc0e:	4313      	orrs	r3, r2
2000dc10:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
2000dc14:	4b3b      	ldr	r3, [pc, #236]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dc16:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000dc1a:	f023 021f 	bic.w	r2, r3, #31
2000dc1e:	687b      	ldr	r3, [r7, #4]
2000dc20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000dc22:	3b01      	subs	r3, #1
2000dc24:	4937      	ldr	r1, [pc, #220]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dc26:	4313      	orrs	r3, r2
2000dc28:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
2000dc2c:	687b      	ldr	r3, [r7, #4]
2000dc2e:	681b      	ldr	r3, [r3, #0]
2000dc30:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000dc34:	2b00      	cmp	r3, #0
2000dc36:	d01d      	beq.n	2000dc74 <HAL_RCCEx_PeriphCLKConfig+0x638>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
2000dc38:	4b32      	ldr	r3, [pc, #200]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dc3a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000dc3e:	0e1b      	lsrs	r3, r3, #24
2000dc40:	f003 030f 	and.w	r3, r3, #15
2000dc44:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
2000dc46:	4b2f      	ldr	r3, [pc, #188]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dc48:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000dc4c:	0f1b      	lsrs	r3, r3, #28
2000dc4e:	f003 0307 	and.w	r3, r3, #7
2000dc52:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
2000dc54:	687b      	ldr	r3, [r7, #4]
2000dc56:	685b      	ldr	r3, [r3, #4]
2000dc58:	019a      	lsls	r2, r3, #6
2000dc5a:	687b      	ldr	r3, [r7, #4]
2000dc5c:	691b      	ldr	r3, [r3, #16]
2000dc5e:	041b      	lsls	r3, r3, #16
2000dc60:	431a      	orrs	r2, r3
2000dc62:	693b      	ldr	r3, [r7, #16]
2000dc64:	061b      	lsls	r3, r3, #24
2000dc66:	431a      	orrs	r2, r3
2000dc68:	68fb      	ldr	r3, [r7, #12]
2000dc6a:	071b      	lsls	r3, r3, #28
2000dc6c:	4925      	ldr	r1, [pc, #148]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dc6e:	4313      	orrs	r3, r2
2000dc70:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
2000dc74:	687b      	ldr	r3, [r7, #4]
2000dc76:	681b      	ldr	r3, [r3, #0]
2000dc78:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000dc7c:	2b00      	cmp	r3, #0
2000dc7e:	d011      	beq.n	2000dca4 <HAL_RCCEx_PeriphCLKConfig+0x668>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
2000dc80:	687b      	ldr	r3, [r7, #4]
2000dc82:	685b      	ldr	r3, [r3, #4]
2000dc84:	019a      	lsls	r2, r3, #6
2000dc86:	687b      	ldr	r3, [r7, #4]
2000dc88:	691b      	ldr	r3, [r3, #16]
2000dc8a:	041b      	lsls	r3, r3, #16
2000dc8c:	431a      	orrs	r2, r3
2000dc8e:	687b      	ldr	r3, [r7, #4]
2000dc90:	68db      	ldr	r3, [r3, #12]
2000dc92:	061b      	lsls	r3, r3, #24
2000dc94:	431a      	orrs	r2, r3
2000dc96:	687b      	ldr	r3, [r7, #4]
2000dc98:	689b      	ldr	r3, [r3, #8]
2000dc9a:	071b      	lsls	r3, r3, #28
2000dc9c:	4919      	ldr	r1, [pc, #100]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dc9e:	4313      	orrs	r3, r2
2000dca0:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
2000dca4:	4b17      	ldr	r3, [pc, #92]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dca6:	681b      	ldr	r3, [r3, #0]
2000dca8:	4a16      	ldr	r2, [pc, #88]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dcaa:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
2000dcae:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2000dcb0:	f7f4 f866 	bl	20001d80 <HAL_GetTick>
2000dcb4:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
2000dcb6:	e008      	b.n	2000dcca <HAL_RCCEx_PeriphCLKConfig+0x68e>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
2000dcb8:	f7f4 f862 	bl	20001d80 <HAL_GetTick>
2000dcbc:	4602      	mov	r2, r0
2000dcbe:	697b      	ldr	r3, [r7, #20]
2000dcc0:	1ad3      	subs	r3, r2, r3
2000dcc2:	2b64      	cmp	r3, #100	; 0x64
2000dcc4:	d901      	bls.n	2000dcca <HAL_RCCEx_PeriphCLKConfig+0x68e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
2000dcc6:	2303      	movs	r3, #3
2000dcc8:	e0d7      	b.n	2000de7a <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
2000dcca:	4b0e      	ldr	r3, [pc, #56]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dccc:	681b      	ldr	r3, [r3, #0]
2000dcce:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000dcd2:	2b00      	cmp	r3, #0
2000dcd4:	d0f0      	beq.n	2000dcb8 <HAL_RCCEx_PeriphCLKConfig+0x67c>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
2000dcd6:	69bb      	ldr	r3, [r7, #24]
2000dcd8:	2b01      	cmp	r3, #1
2000dcda:	f040 80cd 	bne.w	2000de78 <HAL_RCCEx_PeriphCLKConfig+0x83c>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
2000dcde:	4b09      	ldr	r3, [pc, #36]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dce0:	681b      	ldr	r3, [r3, #0]
2000dce2:	4a08      	ldr	r2, [pc, #32]	; (2000dd04 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
2000dce4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2000dce8:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2000dcea:	f7f4 f849 	bl	20001d80 <HAL_GetTick>
2000dcee:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
2000dcf0:	e00a      	b.n	2000dd08 <HAL_RCCEx_PeriphCLKConfig+0x6cc>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
2000dcf2:	f7f4 f845 	bl	20001d80 <HAL_GetTick>
2000dcf6:	4602      	mov	r2, r0
2000dcf8:	697b      	ldr	r3, [r7, #20]
2000dcfa:	1ad3      	subs	r3, r2, r3
2000dcfc:	2b64      	cmp	r3, #100	; 0x64
2000dcfe:	d903      	bls.n	2000dd08 <HAL_RCCEx_PeriphCLKConfig+0x6cc>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
2000dd00:	2303      	movs	r3, #3
2000dd02:	e0ba      	b.n	2000de7a <HAL_RCCEx_PeriphCLKConfig+0x83e>
2000dd04:	40023800 	.word	0x40023800
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
2000dd08:	4b5e      	ldr	r3, [pc, #376]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000dd0a:	681b      	ldr	r3, [r3, #0]
2000dd0c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000dd10:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2000dd14:	d0ed      	beq.n	2000dcf2 <HAL_RCCEx_PeriphCLKConfig+0x6b6>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
2000dd16:	687b      	ldr	r3, [r7, #4]
2000dd18:	681b      	ldr	r3, [r3, #0]
2000dd1a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2000dd1e:	2b00      	cmp	r3, #0
2000dd20:	d003      	beq.n	2000dd2a <HAL_RCCEx_PeriphCLKConfig+0x6ee>
2000dd22:	687b      	ldr	r3, [r7, #4]
2000dd24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000dd26:	2b00      	cmp	r3, #0
2000dd28:	d009      	beq.n	2000dd3e <HAL_RCCEx_PeriphCLKConfig+0x702>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
2000dd2a:	687b      	ldr	r3, [r7, #4]
2000dd2c:	681b      	ldr	r3, [r3, #0]
2000dd2e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
2000dd32:	2b00      	cmp	r3, #0
2000dd34:	d02e      	beq.n	2000dd94 <HAL_RCCEx_PeriphCLKConfig+0x758>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
2000dd36:	687b      	ldr	r3, [r7, #4]
2000dd38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000dd3a:	2b00      	cmp	r3, #0
2000dd3c:	d12a      	bne.n	2000dd94 <HAL_RCCEx_PeriphCLKConfig+0x758>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
2000dd3e:	4b51      	ldr	r3, [pc, #324]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000dd40:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000dd44:	0c1b      	lsrs	r3, r3, #16
2000dd46:	f003 0303 	and.w	r3, r3, #3
2000dd4a:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
2000dd4c:	4b4d      	ldr	r3, [pc, #308]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000dd4e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000dd52:	0f1b      	lsrs	r3, r3, #28
2000dd54:	f003 0307 	and.w	r3, r3, #7
2000dd58:	60fb      	str	r3, [r7, #12]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
2000dd5a:	687b      	ldr	r3, [r7, #4]
2000dd5c:	695b      	ldr	r3, [r3, #20]
2000dd5e:	019a      	lsls	r2, r3, #6
2000dd60:	693b      	ldr	r3, [r7, #16]
2000dd62:	041b      	lsls	r3, r3, #16
2000dd64:	431a      	orrs	r2, r3
2000dd66:	687b      	ldr	r3, [r7, #4]
2000dd68:	699b      	ldr	r3, [r3, #24]
2000dd6a:	061b      	lsls	r3, r3, #24
2000dd6c:	431a      	orrs	r2, r3
2000dd6e:	68fb      	ldr	r3, [r7, #12]
2000dd70:	071b      	lsls	r3, r3, #28
2000dd72:	4944      	ldr	r1, [pc, #272]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000dd74:	4313      	orrs	r3, r2
2000dd76:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
2000dd7a:	4b42      	ldr	r3, [pc, #264]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000dd7c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000dd80:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
2000dd84:	687b      	ldr	r3, [r7, #4]
2000dd86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000dd88:	3b01      	subs	r3, #1
2000dd8a:	021b      	lsls	r3, r3, #8
2000dd8c:	493d      	ldr	r1, [pc, #244]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000dd8e:	4313      	orrs	r3, r2
2000dd90:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
2000dd94:	687b      	ldr	r3, [r7, #4]
2000dd96:	681b      	ldr	r3, [r3, #0]
2000dd98:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2000dd9c:	2b00      	cmp	r3, #0
2000dd9e:	d022      	beq.n	2000dde6 <HAL_RCCEx_PeriphCLKConfig+0x7aa>
2000dda0:	687b      	ldr	r3, [r7, #4]
2000dda2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2000dda4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2000dda8:	d11d      	bne.n	2000dde6 <HAL_RCCEx_PeriphCLKConfig+0x7aa>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
2000ddaa:	4b36      	ldr	r3, [pc, #216]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000ddac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000ddb0:	0e1b      	lsrs	r3, r3, #24
2000ddb2:	f003 030f 	and.w	r3, r3, #15
2000ddb6:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
2000ddb8:	4b32      	ldr	r3, [pc, #200]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000ddba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000ddbe:	0f1b      	lsrs	r3, r3, #28
2000ddc0:	f003 0307 	and.w	r3, r3, #7
2000ddc4:	60fb      	str	r3, [r7, #12]

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
2000ddc6:	687b      	ldr	r3, [r7, #4]
2000ddc8:	695b      	ldr	r3, [r3, #20]
2000ddca:	019a      	lsls	r2, r3, #6
2000ddcc:	687b      	ldr	r3, [r7, #4]
2000ddce:	6a1b      	ldr	r3, [r3, #32]
2000ddd0:	041b      	lsls	r3, r3, #16
2000ddd2:	431a      	orrs	r2, r3
2000ddd4:	693b      	ldr	r3, [r7, #16]
2000ddd6:	061b      	lsls	r3, r3, #24
2000ddd8:	431a      	orrs	r2, r3
2000ddda:	68fb      	ldr	r3, [r7, #12]
2000dddc:	071b      	lsls	r3, r3, #28
2000ddde:	4929      	ldr	r1, [pc, #164]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000dde0:	4313      	orrs	r3, r2
2000dde2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
2000dde6:	687b      	ldr	r3, [r7, #4]
2000dde8:	681b      	ldr	r3, [r3, #0]
2000ddea:	f003 0308 	and.w	r3, r3, #8
2000ddee:	2b00      	cmp	r3, #0
2000ddf0:	d028      	beq.n	2000de44 <HAL_RCCEx_PeriphCLKConfig+0x808>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
2000ddf2:	4b24      	ldr	r3, [pc, #144]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000ddf4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000ddf8:	0e1b      	lsrs	r3, r3, #24
2000ddfa:	f003 030f 	and.w	r3, r3, #15
2000ddfe:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
2000de00:	4b20      	ldr	r3, [pc, #128]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000de02:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000de06:	0c1b      	lsrs	r3, r3, #16
2000de08:	f003 0303 	and.w	r3, r3, #3
2000de0c:	60fb      	str	r3, [r7, #12]

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
2000de0e:	687b      	ldr	r3, [r7, #4]
2000de10:	695b      	ldr	r3, [r3, #20]
2000de12:	019a      	lsls	r2, r3, #6
2000de14:	68fb      	ldr	r3, [r7, #12]
2000de16:	041b      	lsls	r3, r3, #16
2000de18:	431a      	orrs	r2, r3
2000de1a:	693b      	ldr	r3, [r7, #16]
2000de1c:	061b      	lsls	r3, r3, #24
2000de1e:	431a      	orrs	r2, r3
2000de20:	687b      	ldr	r3, [r7, #4]
2000de22:	69db      	ldr	r3, [r3, #28]
2000de24:	071b      	lsls	r3, r3, #28
2000de26:	4917      	ldr	r1, [pc, #92]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000de28:	4313      	orrs	r3, r2
2000de2a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
2000de2e:	4b15      	ldr	r3, [pc, #84]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000de30:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000de34:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
2000de38:	687b      	ldr	r3, [r7, #4]
2000de3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000de3c:	4911      	ldr	r1, [pc, #68]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000de3e:	4313      	orrs	r3, r2
2000de40:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
2000de44:	4b0f      	ldr	r3, [pc, #60]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000de46:	681b      	ldr	r3, [r3, #0]
2000de48:	4a0e      	ldr	r2, [pc, #56]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000de4a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000de4e:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2000de50:	f7f3 ff96 	bl	20001d80 <HAL_GetTick>
2000de54:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
2000de56:	e008      	b.n	2000de6a <HAL_RCCEx_PeriphCLKConfig+0x82e>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
2000de58:	f7f3 ff92 	bl	20001d80 <HAL_GetTick>
2000de5c:	4602      	mov	r2, r0
2000de5e:	697b      	ldr	r3, [r7, #20]
2000de60:	1ad3      	subs	r3, r2, r3
2000de62:	2b64      	cmp	r3, #100	; 0x64
2000de64:	d901      	bls.n	2000de6a <HAL_RCCEx_PeriphCLKConfig+0x82e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
2000de66:	2303      	movs	r3, #3
2000de68:	e007      	b.n	2000de7a <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
2000de6a:	4b06      	ldr	r3, [pc, #24]	; (2000de84 <HAL_RCCEx_PeriphCLKConfig+0x848>)
2000de6c:	681b      	ldr	r3, [r3, #0]
2000de6e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000de72:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2000de76:	d1ef      	bne.n	2000de58 <HAL_RCCEx_PeriphCLKConfig+0x81c>
      }
    }
  }
  return HAL_OK;
2000de78:	2300      	movs	r3, #0
}
2000de7a:	4618      	mov	r0, r3
2000de7c:	3720      	adds	r7, #32
2000de7e:	46bd      	mov	sp, r7
2000de80:	bd80      	pop	{r7, pc}
2000de82:	bf00      	nop
2000de84:	40023800 	.word	0x40023800

2000de88 <HAL_RCCEx_GetPeriphCLKConfig>:
  *         RCC configuration registers.
  * @param  PeriphClkInit pointer to the configured RCC_PeriphCLKInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
2000de88:	b480      	push	{r7}
2000de8a:	b085      	sub	sp, #20
2000de8c:	af00      	add	r7, sp, #0
2000de8e:	6078      	str	r0, [r7, #4]
  uint32_t tempreg = 0;
2000de90:	2300      	movs	r3, #0
2000de92:	60fb      	str	r3, [r7, #12]

  /* Set all possible values for the extended clock type parameter------------*/
#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\
2000de94:	687b      	ldr	r3, [r7, #4]
2000de96:	4a8c      	ldr	r2, [pc, #560]	; (2000e0c8 <HAL_RCCEx_GetPeriphCLKConfig+0x240>)
2000de98:	601a      	str	r2, [r3, #0]
                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\
                                        RCC_PERIPHCLK_CLK48;
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /* Get the PLLI2S Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
2000de9a:	4b8c      	ldr	r3, [pc, #560]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000de9c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000dea0:	099b      	lsrs	r3, r3, #6
2000dea2:	f3c3 0208 	ubfx	r2, r3, #0, #9
2000dea6:	687b      	ldr	r3, [r7, #4]
2000dea8:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLLI2S.PLLI2SP = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
2000deaa:	4b88      	ldr	r3, [pc, #544]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000deac:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000deb0:	0c1b      	lsrs	r3, r3, #16
2000deb2:	f003 0203 	and.w	r2, r3, #3
2000deb6:	687b      	ldr	r3, [r7, #4]
2000deb8:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
2000deba:	4b84      	ldr	r3, [pc, #528]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000debc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000dec0:	0e1b      	lsrs	r3, r3, #24
2000dec2:	f003 020f 	and.w	r2, r3, #15
2000dec6:	687b      	ldr	r3, [r7, #4]
2000dec8:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
2000deca:	4b80      	ldr	r3, [pc, #512]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000decc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000ded0:	0f1b      	lsrs	r3, r3, #28
2000ded2:	f003 0207 	and.w	r2, r3, #7
2000ded6:	687b      	ldr	r3, [r7, #4]
2000ded8:	609a      	str	r2, [r3, #8]

  /* Get the PLLSAI Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);
2000deda:	4b7c      	ldr	r3, [pc, #496]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dedc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000dee0:	099b      	lsrs	r3, r3, #6
2000dee2:	f3c3 0208 	ubfx	r2, r3, #0, #9
2000dee6:	687b      	ldr	r3, [r7, #4]
2000dee8:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
2000deea:	4b78      	ldr	r3, [pc, #480]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000deec:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000def0:	0c1b      	lsrs	r3, r3, #16
2000def2:	f003 0203 	and.w	r2, r3, #3
2000def6:	687b      	ldr	r3, [r7, #4]
2000def8:	621a      	str	r2, [r3, #32]
  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
2000defa:	4b74      	ldr	r3, [pc, #464]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000defc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000df00:	0e1b      	lsrs	r3, r3, #24
2000df02:	f003 020f 	and.w	r2, r3, #15
2000df06:	687b      	ldr	r3, [r7, #4]
2000df08:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
2000df0a:	4b70      	ldr	r3, [pc, #448]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df0c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000df10:	0f1b      	lsrs	r3, r3, #28
2000df12:	f003 0207 	and.w	r2, r3, #7
2000df16:	687b      	ldr	r3, [r7, #4]
2000df18:	61da      	str	r2, [r3, #28]

  /* Get the PLLSAI/PLLI2S division factors -------------------------------------------*/
  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) >> RCC_DCKCFGR1_PLLI2SDIVQ_Pos);
2000df1a:	4b6c      	ldr	r3, [pc, #432]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df1c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000df20:	f003 021f 	and.w	r2, r3, #31
2000df24:	687b      	ldr	r3, [r7, #4]
2000df26:	625a      	str	r2, [r3, #36]	; 0x24
  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> RCC_DCKCFGR1_PLLSAIDIVQ_Pos);
2000df28:	4b68      	ldr	r3, [pc, #416]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df2a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000df2e:	0a1b      	lsrs	r3, r3, #8
2000df30:	f003 021f 	and.w	r2, r3, #31
2000df34:	687b      	ldr	r3, [r7, #4]
2000df36:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLLSAIDivR = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVR) >> RCC_DCKCFGR1_PLLSAIDIVR_Pos);
2000df38:	4b64      	ldr	r3, [pc, #400]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df3a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000df3e:	0c1b      	lsrs	r3, r3, #16
2000df40:	f003 0203 	and.w	r2, r3, #3
2000df44:	687b      	ldr	r3, [r7, #4]
2000df46:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Get the SAI1 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();
2000df48:	4b60      	ldr	r3, [pc, #384]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df4a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000df4e:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
2000df52:	687b      	ldr	r3, [r7, #4]
2000df54:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Get the SAI2 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();
2000df56:	4b5d      	ldr	r3, [pc, #372]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df58:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000df5c:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
2000df60:	687b      	ldr	r3, [r7, #4]
2000df62:	641a      	str	r2, [r3, #64]	; 0x40

  /* Get the I2S clock configuration ------------------------------------------*/
  PeriphClkInit->I2sClockSelection = __HAL_RCC_GET_I2SCLKSOURCE();
2000df64:	4b59      	ldr	r3, [pc, #356]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df66:	689b      	ldr	r3, [r3, #8]
2000df68:	f403 0200 	and.w	r2, r3, #8388608	; 0x800000
2000df6c:	687b      	ldr	r3, [r7, #4]
2000df6e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Get the I2C1 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
2000df70:	4b56      	ldr	r3, [pc, #344]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df72:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000df76:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
2000df7a:	687b      	ldr	r3, [r7, #4]
2000df7c:	665a      	str	r2, [r3, #100]	; 0x64

  /* Get the I2C2 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();
2000df7e:	4b53      	ldr	r3, [pc, #332]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df80:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000df84:	f403 2240 	and.w	r2, r3, #786432	; 0xc0000
2000df88:	687b      	ldr	r3, [r7, #4]
2000df8a:	669a      	str	r2, [r3, #104]	; 0x68

  /* Get the I2C3 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();
2000df8c:	4b4f      	ldr	r3, [pc, #316]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df8e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000df92:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
2000df96:	687b      	ldr	r3, [r7, #4]
2000df98:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Get the I2C4 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c4ClockSelection = __HAL_RCC_GET_I2C4_SOURCE();
2000df9a:	4b4c      	ldr	r3, [pc, #304]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000df9c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dfa0:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
2000dfa4:	687b      	ldr	r3, [r7, #4]
2000dfa6:	671a      	str	r2, [r3, #112]	; 0x70

  /* Get the USART1 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
2000dfa8:	4b48      	ldr	r3, [pc, #288]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dfaa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dfae:	f003 0203 	and.w	r2, r3, #3
2000dfb2:	687b      	ldr	r3, [r7, #4]
2000dfb4:	645a      	str	r2, [r3, #68]	; 0x44

  /* Get the USART2 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
2000dfb6:	4b45      	ldr	r3, [pc, #276]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dfb8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dfbc:	f003 020c 	and.w	r2, r3, #12
2000dfc0:	687b      	ldr	r3, [r7, #4]
2000dfc2:	649a      	str	r2, [r3, #72]	; 0x48

  /* Get the USART3 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
2000dfc4:	4b41      	ldr	r3, [pc, #260]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dfc6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dfca:	f003 0230 	and.w	r2, r3, #48	; 0x30
2000dfce:	687b      	ldr	r3, [r7, #4]
2000dfd0:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Get the UART4 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();
2000dfd2:	4b3e      	ldr	r3, [pc, #248]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dfd4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dfd8:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
2000dfdc:	687b      	ldr	r3, [r7, #4]
2000dfde:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get the UART5 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();
2000dfe0:	4b3a      	ldr	r3, [pc, #232]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dfe2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dfe6:	f403 7240 	and.w	r2, r3, #768	; 0x300
2000dfea:	687b      	ldr	r3, [r7, #4]
2000dfec:	655a      	str	r2, [r3, #84]	; 0x54

  /* Get the USART6 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();
2000dfee:	4b37      	ldr	r3, [pc, #220]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dff0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000dff4:	f403 6240 	and.w	r2, r3, #3072	; 0xc00
2000dff8:	687b      	ldr	r3, [r7, #4]
2000dffa:	659a      	str	r2, [r3, #88]	; 0x58

  /* Get the UART7 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();
2000dffc:	4b33      	ldr	r3, [pc, #204]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000dffe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000e002:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
2000e006:	687b      	ldr	r3, [r7, #4]
2000e008:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Get the UART8 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();
2000e00a:	4b30      	ldr	r3, [pc, #192]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e00c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000e010:	f403 4240 	and.w	r2, r3, #49152	; 0xc000
2000e014:	687b      	ldr	r3, [r7, #4]
2000e016:	661a      	str	r2, [r3, #96]	; 0x60

  /* Get the LPTIM1 clock configuration ------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();
2000e018:	4b2c      	ldr	r3, [pc, #176]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e01a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000e01e:	f003 7240 	and.w	r2, r3, #50331648	; 0x3000000
2000e022:	687b      	ldr	r3, [r7, #4]
2000e024:	675a      	str	r2, [r3, #116]	; 0x74

  /* Get the CEC clock configuration -----------------------------------------------*/
  PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
2000e026:	4b29      	ldr	r3, [pc, #164]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e028:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000e02c:	f003 6280 	and.w	r2, r3, #67108864	; 0x4000000
2000e030:	687b      	ldr	r3, [r7, #4]
2000e032:	679a      	str	r2, [r3, #120]	; 0x78

  /* Get the CK48 clock configuration -----------------------------------------------*/
  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();
2000e034:	4b25      	ldr	r3, [pc, #148]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e036:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000e03a:	f003 6200 	and.w	r2, r3, #134217728	; 0x8000000
2000e03e:	687b      	ldr	r3, [r7, #4]
2000e040:	67da      	str	r2, [r3, #124]	; 0x7c

  /* Get the SDMMC1 clock configuration -----------------------------------------------*/
  PeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();
2000e042:	4b22      	ldr	r3, [pc, #136]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e044:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000e048:	f003 5280 	and.w	r2, r3, #268435456	; 0x10000000
2000e04c:	687b      	ldr	r3, [r7, #4]
2000e04e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /* Get the SDMMC2 clock configuration -----------------------------------------------*/
  PeriphClkInit->Sdmmc2ClockSelection = __HAL_RCC_GET_SDMMC2_SOURCE();
2000e052:	4b1e      	ldr	r3, [pc, #120]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e054:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000e058:	f003 5200 	and.w	r2, r3, #536870912	; 0x20000000
2000e05c:	687b      	ldr	r3, [r7, #4]
2000e05e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Get the DFSDM clock configuration -----------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection = __HAL_RCC_GET_DFSDM1_SOURCE();
2000e062:	4b1a      	ldr	r3, [pc, #104]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e064:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e068:	f003 7200 	and.w	r2, r3, #33554432	; 0x2000000
2000e06c:	687b      	ldr	r3, [r7, #4]
2000e06e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Get the DFSDM AUDIO clock configuration -----------------------------------------------*/
  PeriphClkInit->Dfsdm1AudioClockSelection = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
2000e072:	4b16      	ldr	r3, [pc, #88]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e074:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e078:	f003 6280 	and.w	r2, r3, #67108864	; 0x4000000
2000e07c:	687b      	ldr	r3, [r7, #4]
2000e07e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /* Get the RTC Clock configuration -----------------------------------------------*/
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
2000e082:	4b12      	ldr	r3, [pc, #72]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e084:	689b      	ldr	r3, [r3, #8]
2000e086:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
2000e08a:	60fb      	str	r3, [r7, #12]
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
2000e08c:	4b0f      	ldr	r3, [pc, #60]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e08e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000e090:	f403 7240 	and.w	r2, r3, #768	; 0x300
2000e094:	68fb      	ldr	r3, [r7, #12]
2000e096:	431a      	orrs	r2, r3
2000e098:	687b      	ldr	r3, [r7, #4]
2000e09a:	631a      	str	r2, [r3, #48]	; 0x30

  /* Get the TIM Prescaler configuration --------------------------------------------*/
  if ((RCC->DCKCFGR1 & RCC_DCKCFGR1_TIMPRE) == RESET)
2000e09c:	4b0b      	ldr	r3, [pc, #44]	; (2000e0cc <HAL_RCCEx_GetPeriphCLKConfig+0x244>)
2000e09e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e0a2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2000e0a6:	2b00      	cmp	r3, #0
2000e0a8:	d103      	bne.n	2000e0b2 <HAL_RCCEx_GetPeriphCLKConfig+0x22a>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
2000e0aa:	687b      	ldr	r3, [r7, #4]
2000e0ac:	2200      	movs	r2, #0
2000e0ae:	639a      	str	r2, [r3, #56]	; 0x38
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
2000e0b0:	e003      	b.n	2000e0ba <HAL_RCCEx_GetPeriphCLKConfig+0x232>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
2000e0b2:	687b      	ldr	r3, [r7, #4]
2000e0b4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
2000e0b8:	639a      	str	r2, [r3, #56]	; 0x38
}
2000e0ba:	bf00      	nop
2000e0bc:	3714      	adds	r7, #20
2000e0be:	46bd      	mov	sp, r7
2000e0c0:	f85d 7b04 	ldr.w	r7, [sp], #4
2000e0c4:	4770      	bx	lr
2000e0c6:	bf00      	nop
2000e0c8:	1cfffff1 	.word	0x1cfffff1
2000e0cc:	40023800 	.word	0x40023800

2000e0d0 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_SAI1: SAI1 peripheral clock
  *            @arg RCC_PERIPHCLK_SAI2: SAI2 peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
2000e0d0:	b480      	push	{r7}
2000e0d2:	b087      	sub	sp, #28
2000e0d4:	af00      	add	r7, sp, #0
2000e0d6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
2000e0d8:	2300      	movs	r3, #0
2000e0da:	60fb      	str	r3, [r7, #12]
  /* This variable is used to store the SAI clock frequency (value in Hz) */
  uint32_t frequency = 0;
2000e0dc:	2300      	movs	r3, #0
2000e0de:	617b      	str	r3, [r7, #20]
  /* This variable is used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
2000e0e0:	2300      	movs	r3, #0
2000e0e2:	613b      	str	r3, [r7, #16]
  /* This variable is used to store the SAI clock source */
  uint32_t saiclocksource = 0;
2000e0e4:	2300      	movs	r3, #0
2000e0e6:	60bb      	str	r3, [r7, #8]

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
2000e0e8:	687b      	ldr	r3, [r7, #4]
2000e0ea:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
2000e0ee:	f040 8099 	bne.w	2000e224 <HAL_RCCEx_GetPeriphCLKFreq+0x154>
  {
    saiclocksource = RCC->DCKCFGR1;
2000e0f2:	4ba0      	ldr	r3, [pc, #640]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e0f4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e0f8:	60bb      	str	r3, [r7, #8]
    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
2000e0fa:	68bb      	ldr	r3, [r7, #8]
2000e0fc:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
2000e100:	60bb      	str	r3, [r7, #8]
    switch (saiclocksource)
2000e102:	68bb      	ldr	r3, [r7, #8]
2000e104:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2000e108:	d045      	beq.n	2000e196 <HAL_RCCEx_GetPeriphCLKFreq+0xc6>
2000e10a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2000e10e:	d802      	bhi.n	2000e116 <HAL_RCCEx_GetPeriphCLKFreq+0x46>
2000e110:	2b00      	cmp	r3, #0
2000e112:	d007      	beq.n	2000e124 <HAL_RCCEx_GetPeriphCLKFreq+0x54>
        break;
      }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
    default :
      {
        break;
2000e114:	e087      	b.n	2000e226 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
    switch (saiclocksource)
2000e116:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2000e11a:	d074      	beq.n	2000e206 <HAL_RCCEx_GetPeriphCLKFreq+0x136>
2000e11c:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2000e120:	d074      	beq.n	2000e20c <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
        break;
2000e122:	e080      	b.n	2000e226 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
2000e124:	4b93      	ldr	r3, [pc, #588]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e126:	685b      	ldr	r3, [r3, #4]
2000e128:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000e12c:	2b00      	cmp	r3, #0
2000e12e:	d108      	bne.n	2000e142 <HAL_RCCEx_GetPeriphCLKFreq+0x72>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
2000e130:	4b90      	ldr	r3, [pc, #576]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e132:	685b      	ldr	r3, [r3, #4]
2000e134:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e138:	4a8f      	ldr	r2, [pc, #572]	; (2000e378 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2000e13a:	fbb2 f3f3 	udiv	r3, r2, r3
2000e13e:	613b      	str	r3, [r7, #16]
2000e140:	e007      	b.n	2000e152 <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
2000e142:	4b8c      	ldr	r3, [pc, #560]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e144:	685b      	ldr	r3, [r3, #4]
2000e146:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e14a:	4a8c      	ldr	r2, [pc, #560]	; (2000e37c <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>)
2000e14c:	fbb2 f3f3 	udiv	r3, r2, r3
2000e150:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
2000e152:	4b88      	ldr	r3, [pc, #544]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e154:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000e158:	0e1b      	lsrs	r3, r3, #24
2000e15a:	f003 030f 	and.w	r3, r3, #15
2000e15e:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
2000e160:	4b84      	ldr	r3, [pc, #528]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e162:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000e166:	099b      	lsrs	r3, r3, #6
2000e168:	f3c3 0308 	ubfx	r3, r3, #0, #9
2000e16c:	693a      	ldr	r2, [r7, #16]
2000e16e:	fb02 f203 	mul.w	r2, r2, r3
2000e172:	68fb      	ldr	r3, [r7, #12]
2000e174:	fbb2 f3f3 	udiv	r3, r2, r3
2000e178:	617b      	str	r3, [r7, #20]
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
2000e17a:	4b7e      	ldr	r3, [pc, #504]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e17c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e180:	0a1b      	lsrs	r3, r3, #8
2000e182:	f003 031f 	and.w	r3, r3, #31
2000e186:	3301      	adds	r3, #1
2000e188:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
2000e18a:	697a      	ldr	r2, [r7, #20]
2000e18c:	68fb      	ldr	r3, [r7, #12]
2000e18e:	fbb2 f3f3 	udiv	r3, r2, r3
2000e192:	617b      	str	r3, [r7, #20]
        break;
2000e194:	e047      	b.n	2000e226 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
2000e196:	4b77      	ldr	r3, [pc, #476]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e198:	685b      	ldr	r3, [r3, #4]
2000e19a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000e19e:	2b00      	cmp	r3, #0
2000e1a0:	d108      	bne.n	2000e1b4 <HAL_RCCEx_GetPeriphCLKFreq+0xe4>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
2000e1a2:	4b74      	ldr	r3, [pc, #464]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e1a4:	685b      	ldr	r3, [r3, #4]
2000e1a6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e1aa:	4a73      	ldr	r2, [pc, #460]	; (2000e378 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2000e1ac:	fbb2 f3f3 	udiv	r3, r2, r3
2000e1b0:	613b      	str	r3, [r7, #16]
2000e1b2:	e007      	b.n	2000e1c4 <HAL_RCCEx_GetPeriphCLKFreq+0xf4>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
2000e1b4:	4b6f      	ldr	r3, [pc, #444]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e1b6:	685b      	ldr	r3, [r3, #4]
2000e1b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e1bc:	4a6f      	ldr	r2, [pc, #444]	; (2000e37c <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>)
2000e1be:	fbb2 f3f3 	udiv	r3, r2, r3
2000e1c2:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
2000e1c4:	4b6b      	ldr	r3, [pc, #428]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e1c6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000e1ca:	0e1b      	lsrs	r3, r3, #24
2000e1cc:	f003 030f 	and.w	r3, r3, #15
2000e1d0:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
2000e1d2:	4b68      	ldr	r3, [pc, #416]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e1d4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000e1d8:	099b      	lsrs	r3, r3, #6
2000e1da:	f3c3 0308 	ubfx	r3, r3, #0, #9
2000e1de:	693a      	ldr	r2, [r7, #16]
2000e1e0:	fb02 f203 	mul.w	r2, r2, r3
2000e1e4:	68fb      	ldr	r3, [r7, #12]
2000e1e6:	fbb2 f3f3 	udiv	r3, r2, r3
2000e1ea:	617b      	str	r3, [r7, #20]
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
2000e1ec:	4b61      	ldr	r3, [pc, #388]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e1ee:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e1f2:	f003 031f 	and.w	r3, r3, #31
2000e1f6:	3301      	adds	r3, #1
2000e1f8:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
2000e1fa:	697a      	ldr	r2, [r7, #20]
2000e1fc:	68fb      	ldr	r3, [r7, #12]
2000e1fe:	fbb2 f3f3 	udiv	r3, r2, r3
2000e202:	617b      	str	r3, [r7, #20]
        break;
2000e204:	e00f      	b.n	2000e226 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
        frequency = EXTERNAL_CLOCK_VALUE;
2000e206:	4b5e      	ldr	r3, [pc, #376]	; (2000e380 <HAL_RCCEx_GetPeriphCLKFreq+0x2b0>)
2000e208:	617b      	str	r3, [r7, #20]
        break;
2000e20a:	e00c      	b.n	2000e226 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
2000e20c:	4b59      	ldr	r3, [pc, #356]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e20e:	685b      	ldr	r3, [r3, #4]
2000e210:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000e214:	2b00      	cmp	r3, #0
2000e216:	d102      	bne.n	2000e21e <HAL_RCCEx_GetPeriphCLKFreq+0x14e>
          frequency = HSI_VALUE;
2000e218:	4b57      	ldr	r3, [pc, #348]	; (2000e378 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2000e21a:	617b      	str	r3, [r7, #20]
        break;
2000e21c:	e003      	b.n	2000e226 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
          frequency = HSE_VALUE;
2000e21e:	4b57      	ldr	r3, [pc, #348]	; (2000e37c <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>)
2000e220:	617b      	str	r3, [r7, #20]
        break;
2000e222:	e000      	b.n	2000e226 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
      }
    }
  }
2000e224:	bf00      	nop

  if (PeriphClk == RCC_PERIPHCLK_SAI2)
2000e226:	687b      	ldr	r3, [r7, #4]
2000e228:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2000e22c:	f040 8099 	bne.w	2000e362 <HAL_RCCEx_GetPeriphCLKFreq+0x292>
  {
    saiclocksource = RCC->DCKCFGR1;
2000e230:	4b50      	ldr	r3, [pc, #320]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e232:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e236:	60bb      	str	r3, [r7, #8]
    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
2000e238:	68bb      	ldr	r3, [r7, #8]
2000e23a:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
2000e23e:	60bb      	str	r3, [r7, #8]
    switch (saiclocksource)
2000e240:	68bb      	ldr	r3, [r7, #8]
2000e242:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2000e246:	d045      	beq.n	2000e2d4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>
2000e248:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2000e24c:	d802      	bhi.n	2000e254 <HAL_RCCEx_GetPeriphCLKFreq+0x184>
2000e24e:	2b00      	cmp	r3, #0
2000e250:	d007      	beq.n	2000e262 <HAL_RCCEx_GetPeriphCLKFreq+0x192>
        break;
      }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
    default :
      {
        break;
2000e252:	e087      	b.n	2000e364 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
    switch (saiclocksource)
2000e254:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2000e258:	d074      	beq.n	2000e344 <HAL_RCCEx_GetPeriphCLKFreq+0x274>
2000e25a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
2000e25e:	d074      	beq.n	2000e34a <HAL_RCCEx_GetPeriphCLKFreq+0x27a>
        break;
2000e260:	e080      	b.n	2000e364 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
2000e262:	4b44      	ldr	r3, [pc, #272]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e264:	685b      	ldr	r3, [r3, #4]
2000e266:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000e26a:	2b00      	cmp	r3, #0
2000e26c:	d108      	bne.n	2000e280 <HAL_RCCEx_GetPeriphCLKFreq+0x1b0>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
2000e26e:	4b41      	ldr	r3, [pc, #260]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e270:	685b      	ldr	r3, [r3, #4]
2000e272:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e276:	4a40      	ldr	r2, [pc, #256]	; (2000e378 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2000e278:	fbb2 f3f3 	udiv	r3, r2, r3
2000e27c:	613b      	str	r3, [r7, #16]
2000e27e:	e007      	b.n	2000e290 <HAL_RCCEx_GetPeriphCLKFreq+0x1c0>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
2000e280:	4b3c      	ldr	r3, [pc, #240]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e282:	685b      	ldr	r3, [r3, #4]
2000e284:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e288:	4a3c      	ldr	r2, [pc, #240]	; (2000e37c <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>)
2000e28a:	fbb2 f3f3 	udiv	r3, r2, r3
2000e28e:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
2000e290:	4b38      	ldr	r3, [pc, #224]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e292:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000e296:	0e1b      	lsrs	r3, r3, #24
2000e298:	f003 030f 	and.w	r3, r3, #15
2000e29c:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
2000e29e:	4b35      	ldr	r3, [pc, #212]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e2a0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000e2a4:	099b      	lsrs	r3, r3, #6
2000e2a6:	f3c3 0308 	ubfx	r3, r3, #0, #9
2000e2aa:	693a      	ldr	r2, [r7, #16]
2000e2ac:	fb02 f203 	mul.w	r2, r2, r3
2000e2b0:	68fb      	ldr	r3, [r7, #12]
2000e2b2:	fbb2 f3f3 	udiv	r3, r2, r3
2000e2b6:	617b      	str	r3, [r7, #20]
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
2000e2b8:	4b2e      	ldr	r3, [pc, #184]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e2ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e2be:	0a1b      	lsrs	r3, r3, #8
2000e2c0:	f003 031f 	and.w	r3, r3, #31
2000e2c4:	3301      	adds	r3, #1
2000e2c6:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
2000e2c8:	697a      	ldr	r2, [r7, #20]
2000e2ca:	68fb      	ldr	r3, [r7, #12]
2000e2cc:	fbb2 f3f3 	udiv	r3, r2, r3
2000e2d0:	617b      	str	r3, [r7, #20]
        break;
2000e2d2:	e047      	b.n	2000e364 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
2000e2d4:	4b27      	ldr	r3, [pc, #156]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e2d6:	685b      	ldr	r3, [r3, #4]
2000e2d8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000e2dc:	2b00      	cmp	r3, #0
2000e2de:	d108      	bne.n	2000e2f2 <HAL_RCCEx_GetPeriphCLKFreq+0x222>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
2000e2e0:	4b24      	ldr	r3, [pc, #144]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e2e2:	685b      	ldr	r3, [r3, #4]
2000e2e4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e2e8:	4a23      	ldr	r2, [pc, #140]	; (2000e378 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2000e2ea:	fbb2 f3f3 	udiv	r3, r2, r3
2000e2ee:	613b      	str	r3, [r7, #16]
2000e2f0:	e007      	b.n	2000e302 <HAL_RCCEx_GetPeriphCLKFreq+0x232>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
2000e2f2:	4b20      	ldr	r3, [pc, #128]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e2f4:	685b      	ldr	r3, [r3, #4]
2000e2f6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2000e2fa:	4a20      	ldr	r2, [pc, #128]	; (2000e37c <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>)
2000e2fc:	fbb2 f3f3 	udiv	r3, r2, r3
2000e300:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
2000e302:	4b1c      	ldr	r3, [pc, #112]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e304:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000e308:	0e1b      	lsrs	r3, r3, #24
2000e30a:	f003 030f 	and.w	r3, r3, #15
2000e30e:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
2000e310:	4b18      	ldr	r3, [pc, #96]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e312:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2000e316:	099b      	lsrs	r3, r3, #6
2000e318:	f3c3 0308 	ubfx	r3, r3, #0, #9
2000e31c:	693a      	ldr	r2, [r7, #16]
2000e31e:	fb02 f203 	mul.w	r2, r2, r3
2000e322:	68fb      	ldr	r3, [r7, #12]
2000e324:	fbb2 f3f3 	udiv	r3, r2, r3
2000e328:	617b      	str	r3, [r7, #20]
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
2000e32a:	4b12      	ldr	r3, [pc, #72]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e32c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2000e330:	f003 031f 	and.w	r3, r3, #31
2000e334:	3301      	adds	r3, #1
2000e336:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
2000e338:	697a      	ldr	r2, [r7, #20]
2000e33a:	68fb      	ldr	r3, [r7, #12]
2000e33c:	fbb2 f3f3 	udiv	r3, r2, r3
2000e340:	617b      	str	r3, [r7, #20]
        break;
2000e342:	e00f      	b.n	2000e364 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
        frequency = EXTERNAL_CLOCK_VALUE;
2000e344:	4b0e      	ldr	r3, [pc, #56]	; (2000e380 <HAL_RCCEx_GetPeriphCLKFreq+0x2b0>)
2000e346:	617b      	str	r3, [r7, #20]
        break;
2000e348:	e00c      	b.n	2000e364 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
2000e34a:	4b0a      	ldr	r3, [pc, #40]	; (2000e374 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2000e34c:	685b      	ldr	r3, [r3, #4]
2000e34e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000e352:	2b00      	cmp	r3, #0
2000e354:	d102      	bne.n	2000e35c <HAL_RCCEx_GetPeriphCLKFreq+0x28c>
          frequency = HSI_VALUE;
2000e356:	4b08      	ldr	r3, [pc, #32]	; (2000e378 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2000e358:	617b      	str	r3, [r7, #20]
        break;
2000e35a:	e003      	b.n	2000e364 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
          frequency = HSE_VALUE;
2000e35c:	4b07      	ldr	r3, [pc, #28]	; (2000e37c <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>)
2000e35e:	617b      	str	r3, [r7, #20]
        break;
2000e360:	e000      	b.n	2000e364 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
      }
    }
  }
2000e362:	bf00      	nop

  return frequency;
2000e364:	697b      	ldr	r3, [r7, #20]
}
2000e366:	4618      	mov	r0, r3
2000e368:	371c      	adds	r7, #28
2000e36a:	46bd      	mov	sp, r7
2000e36c:	f85d 7b04 	ldr.w	r7, [sp], #4
2000e370:	4770      	bx	lr
2000e372:	bf00      	nop
2000e374:	40023800 	.word	0x40023800
2000e378:	00f42400 	.word	0x00f42400
2000e37c:	017d7840 	.word	0x017d7840
2000e380:	00bb8000 	.word	0x00bb8000

2000e384 <HAL_RCCEx_EnablePLLI2S>:
  * @param  PLLI2SInit  pointer to an RCC_PLLI2SInitTypeDef structure that
  *         contains the configuration information for the PLLI2S
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit)
{
2000e384:	b580      	push	{r7, lr}
2000e386:	b084      	sub	sp, #16
2000e388:	af00      	add	r7, sp, #0
2000e38a:	6078      	str	r0, [r7, #4]
#if defined(RCC_PLLI2SCFGR_PLLI2SP)
  assert_param(IS_RCC_PLLI2SP_VALUE(PLLI2SInit->PLLI2SP));
#endif /* RCC_PLLI2SCFGR_PLLI2SP */

  /* Disable the PLLI2S */
  __HAL_RCC_PLLI2S_DISABLE();
2000e38c:	4b24      	ldr	r3, [pc, #144]	; (2000e420 <HAL_RCCEx_EnablePLLI2S+0x9c>)
2000e38e:	681b      	ldr	r3, [r3, #0]
2000e390:	4a23      	ldr	r2, [pc, #140]	; (2000e420 <HAL_RCCEx_EnablePLLI2S+0x9c>)
2000e392:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
2000e396:	6013      	str	r3, [r2, #0]

  /* Wait till PLLI2S is disabled */
  tickstart = HAL_GetTick();
2000e398:	f7f3 fcf2 	bl	20001d80 <HAL_GetTick>
2000e39c:	60f8      	str	r0, [r7, #12]
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) != RESET)
2000e39e:	e008      	b.n	2000e3b2 <HAL_RCCEx_EnablePLLI2S+0x2e>
  {
    if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
2000e3a0:	f7f3 fcee 	bl	20001d80 <HAL_GetTick>
2000e3a4:	4602      	mov	r2, r0
2000e3a6:	68fb      	ldr	r3, [r7, #12]
2000e3a8:	1ad3      	subs	r3, r2, r3
2000e3aa:	2b64      	cmp	r3, #100	; 0x64
2000e3ac:	d901      	bls.n	2000e3b2 <HAL_RCCEx_EnablePLLI2S+0x2e>
    {
      /* return in case of Timeout detected */
      return HAL_TIMEOUT;
2000e3ae:	2303      	movs	r3, #3
2000e3b0:	e031      	b.n	2000e416 <HAL_RCCEx_EnablePLLI2S+0x92>
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) != RESET)
2000e3b2:	4b1b      	ldr	r3, [pc, #108]	; (2000e420 <HAL_RCCEx_EnablePLLI2S+0x9c>)
2000e3b4:	681b      	ldr	r3, [r3, #0]
2000e3b6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000e3ba:	2b00      	cmp	r3, #0
2000e3bc:	d1f0      	bne.n	2000e3a0 <HAL_RCCEx_EnablePLLI2S+0x1c>
#else
  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * PLLI2SN */
  /* I2SPCLK = PLLI2S_VCO / PLLI2SP */
  /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */
  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
  __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SP, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);
2000e3be:	687b      	ldr	r3, [r7, #4]
2000e3c0:	681b      	ldr	r3, [r3, #0]
2000e3c2:	019a      	lsls	r2, r3, #6
2000e3c4:	687b      	ldr	r3, [r7, #4]
2000e3c6:	68db      	ldr	r3, [r3, #12]
2000e3c8:	041b      	lsls	r3, r3, #16
2000e3ca:	431a      	orrs	r2, r3
2000e3cc:	687b      	ldr	r3, [r7, #4]
2000e3ce:	689b      	ldr	r3, [r3, #8]
2000e3d0:	061b      	lsls	r3, r3, #24
2000e3d2:	431a      	orrs	r2, r3
2000e3d4:	687b      	ldr	r3, [r7, #4]
2000e3d6:	685b      	ldr	r3, [r3, #4]
2000e3d8:	071b      	lsls	r3, r3, #28
2000e3da:	4911      	ldr	r1, [pc, #68]	; (2000e420 <HAL_RCCEx_EnablePLLI2S+0x9c>)
2000e3dc:	4313      	orrs	r3, r2
2000e3de:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
#endif /* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F730xx */

  /* Enable the PLLI2S */
  __HAL_RCC_PLLI2S_ENABLE();
2000e3e2:	4b0f      	ldr	r3, [pc, #60]	; (2000e420 <HAL_RCCEx_EnablePLLI2S+0x9c>)
2000e3e4:	681b      	ldr	r3, [r3, #0]
2000e3e6:	4a0e      	ldr	r2, [pc, #56]	; (2000e420 <HAL_RCCEx_EnablePLLI2S+0x9c>)
2000e3e8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
2000e3ec:	6013      	str	r3, [r2, #0]

  /* Wait till PLLI2S is ready */
  tickstart = HAL_GetTick();
2000e3ee:	f7f3 fcc7 	bl	20001d80 <HAL_GetTick>
2000e3f2:	60f8      	str	r0, [r7, #12]
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) == RESET)
2000e3f4:	e008      	b.n	2000e408 <HAL_RCCEx_EnablePLLI2S+0x84>
  {
    if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
2000e3f6:	f7f3 fcc3 	bl	20001d80 <HAL_GetTick>
2000e3fa:	4602      	mov	r2, r0
2000e3fc:	68fb      	ldr	r3, [r7, #12]
2000e3fe:	1ad3      	subs	r3, r2, r3
2000e400:	2b64      	cmp	r3, #100	; 0x64
2000e402:	d901      	bls.n	2000e408 <HAL_RCCEx_EnablePLLI2S+0x84>
    {
      /* return in case of Timeout detected */
      return HAL_TIMEOUT;
2000e404:	2303      	movs	r3, #3
2000e406:	e006      	b.n	2000e416 <HAL_RCCEx_EnablePLLI2S+0x92>
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) == RESET)
2000e408:	4b05      	ldr	r3, [pc, #20]	; (2000e420 <HAL_RCCEx_EnablePLLI2S+0x9c>)
2000e40a:	681b      	ldr	r3, [r3, #0]
2000e40c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000e410:	2b00      	cmp	r3, #0
2000e412:	d0f0      	beq.n	2000e3f6 <HAL_RCCEx_EnablePLLI2S+0x72>
    }
  }

 return HAL_OK;
2000e414:	2300      	movs	r3, #0
}
2000e416:	4618      	mov	r0, r3
2000e418:	3710      	adds	r7, #16
2000e41a:	46bd      	mov	sp, r7
2000e41c:	bd80      	pop	{r7, pc}
2000e41e:	bf00      	nop
2000e420:	40023800 	.word	0x40023800

2000e424 <HAL_RCCEx_DisablePLLI2S>:
/**
  * @brief  Disable PLLI2S.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLI2S(void)
{
2000e424:	b580      	push	{r7, lr}
2000e426:	b082      	sub	sp, #8
2000e428:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the PLLI2S */
  __HAL_RCC_PLLI2S_DISABLE();
2000e42a:	4b0f      	ldr	r3, [pc, #60]	; (2000e468 <HAL_RCCEx_DisablePLLI2S+0x44>)
2000e42c:	681b      	ldr	r3, [r3, #0]
2000e42e:	4a0e      	ldr	r2, [pc, #56]	; (2000e468 <HAL_RCCEx_DisablePLLI2S+0x44>)
2000e430:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
2000e434:	6013      	str	r3, [r2, #0]

  /* Wait till PLLI2S is disabled */
  tickstart = HAL_GetTick();
2000e436:	f7f3 fca3 	bl	20001d80 <HAL_GetTick>
2000e43a:	6078      	str	r0, [r7, #4]
  while(READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
2000e43c:	e008      	b.n	2000e450 <HAL_RCCEx_DisablePLLI2S+0x2c>
  {
    if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
2000e43e:	f7f3 fc9f 	bl	20001d80 <HAL_GetTick>
2000e442:	4602      	mov	r2, r0
2000e444:	687b      	ldr	r3, [r7, #4]
2000e446:	1ad3      	subs	r3, r2, r3
2000e448:	2b64      	cmp	r3, #100	; 0x64
2000e44a:	d901      	bls.n	2000e450 <HAL_RCCEx_DisablePLLI2S+0x2c>
    {
      /* return in case of Timeout detected */
      return HAL_TIMEOUT;
2000e44c:	2303      	movs	r3, #3
2000e44e:	e006      	b.n	2000e45e <HAL_RCCEx_DisablePLLI2S+0x3a>
  while(READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
2000e450:	4b05      	ldr	r3, [pc, #20]	; (2000e468 <HAL_RCCEx_DisablePLLI2S+0x44>)
2000e452:	681b      	ldr	r3, [r3, #0]
2000e454:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2000e458:	2b00      	cmp	r3, #0
2000e45a:	d1f0      	bne.n	2000e43e <HAL_RCCEx_DisablePLLI2S+0x1a>
    }
  }

  return HAL_OK;
2000e45c:	2300      	movs	r3, #0
}
2000e45e:	4618      	mov	r0, r3
2000e460:	3708      	adds	r7, #8
2000e462:	46bd      	mov	sp, r7
2000e464:	bd80      	pop	{r7, pc}
2000e466:	bf00      	nop
2000e468:	40023800 	.word	0x40023800

2000e46c <HAL_RCCEx_EnablePLLSAI>:
  * @param  PLLSAIInit  pointer to an RCC_PLLSAIInitTypeDef structure that
  *         contains the configuration information for the PLLSAI
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI(RCC_PLLSAIInitTypeDef  *PLLSAIInit)
{
2000e46c:	b580      	push	{r7, lr}
2000e46e:	b084      	sub	sp, #16
2000e470:	af00      	add	r7, sp, #0
2000e472:	6078      	str	r0, [r7, #4]
#if defined(RCC_PLLSAICFGR_PLLSAIR)
  assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIInit->PLLSAIR));
#endif /* RCC_PLLSAICFGR_PLLSAIR */

  /* Disable the PLLSAI */
  __HAL_RCC_PLLSAI_DISABLE();
2000e474:	4b25      	ldr	r3, [pc, #148]	; (2000e50c <HAL_RCCEx_EnablePLLSAI+0xa0>)
2000e476:	681b      	ldr	r3, [r3, #0]
2000e478:	4a24      	ldr	r2, [pc, #144]	; (2000e50c <HAL_RCCEx_EnablePLLSAI+0xa0>)
2000e47a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2000e47e:	6013      	str	r3, [r2, #0]

  /* Wait till PLLSAI is disabled */
  tickstart = HAL_GetTick();
2000e480:	f7f3 fc7e 	bl	20001d80 <HAL_GetTick>
2000e484:	60f8      	str	r0, [r7, #12]
  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
2000e486:	e008      	b.n	2000e49a <HAL_RCCEx_EnablePLLSAI+0x2e>
  {
    if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
2000e488:	f7f3 fc7a 	bl	20001d80 <HAL_GetTick>
2000e48c:	4602      	mov	r2, r0
2000e48e:	68fb      	ldr	r3, [r7, #12]
2000e490:	1ad3      	subs	r3, r2, r3
2000e492:	2b64      	cmp	r3, #100	; 0x64
2000e494:	d901      	bls.n	2000e49a <HAL_RCCEx_EnablePLLSAI+0x2e>
    {
      /* return in case of Timeout detected */
      return HAL_TIMEOUT;
2000e496:	2303      	movs	r3, #3
2000e498:	e033      	b.n	2000e502 <HAL_RCCEx_EnablePLLSAI+0x96>
  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
2000e49a:	4b1c      	ldr	r3, [pc, #112]	; (2000e50c <HAL_RCCEx_EnablePLLSAI+0xa0>)
2000e49c:	681b      	ldr	r3, [r3, #0]
2000e49e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000e4a2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2000e4a6:	d0ef      	beq.n	2000e488 <HAL_RCCEx_EnablePLLSAI+0x1c>
#else
  /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * PLLSAIN */
  /* SAIPCLK = PLLSAI_VCO / PLLSAIP */
  /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */
  /* SAIRCLK = PLLSAI_VCO / PLLSAIR */
  __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIN, PLLSAIInit->PLLSAIP, \
2000e4a8:	687b      	ldr	r3, [r7, #4]
2000e4aa:	681b      	ldr	r3, [r3, #0]
2000e4ac:	019a      	lsls	r2, r3, #6
2000e4ae:	687b      	ldr	r3, [r7, #4]
2000e4b0:	68db      	ldr	r3, [r3, #12]
2000e4b2:	041b      	lsls	r3, r3, #16
2000e4b4:	431a      	orrs	r2, r3
2000e4b6:	687b      	ldr	r3, [r7, #4]
2000e4b8:	685b      	ldr	r3, [r3, #4]
2000e4ba:	061b      	lsls	r3, r3, #24
2000e4bc:	431a      	orrs	r2, r3
2000e4be:	687b      	ldr	r3, [r7, #4]
2000e4c0:	689b      	ldr	r3, [r3, #8]
2000e4c2:	071b      	lsls	r3, r3, #28
2000e4c4:	4911      	ldr	r1, [pc, #68]	; (2000e50c <HAL_RCCEx_EnablePLLSAI+0xa0>)
2000e4c6:	4313      	orrs	r3, r2
2000e4c8:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
                          PLLSAIInit->PLLSAIQ, PLLSAIInit->PLLSAIR);
#endif /* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F730xx */

  /* Enable the PLLSAI */
  __HAL_RCC_PLLSAI_ENABLE();
2000e4cc:	4b0f      	ldr	r3, [pc, #60]	; (2000e50c <HAL_RCCEx_EnablePLLSAI+0xa0>)
2000e4ce:	681b      	ldr	r3, [r3, #0]
2000e4d0:	4a0e      	ldr	r2, [pc, #56]	; (2000e50c <HAL_RCCEx_EnablePLLSAI+0xa0>)
2000e4d2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2000e4d6:	6013      	str	r3, [r2, #0]

  /* Wait till PLLSAI is ready */
  tickstart = HAL_GetTick();
2000e4d8:	f7f3 fc52 	bl	20001d80 <HAL_GetTick>
2000e4dc:	60f8      	str	r0, [r7, #12]
  while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
2000e4de:	e008      	b.n	2000e4f2 <HAL_RCCEx_EnablePLLSAI+0x86>
  {
    if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
2000e4e0:	f7f3 fc4e 	bl	20001d80 <HAL_GetTick>
2000e4e4:	4602      	mov	r2, r0
2000e4e6:	68fb      	ldr	r3, [r7, #12]
2000e4e8:	1ad3      	subs	r3, r2, r3
2000e4ea:	2b64      	cmp	r3, #100	; 0x64
2000e4ec:	d901      	bls.n	2000e4f2 <HAL_RCCEx_EnablePLLSAI+0x86>
    {
      /* return in case of Timeout detected */
      return HAL_TIMEOUT;
2000e4ee:	2303      	movs	r3, #3
2000e4f0:	e007      	b.n	2000e502 <HAL_RCCEx_EnablePLLSAI+0x96>
  while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
2000e4f2:	4b06      	ldr	r3, [pc, #24]	; (2000e50c <HAL_RCCEx_EnablePLLSAI+0xa0>)
2000e4f4:	681b      	ldr	r3, [r3, #0]
2000e4f6:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000e4fa:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2000e4fe:	d1ef      	bne.n	2000e4e0 <HAL_RCCEx_EnablePLLSAI+0x74>
    }
  }

 return HAL_OK;
2000e500:	2300      	movs	r3, #0
}
2000e502:	4618      	mov	r0, r3
2000e504:	3710      	adds	r7, #16
2000e506:	46bd      	mov	sp, r7
2000e508:	bd80      	pop	{r7, pc}
2000e50a:	bf00      	nop
2000e50c:	40023800 	.word	0x40023800

2000e510 <HAL_RCCEx_DisablePLLSAI>:
/**
  * @brief  Disable PLLSAI.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI(void)
{
2000e510:	b580      	push	{r7, lr}
2000e512:	b082      	sub	sp, #8
2000e514:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the PLLSAI */
  __HAL_RCC_PLLSAI_DISABLE();
2000e516:	4b0f      	ldr	r3, [pc, #60]	; (2000e554 <HAL_RCCEx_DisablePLLSAI+0x44>)
2000e518:	681b      	ldr	r3, [r3, #0]
2000e51a:	4a0e      	ldr	r2, [pc, #56]	; (2000e554 <HAL_RCCEx_DisablePLLSAI+0x44>)
2000e51c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
2000e520:	6013      	str	r3, [r2, #0]

  /* Wait till PLLSAI is disabled */
  tickstart = HAL_GetTick();
2000e522:	f7f3 fc2d 	bl	20001d80 <HAL_GetTick>
2000e526:	6078      	str	r0, [r7, #4]
  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
2000e528:	e008      	b.n	2000e53c <HAL_RCCEx_DisablePLLSAI+0x2c>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
2000e52a:	f7f3 fc29 	bl	20001d80 <HAL_GetTick>
2000e52e:	4602      	mov	r2, r0
2000e530:	687b      	ldr	r3, [r7, #4]
2000e532:	1ad3      	subs	r3, r2, r3
2000e534:	2b64      	cmp	r3, #100	; 0x64
2000e536:	d901      	bls.n	2000e53c <HAL_RCCEx_DisablePLLSAI+0x2c>
    {
      /* return in case of Timeout detected */
      return HAL_TIMEOUT;
2000e538:	2303      	movs	r3, #3
2000e53a:	e007      	b.n	2000e54c <HAL_RCCEx_DisablePLLSAI+0x3c>
  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
2000e53c:	4b05      	ldr	r3, [pc, #20]	; (2000e554 <HAL_RCCEx_DisablePLLSAI+0x44>)
2000e53e:	681b      	ldr	r3, [r3, #0]
2000e540:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2000e544:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2000e548:	d0ef      	beq.n	2000e52a <HAL_RCCEx_DisablePLLSAI+0x1a>
    }
  }

  return HAL_OK;
2000e54a:	2300      	movs	r3, #0
}
2000e54c:	4618      	mov	r0, r3
2000e54e:	3708      	adds	r7, #8
2000e550:	46bd      	mov	sp, r7
2000e552:	bd80      	pop	{r7, pc}
2000e554:	40023800 	.word	0x40023800

2000e558 <__errno>:
2000e558:	4b01      	ldr	r3, [pc, #4]	; (2000e560 <__errno+0x8>)
2000e55a:	6818      	ldr	r0, [r3, #0]
2000e55c:	4770      	bx	lr
2000e55e:	bf00      	nop
2000e560:	2000041c 	.word	0x2000041c

2000e564 <exit>:
2000e564:	b508      	push	{r3, lr}
2000e566:	4b07      	ldr	r3, [pc, #28]	; (2000e584 <exit+0x20>)
2000e568:	4604      	mov	r4, r0
2000e56a:	b113      	cbz	r3, 2000e572 <exit+0xe>
2000e56c:	2100      	movs	r1, #0
2000e56e:	f3af 8000 	nop.w
2000e572:	4b05      	ldr	r3, [pc, #20]	; (2000e588 <exit+0x24>)
2000e574:	6818      	ldr	r0, [r3, #0]
2000e576:	6a83      	ldr	r3, [r0, #40]	; 0x28
2000e578:	b103      	cbz	r3, 2000e57c <exit+0x18>
2000e57a:	4798      	blx	r3
2000e57c:	4620      	mov	r0, r4
2000e57e:	f7f3 f984 	bl	2000188a <_exit>
2000e582:	bf00      	nop
2000e584:	00000000 	.word	0x00000000
2000e588:	2000e708 	.word	0x2000e708

2000e58c <__libc_init_array>:
2000e58c:	b570      	push	{r4, r5, r6, lr}
2000e58e:	4e0d      	ldr	r6, [pc, #52]	; (2000e5c4 <__libc_init_array+0x38>)
2000e590:	4c0d      	ldr	r4, [pc, #52]	; (2000e5c8 <__libc_init_array+0x3c>)
2000e592:	1ba4      	subs	r4, r4, r6
2000e594:	10a4      	asrs	r4, r4, #2
2000e596:	2500      	movs	r5, #0
2000e598:	42a5      	cmp	r5, r4
2000e59a:	d109      	bne.n	2000e5b0 <__libc_init_array+0x24>
2000e59c:	4e0b      	ldr	r6, [pc, #44]	; (2000e5cc <__libc_init_array+0x40>)
2000e59e:	4c0c      	ldr	r4, [pc, #48]	; (2000e5d0 <__libc_init_array+0x44>)
2000e5a0:	f000 f832 	bl	2000e608 <_init>
2000e5a4:	1ba4      	subs	r4, r4, r6
2000e5a6:	10a4      	asrs	r4, r4, #2
2000e5a8:	2500      	movs	r5, #0
2000e5aa:	42a5      	cmp	r5, r4
2000e5ac:	d105      	bne.n	2000e5ba <__libc_init_array+0x2e>
2000e5ae:	bd70      	pop	{r4, r5, r6, pc}
2000e5b0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
2000e5b4:	4798      	blx	r3
2000e5b6:	3501      	adds	r5, #1
2000e5b8:	e7ee      	b.n	2000e598 <__libc_init_array+0xc>
2000e5ba:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
2000e5be:	4798      	blx	r3
2000e5c0:	3501      	adds	r5, #1
2000e5c2:	e7f2      	b.n	2000e5aa <__libc_init_array+0x1e>
2000e5c4:	20000400 	.word	0x20000400
2000e5c8:	20000400 	.word	0x20000400
2000e5cc:	20000400 	.word	0x20000400
2000e5d0:	20000404 	.word	0x20000404

2000e5d4 <memcmp>:
2000e5d4:	b530      	push	{r4, r5, lr}
2000e5d6:	2400      	movs	r4, #0
2000e5d8:	42a2      	cmp	r2, r4
2000e5da:	d101      	bne.n	2000e5e0 <memcmp+0xc>
2000e5dc:	2000      	movs	r0, #0
2000e5de:	e007      	b.n	2000e5f0 <memcmp+0x1c>
2000e5e0:	5d03      	ldrb	r3, [r0, r4]
2000e5e2:	3401      	adds	r4, #1
2000e5e4:	190d      	adds	r5, r1, r4
2000e5e6:	f815 5c01 	ldrb.w	r5, [r5, #-1]
2000e5ea:	42ab      	cmp	r3, r5
2000e5ec:	d0f4      	beq.n	2000e5d8 <memcmp+0x4>
2000e5ee:	1b58      	subs	r0, r3, r5
2000e5f0:	bd30      	pop	{r4, r5, pc}

2000e5f2 <memset>:
2000e5f2:	4402      	add	r2, r0
2000e5f4:	4603      	mov	r3, r0
2000e5f6:	4293      	cmp	r3, r2
2000e5f8:	d100      	bne.n	2000e5fc <memset+0xa>
2000e5fa:	4770      	bx	lr
2000e5fc:	f803 1b01 	strb.w	r1, [r3], #1
2000e600:	e7f9      	b.n	2000e5f6 <memset+0x4>
	...

2000e604 <__EH_FRAME_BEGIN__>:
2000e604:	0000 0000                                   ....

2000e608 <_init>:
2000e608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000e60a:	bf00      	nop
2000e60c:	bcf8      	pop	{r3, r4, r5, r6, r7}
2000e60e:	bc08      	pop	{r3}
2000e610:	469e      	mov	lr, r3
2000e612:	4770      	bx	lr

2000e614 <_fini>:
2000e614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000e616:	bf00      	nop
2000e618:	bcf8      	pop	{r3, r4, r5, r6, r7}
2000e61a:	bc08      	pop	{r3}
2000e61c:	469e      	mov	lr, r3
2000e61e:	4770      	bx	lr
